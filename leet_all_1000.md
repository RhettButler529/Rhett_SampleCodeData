### Bit Manipulation - 1310 - https://leetcode.com/problems/xor-queries-of-a-subarray/
Time: O(n)  Space: O(1)   Medium
.Python/xor-queries-of-a-subarray.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def xorQueries(self, arr, queries):
        """
        :type arr: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        for i in xrange(1, len(arr)):
            arr[i] ^= arr[i-1]
        return [arr[right] ^ arr[left-1] if left else arr[right] for left, right in queries]

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 1318 - https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/
Time: O(1)  Space: O(1)   Medium
.Python/minimum-flips-to-make-a-or-b-equal-to-c.py


```python
# Time:  O(31)
# Space: O(1)

class Solution(object):
    def minFlips(self, a, b, c):
        """
        :type a: int
        :type b: int
        :type c: int
        :rtype: int
        """
        def number_of_1_bits(n):
            result = 0
            while n:
                n &amp;= n-1
                result += 1
            return result

        return number_of_1_bits((a|b)^c) + number_of_1_bits(a&amp;b&amp;~c)


# Time:  O(31)
# Space: O(1)
class Solution2(object):
    def minFlips(self, a, b, c):
        """
        :type a: int
        :type b: int
        :type c: int
        :rtype: int
        """
        result = 0
        for i in xrange(31):
            a_i, b_i, c_i = map(lambda x: x&amp;1, [a, b, c])
            if (a_i | b_i) != c_i:
                result += 2 if a_i == b_i == 1 else 1
            a, b, c = a &gt;&gt; 1, b &gt;&gt; 1, c &gt;&gt; 1
        return result

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 1342 - https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/
Time: O(logn)  Space: O(1)   Easy
.Python/number-of-steps-to-reduce-a-number-to-zero.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def numberOfSteps (self, num):
        """
        :type num: int
        :rtype: int
        """
        result = 0
        while num:
            result += 2 if num%2 else 1
            num //= 2
        return max(result-1, 0)

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 1558 - https://leetcode.com/problems/minimum-numbers-of-function-calls-to-make-target-array/
Time: O(nlogn)  Space: O(1)   Medium
.Python/minimum-numbers-of-function-calls-to-make-target-array.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def minOperations(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def popcount(n):
            result = 0
            while n:
                n &amp;= n-1
                result += 1
            return result

        result, max_len = 0, 0
        for num in nums:
            result += popcount(num)
            max_len = max(max_len, num.bit_length())
        return result + max_len-1

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 1707 - https://leetcode.com/problems/maximum-xor-with-an-element-from-array/
Time: O(nlogn + mlogm + nlogk + mlogk)  Space: O(nlogk)   Hard
.Python/maximum-xor-with-an-element-from-array.py


```python
# Time:  O(nlogn + mlogm + nlogk + mlogk), k is max(max(nums), max(xi))
# Space: O(nlogk)

class Trie(object):
    def __init__(self, bit_length):
        self.__root = {}
        self.__bit_length = bit_length
        
    def insert(self, num):
        node = self.__root
        for i in reversed(xrange(self.__bit_length)):
            curr = (num&gt;&gt;i) &amp; 1
            if curr not in node:
                node[curr] = {}
            node = node[curr]
                
    def query(self, num):
        if not self.__root: 
            return -1
        node, result = self.__root, 0
        for i in reversed(xrange(self.__bit_length)):
            curr = (num&gt;&gt;i) &amp; 1
            if 1^curr in node:
                node = node[1^curr]
                result |= 1&lt;&lt;i
            else:
                node = node[curr]
        return result


class Solution(object):
    def maximizeXor(self, nums, queries):
        """
        :type nums: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        nums.sort()
        max_val = max(nums[-1], max(queries, key=lambda x: x[0])[0])
        queries = sorted(enumerate(queries), key=lambda x: x[1][1])        
        trie = Trie(max_val.bit_length())
        result = [-1]*len(queries)
        j = 0
        for i, (x, m) in queries:
            while j &lt; len(nums) and nums[j] &lt;= m:
                trie.insert(nums[j])
                j += 1
            result[i] = trie.query(x)
        return result

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 1720 - https://leetcode.com/problems/decode-xored-array/
Time: O(n)  Space: O(1)   Easy
.Python/decode-xored-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def decode(self, encoded, first):
        """
        :type encoded: List[int]
        :type first: int
        :rtype: List[int]
        """
        result = [first]
        for x in encoded:
            result.append(result[-1]^x)
        return result

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 1734 - https://leetcode.com/problems/decode-xored-permutation/
Time: O(n)  Space: O(1)   Medium
.Python/decode-xored-permutation.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def decode(self, encoded):
        """
        :type encoded: List[int]
        :rtype: List[int]
        """
        curr = 0
        for i in xrange(1, (len(encoded)+1) + 1):
            curr ^= i
            if i &lt; len(encoded) and i%2 == 1:
                curr ^= encoded[i]
        result = [curr]
        for x in encoded:
            result.append(result[-1]^x)
        return result

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 1829 - https://leetcode.com/problems/maximum-xor-for-each-query/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-xor-for-each-query.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def getMaximumXor(self, nums, maximumBit):
        """
        :type nums: List[int]
        :type maximumBit: int
        :rtype: List[int]
        """
        result = [0]*len(nums)
        mask = 2**maximumBit-1
        for i in xrange(len(nums)):
            mask ^= nums[i]
            result[-1-i] = mask
        return result

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 2151 - https://leetcode.com/problems/maximum-good-people-based-on-statements/
Time: O(n^2 * 2^n)  Space: O(1)   Hard
.Python/maximum-good-people-based-on-statements.py


```python
# Time:  O(n^2 * 2^n)
# Space: O(1)

# brute force, bitmask
class Solution(object):
    def maximumGood(self, statements):
        """
        :type statements: List[List[int]]
        :rtype: int
        """
        def check(mask):
            return all(((mask&gt;&gt;j)&amp;1) == statements[i][j]
                       for i in xrange(len(statements)) if (mask&gt;&gt;i)&amp;1 
                       for j in xrange(len(statements[i])) if statements[i][j] != 2)

        def popcount(x):
            result = 0
            while x:
                x &amp;= x-1
                result += 1
            return result

        result = 0
        for mask in xrange(1&lt;&lt;len(statements)):
            if check(mask):
                result = max(result, popcount(mask))
        return result

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 2212 - https://leetcode.com/problems/maximum-points-in-an-archery-competition/
Time: O(n * 2^n)  Space: O(n)   Medium
.Python/maximum-points-in-an-archery-competition.py


```python
# Time:  O(n * 2^n)
# Space: O(n)

# bitmasks
class Solution(object):
    def maximumBobPoints(self, numArrows, aliceArrows):
        """
        :type numArrows: int
        :type aliceArrows: List[int]
        :rtype: List[int]
        """
        def check(mask, numArrows):
            score = 0
            cnt = [0]*len(aliceArrows)
            i, base = 0, 1
            for k, a in enumerate(aliceArrows):
                if mask&amp;1:
                    need = a+1
                    if need &gt; numArrows:
                        return 0, [0]*len(aliceArrows)
                    numArrows -= need
                    cnt[k] = need
                    score += k
                mask &gt;&gt;= 1
            cnt[-1] += numArrows
            return score, cnt
        
        result = [0]*len(aliceArrows)
        best = 0
        for mask in xrange(1, 2**len(aliceArrows)):
            score, cnt = check(mask, numArrows)
            if score &gt; best:
                best = score
                result = cnt
        return result

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 2220 - https://leetcode.com/problems/minimum-bit-flips-to-convert-number/
Time: O(logn)  Space: O(1)   Easy
.Python/minimum-bit-flips-to-convert-number.py


```python
# Time:  O(logn)
# Space: O(1)

# bit manipulation
class Solution(object):
    def minBitFlips(self, start, goal):
        """
        :type start: int
        :type goal: int
        :rtype: int
        """
        return bin(start^goal).count('1')

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 2275 - https://leetcode.com/problems/largest-combination-with-bitwise-and-greater-than-zero/
Time: O(nlogr)  Space: O(logr)   Medium
.Python/largest-combination-with-bitwise-and-greater-than-zero.py


```python
# Time:  O(nlogr), r is the max of candidates
# Space: O(logr)

# bit manipulation, freq table
class Solution(object):
    def largestCombination(self, candidates):
        """
        :type candidates: List[int]
        :rtype: int
        """
        cnt = []
        base, mx = 1, max(candidates)
        while base &lt;= mx:
            cnt.append(sum(x&amp;base &gt; 0 for x in candidates))
            base &lt;&lt;= 1
        return max(cnt)

```



----------------------------------------------------------------------------------------

### Bit Manipulation - 2317 - https://leetcode.com/problems/maximum-xor-after-operations/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-xor-after-operations.py


```python
# Time:  O(n)
# Space: O(1)

# bit manipulation
class Solution(object):
    def maximumXOR(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return reduce(lambda x, y: x|y, nums)

```



----------------------------------------------------------------------------------------

### Array - 1002 - https://leetcode.com/problems/find-common-characters/
Time: O(n * l)  Space: O(1)   Easy
.Python/find-common-characters.py


```python
# Time:  O(n * l)
# Space: O(1)

import collections


class Solution(object):
    def commonChars(self, A):
        """
        :type A: List[str]
        :rtype: List[str]
        """
        result = collections.Counter(A[0])
        for a in A:
            result &amp;= collections.Counter(a)
        return list(result.elements())

```



----------------------------------------------------------------------------------------

### Array - 1007 - https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-domino-rotations-for-equal-row.py


```python
# Time:  O(n)
# Space: O(1)

import itertools


class Solution(object):
    def minDominoRotations(self, A, B):
        """
        :type A: List[int]
        :type B: List[int]
        :rtype: int
        """
        intersect = reduce(set.__and__, [set(d) for d in itertools.izip(A, B)])
        if not intersect:
            return -1
        x = intersect.pop()
        return min(len(A)-A.count(x), len(B)-B.count(x))

```



----------------------------------------------------------------------------------------

### Array - 1010 - https://leetcode.com/problems/pairs-of-songs-with-total-durations-divisible-by-60/
Time: O(n)  Space: O(1)   Easy
.Python/pairs-of-songs-with-total-durations-divisible-by-60.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def numPairsDivisibleBy60(self, time):
        """
        :type time: List[int]
        :rtype: int
        """
        result = 0
        count = collections.Counter()
        for t in time:
            result += count[-t%60]
            count[t%60] += 1
        return result

```



----------------------------------------------------------------------------------------

### Array - 1013 - https://leetcode.com/problems/partition-array-into-three-parts-with-equal-sum/
Time: O(n)  Space: O(1)   Easy
.Python/partition-array-into-three-parts-with-equal-sum.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def canThreePartsEqualSum(self, A):
        """
        :type A: List[int]
        :rtype: bool
        """
        total = sum(A)
        if total % 3 != 0:
            return False
        parts, curr = 0, 0
        for x in A:
            curr += x
            if curr == total//3:
                parts += 1
                curr = 0
        return parts &gt;= 3

```



----------------------------------------------------------------------------------------

### Array - 1014 - https://leetcode.com/problems/best-sightseeing-pair/
Time: O(n)  Space: O(1)   Medium
.Python/best-sightseeing-pair.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxScoreSightseeingPair(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        result, curr = 0, 0
        for x in A:
            result = max(result, curr+x)
            curr = max(curr, x)-1
        return result

```



----------------------------------------------------------------------------------------

### Array - 1018 - https://leetcode.com/problems/binary-prefix-divisible-by-5/
Time: O(n)  Space: O(1)   Easy
.Python/binary-prefix-divisible-by-5.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def prefixesDivBy5(self, A):
        """
        :type A: List[int]
        :rtype: List[bool]
        """
        for i in xrange(1, len(A)):
            A[i] += A[i-1] * 2 % 5
        return [x % 5 == 0 for x in A]

```



----------------------------------------------------------------------------------------

### Array - 1030 - https://leetcode.com/problems/matrix-cells-in-distance-order/
Time: O(m * n)  Space: O(1)   Easy
.Python/matrix-cells-in-distance-order.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def allCellsDistOrder(self, R, C, r0, c0):
        """
        :type R: int
        :type C: int
        :type r0: int
        :type c0: int
        :rtype: List[List[int]]
        """
        def append(R, C, r, c, result):
            if 0 &lt;= r &lt; R and 0 &lt;= c &lt; C:
                result.append([r, c])
            
        result = [[r0, c0]]
        for d in xrange(1, R+C):
            append(R, C, r0-d, c0, result)
            for x in xrange(-d+1, d):
                append(R, C, r0+x, c0+abs(x)-d, result)
                append(R, C, r0+x, c0+d-abs(x), result)
            append(R, C, r0+d, c0, result)
        return result

```



----------------------------------------------------------------------------------------

### Array - 1031 - https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-sum-of-two-non-overlapping-subarrays.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxSumTwoNoOverlap(self, A, L, M):
        """
        :type A: List[int]
        :type L: int
        :type M: int
        :rtype: int
        """
        for i in xrange(1, len(A)):
            A[i] += A[i-1]
        result, L_max, M_max = A[L+M-1], A[L-1], A[M-1]
        for i in xrange(L+M, len(A)):
            L_max = max(L_max, A[i-M] - A[i-L-M])
            M_max = max(M_max, A[i-L] - A[i-L-M])
            result = max(result,
                         L_max + A[i] - A[i-M],
                         M_max + A[i] - A[i-L])
        return result

```



----------------------------------------------------------------------------------------

### Array - 1051 - https://leetcode.com/problems/height-checker/
Time: O(nlogn)  Space: O(n)   Easy
.Python/height-checker.py


```python
# Time:  O(nlogn)
# Space: O(n)

import itertools


class Solution(object):
    def heightChecker(self, heights):
        """
        :type heights: List[int]
        :rtype: int
        """
        return sum(i != j for i, j in itertools.izip(heights, sorted(heights)))

```



----------------------------------------------------------------------------------------

### Array - 1052 - https://leetcode.com/problems/grumpy-bookstore-owner/
Time: O(n)  Space: O(1)   Medium
.Python/grumpy-bookstore-owner.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxSatisfied(self, customers, grumpy, X):
        """
        :type customers: List[int]
        :type grumpy: List[int]
        :type X: int
        :rtype: int
        """
        result, max_extra, extra = 0, 0, 0
        for i in xrange(len(customers)):
            result += 0 if grumpy[i] else customers[i]
            extra += customers[i] if grumpy[i] else 0
            if i &gt;= X:
                extra -= customers[i-X] if grumpy[i-X] else 0
            max_extra = max(max_extra, extra)
        return result + max_extra

```



----------------------------------------------------------------------------------------

### Array - 1072 - https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/
Time: O(m * n)  Space: O(m * n)   Medium
.Python/flip-columns-for-maximum-number-of-equal-rows.py


```python
# Time:  O(m * n)
# Space: O(m * n)

import collections


class Solution(object):
    def maxEqualRowsAfterFlips(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: int
        """
        count = collections.Counter(tuple(x^row[0] for x in row)
                                          for row in matrix)
        return max(count.itervalues())

```



----------------------------------------------------------------------------------------

### Array - 1074 - https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/
Time: O(m^2 * n)  Space: O(n)   Hard
.Python/number-of-submatrices-that-sum-to-target.py


```python
# Time:  O(m^2*n), m is min(r, c), n is max(r, c)
# Space: O(n), which doesn't include transposed space

import collections


class Solution(object):
    def numSubmatrixSumTarget(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: int
        """
        if len(matrix) &gt; len(matrix[0]):
            return self.numSubmatrixSumTarget(map(list, zip(*matrix)), target)
        
        for i in xrange(len(matrix)):
            for j in xrange(len(matrix[i])-1):
                matrix[i][j+1] += matrix[i][j]

        result = 0
        for i in xrange(len(matrix)):
            prefix_sum = [0]*len(matrix[i])
            for j in xrange(i, len(matrix)):
                lookup = collections.defaultdict(int)
                lookup[0] = 1
                for k in xrange(len(matrix[j])):
                    prefix_sum[k] += matrix[j][k]
                    if prefix_sum[k]-target in lookup:
                        result += lookup[prefix_sum[k]-target]
                    lookup[prefix_sum[k]] += 1
        return result

```



----------------------------------------------------------------------------------------

### Array - 1085 - https://leetcode.com/problems/sum-of-digits-in-the-minimum-number/
Time: O(n * l)  Space: O(l)   Easy
.Python/sum-of-digits-in-the-minimum-number.py


```python
# Time:  O(n * l)
# Space: O(l)

class Solution(object):
    def sumOfDigits(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        total = sum([int(c) for c in str(min(A))])
        return 1 if total % 2 == 0 else 0

```



----------------------------------------------------------------------------------------

### Array - 1089 - https://leetcode.com/problems/duplicate-zeros/
Time: O(n)  Space: O(1)   Easy
.Python/duplicate-zeros.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def duplicateZeros(self, arr):
        """
        :type arr: List[int]
        :rtype: None Do not return anything, modify arr in-place instead.
        """
        shift, i = 0, 0
        while i+shift &lt; len(arr):
            shift += int(arr[i] == 0)
            i += 1
        i -= 1
        while shift:
            if i+shift &lt; len(arr):
                arr[i+shift] = arr[i]
            if arr[i] == 0:
                shift -= 1
                arr[i+shift] = arr[i]
            i -= 1

```



----------------------------------------------------------------------------------------

### Array - 1093 - https://leetcode.com/problems/statistics-from-a-large-sample/
Time: O(n)  Space: O(1)   Medium
.Python/statistics-from-a-large-sample.py


```python
# Time:  O(n)
# Space: O(1)

import bisect


class Solution(object):
    def sampleStats(self, count):
        """
        :type count: List[int]
        :rtype: List[float]
        """
        n = sum(count)
        mi = next(i for i in xrange(len(count)) if count[i]) * 1.0
        ma = next(i for i in reversed(xrange(len(count))) if count[i]) * 1.0
        mean = sum(i * v for i, v in enumerate(count)) * 1.0 / n
        mode = count.index(max(count)) * 1.0
        for i in xrange(1, len(count)):
            count[i] += count[i-1]
        median1 = bisect.bisect_left(count, (n+1) // 2)
        median2 = bisect.bisect_left(count, (n+2) // 2)
        median = (median1+median2) / 2.0
        return [mi, ma, mean, median, mode]

```



----------------------------------------------------------------------------------------

### Array - 1099 - https://leetcode.com/problems/two-sum-less-than-k/
Time: O(nlogn)  Space: O(1)   Easy
.Python/two-sum-less-than-k.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def twoSumLessThanK(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: int
        """
        A.sort()
        result = -1
        left, right = 0, len(A)-1
        while left &lt; right:
            if A[left]+A[right] &gt;= K:
                right -= 1
            else:
                result = max(result, A[left]+A[right])
                left += 1
        return result

```



----------------------------------------------------------------------------------------

### Array - 1109 - https://leetcode.com/problems/corporate-flight-bookings/
Time: O(n)  Space: O(1)   Medium
.Python/corporate-flight-bookings.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def corpFlightBookings(self, bookings, n):
        """
        :type bookings: List[List[int]]
        :type n: int
        :rtype: List[int]
        """
        result = [0]*(n+1)
        for i, j, k in bookings:
            result[i-1] += k
            result[j] -= k
        for i in xrange(1, len(result)):
            result[i] += result[i-1]
        result.pop()
        return result

```



----------------------------------------------------------------------------------------

### Array - 1144 - https://leetcode.com/problems/decrease-elements-to-make-array-zigzag/
Time: O(n)  Space: O(1)   Medium
.Python/decrease-elements-to-make-array-zigzag.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def movesToMakeZigzag(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = [0, 0]
        for i in xrange(len(nums)):
            left = nums[i-1] if i-1 &gt;= 0 else float("inf")
            right = nums[i+1] if i+1 &lt; len(nums) else float("inf")
            result[i%2] += max(nums[i] - min(left, right) + 1, 0)
        return min(result)

```



----------------------------------------------------------------------------------------

### Array - 1184 - https://leetcode.com/problems/distance-between-bus-stops/
Time: O(n)  Space: O(1)   Easy
.Python/distance-between-bus-stops.py


```python
# Time:  O(n)
# Space: O(1)

import itertools


class Solution(object):
    def distanceBetweenBusStops(self, distance, start, destination):
        """
        :type distance: List[int]
        :type start: int
        :type destination: int
        :rtype: int
        """
        if start &gt; destination:
            start, destination = destination, start
        s_to_d = sum(itertools.islice(distance, start, destination))
        d_to_s = sum(itertools.islice(distance, 0, start)) + \
                 sum(itertools.islice(distance, destination, len(distance)))
        return min(s_to_d, d_to_s)

```



----------------------------------------------------------------------------------------

### Array - 1200 - https://leetcode.com/problems/minimum-absolute-difference/
Time: O(nlogn)  Space: O(n)   Easy
.Python/minimum-absolute-difference.py


```python
# Time:  O(nlogn)
# Space: O(n)

class Solution(object):
    def minimumAbsDifference(self, arr):
        """
        :type arr: List[int]
        :rtype: List[List[int]]
        """
        result = []
        min_diff = float("inf")
        arr.sort()
        for i in xrange(len(arr)-1):
            diff = arr[i+1]-arr[i]
            if diff &lt; min_diff:
                min_diff = diff
                result = [[arr[i], arr[i+1]]]
            elif diff == min_diff:
                result.append([arr[i], arr[i+1]])
        return result

```



----------------------------------------------------------------------------------------

### Array - 1222 - https://leetcode.com/problems/queens-that-can-attack-the-king/
Time: O(1)  Space: O(1)   Medium
.Python/queens-that-can-attack-the-king.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def queensAttacktheKing(self, queens, king):
        """
        :type queens: List[List[int]]
        :type king: List[int]
        :rtype: List[List[int]]
        """
        dirctions = [(-1, 0), (0, 1), (1, 0), (0, -1),
                     (-1, 1), (1, 1), (1, -1), (-1, -1)]
        result = []
        lookup = {(i, j) for i, j in queens}
        for dx, dy in dirctions:
            for i in xrange(1, 8):
                x, y = king[0] + dx*i, king[1] + dy*i
                if (x, y) in lookup:
                    result.append([x, y])
                    break
        return result

```



----------------------------------------------------------------------------------------

### Array - 1252 - https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/
Time: O(n + m)  Space: O(n + m)   Easy
.Python/cells-with-odd-values-in-a-matrix.py


```python
# Time:  O(n + m)
# Space: O(n + m)

class Solution(object):
    def oddCells(self, n, m, indices):
        """
        :type n: int
        :type m: int
        :type indices: List[List[int]]
        :rtype: int
        """
        row, col = [0]*n, [0]*m
        for r, c in indices:
            row[r] ^= 1
            col[c] ^= 1
        row_sum, col_sum = sum(row), sum(col)
        return row_sum*m+col_sum*n-2*row_sum*col_sum


# Time:  O(n + m)
# Space: O(n + m)
import collections
import itertools


class Solution2(object):
    def oddCells(self, n, m, indices):
        """
        :type n: int
        :type m: int
        :type indices: List[List[int]]
        :rtype: int
        """
        fn = lambda x: sum(count&amp;1 for count in collections.Counter(x).itervalues())
        row_sum, col_sum = map(fn, itertools.izip(*indices))
        return row_sum*m+col_sum*n-2*row_sum*col_sum

```



----------------------------------------------------------------------------------------

### Array - 1260 - https://leetcode.com/problems/shift-2d-grid/
Time: O(n)  Space: O(1)   Easy
.Python/shift-2d-grid.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def shiftGrid(self, grid, k):
        """
        :type grid: List[List[int]]
        :type k: int
        :rtype: List[List[int]]
        """
        def rotate(grids, k):
            def reverse(grid, start, end):
                while start &lt; end:
                    start_r, start_c = divmod(start, len(grid[0]))
                    end_r, end_c = divmod(end-1, len(grid[0]))
                    grid[start_r][start_c], grid[end_r][end_c] = grid[end_r][end_c], grid[start_r][start_c]
                    start += 1
                    end -= 1

            k %= len(grid)*len(grid[0])
            reverse(grid, 0, len(grid)*len(grid[0]))
            reverse(grid, 0, k)
            reverse(grid, k, len(grid)*len(grid[0]))

        rotate(grid, k)
        return grid

```



----------------------------------------------------------------------------------------

### Array - 1267 - https://leetcode.com/problems/count-servers-that-communicate/
Time: O(m * n)  Space: O(m + n)   Medium
.Python/count-servers-that-communicate.py


```python
# Time:  O(m * n)
# Space: O(m + n)

class Solution(object):
    def countServers(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        rows, cols = [0]*len(grid), [0]*len(grid[0])
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if grid[i][j]:
                    rows[i] += 1
                    cols[j] += 1
        result = 0
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if grid[i][j] and (rows[i] &gt; 1 or cols[j] &gt; 1):
                    result += 1
        return result

```



----------------------------------------------------------------------------------------

### Array - 1275 - https://leetcode.com/problems/find-winner-on-a-tic-tac-toe-game/
Time: O(1)  Space: O(1)   Easy
.Python/find-winner-on-a-tic-tac-toe-game.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def tictactoe(self, moves):
        """
        :type moves: List[List[int]]
        :rtype: str
        """
        row, col = [[0]*3 for _ in xrange(2)], [[0]*3 for _ in xrange(2)]
        diag, anti_diag = [0]*2, [0]*2
        p = 0
        for r, c in moves:
            row[p][r] += 1
            col[p][c] += 1
            diag[p] += r == c
            anti_diag[p] += r+c == 2
            if 3 in (row[p][r], col[p][c], diag[p], anti_diag[p]):
                return "AB"[p]
            p ^= 1
        return "Draw" if len(moves) == 9 else "Pending"

```



----------------------------------------------------------------------------------------

### Array - 1295 - https://leetcode.com/problems/find-numbers-with-even-number-of-digits/
Time: O(nlog(logm))  Space: O(logm)   Easy
.Python/find-numbers-with-even-number-of-digits.py


```python
# Time:  O(nlog(logm)), n the length of nums, m is the max value of nums
# Space: O(logm)

import bisect


class Solution(object):
    def __init__(self):
        M = 10**5
        self.__lookup = [0]
        i = 10
        while i &lt; M:
            self.__lookup.append(i)
            i *= 10
        self.__lookup.append(i)

    def findNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def digit_count(n):
            return bisect.bisect_right(self.__lookup, n)

        return sum(digit_count(n) % 2 == 0 for n in nums)
    

# Time:  O(nlogm), n the length of nums, m is the max value of nums
# Space: O(logm)
class Solution2(object):
    def findNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def digit_count(n):
            result = 0
            while n:
                n //= 10
                result += 1
            return result

        return sum(digit_count(n) % 2 == 0 for n in nums)


# Time:  O(nlogm), n the length of nums, m is the max value of nums
# Space: O(logm)
class Solution3(object):
    def findNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return sum(len(str(n)) % 2 == 0 for n in nums)

```



----------------------------------------------------------------------------------------

### Array - 1299 - https://leetcode.com/problems/replace-elements-with-greatest-element-on-right-side/
Time: O(n)  Space: O(1)   Easy
.Python/replace-elements-with-greatest-element-on-right-side.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def replaceElements(self, arr):
        """
        :type arr: List[int]
        :rtype: List[int]
        """
        curr_max = -1
        for i in reversed(xrange(len(arr))):
            arr[i], curr_max = curr_max, max(curr_max, arr[i])
        return arr

```



----------------------------------------------------------------------------------------

### Array - 1304 - https://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/
Time: O(n)  Space: O(1)   Easy
.Python/find-n-unique-integers-sum-up-to-zero.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def sumZero(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        return [i for i in xrange(-(n//2), n//2+1) if not (i == 0 and n%2 == 0)]

```



----------------------------------------------------------------------------------------

### Array - 1313 - https://leetcode.com/problems/decompress-run-length-encoded-list/
Time: O(n)  Space: O(1)   Easy
.Python/decompress-run-length-encoded-list.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def decompressRLElist(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        return [nums[i+1] for i in xrange(0, len(nums), 2) for _ in xrange(nums[i])]

```



----------------------------------------------------------------------------------------

### Array - 1329 - https://leetcode.com/problems/sort-the-matrix-diagonally/
Time: O(m * n * log(min(m, n))  Space: O(m * n)   Medium
.Python/sort-the-matrix-diagonally.py


```python
# Time:  O(m * n * log(min(m, n))
# Space: O(m * n)

import collections


class Solution(object):
    def diagonalSort(self, mat):
        """
        :type mat: List[List[int]]
        :rtype: List[List[int]]
        """
        lookup = collections.defaultdict(list)
        for i in xrange(len(mat)):
            for j in xrange(len(mat[0])):
                lookup[i-j].append(mat[i][j])
        for v in lookup.itervalues():
            v.sort()
        for i in reversed(xrange(len(mat))):
            for j in reversed(xrange(len(mat[0]))):
                mat[i][j] = lookup[i-j].pop()
        return mat

```



----------------------------------------------------------------------------------------

### Array - 1331 - https://leetcode.com/problems/rank-transform-of-an-array/
Time: O(nlogn)  Space: O(n)   Easy
.Python/rank-transform-of-an-array.py


```python
# Time:  O(nlogn)
# Space: O(n)

class Solution(object):
    def arrayRankTransform(self, arr):
        """
        :type arr: List[int]
        :rtype: List[int]
        """
        return map({x: i+1 for i, x in enumerate(sorted(set(arr)))}.get, arr)

```



----------------------------------------------------------------------------------------

### Array - 1333 - https://leetcode.com/problems/filter-restaurants-by-vegan-friendly-price-and-distance/
Time: O(rlogr)  Space: O(r)   Medium
.Python/filter-restaurants-by-vegan-friendly-price-and-distance.py


```python
# Time:  O(rlogr), r is the number of result
# Space: O(r)

class Solution(object):
    def filterRestaurants(self, restaurants, veganFriendly, maxPrice, maxDistance):
        """
        :type restaurants: List[List[int]]
        :type veganFriendly: int
        :type maxPrice: int
        :type maxDistance: int
        :rtype: List[int]
        """
        result, lookup = [], {}
        for j, (i, _, v, p, d) in enumerate(restaurants):
            if v &gt;= veganFriendly and p &lt;= maxPrice and d &lt;= maxDistance:
                lookup[i] = j
                result.append(i)
        result.sort(key=lambda i: (-restaurants[lookup[i]][1], -restaurants[lookup[i]][0]))
        return result

```



----------------------------------------------------------------------------------------

### Array - 1337 - https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/
Time: O(m * n)  Space: O(k)   Easy
.Python/the-k-weakest-rows-in-a-matrix.py


```python
# Time:  O(m * n)
# Space: O(k)

class Solution(object):
    def kWeakestRows(self, mat, k):
        """
        :type mat: List[List[int]]
        :type k: int
        :rtype: List[int]
        """
        result, lookup = [], set()
        for j in xrange(len(mat[0])):
            for i in xrange(len(mat)):
                if mat[i][j] or i in lookup:
                    continue
                lookup.add(i)
                result.append(i)
                if len(result) == k:
                    return result
        for i in xrange(len(mat)):
            if i in lookup:
                continue
            lookup.add(i)
            result.append(i)
            if len(result) == k:
                break
        return result


# Time:  O(m * n)
# Space: O(k)
import collections


class Solution2(object):
    def kWeakestRows(self, mat, k):
        """
        :type mat: List[List[int]]
        :type k: int
        :rtype: List[int]
        """
        lookup = collections.OrderedDict()
        for j in xrange(len(mat[0])):
            for i in xrange(len(mat)):
                if mat[i][j] or i in lookup:
                    continue
                lookup[i] = True
                if len(lookup) == k:
                    return lookup.keys()
        for i in xrange(len(mat)):
            if i in lookup:
                continue
            lookup[i] = True
            if len(lookup) == k:
                break
        return lookup.keys()


# Time:  O(m * n + klogk)
# Space: O(m)
import random


class Solution3(object):
    def kWeakestRows(self, mat, k):
        """
        :type mat: List[List[int]]
        :type k: int
        :rtype: List[int]
        """
        def nth_element(nums, n, compare=lambda a, b: a &lt; b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in xrange(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx &gt; n:
                    right = new_pivot_idx - 1
                else:  # new_pivot_idx &lt; n
                    left = new_pivot_idx + 1
        
        nums = [(sum(mat[i]), i) for i in xrange(len(mat))]
        nth_element(nums, k)
        return map(lambda x: x[1], sorted(nums[:k]))

```



----------------------------------------------------------------------------------------

### Array - 1343 - https://leetcode.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold.py


```python
# Time:  O(n)
# Space: O(1)

import itertools


class Solution(object):
    def numOfSubarrays(self, arr, k, threshold):
        """
        :type arr: List[int]
        :type k: int
        :type threshold: int
        :rtype: int
        """
        result, curr = 0, sum(itertools.islice(arr, 0, k-1))
        for i in xrange(k-1, len(arr)):
            curr += arr[i]-(arr[i-k] if i-k &gt;= 0 else 0)
            result += int(curr &gt;= threshold*k)
        return result
    

# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def numOfSubarrays(self, arr, k, threshold):
        """
        :type arr: List[int]
        :type k: int
        :type threshold: int
        :rtype: int
        """
        accu = [0]
        for x in arr:
            accu.append(accu[-1]+x)
        result = 0
        for i in xrange(len(accu)-k):
            if accu[i+k]-accu[i] &gt;= threshold*k:
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Array - 1346 - https://leetcode.com/problems/check-if-n-and-its-double-exist/
Time: O(n)  Space: O(n)   Easy
.Python/check-if-n-and-its-double-exist.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def checkIfExist(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        lookup = set()
        for x in arr:
            if 2*x in lookup or \
               (x%2 == 0 and x//2 in lookup):
                return True
            lookup.add(x)
        return False

```



----------------------------------------------------------------------------------------

### Array - 1351 - https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/
Time: O(m + n)  Space: O(1)   Easy
.Python/count-negative-numbers-in-a-sorted-matrix.py


```python
# Time:  O(m + n)
# Space: O(1)

class Solution(object):
    def countNegatives(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        result, c = 0, len(grid[0])-1
        for row in grid:
            while c &gt;= 0 and row[c] &lt; 0:
                c -= 1
            result += len(grid[0])-1-c
        return result

```



----------------------------------------------------------------------------------------

### Array - 1375 - https://leetcode.com/problems/bulb-switcher-iii/
Time: O(n)  Space: O(1)   Medium
.Python/bulb-switcher-iii.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def numTimesAllBlue(self, light):
        """
        :type light: List[int]
        :rtype: int
        """
        result, right = 0, 0
        for i, num in enumerate(light, 1):
            right = max(right, num)
            result += (right == i)
        return result

```



----------------------------------------------------------------------------------------

### Array - 1380 - https://leetcode.com/problems/lucky-numbers-in-a-matrix/
Time: O(m * n)  Space: O(m + n)   Easy
.Python/lucky-numbers-in-a-matrix.py


```python
# Time:  O(m * n)
# Space: O(m + n)

import itertools


class Solution(object):
    def luckyNumbers (self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        rows = map(min, matrix)
        cols = map(max, itertools.izip(*matrix))
        return [cell for i, row in enumerate(matrix)
                     for j, cell in enumerate(row) if rows[i] == cols[j]]

    
# Time:  O(m * n)
# Space: O(m + n)
import itertools


class Solution2(object):
    def luckyNumbers (self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[int]
        """
        return list(set(map(min, matrix)) &amp;
                    set(map(max, itertools.izip(*matrix))))

```



----------------------------------------------------------------------------------------

### Array - 1389 - https://leetcode.com/problems/create-target-array-in-the-given-order/
Time: O(n^2)  Space: O(1)   Easy
.Python/create-target-array-in-the-given-order.py


```python
# Time:  O(n^2)
# Space: O(1)

class Solution(object):
    def createTargetArray(self, nums, index):
        """
        :type nums: List[int]
        :type index: List[int]
        :rtype: List[int]
        """
        for i in xrange(len(nums)):
            for j in xrange(i):
                if index[j] &gt;= index[i]:
                    index[j] += 1
        result = [0]*(len(nums))
        for i in xrange(len(nums)):
            result[index[i]] = nums[i]
        return result


# Time:  O(n^2)
# Space: O(1)
import itertools


class Solution2(object):
    def createTargetArray(self, nums, index):
        """
        :type nums: List[int]
        :type index: List[int]
        :rtype: List[int]
        """
        result = []
        for i, x in itertools.izip(index, nums):
            result.insert(i, x)
        return result

```



----------------------------------------------------------------------------------------

### Array - 1394 - https://leetcode.com/problems/find-lucky-integer-in-an-array/
Time: O(n)  Space: O(n)   Easy
.Python/find-lucky-integer-in-an-array.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def findLucky(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        count = collections.Counter(arr)
        result = -1
        for k, v in count.iteritems():
            if k == v:
                result = max(result, k)
        return result

```



----------------------------------------------------------------------------------------

### Array - 1399 - https://leetcode.com/problems/count-largest-group/
Time: O(nlogn)  Space: O(n)   Easy
.Python/count-largest-group.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class Solution(object):
    def countLargestGroup(self, n):
        """
        :type n: int
        :rtype: int
        """
        count = collections.Counter()
        for x in xrange(1, n+1):
            count[sum(map(int, str(x)))] += 1
        max_count = max(count.itervalues())
        return sum(v == max_count for v in count.itervalues())

```



----------------------------------------------------------------------------------------

### Array - 1404 - https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-steps-to-reduce-a-number-in-binary-representation-to-one.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def numSteps(self, s):
        """
        :type s: str
        :rtype: int
        """
        result, carry = 0, 0
        for i in reversed(xrange(1, len(s))):
            if int(s[i]) + carry == 1:
                carry = 1  # once it was set, it would keep carrying forever
                result += 2
            else:
                result += 1
        return result+carry

```



----------------------------------------------------------------------------------------

### Array - 1413 - https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/
Time: O(n)  Space: O(1)   Easy
.Python/minimum-value-to-get-positive-step-by-step-sum.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minStartValue(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        min_prefix, prefix = 0, 0
        for num in nums:
            prefix += num
            min_prefix = min(min_prefix, prefix)
        return 1-min_prefix

```



----------------------------------------------------------------------------------------

### Array - 1426 - https://leetcode.com/problems/counting-elements/
Time: O(n)  Space: O(n)   Easy
.Python/counting-elements.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def countElements(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        lookup = set(arr)
        return sum(1 for x in arr if x+1 in lookup)


# Time:  O(nlogn)
# Space: O(1)
class Solution(object):
    def countElements(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        arr.sort()
        result, l = 0, 1
        for i in xrange(len(arr)-1):
            if arr[i] == arr[i+1]:
                l += 1
                continue
            if arr[i]+1 == arr[i+1]:
                result += l
            l = 1
        return result

```



----------------------------------------------------------------------------------------

### Array - 1427 - https://leetcode.com/problems/perform-string-shifts/
Time: O(n + l)  Space: O(1)   Easy
.Python/perform-string-shifts.py


```python
# Time:  O(n + l)
# Space: O(l)

class Solution(object):
    def stringShift(self, s, shift):
        """
        :type s: str
        :type shift: List[List[int]]
        :rtype: str
        """
        left_shifts = 0
        for direction, amount in shift:
            if not direction:
                left_shifts += amount
            else:
                left_shifts -= amount
        left_shifts %= len(s)
        return s[left_shifts:] + s[:left_shifts]

```



----------------------------------------------------------------------------------------

### Array - 1428 - https://leetcode.com/problems/leftmost-column-with-at-least-a-one/
Time: O(m + n)  Space: O(1)   Medium
.Python/leftmost-column-with-at-least-a-one.py


```python
# Time:  O(m + n)
# Space: O(1)

class BinaryMatrix(object):
    def get(self, row, col):
        pass

    def dimensions(self):
        pass


class Solution(object):
    def leftMostColumnWithOne(self, binaryMatrix):
        """
        :type binaryMatrix: BinaryMatrix
        :rtype: int
        """
        m, n = binaryMatrix.dimensions()
        r, c = 0, n-1
        while r &lt; m and c &gt;= 0:
            if not binaryMatrix.get(r, c):
                r += 1
            else:
                c -= 1        
        return c+1 if c+1 != n else -1

```



----------------------------------------------------------------------------------------

### Array - 1431 - https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/
Time: O(n)  Space: O(1)   Easy
.Python/kids-with-the-greatest-number-of-candies.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def kidsWithCandies(self, candies, extraCandies):
        """
        :type candies: List[int]
        :type extraCandies: int
        :rtype: List[bool]
        """
        max_num = max(candies)
        return [x + extraCandies &gt;= max_num for x in candies]

```



----------------------------------------------------------------------------------------

### Array - 1437 - https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/
Time: O(n)  Space: O(1)   Medium
.Python/check-if-all-1s-are-at-least-length-k-places-away.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def kLengthApart(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        prev = -k-1
        for i in xrange(len(nums)):
            if not nums[i]:
                continue
            if i-prev &lt;= k:
                return False
            prev = i
        return True

```



----------------------------------------------------------------------------------------

### Array - 1450 - https://leetcode.com/problems/number-of-students-doing-homework-at-a-given-time/
Time: O(n)  Space: O(1)   Easy
.Python/number-of-students-doing-homework-at-a-given-time.py


```python
# Time:  O(n)
# Space: O(1)

import itertools


class Solution(object):
    def busyStudent(self, startTime, endTime, queryTime):
        """
        :type startTime: List[int]
        :type endTime: List[int]
        :type queryTime: int
        :rtype: int
        """
        return sum(s &lt;= queryTime &lt;= e for s, e in itertools.izip(startTime, endTime))

```



----------------------------------------------------------------------------------------

### Array - 1460 - https://leetcode.com/problems/make-two-arrays-equal-by-reversing-sub-arrays/
Time: O(n)  Space: O(n)   Easy
.Python/make-two-arrays-equal-by-reversing-sub-arrays.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def canBeEqual(self, target, arr):
        """
        :type target: List[int]
        :type arr: List[int]
        :rtype: bool
        """
        return collections.Counter(target) == collections.Counter(arr)


# Time:  O(nlogn)
# Space: O(1)
class Solution2(object):
    def canBeEqual(self, target, arr):
        """
        :type target: List[int]
        :type arr: List[int]
        :rtype: bool
        """
        target.sort(), arr.sort()
        return target == arr

```



----------------------------------------------------------------------------------------

### Array - 1464 - https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/
Time: O(n)  Space: O(1)   Easy
.Python/maximum-product-of-two-elements-in-an-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        m1 = m2 = 0
        for num in nums:
            if num &gt; m1:
                m1, m2 = num, m1
            elif num &gt; m2:
                m2 = num
        return (m1-1)*(m2-1)

```



----------------------------------------------------------------------------------------

### Array - 1465 - https://leetcode.com/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/
Time: O(hlogh + wlogw)  Space: O(1)   Medium
.Python/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts.py


```python
# Time:  O(hlogh + wlogw)
# Space: O(1)

class Solution(object):
    def maxArea(self, h, w, horizontalCuts, verticalCuts):
        """
        :type h: int
        :type w: int
        :type horizontalCuts: List[int]
        :type verticalCuts: List[int]
        :rtype: int
        """
        def max_len(l, cuts):
            cuts.sort()
            l = max(cuts[0]-0, l-cuts[-1])
            for i in xrange(1, len(cuts)):
                l = max(l, cuts[i]-cuts[i-1])
            return l

        MOD = 10**9+7
        return max_len(h, horizontalCuts) * max_len(w, verticalCuts) % MOD

```



----------------------------------------------------------------------------------------

### Array - 1470 - https://leetcode.com/problems/shuffle-the-array/
Time: O(n)  Space: O(1)   Easy
.Python/shuffle-the-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def shuffle(self, nums, n):
        """
        :type nums: List[int]
        :type n: int
        :rtype: List[int]
        """
        def index(i):
            return 2*i if i &lt; n else 2*(i-n)+1
    
        for i in xrange(len(nums)):
            j = i
            while nums[i] &gt;= 0:
                j = index(j)
                nums[i], nums[j] = nums[j], ~nums[i]  # processed
        for i in xrange(len(nums)):
            nums[i] = ~nums[i]
        return nums

```



----------------------------------------------------------------------------------------

### Array - 1471 - https://leetcode.com/problems/the-k-strongest-values-in-an-array/
Time: O(n)  Space: O(1)   Medium
.Python/the-k-strongest-values-in-an-array.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def getStrongest(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: List[int]
        """
        arr.sort()
        m = arr[(len(arr)-1)//2]
        result = []
        left, right = 0, len(arr)-1
        while len(result) &lt; k:
            if m-arr[left] &gt; arr[right]-m:
                result.append(arr[left])
                left += 1
            else:
                result.append(arr[right])
                right -= 1
        return result


# Time:  O(nlogn)
# Space: O(1)
class Solution2(object):
    def getStrongest(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: List[int]
        """
        arr.sort()
        m = arr[(len(arr)-1)//2]
        arr.sort(key=lambda x: (-abs(x-m), -x))
        return arr[:k]


# Time:  O(n)
# Space: O(1)
import random


class Solution_TLE(object):
    def getStrongest(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: List[int]
        """
        def nth_element(nums, n, compare=lambda a, b: a &lt; b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in xrange(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx &gt; n:
                    right = new_pivot_idx - 1
                else:  # new_pivot_idx &lt; n
                    left = new_pivot_idx + 1
        
        nth_element(arr, (len(arr)-1)//2)
        m = arr[(len(arr)-1)//2]
        nth_element(arr, k, lambda a, b: abs(a-m) &gt; abs(b-m) if abs(a-m) != abs(b-m) else a &gt; b)
        return arr[:k]

```



----------------------------------------------------------------------------------------

### Array - 1475 - https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/
Time: O(n)  Space: O(n)   Easy
.Python/final-prices-with-a-special-discount-in-a-shop.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def finalPrices(self, prices):
        """
        :type prices: List[int]
        :rtype: List[int]
        """
        stk = []
        for i, p in enumerate(prices):
            while stk and prices[stk[-1]] &gt;= p:
                prices[stk.pop()] -= p
            stk.append(i)
        return prices

```



----------------------------------------------------------------------------------------

### Array - 1480 - https://leetcode.com/problems/running-sum-of-1d-array/
Time: O(n)  Space: O(1)   Easy
.Python/running-sum-of-1d-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def runningSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        for i in xrange(len(nums)-1):
            nums[i+1] += nums[i]
        return nums

```



----------------------------------------------------------------------------------------

### Array - 1491 - https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/
Time: O(n)  Space: O(1)   Easy
.Python/average-salary-excluding-the-minimum-and-maximum-salary.py


```python
# Time:  O(n)
# Space: O(1)

# one pass solution
class Solution(object):
    def average(self, salary):
        """
        :type salary: List[int]
        :rtype: float
        """
        total, mi, ma = 0, float("inf"), float("-inf")
        for s in salary:
            total += s
            mi, ma = min(mi, s), max(ma, s)
        return 1.0*(total-mi-ma)/(len(salary)-2)


# Time:  O(n)
# Space: O(1)
# one-liner solution
class Solution2(object):
    def average(self, salary):
        """
        :type salary: List[int]
        :rtype: float
        """
        return 1.0*(sum(salary)-min(salary)-max(salary))/(len(salary)-2)

```



----------------------------------------------------------------------------------------

### Array - 1502 - https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/
Time: O(n)  Space: O(1)   Easy
.Python/can-make-arithmetic-progression-from-sequence.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def canMakeArithmeticProgression(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        m = min(arr)
        d = (max(arr)-m)//(len(arr)-1)
        if not d:
            return True
        i = 0
        while i &lt; len(arr):
            if arr[i] == m+i*d:
                i += 1
            else:
                j, r = divmod(arr[i]-m, d)
                if r or j &gt;= len(arr) or arr[i] == arr[j]:
                    return False
                arr[i], arr[j] = arr[j], arr[i]
        return True

```



----------------------------------------------------------------------------------------

### Array - 1503 - https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/
Time: O(n)  Space: O(1)   Medium
.Python/last-moment-before-all-ants-fall-out-of-a-plank.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def getLastMoment(self, n, left, right):
        """
        :type n: int
        :type left: List[int]
        :type right: List[int]
        :rtype: int
        """
        return max(max(left or [0]), n-min(right or [n]))

```



----------------------------------------------------------------------------------------

### Array - 1534 - https://leetcode.com/problems/count-good-triplets/
Time: O(n^3)  Space: O(1)   Easy
.Python/count-good-triplets.py


```python
# Time:  O(n^3)
# Space: O(1)

class Solution(object):
    def countGoodTriplets(self, arr, a, b, c):
        """
        :type arr: List[int]
        :type a: int
        :type b: int
        :type c: int
        :rtype: int
        """
        return sum(abs(arr[i]-arr[j]) &lt;= a and
                   abs(arr[j]-arr[k]) &lt;= b and
                   abs(arr[k]-arr[i]) &lt;= c 
                   for i in xrange(len(arr)-2)
                       for j in xrange(i+1, len(arr)-1)
                           for k in xrange(j+1, len(arr)))

```



----------------------------------------------------------------------------------------

### Array - 1535 - https://leetcode.com/problems/find-the-winner-of-an-array-game/
Time: O(n)  Space: O(1)   Medium
.Python/find-the-winner-of-an-array-game.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def getWinner(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: int
        """
        result = arr[0]
        count = 0
        for i in xrange(1, len(arr)):
            if arr[i] &gt; result:
                result = arr[i]
                count = 0
            count += 1
            if (count == k):
                break
        return result

```



----------------------------------------------------------------------------------------

### Array - 1538 - https://leetcode.com/problems/guess-the-majority-in-a-hidden-array/
Time: O(n)  Space: O(1)   Medium
.Python/guess-the-majority-in-a-hidden-array.py


```python
# Time:  O(n), n queries
# Space: O(1)

class ArrayReader(object):
    def query(self, a, b, c, d):
        """
        :type a, b, c, d: int
        :rtype int
        """
        pass

    def length(self):
        """
        :rtype int
        """
        pass
    

class Solution(object):
    def guessMajority(self, reader):
        """
        :type reader: ArrayReader
        :rtype: integer
        """
        count_a, count_b, idx_b = 1, 0, None
        value_0_1_2_3 = reader.query(0, 1, 2, 3)
        for i in reversed(xrange(4, reader.length())):
            value_0_1_2_i = reader.query(0, 1, 2, i)
            if value_0_1_2_i == value_0_1_2_3:  # nums[i] == nums[3]
                count_a = count_a+1
            else:
                count_b, idx_b = count_b+1, i
        value_0_1_2_4 = value_0_1_2_i
        for i in xrange(3):
            value_a_b_3_4 = reader.query(*[v for v in [0, 1, 2, 3, 4] if v != i])
            if value_a_b_3_4 == value_0_1_2_4:  # nums[i] == nums[3]
                count_a = count_a+1
            else:
                count_b, idx_b = count_b+1, i
        if count_a == count_b:
            return -1
        return 3 if count_a &gt; count_b else idx_b

```



----------------------------------------------------------------------------------------

### Array - 1550 - https://leetcode.com/problems/three-consecutive-odds/
Time: O(n)  Space: O(1)   Easy
.Python/three-consecutive-odds.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def threeConsecutiveOdds(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        count = 0
        for x in arr:
            count = count+1 if x%2 else 0
            if count == 3:
                return True
        return False

```



----------------------------------------------------------------------------------------

### Array - 1559 - https://leetcode.com/problems/detect-cycles-in-2d-grid/
Time: O(m * n)  Space: O(m * n)   Hard
.Python/detect-cycles-in-2d-grid.py


```python
# Time:  O(m * n * (n)) ~= O(m * n)
# Space: O(m * n)

class UnionFind(object):
    def __init__(self, n):
        self.set = range(n)
        self.count = n

    def find_set(self, x):
       if self.set[x] != x:
           self.set[x] = self.find_set(self.set[x])  # path compression.
       return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root != y_root:
            self.set[min(x_root, y_root)] = max(x_root, y_root)
            self.count -= 1


class Solution(object):
    def containsCycle(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: bool
        """
        def index(n, i, j):
            return i*n + j
    
        union_find = UnionFind(len(grid)*len(grid[0]))
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if i and j and grid[i][j] == grid[i-1][j] == grid[i][j-1] and \
                   union_find.find_set(index(len(grid[0]), i-1, j)) == \
                   union_find.find_set(index(len(grid[0]), i, j-1)):
                    return True
                if i and grid[i][j] == grid[i-1][j]:
                    union_find.union_set(index(len(grid[0]), i-1, j),
                                         index(len(grid[0]),i, j))
                if j and grid[i][j] == grid[i][j-1]:
                    union_find.union_set(index(len(grid[0]), i, j-1),
                                         index(len(grid[0]), i, j))
        return False


# Time:  O(m * n)
# Space: O(m * n)
class Solution2(object):
    def containsCycle(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: bool
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if not grid[i][j]:
                    continue
                val = grid[i][j]
                q = [(i, j)]
                while q:
                    new_q = []
                    for r, c in q:
                        if not grid[r][c]:
                            return True
                        grid[r][c] = 0
                        for dr, dc in directions:
                            nr, nc = r+dr, c+dc
                            if not (0 &lt;= nr &lt; len(grid) and
                                    0 &lt;= nc &lt; len(grid[0]) and
                                    grid[nr][nc] == val):
                                continue
                            new_q.append((nr, nc))
                    q = new_q
        return False

```



----------------------------------------------------------------------------------------

### Array - 1560 - https://leetcode.com/problems/most-visited-sector-in-a-circular-track/
Time: O(n)  Space: O(1)   Easy
.Python/most-visited-sector-in-a-circular-track.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def mostVisited(self, n, rounds):
        """
        :type n: int
        :type rounds: List[int]
        :rtype: List[int]
        """
        return range(rounds[0], rounds[-1]+1) or \
               range(1, rounds[-1]+1) + range(rounds[0], n+1)

```



----------------------------------------------------------------------------------------

### Array - 1562 - https://leetcode.com/problems/find-latest-group-of-size-m/
Time: O(n)  Space: O(n)   Medium
.Python/find-latest-group-of-size-m.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def findLatestStep(self, arr, m):
        """
        :type arr: List[int]
        :type m: int
        :rtype: int
        """
        if m == len(arr):
            return m
        length = [0]*(len(arr)+2)
        result = -1
        for i, x in enumerate(arr):
            left, right = length[x-1], length[x+1]
            if left == m or right == m:
                result = i
            length[x-left] = length[x+right] = left+right+1
        return result

```



----------------------------------------------------------------------------------------

### Array - 1566 - https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/
Time: O(n)  Space: O(1)   Easy
.Python/detect-pattern-of-length-m-repeated-k-or-more-times.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def containsPattern(self, arr, m, k):
        """
        :type arr: List[int]
        :type m: int
        :type k: int
        :rtype: bool
        """
        cnt = 0
        for i in xrange(len(arr)-m):
            if arr[i] != arr[i+m]:
                cnt = 0
                continue
            cnt += 1
            if cnt == (k-1)*m:
                return True
        return False

```



----------------------------------------------------------------------------------------

### Array - 1572 - https://leetcode.com/problems/matrix-diagonal-sum/
Time: O(n)  Space: O(1)   Easy
.Python/matrix-diagonal-sum.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def diagonalSum(self, mat):
        """
        :type mat: List[List[int]]
        :rtype: int
        """
        return sum(mat[i][i]+mat[~i][i] for i in xrange(len(mat))) - (mat[len(mat)//2][len(mat)//2] if len(mat)%2 == 1 else 0)

```



----------------------------------------------------------------------------------------

### Array - 1574 - https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/
Time: O(n)  Space: O(1)   Medium
.Python/shortest-subarray-to-be-removed-to-make-array-sorted.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def findLengthOfShortestSubarray(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        j = -1
        for j in reversed(xrange(1, len(arr))):
            if arr[j-1] &gt; arr[j]:
                break
        else:
            return 0
        result = j
        for i in xrange(j):
            if i and arr[i] &lt; arr[i-1]:
                break
            while j &lt; len(arr) and arr[i] &gt; arr[j]:
                j += 1
            result = min(result, (j-i+1)-2)
        return result


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def findLengthOfShortestSubarray(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        result = 0
        for i in xrange(1, len(arr)):
            if arr[i-1] &lt;= arr[i]:
                continue
            j = len(arr)-1
            while j &gt; i and (j == len(arr)-1 or arr[j] &lt;= arr[j+1]) and arr[i-1] &lt;= arr[j]:
                j -= 1
            result = j-i+1
            break
        for j in reversed(xrange(len(arr)-1)):
            if arr[j] &lt;= arr[j+1]:
                continue
            i = 0
            while i &lt; j and (i == 0 or arr[i-1] &lt;= arr[i]) and arr[i] &lt;= arr[j+1]:
                i += 1
            result = min(result, j-i+1)
            break
        return result

```



----------------------------------------------------------------------------------------

### Array - 1582 - https://leetcode.com/problems/special-positions-in-a-binary-matrix/
Time: O(n^2)  Space: O(n)   Easy
.Python/special-positions-in-a-binary-matrix.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def numSpecial(self, mat):
        """
        :type mat: List[List[int]]
        :rtype: int
        """
        rows, cols = [0]*len(mat), [0]*len(mat[0])
        for i in xrange(len(rows)):
            for j in xrange(len(cols)):
                if mat[i][j]:
                    rows[i] += 1
                    cols[j] += 1
        result = 0
        for i in xrange(len(rows)):
            for j in xrange(len(cols)):
                if mat[i][j] == rows[i] == cols[j] == 1:
                    result += 1
        return result

```



----------------------------------------------------------------------------------------

### Array - 1583 - https://leetcode.com/problems/count-unhappy-friends/
Time: O(n^2)  Space: O(n^2)   Medium
.Python/count-unhappy-friends.py


```python
# Time:  O(n^2)
# Space: O(n^2)

class Solution(object):
    def unhappyFriends(self, n, preferences, pairs):
        """
        :type n: int
        :type preferences: List[List[int]]
        :type pairs: List[List[int]]
        :rtype: int
        """
        friends = [[0]*n for _ in xrange(n)]
        for i in xrange(len(preferences)):
            for j in xrange(len(preferences[i])):
                friends[i][preferences[i][j]] = j
        pairing = [0]*n
        for i, j in pairs:
            pairing[i], pairing[j] = j, i
        return sum(any(friends[i][j] &lt; friends[i][pairing[i]] and friends[j][i] &lt; friends[j][pairing[j]]
                       for j in xrange(len(friends[i])) if j != i and j != pairing[i])
                   for i in xrange(len(friends)))

```



----------------------------------------------------------------------------------------

### Array - 1619 - https://leetcode.com/problems/mean-of-array-after-removing-some-elements/
Time: O(n)  Space: O(1)   Easy
.Python/mean-of-array-after-removing-some-elements.py


```python
# Time:  O(n) on average, using Median of Medians could achieve O(n) (Intro Select)
# Space: O(1)

import random


class Solution(object):
    def trimMean(self, arr):
        """
        :type arr: List[int]
        :rtype: float
        """
        P = 20
        def nth_element(nums, n, left=0, compare=lambda a, b: a &lt; b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid &lt;= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            right = len(nums)-1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left &lt;= n &lt;= pivot_right:
                    return
                elif pivot_left &gt; n:
                    right = pivot_left-1
                else:  # pivot_right &lt; n.
                    left = pivot_right+1
        
        k = len(arr)//P
        nth_element(arr, k-1)
        nth_element(arr, len(arr)-k, left=k)
        return float(sum(arr[i] for i in xrange(k, len(arr)-k)))/(len(arr)-2*k)

```



----------------------------------------------------------------------------------------

### Array - 1629 - https://leetcode.com/problems/slowest-key/
Time: O(n)  Space: O(1)   Easy
.Python/slowest-key.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def slowestKey(self, releaseTimes, keysPressed):
        """
        :type releaseTimes: List[int]
        :type keysPressed: str
        :rtype: str
        """
        result, lookup = 'a', collections.Counter()
        for i, c in enumerate(keysPressed):
            lookup[c] = max(lookup[c], releaseTimes[i]-(releaseTimes[i-1] if i &gt; 0 else 0))
            if lookup[c] &gt; lookup[result] or lookup[c] == lookup[result] and c &gt; result:
                result = c
        return result

```



----------------------------------------------------------------------------------------

### Array - 1646 - https://leetcode.com/problems/get-maximum-in-generated-array/
Time: O(n)  Space: O(n)   Easy
.Python/get-maximum-in-generated-array.py


```python
# Time:  O(n)
# Space: O(n)

nums = [0, 1]
dp = [0, 1]
class Solution(object):
    def getMaximumGenerated(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n+1 &gt; len(dp):
            for i in xrange(len(nums), n+1):
                if i%2 == 0:
                    nums.append(nums[i//2])
                else:
                    nums.append(nums[i//2] + nums[i//2+1])
                dp.append(max(dp[-1], nums[-1]))
        return dp[n]


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def getMaximumGenerated(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 0:
            return 0
        nums = [0]*(n+1)
        nums[1] = 1
        result = 1
        for i in xrange(2, n+1):
            if i%2 == 0:
                nums[i] = nums[i//2]
            else:
                nums[i] = nums[i//2] + nums[i//2+1]
            result = max(result, nums[i])
        return result

```



----------------------------------------------------------------------------------------

### Array - 1652 - https://leetcode.com/problems/defuse-the-bomb/
Time: O(n)  Space: O(1)   Easy
.Python/defuse-the-bomb.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def decrypt(self, code, k):
        """
        :type code: List[int]
        :type k: int
        :rtype: List[int]
        """
        result = [0]*len(code)
        if k == 0:
            return result
        left, right = 1, k
        if k &lt; 0:
            k = -k
            left, right = len(code)-k, len(code)-1
        total = sum(code[i] for i in xrange(left, right+1))
        for i in xrange(len(code)):
            result[i] = total
            total -= code[left%len(code)]
            total += code[(right+1)%len(code)]
            left += 1
            right += 1
        return result

```



----------------------------------------------------------------------------------------

### Array - 1672 - https://leetcode.com/problems/richest-customer-wealth/
Time: O(m * n)  Space: O(1)   Easy
.Python/richest-customer-wealth.py


```python
# Time:  O(m * n)
# Space: O(1)

import itertools


class Solution(object):
    def maximumWealth(self, accounts):
        """
        :type accounts: List[List[int]]
        :rtype: int
        """
        return max(itertools.imap(sum, accounts))

```



----------------------------------------------------------------------------------------

### Array - 1700 - https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/
Time: O(n)  Space: O(1)   Easy
.Python/number-of-students-unable-to-eat-lunch.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def countStudents(self, students, sandwiches):
        """
        :type students: List[int]
        :type sandwiches: List[int]
        :rtype: int
        """
        count = collections.Counter(students)
        for i, s in enumerate(sandwiches):
            if not count[s]:
                break
            count[s] -= 1
        else:
            i = len(sandwiches)
        return len(sandwiches)-i

```



----------------------------------------------------------------------------------------

### Array - 1701 - https://leetcode.com/problems/average-waiting-time/
Time: O(n)  Space: O(1)   Medium
.Python/average-waiting-time.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def averageWaitingTime(self, customers):
        """
        :type customers: List[List[int]]
        :rtype: float
        """
        avai = wait = 0.0
        for a, t in customers:
            avai = max(avai, a)+t
            wait += avai-a
        return wait/len(customers)

```



----------------------------------------------------------------------------------------

### Array - 1706 - https://leetcode.com/problems/where-will-the-ball-fall/
Time: O(m * n)  Space: O(1)   Medium
.Python/where-will-the-ball-fall.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def findBall(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: List[int]
        """
        result = []
        for c in xrange(len(grid[0])):
            for r in xrange(len(grid)):
                nc = c+grid[r][c]
                if not (0 &lt;= nc &lt; len(grid[0]) and grid[r][nc] == grid[r][c]):
                    c = -1
                    break
                c = nc
            result.append(c)
        return result

```



----------------------------------------------------------------------------------------

### Array - 1714 - https://leetcode.com/problems/sum-of-special-evenly-spaced-elements-in-array/
Time: O(n * sqrt(n))  Space: O(n * sqrt(n))   Hard
.Python/sum-of-special-evenly-spaced-elements-in-array.py


```python
# Time:  O(n * sqrt(n))
# Space: O(n * sqrt(n))

class Solution(object):
    def solve(self, nums, queries):
        """
        :type nums: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        MOD = 10**9+7

        prefix = {}          
        result = []
        for x, y in queries:
            if y*y &gt; len(nums):
                total = 0
                for i in xrange(x, len(nums), y):
                    total += nums[i]
                    total %= MOD
                result.append(total)
            else:
                begin = x%y
                if (begin, y) not in prefix:
                    prefix[(begin, y)] = [0]
                    for i in xrange(begin, len(nums), y):
                        prefix[(begin, y)].append((prefix[(begin, y)][-1] + nums[i]) % MOD)
                result.append((prefix[(begin, y)][-1]-prefix[(begin, y)][x//y]) % MOD)
        return result

```



----------------------------------------------------------------------------------------

### Array - 1726 - https://leetcode.com/problems/tuple-with-same-product/
Time: O(n^2)  Space: O(n^2)   Medium
.Python/tuple-with-same-product.py


```python
# Time:  O(n^2)
# Space: O(n^2)

import collections


class Solution(object):
    def tupleSameProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = 0
        count = collections.Counter()
        for i in xrange(len(nums)):
            for j in xrange(i+1, len(nums)): 
                result += count[nums[i]*nums[j]]
                count[nums[i]*nums[j]] += 1
        return 8*result

```



----------------------------------------------------------------------------------------

### Array - 1732 - https://leetcode.com/problems/find-the-highest-altitude/
Time: O(n)  Space: O(1)   Medium
.Python/find-the-highest-altitude.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def largestAltitude(self, gain):
        """
        :type gain: List[int]
        :rtype: int
        """
        result = curr = 0
        for g in gain:
            curr += g
            result = max(result, curr)
        return result

```



----------------------------------------------------------------------------------------

### Array - 1738 - https://leetcode.com/problems/find-kth-largest-xor-coordinate-value/
Time: O(m * n) on average  Space: O(m * n)   Medium
.Python/find-kth-largest-xor-coordinate-value.py


```python
# Time:  O(m * n) on average
# Space: O(m * n)

import random


class Solution(object):
    def kthLargestValue(self, matrix, k):
        """
        :type matrix: List[List[int]]
        :type k: int
        :rtype: int
        """
        def nth_element(nums, n, compare=lambda a, b: a &lt; b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid &lt;= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left &lt;= n &lt;= pivot_right:
                    return
                elif pivot_left &gt; n:
                    right = pivot_left-1
                else:  # pivot_right &lt; n.
                    left = pivot_right+1
        
        
        vals = []
        for r in xrange(len(matrix)):
            curr = 0
            for c in xrange(len(matrix[0])):
                curr = curr^matrix[r][c]
                if r == 0:
                    matrix[r][c] = curr
                else:
                    matrix[r][c] = curr^matrix[r-1][c]
                vals.append(matrix[r][c])
        nth_element(vals, k-1, compare=lambda a, b: a &gt; b)
        return vals[k-1]

```



----------------------------------------------------------------------------------------

### Array - 1742 - https://leetcode.com/problems/maximum-number-of-balls-in-a-box/
Time: O(nlogm)  Space: O(logm)   Easy
.Python/maximum-number-of-balls-in-a-box.py


```python
# Time:  O(nlogm)
# Space: O(logm)

import collections
import itertools


class Solution(object):
    def countBalls(self, lowLimit, highLimit):
        """
        :type lowLimit: int
        :type highLimit: int
        :rtype: int
        """
        count = collections.Counter()
        for i in xrange(lowLimit, highLimit+1):
            count[sum(itertools.imap(int, str(i)))] += 1
        return max(count.itervalues())

```



----------------------------------------------------------------------------------------

### Array - 1752 - https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-array-is-sorted-and-rotated.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def check(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        count = 0
        for i in xrange(len(nums)):
            if nums[i] &gt; nums[(i+1)%len(nums)]:
                count += 1
                if count &gt; 1:
                    return False
        return True

```



----------------------------------------------------------------------------------------

### Array - 1755 - https://leetcode.com/problems/closest-subsequence-sum/
Time: O(n * 2^(n/2))  Space: O(2^(n/2))   Hard
.Python/closest-subsequence-sum.py


```python
# Time:  O(n * 2^(n/2))
# Space: O(2^(n/2))

import bisect


class Solution(object):
    def minAbsDifference(self, nums, goal):
        """
        :type nums: List[int]
        :type goal: int
        :rtype: int
        """
        mx, mn = sum(x for x in nums if x &gt; 0), sum(x for x in nums if x &lt; 0)
        if goal &gt; mx:
            return goal-mx
        if goal &lt; mn:
            return mn-goal
        result = abs(goal)
        sums1 = set([0])
        for i in xrange(len(nums)//2):
            for x in list(sums1):
                if x+nums[i] in sums1:
                    continue
                sums1.add(x+nums[i])
                result = min(result, abs(goal-x-nums[i]))  # case of right half part is 0
        sorted_sums1 = sorted(sums1)  # Time: O((n/2) * 2^(n/2)) = O(n * 2^(n/2)), Space: O(2^(n/2))
        sums2 = set([0])
        for i in xrange(len(nums)//2, len(nums)):
            for x in list(sums2):
                if x+nums[i] in sums2:
                    continue
                sums2.add(x+nums[i])
                ni = bisect.bisect_left(sorted_sums1, goal-x-nums[i])  # Time: O(2^(n/2)) * O(n/2)
                if ni &lt; len(sorted_sums1):
                    result = min(result, abs(goal-x-nums[i]-sorted_sums1[ni]))
                if ni &gt; 0:
                    result = min(result, abs(goal-x-nums[i]-sorted_sums1[ni-1]))
                if result == 0:
                    return result
        return result

```



----------------------------------------------------------------------------------------

### Array - 1773 - https://leetcode.com/problems/count-items-matching-a-rule/
Time: O(n)  Space: O(1)   Easy
.Python/count-items-matching-a-rule.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countMatches(self, items, ruleKey, ruleValue):
        """
        :type items: List[List[str]]
        :type ruleKey: str
        :type ruleValue: str
        :rtype: int
        """
        rule = {"type":0, "color":1, "name":2}
        return sum(item[rule[ruleKey]] == ruleValue for item in items)

```



----------------------------------------------------------------------------------------

### Array - 1779 - https://leetcode.com/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate/
Time: O(n)  Space: O(1)   Easy
.Python/find-nearest-point-that-has-the-same-x-or-y-coordinate.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def nearestValidPoint(self, x, y, points):
        """
        :type x: int
        :type y: int
        :type points: List[List[int]]
        :rtype: int
        """
        smallest, idx = float("inf"), -1
        for i, (r, c) in enumerate(points):
            dx, dy = x-r, y-c
            if dx*dy == 0 and abs(dx)+abs(dy) &lt; smallest:
                smallest = abs(dx)+abs(dy)
                idx = i
        return idx

```



----------------------------------------------------------------------------------------

### Array - 1800 - https://leetcode.com/problems/maximum-ascending-subarray-sum/
Time: O(n)  Space: O(1)   Easy
.Python/maximum-ascending-subarray-sum.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxAscendingSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = curr = 0
        for i in xrange(len(nums)): 
            if not (i and nums[i-1] &lt; nums[i]):
                curr = 0
            curr += nums[i]
            result = max(result, curr)
        return result

```



----------------------------------------------------------------------------------------

### Array - 1826 - https://leetcode.com/problems/faulty-sensor/
Time: O(n)  Space: O(1)   Easy
.Python/faulty-sensor.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def badSensor(self, sensor1, sensor2):
        """
        :type sensor1: List[int]
        :type sensor2: List[int]
        :rtype: int
        """
        for i in xrange(len(sensor1)-1):
            if sensor1[i] == sensor2[i]:
                continue
            while i+1 &lt; len(sensor2) and sensor2[i+1] == sensor1[i]:
                i += 1
            return 1 if i+1 == len(sensor2) else 2
        return -1

```



----------------------------------------------------------------------------------------

### Array - 1848 - https://leetcode.com/problems/minimum-distance-to-the-target-element/
Time: O(n)  Space: O(1)   Easy
.Python/minimum-distance-to-the-target-element.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def getMinDistance(self, nums, target, start):
        """
        :type nums: List[int]
        :type target: int
        :type start: int
        :rtype: int
        """
        for i in xrange(len(nums)):
            if (start-i &gt;= 0 and nums[start-i] == target) or \
               (start+i &lt; len(nums) and nums[start+i] == target):
                break
        return i

```



----------------------------------------------------------------------------------------

### Array - 1861 - https://leetcode.com/problems/rotating-the-box/
Time: O(m * n)  Space: O(1)   Medium
.Python/rotating-the-box.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def rotateTheBox(self, box):
        """
        :type box: List[List[str]]
        :rtype: List[List[str]]
        """
        result = [['.']*len(box) for _ in xrange(len(box[0]))]
        for i in xrange(len(box)):
            k = len(box[0])-1
            for j in reversed(xrange(len(box[0]))):
                if box[i][j] == '.':
                    continue
                if box[i][j] == '*':
                    k = j
                result[k][-1-i] = box[i][j]
                k -= 1
        return result

```



----------------------------------------------------------------------------------------

### Array - 1869 - https://leetcode.com/problems/longer-contiguous-segments-of-ones-than-zeros/
Time: O(n)  Space: O(1)   Easy
.Python/longer-contiguous-segments-of-ones-than-zeros.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def checkZeroOnes(self, s):
        """
        :type s: str
        :rtype: bool
        """
        max_cnt = [0]*2
        cnt = 0
        for i in xrange(len(s)+1):
            if i == len(s) or (i &gt;= 1 and s[i] != s[i-1]):
                max_cnt[int(s[i-1])] = max(max_cnt[int(s[i-1])], cnt)
                cnt = 0
            cnt += 1
        return max_cnt[0] &lt; max_cnt[1]

```



----------------------------------------------------------------------------------------

### Array - 1878 - https://leetcode.com/problems/get-biggest-three-rhombus-sums-in-a-grid/
Time: O(m * n * min(m, n))  Space: O(m * n)   Easy
.Python/get-biggest-three-rhombus-sums-in-a-grid.py


```python
# Time:  O(m * n * min(m, n))
# Space: O(m * n)

import heapq


class Solution(object):
    def getBiggestThree(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: List[int]
        """	
        K = 3
        left = [[grid[i][j] for j in xrange(len(grid[i]))] for i in xrange(len(grid))]
        right = [[grid[i][j] for j in xrange(len(grid[i]))] for i in xrange(len(grid))]
        for i in xrange(1, len(grid)):
            for j in xrange(len(grid[0])-1):
                left[i][j] += left[i-1][j+1]
        for i in xrange(1, len(grid)):
            for j in xrange(1, len(grid[0])):
                right[i][j] += right[i-1][j-1]
        min_heap = []
        lookup = set()
        for k in xrange((min(len(grid), len(grid[0]))+1)//2):
            for i in xrange(k, len(grid)-k):
                for j in xrange(k, len(grid[0])-k):
                    total = (((left[i][j-k]-left[i-k][j])+(right[i][j+k]-right[i-k][j])+grid[i-k][j]) +  
                             ((left[i+k][j]-left[i][j+k])+(right[i+k][j]-right[i][j-k])-grid[i+k][j])) if k else grid[i][j]
                    if total in lookup:
                        continue
                    lookup.add(total)
                    heapq.heappush(min_heap, total)
                    if len(min_heap) == K+1:                        
                        lookup.remove(heapq.heappop(min_heap))
        min_heap.sort(reverse=True)
        return min_heap

```



----------------------------------------------------------------------------------------

### Array - 1886 - https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/
Time: O(m * n)  Space: O(1)   Easy
.Python/determine-whether-matrix-can-be-obtained-by-rotation.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def findRotation(self, mat, target):
        """
        :type mat: List[List[int]]
        :type target: List[List[int]]
        :rtype: bool
        """
        checks = [lambda i, j: mat[i][j] == target[i][j],
                  lambda i, j: mat[i][j] == target[j][-1-i],
                  lambda i, j: mat[i][j] == target[-1-i][-1-j],
                  lambda i, j: mat[i][j] == target[-1-j][i]]
        traverse = lambda check: all(check(i, j) for i in xrange(len(mat)) for j in xrange(len(mat[0])))
        return any(traverse(check) for check in checks)

```



----------------------------------------------------------------------------------------

### Array - 1895 - https://leetcode.com/problems/largest-magic-square/
Time: O(max(m, n) * min(m, n)^3)  Space: O(m * n)   Medium
.Python/largest-magic-square.py


```python
# Time:  O(max(m, n) * min(m, n)^3)
# Space: O(m + n)

class Solution(object):
    def largestMagicSquare(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        def get_sum(prefix, a, b):
            return prefix[b+1]-prefix[a]

        def check(grid, prefix_row, prefix_col, l, i, j):
            diag, anti_diag = 0, 0
            for d in xrange(l):
                diag += grid[i+d][j+d]
                anti_diag += grid[i+d][j+l-1-d]
            if diag != anti_diag:
                return False
            for ni in xrange(i, i+l):
                if diag != get_sum(prefix_row[ni], j, j+l-1):
                    return False
            for nj in xrange(j, j+l):
                if diag != get_sum(prefix_col[nj], i, i+l-1):
                    return False  
            return True

        prefix_row = [[0]*(len(grid[0])+1) for _ in xrange(len(grid))]
        prefix_col = [[0]*(len(grid)+1) for _ in xrange(len(grid[0]))]
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                prefix_row[i][j+1] = prefix_row[i][j] + grid[i][j]
                prefix_col[j][i+1] = prefix_col[j][i] + grid[i][j]
        for l in reversed(xrange(1, min(len(grid), len(grid[0]))+1)):
            for i in xrange(len(grid)-(l-1)):
                for j in xrange(len(grid[0])-(l-1)):
                    if check(grid, prefix_row, prefix_col, l, i, j):
                        return l
        return 1

```



----------------------------------------------------------------------------------------

### Array - 1906 - https://leetcode.com/problems/minimum-absolute-difference-queries/
Time: O(r * (n + q))  Space: O(r * n)   Medium
.Python/minimum-absolute-difference-queries.py


```python
# Time:  O(r * (n + q)), r is the max of nums
# Space: O(r * n)

class Solution(object):
    def minDifference(self, nums, queries):
        """
        :type nums: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        INF = float("inf")
        prefix = [[0]*(max(nums)+1)]
        for num in nums:
            prefix.append(prefix[-1][:])
            prefix[-1][num] += 1
        result = []
        for l, r in queries:
            min_diff, prev = INF, -1
            for num in xrange(len(prefix[0])):
                if not (prefix[l][num] &lt; prefix[r+1][num]):
                    continue
                if prev != -1:
                    min_diff = min(min_diff, num-prev)
                prev = num
            result.append(min_diff if min_diff != INF else -1)
        return result


# Time:  O(r + n + q * r * logn), r is the max of nums
# Space: O(r + n)
import bisect


class Solution2(object):
    def minDifference(self, nums, queries):
        """
        :type nums: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        INF = float("inf")
        idxs = [[] for _ in xrange(max(nums)+1)]
        for i, num in enumerate(nums):
            idxs[num].append(i)
        result = []
        for l, r in queries:
            min_diff, prev = INF, -1
            for num in xrange(len(idxs)):
                i = bisect.bisect_left(idxs[num], l)
                if not (i &lt; len(idxs[num]) and idxs[num][i] &lt;= r):
                    continue
                if prev != -1:
                    min_diff = min(min_diff, num-prev)
                prev = num
            result.append(min_diff if min_diff != INF else -1)
        return result

```



----------------------------------------------------------------------------------------

### Array - 1909 - https://leetcode.com/problems/remove-one-element-to-make-the-array-strictly-increasing/
Time: O(n)  Space: O(1)   Easy
.Python/remove-one-element-to-make-the-array-strictly-increasing.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def canBeIncreasing(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        deleted = False
        for i in xrange(1, len(nums)):
            if nums[i] &gt; nums[i-1]:
                continue
            if deleted:
                return False
            deleted = True
            if i &gt;= 2 and nums[i-2] &gt; nums[i]:  # delete nums[i] or nums[i-1]
                nums[i] = nums[i-1]
        return True

```



----------------------------------------------------------------------------------------

### Array - 1914 - https://leetcode.com/problems/cyclically-rotating-a-grid/
Time: O(m * n)  Space: O(1)   Medium
.Python/cyclically-rotating-a-grid.py


```python
# Time:  O(m * n)
# Space: O(1)

import fractions


# inplace rotation
class Solution(object):
    def rotateGrid(self, grid, k):
        """
        :type grid: List[List[int]]
        :type k: int
        :rtype: List[List[int]]
        """
        def get_index(m, n, l):
            if l &lt; m-1:
                return l, 0
            if l &lt; (m-1)+(n-1):
                return m-1, l-(m-1)
            if l &lt; (m-1)+(n-1)+(m-1):
                return (m-1)-(l-((m-1)+(n-1))), n-1
            return 0, (n-1)-(l-((m-1)+(n-1)+(m-1)))

        m, n = len(grid), len(grid[0])
        for i in xrange(min(m, n)//2):
            total = 2*((m-1)+(n-1))
            nk = k%total
            num_cycles = fractions.gcd(total, nk)
            cycle_len = total//num_cycles
            for offset in xrange(num_cycles):
                r, c = get_index(m, n, offset)
                for j in xrange(1, cycle_len):
                    nr, nc = get_index(m, n, (offset+j*nk)%total)
                    grid[i+nr][i+nc], grid[i+r][i+c] = grid[i+r][i+c], grid[i+nr][i+nc]
            m, n = m-2, n-2
        return grid


# Time:  O(m * n)
# Space: O(1)
# inplace rotation
class Solution2(object):
    def rotateGrid(self, grid, k):
        """
        :type grid: List[List[int]]
        :type k: int
        :rtype: List[List[int]]
        """
        def get_index(m, n, l):
            if l &lt; m-1:
                return l, 0
            if l &lt; (m-1)+(n-1):
                return m-1, l-(m-1)
            if l &lt; (m-1)+(n-1)+(m-1):
                return (m-1)-(l-((m-1)+(n-1))), n-1
            return 0, (n-1)-(l-((m-1)+(n-1)+(m-1)))

        def reverse(grid, m, n, i, left, right):
            while left &lt; right:
                lr, lc = get_index(m, n, left)
                rr, rc = get_index(m, n, right)
                grid[i+lr][i+lc], grid[i+rr][i+rc] = grid[i+rr][i+rc], grid[i+lr][i+lc]
                left += 1
                right -= 1

        m, n = len(grid), len(grid[0])
        for i in xrange(min(m, n)//2):
            total = 2*((m-1)+(n-1))
            nk = k%total
            reverse(grid, m, n, i, 0, total-1)
            reverse(grid, m, n, i, 0, nk-1)
            reverse(grid, m, n, i, nk, total-1)
            m, n = m-2, n-2
        return grid

```



----------------------------------------------------------------------------------------

### Array - 1920 - https://leetcode.com/problems/build-array-from-permutation/
Time: O(n)  Space: O(1)   Easy
.Python/build-array-from-permutation.py


```python
# Time:  O(n)
# Space: O(1)

# inplace solution
class Solution(object):
    def buildArray(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        for i in xrange(len(nums)):
            prev, curr = i, nums[i]
            while curr &gt;= 0 and curr != i:
                nums[prev], nums[curr] = ~nums[curr], ~nums[prev] if prev == i else nums[prev]
                prev, curr = curr, ~nums[prev]
        for i in xrange(len(nums)):
            if nums[i] &lt; 0:
                nums[i] = ~nums[i]
        return nums


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def buildArray(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        return [nums[x] for x in nums]

```



----------------------------------------------------------------------------------------

### Array - 1929 - https://leetcode.com/problems/concatenation-of-array/
Time: O(n)  Space: O(1)   Easy
.Python/concatenation-of-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def getConcatenation(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        nums.extend(nums)
        return nums


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def getConcatenation(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        return nums+nums


# Time:  O(n)
# Space: O(1)
class Solution3(object):
    def getConcatenation(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        return nums*2

```



----------------------------------------------------------------------------------------

### Array - 1940 - https://leetcode.com/problems/longest-common-subsequence-between-sorted-arrays/
Time: O(m * n)  Space: O(l)   Medium
.Python/longest-common-subsequence-between-sorted-arrays.py


```python
# Time:  O(m * n)
# Space: O(l), l is min(len(arr) for arr in arrays)

class Solution(object):
    def longestCommomSubsequence(self, arrays):
        """
        :type arrays: List[List[int]]
        :rtype: List[int]
        """
        result = min(arrays, key=lambda x: len(x))
        for arr in arrays:
            new_result = []
            i, j = 0, 0
            while i != len(result) and j != len(arr):
                if result[i] &lt; arr[j]:
                    i += 1
                elif result[i] &gt; arr[j]:
                    j += 1
                else:
                    new_result.append(result[i])
                    i += 1
                    j += 1
            result = new_result
        return result


# Time:  O(m * n)
# Space: O(k), k is min(m * n, max(x for arr in arrays for x in arr))
import collections


class Solution2(object):
    def longestCommomSubsequence(self, arrays):
        """
        :type arrays: List[List[int]]
        :rtype: List[int]
        """
        return [num for num, cnt in collections.Counter(x for arr in arrays for x in arr).iteritems() if cnt == len(arrays)]

```



----------------------------------------------------------------------------------------

### Array - 1958 - https://leetcode.com/problems/check-if-move-is-legal/
Time: O(1)  Space: O(1)   Medium
.Python/check-if-move-is-legal.py


```python
# Time:  O(8 * n) = O(1), grid is a n x n board and n = 8
# Space: O(1)

class Solution(object):
    def checkMove(self, board, rMove, cMove, color):
        """
        :type board: List[List[str]]
        :type rMove: int
        :type cMove: int
        :type color: str
        :rtype: bool
        """
        def check(board, color, r, c, dr, dc):
            l = 2
            while 0 &lt;= r &lt; len(board) and 0 &lt;= c &lt; len(board[0]) and board[r][c] != '.':
                if board[r][c] == color:
                    return l &gt;= 3    
                r += dr
                c += dc
                l += 1
            return False

        directions = [(0, -1), (0, 1), (-1, 0), (1, 0),
                      (-1, -1), (1, -1), (-1, 1), (1, 1)]
        for dr, dc in directions:
            r, c = rMove+dr, cMove+dc
            if check(board, color, r, c, dr, dc):
                return True
        return False

```



----------------------------------------------------------------------------------------

### Array - 1966 - https://leetcode.com/problems/binary-searchable-numbers-in-an-unsorted-array/
Time: O(n)  Space: O(n)   Medium
.Python/binary-searchable-numbers-in-an-unsorted-array.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def binarySearchableNumbers(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        right = [float("inf")]*(len(nums)+1)
        for i in reversed(xrange(1, len(nums)+1)):
            right[i-1] = min(right[i], nums[i-1])
        result, left = set(), float("-inf")
        for i in xrange(len(nums)):
            if left &lt;= nums[i] &lt;= right[i+1]:
                result.add(nums[i])
            left = max(left, nums[i])
        return len(result)

```



----------------------------------------------------------------------------------------

### Array - 1970 - https://leetcode.com/problems/last-day-where-you-can-still-cross/
Time: O(m * n)  Space: O(m * n)   Hard
.Python/last-day-where-you-can-still-cross.py


```python
# Time:  O(m * n + c *  (c)) = O(m * n)
# Space: O(m * n)

class UnionFind(object):  # Time: O(n * (n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        if self.rank[x_root] &lt; self.rank[y_root]:  # union by rank
            self.set[x_root] = y_root
        elif self.rank[x_root] &gt; self.rank[y_root]:
            self.set[y_root] = x_root
        else:
            self.set[y_root] = x_root
            self.rank[x_root] += 1
        return True


class Solution(object):
    def latestDayToCross(self, row, col, cells):
        """
        :type row: int
        :type col: int
        :type cells: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def index(n, i, j):
            return i*n+j

        start, end = row*col, row*col+1
        uf = UnionFind(row*col+2)
        lookup = [[False]*col for _ in xrange(row)]
        for i in reversed(xrange(len(cells))):
            r, c = cells[i]
            r, c = r-1, c-1
            for dr, dc in directions:
                nr, nc = r+dr, c+dc
                if not (0 &lt;= nr &lt; row and 0 &lt;= nc &lt; col and lookup[nr][nc]):
                    continue
                uf.union_set(index(col, r, c), index(col, nr, nc))
            if r == 0:
                uf.union_set(start, index(col, r, c))
            if r == row-1:
                uf.union_set(end, index(col, r, c))
            if uf.find_set(start) == uf.find_set(end):
                return i
            lookup[r][c] = True
        return -1

```



----------------------------------------------------------------------------------------

### Array - 1983 - https://leetcode.com/problems/widest-pair-of-indices-with-equal-range-sum/
Time: O(n)  Space: O(n)   Medium
.Python/widest-pair-of-indices-with-equal-range-sum.py


```python
# Time:  O(n)
# Space: O(n)

import itertools


class Solution(object):
    def widestPairOfIndices(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        lookup = {0:-1}
        result = total = 0
        for i, (n1, n2) in enumerate(itertools.izip(nums1, nums2)):
            total += n1-n2
            if total not in lookup:
                lookup[total] = i
            result = max(result, i-lookup[total])
        return result

```



----------------------------------------------------------------------------------------

### Array - 1991 - https://leetcode.com/problems/find-the-middle-index-in-array/
Time: O(n)  Space: O(1)   Easy
.Python/find-the-middle-index-in-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def findMiddleIndex(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        total = sum(nums)
        accu = 0
        for i, x in enumerate(nums):
            if accu*2 == total-x:
                return i
            accu += x
        return -1

```



----------------------------------------------------------------------------------------

### Array - 1992 - https://leetcode.com/problems/find-all-groups-of-farmland/
Time: O(m * n)  Space: O(1)   Medium
.Python/find-all-groups-of-farmland.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def findFarmland(self, land):
        """
        :type land: List[List[int]]
        :rtype: List[List[int]]
        """
        result = []
        for i in xrange(len(land)):
            for j in xrange(len(land[0])):
                if land[i][j] != 1:
                    continue
                ni, nj = i, j
                while ni+1 &lt; len(land) and land[ni+1][j] == 1:
                    ni += 1
                while nj+1 &lt; len(land[0]) and land[i][nj+1] == 1:
                    nj += 1
                for r in xrange(i, ni+1):
                    for c in xrange(j, nj+1):
                        land[r][c] = -1
                result.append([i, j, ni, nj])
        return result

```



----------------------------------------------------------------------------------------

### Array - 1998 - https://leetcode.com/problems/gcd-sort-of-an-array/
Time: O(nlogn + m)  Space: O(n + m)   Hard
.Python/gcd-sort-of-an-array.py


```python
# Time:  O(nlogn + n * (n) + m * log(logm)) ~= O(nlogn + m), m is the max of nums
# Space: O(n + m)

import itertools


class UnionFind(object):  # Time: O(n * (n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        if self.rank[x_root] &lt; self.rank[y_root]:  # union by rank
            self.set[x_root] = y_root
        elif self.rank[x_root] &gt; self.rank[y_root]:
            self.set[y_root] = x_root
        else:
            self.set[y_root] = x_root
            self.rank[x_root] += 1
        return True


class Solution(object):
    def gcdSort(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        def modified_sieve_of_eratosthenes(n, lookup, uf):  # Time: O(n * log(logn)), Space: O(n)
            if n &lt; 2:
                return
            is_prime = [True]*(n+1)
            for i in xrange(2, len(is_prime)):
                if not is_prime[i]:
                    continue
                for j in xrange(i+i, len(is_prime), i):
                    is_prime[j] = False
                    if j in lookup:  # modified
                        uf.union_set(i-1, j-1)

        max_num = max(nums)
        uf = UnionFind(max_num)
        modified_sieve_of_eratosthenes(max_num, set(nums), uf)
        return all(uf.find_set(a-1) == uf.find_set(b-1) for a, b in itertools.izip(nums, sorted(nums)))

```



----------------------------------------------------------------------------------------

### Array - 2007 - https://leetcode.com/problems/find-original-array-from-doubled-array/
Time: O(n + klogk)  Space: O(k)   Medium
.Python/find-original-array-from-doubled-array.py


```python
# Time:  O(n + klogk), k is the distinct number of changed
# Space: O(k)

class Solution(object):
    def findOriginalArray(self, changed):
        """
        :type changed: List[int]
        :rtype: List[int]
        """
        if len(changed)%2:
            return []
        cnts = collections.Counter(changed)
        for x in sorted(cnts.iterkeys()):
            if cnts[x] &gt; cnts[2*x]:
                return []
            cnts[2*x] -= cnts[x] if x else cnts[x]//2
        return list(cnts.elements())

```



----------------------------------------------------------------------------------------

### Array - 2011 - https://leetcode.com/problems/final-value-of-variable-after-performing-operations/
Time: O(n)  Space: O(1)   Easy
.Python/final-value-of-variable-after-performing-operations.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def finalValueAfterOperations(self, operations):
        """
        :type operations: List[str]
        :rtype: int
        """
        return sum(1 if '+' == op[1] else -1 for op in operations)

```



----------------------------------------------------------------------------------------

### Array - 2012 - https://leetcode.com/problems/sum-of-beauty-in-the-array/
Time: O(n)  Space: O(n)   Medium
.Python/sum-of-beauty-in-the-array.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def sumOfBeauties(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        right = [nums[-1]]*len(nums)
        for i in reversed(xrange(2, len(nums)-1)):
            right[i] = min(right[i+1], nums[i])
        result, left = 0, nums[0]
        for i in xrange(1, len(nums)-1):
            if left &lt; nums[i] &lt; right[i+1]:
                result += 2
            elif nums[i-1] &lt; nums[i] &lt; nums[i+1]:
                result += 1
            left = max(left, nums[i])
        return result

```



----------------------------------------------------------------------------------------

### Array - 2016 - https://leetcode.com/problems/maximum-difference-between-increasing-elements/
Time: O(n)  Space: O(1)   Easy
.Python/maximum-difference-between-increasing-elements.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maximumDifference(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result, prefix = 0, float("inf")
        for x in nums: 
            result = max(result, x-prefix)
            prefix = min(prefix, x)
        return result if result else -1

```



----------------------------------------------------------------------------------------

### Array - 2017 - https://leetcode.com/problems/grid-game/
Time: O(n)  Space: O(1)   Medium
.Python/grid-game.py


```python
# Time:  O(n)
# Space: O(1)

import itertools


class Solution(object):
    def gridGame(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        result = float("inf")
        left, right = 0, sum(grid[0])
        for a, b in itertools.izip(grid[0], grid[1]):
            right -= a
            result = min(result, max(left, right))
            left += b
        return result

```



----------------------------------------------------------------------------------------

### Array - 2018 - https://leetcode.com/problems/check-if-word-can-be-placed-in-crossword/
Time: O(m * n)  Space: O(1)   Medium
.Python/check-if-word-can-be-placed-in-crossword.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def placeWordInCrossword(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        def get_val(mat, i, j, transposed):
            return mat[i][j] if not transposed else mat[j][i]

        def get_vecs(mat, transposed):
            for i in xrange(len(mat) if not transposed else len(mat[0])):
                yield (get_val(mat, i, j, transposed) for j in xrange(len(mat[0]) if not transposed else len(mat)))

        for direction in (lambda x: iter(x), reversed):
            for transposed in xrange(2):
                for row in get_vecs(board, transposed):
                    it, matched = direction(word), True
                    for c in row:
                        if c == '#':
                            if next(it, None) is None and matched:
                                return True
                            it, matched = direction(word), True
                            continue
                        if not matched:
                            continue
                        nc = next(it, None)
                        matched = (nc is not None) and c in (nc, ' ')
                    if (next(it, None) is None) and matched:
                        return True
        return False


# Time:  O(m * n)
# Space: O(m * n)
class Solution2(object):
    def placeWordInCrossword(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        words = [word, word[::-1]]
        for mat in (board, zip(*board)):
            for row in mat:
                blocks = ''.join(row).split('#')
                for s in blocks:
                    if len(s) != len(word):
                        continue
                    for w in words:
                        if all(s[i] in (w[i], ' ') for i in xrange(len(s))):
                            return True
        return False

```



----------------------------------------------------------------------------------------

### Array - 2022 - https://leetcode.com/problems/convert-1d-array-into-2d-array/
Time: O(m * n)  Space: O(1)   Easy
.Python/convert-1d-array-into-2d-array.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def construct2DArray(self, original, m, n):
        """
        :type original: List[int]
        :type m: int
        :type n: int
        :rtype: List[List[int]]
        """
        return [original[i:i+n] for i in xrange(0, len(original), n)] if len(original) == m*n else []

```



----------------------------------------------------------------------------------------

### Array - 2033 - https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/
Time: O(m * n)  on average  Space: O(m * n)   Medium
.Python/minimum-operations-to-make-a-uni-value-grid.py


```python
# Time:  O(m * n) on average
# Space: O(m * n)

import random

class Solution(object):
    def minOperations(self, grid, x):
        """
        :type grid: List[List[int]]
        :type x: int
        :rtype: int
        """
        def nth_element(nums, n, compare=lambda a, b: a &lt; b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid &lt;= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left &lt;= n &lt;= pivot_right:
                    return
                elif pivot_left &gt; n:
                    right = pivot_left-1
                else:  # pivot_right &lt; n.
                    left = pivot_right+1

        nums = [v for row in grid for v in row]
        if len(set(v%x for v in nums)) &gt; 1:
            return -1
        nth_element(nums, len(nums)//2)
        median = nums[len(nums)//2]
        return sum(abs(v-median)//x for v in nums)

```



----------------------------------------------------------------------------------------

### Array - 2035 - https://leetcode.com/problems/partition-array-into-two-arrays-to-minimize-sum-difference/
Time: O(n * 2^n)  Space: O(2^n)   Hard
.Python/partition-array-into-two-arrays-to-minimize-sum-difference.py


```python
# Time:  O(n * 2^n)
# Space: O(2^n)

import itertools
import bisect


class Solution(object):
    def minimumDifference(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        left, right = nums[:len(nums)//2], nums[len(nums)//2:]
        total1, total2 = sum(left), sum(right)
        result = float("inf")
        for k in xrange(len(left)+1): 
            sums = sorted(2*sum(comb)-total1 for comb in itertools.combinations(left, k))
            for comb in itertools.combinations(right, len(left)-k): 
                diff = 2*sum(comb)-total2
                i = bisect.bisect_left(sums, -diff)
                if i &lt; len(sums):
                    result = min(result, abs(sums[i]+diff))
                if i &gt; 0:
                    result = min(result, abs(sums[i-1]+diff))
        return result

```



----------------------------------------------------------------------------------------

### Array - 2038 - https://leetcode.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/
Time: O(n)  Space: O(1)   Medium
.Python/remove-colored-pieces-if-both-neighbors-are-the-same-color.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def winnerOfGame(self, colors):
        """
        :type colors: str
        :rtype: bool
        """
        cnt1 = cnt2 = 0
        for i in xrange(1, len(colors)-1):
            if not (colors[i-1] == colors[i] == colors[i+1]):
                continue
            if colors[i] == 'A':
                cnt1 += 1
            else:
                cnt2 += 1
        return cnt1 &gt; cnt2

```



----------------------------------------------------------------------------------------

### Array - 2055 - https://leetcode.com/problems/plates-between-candles/
Time: O(n + q)  Space: O(n)   Medium
.Python/plates-between-candles.py


```python
# Time:  O(n + q)
# Space: O(n)

class Solution(object):
    def platesBetweenCandles(self, s, queries):
        """
        :type s: str
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        left, prefix = [0]*len(s), {}
        curr, cnt = -1, 0
        for i in xrange(len(s)):
            if s[i] == '|':
                curr = i
                cnt += 1
                prefix[i] = cnt
            left[i] = curr
        right = [0]*len(s)
        curr = len(s)
        for i in reversed(xrange(len(s))):
            if s[i] == '|':
                curr = i
            right[i] = curr
        return [max((left[r]-right[l]+1) - (prefix[left[r]]-prefix[right[l]]+1), 0) for l, r in queries]

```



----------------------------------------------------------------------------------------

### Array - 2057 - https://leetcode.com/problems/smallest-index-with-equal-value/
Time: O(n)  Space: O(1)   Easy
.Python/smallest-index-with-equal-value.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def smallestEqual(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return next((i for i, x in enumerate(nums) if i%10 == x), -1)

```



----------------------------------------------------------------------------------------

### Array - 2075 - https://leetcode.com/problems/decode-the-slanted-ciphertext/
Time: O(n)  Space: O(1)   Medium
.Python/decode-the-slanted-ciphertext.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def decodeCiphertext(self, encodedText, rows):
        """
        :type encodedText: str
        :type rows: int
        :rtype: str
        """
        cols = len(encodedText)//rows
        k = len(encodedText)
        for i in reversed(xrange(cols)):
            for j in reversed(xrange(i, len(encodedText), cols+1)):
                if encodedText[j] != ' ':
                    k = j
                    break
            else:
                continue
            break
        result = []
        for i in xrange(cols):
            for j in xrange(i, len(encodedText), cols+1):
                result.append(encodedText[j])
                if j == k:
                    break
            else:
                continue
            break
        return "".join(result)


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def decodeCiphertext(self, encodedText, rows):
        """
        :type encodedText: str
        :type rows: int
        :rtype: str
        """
        cols = len(encodedText)//rows
        result = []
        for i in xrange(cols):
            for j in xrange(i, len(encodedText), cols+1):
                result.append(encodedText[j])
        while result and result[-1] == ' ':
            result.pop()
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Array - 2078 - https://leetcode.com/problems/two-furthest-houses-with-different-colors/
Time: O(n)  Space: O(1)   Easy
.Python/two-furthest-houses-with-different-colors.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxDistance(self, colors):
        """
        :type colors: List[int]
        :rtype: int
        """
        result = 0
        for i, x in enumerate(colors):
            if x != colors[0]:
                result = max(result, i)
            if x != colors[-1]:
                result = max(result, len(colors)-1-i)
        return result

```



----------------------------------------------------------------------------------------

### Array - 2079 - https://leetcode.com/problems/watering-plants/
Time: O(n)  Space: O(1)   Medium
.Python/watering-plants.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def wateringPlants(self, plants, capacity):
        """
        :type plants: List[int]
        :type capacity: int
        :rtype: int
        """
        result, can = len(plants), capacity
        for i, x in enumerate(plants):
            if can &lt; x:
                result += 2*i
                can = capacity
            can -= x
        return result

```



----------------------------------------------------------------------------------------

### Array - 2098 - https://leetcode.com/problems/subsequence-of-size-k-with-the-largest-even-sum/
Time: O(n) on average  Space: O(1)   Medium
.Python/subsequence-of-size-k-with-the-largest-even-sum.py


```python
# Time:  O(n) on average
# Space: O(1)

import random


# quick select solution
class Solution(object):
    def largestEvenSum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def nth_element(nums, n, compare=lambda a, b: a &lt; b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid &lt;= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left &lt;= n &lt;= pivot_right:
                    return
                elif pivot_left &gt; n:
                    right = pivot_left-1
                else:  # pivot_right &lt; n.
                    left = pivot_right+1

        nth_element(nums, k-1, compare=lambda a, b: a &gt; b)
        total = sum(nums[i] for i in xrange(k))
        if total%2 == 0:
            return total
        min_k = [float("inf")]*2
        for i in xrange(k):
            min_k[nums[i]%2] = min(min_k[nums[i]%2], nums[i])
        result = -1
        for i in xrange(k, len(nums)):
            result = max(result, total-min_k[not (nums[i]%2)]+nums[i])
        return result

```



----------------------------------------------------------------------------------------

### Array - 2099 - https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/
Time: O(n) on average  Space: O(n)   Easy
.Python/find-subsequence-of-length-k-with-the-largest-sum.py


```python
# Time:  O(n)
# Space: O(n)

import random


# quick select solution
class Solution(object):
    def maxSubsequence(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        def nth_element(nums, n, compare=lambda a, b: a &lt; b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid &lt;= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left &lt;= n &lt;= pivot_right:
                    return
                elif pivot_left &gt; n:
                    right = pivot_left-1
                else:  # pivot_right &lt; n.
                    left = pivot_right+1

        partition = nums[:]
        nth_element(partition, k-1, compare=lambda a, b: a &gt; b)
        cnt = sum(partition[i] == partition[k-1] for i in xrange(k))
        result = []
        for x in nums:
            if x &gt; partition[k-1]:
                result.append(x)
            elif x == partition[k-1] and cnt &gt; 0:
                cnt -= 1
                result.append(x)
        return result

```



----------------------------------------------------------------------------------------

### Array - 2100 - https://leetcode.com/problems/find-good-days-to-rob-the-bank/
Time: O(n)  Space: O(n)   Medium
.Python/find-good-days-to-rob-the-bank.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def goodDaysToRobBank(self, security, time):
        """
        :type security: List[int]
        :type time: int
        :rtype: List[int]
        """
        right = [0]
        for i in reversed(xrange(1, len(security))):
            right.append(right[-1]+1 if security[i] &gt;= security[i-1] else 0)
        right.reverse()
        result = []
        left = 0
        for i in xrange(len(security)):
            if left &gt;= time and right[i] &gt;= time:
                result.append(i)
            if i+1 &lt; len(security):
                left = left+1 if security[i] &gt;= security[i+1] else 0
        return result

```



----------------------------------------------------------------------------------------

### Array - 2106 - https://leetcode.com/problems/maximum-fruits-harvested-after-at-most-k-steps/
Time: O(n)  Space: O(n)   Hard
.Python/maximum-fruits-harvested-after-at-most-k-steps.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def maxTotalFruits(self, fruits, startPos, k):
        """
        :type fruits: List[List[int]]
        :type startPos: int
        :type k: int
        :rtype: int
        """
        max_pos = max(startPos, fruits[-1][0])
        cnt = [0]*(1+max_pos)
        for p, a in fruits:
            cnt[p] = a
        prefix = [0]
        for x in cnt:
            prefix.append(prefix[-1]+x)
        result = 0
        for left_dist in xrange(min(startPos, k)+1):
            right_dist = max(k-2*left_dist, 0)            
            left, right = startPos-left_dist, min(startPos+right_dist, max_pos)
            result = max(result, prefix[right+1]-prefix[left])
        for right_dist in xrange(min(max_pos-startPos, k)+1):
            left_dist = max(k-2*right_dist, 0) 
            left, right = max(startPos-left_dist, 0), startPos+right_dist
            result = max(result, prefix[right+1]-prefix[left])
        return result

```



----------------------------------------------------------------------------------------

### Array - 2113 - https://leetcode.com/problems/elements-in-array-after-removing-and-replacing-elements/
Time: O(n)  Space: O(1)   Medium
.Python/elements-in-array-after-removing-and-replacing-elements.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def elementInNums(self, nums, queries):
        """
        :type nums: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        result = []
        for t, i in queries:
            t %= 2*len(nums)
            if t+i &lt; len(nums):
                result.append(nums[t+i])
            elif i &lt; t-len(nums):
                result.append(nums[i])
            else:
                result.append(-1)
        return result

```



----------------------------------------------------------------------------------------

### Array - 2121 - https://leetcode.com/problems/intervals-between-identical-elements/
Time: O(n)  Space: O(n)   Medium
.Python/intervals-between-identical-elements.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def getDistances(self, arr):
        """
        :type arr: List[int]
        :rtype: List[int]
        """
        lookup = collections.defaultdict(list)
        for i, x in enumerate(arr):
            lookup[x].append(i)
        result = [0]*len(arr)
        for idxs in lookup.itervalues():
            prefix = [0]
            for i in idxs:
                prefix.append(prefix[-1]+i)
            for i, idx in enumerate(idxs):
                result[idx] = (idx*(i+1)-prefix[i+1]) + ((prefix[len(idxs)]-prefix[i])-idx*(len(idxs)-i))
        return result

```



----------------------------------------------------------------------------------------

### Array - 2122 - https://leetcode.com/problems/recover-the-original-array/
Time: O(n^2)  Space: O(n)   Hard
.Python/recover-the-original-array.py


```python
# Time:  O(n^2)
# Space: O(n)

import collections


class Solution(object):
    def recoverArray(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        def check(k, cnt, result):
            for x in nums:
                if cnt[x] == 0:
                    continue
                if cnt[x+2*k] == 0:
                    return False
                cnt[x] -= 1
                cnt[x+2*k] -= 1
                result.append(x+k)
            return True
            
        nums.sort()
        cnt = collections.Counter(nums)
        for i in xrange(1, len(nums)//2+1):
            k = nums[i]-nums[0]
            if k == 0 or k%2:
                continue
            k //= 2
            result = []
            if check(k, collections.Counter(cnt), result):
                return result
        return []

```



----------------------------------------------------------------------------------------

### Array - 2128 - https://leetcode.com/problems/remove-all-ones-with-row-and-column-flips/
Time: O(m * n)  Space: O(1)   Medium
.Python/remove-all-ones-with-row-and-column-flips.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def removeOnes(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: bool
        """
        return all(grid[i] == grid[0] or all(grid[i][j] != grid[0][j] for j in xrange(len(grid[0]))) for i in xrange(1, len(grid)))

```



----------------------------------------------------------------------------------------

### Array - 2132 - https://leetcode.com/problems/stamping-the-grid/
Time: O(m * n)  Space: O(m * n)   Hard
.Python/stamping-the-grid.py


```python
# Time:  O(m * n)
# Space: O(m * n)

class Solution(object):
    def possibleToStamp(self, grid, stampHeight, stampWidth):
        """
        :type grid: List[List[int]]
        :type stampHeight: int
        :type stampWidth: int
        :rtype: bool
        """
        prefix = [[0]*(len(grid[0])+1) for _ in xrange(len(grid)+1)]
        fit = [[0]*len(grid[0]) for _ in xrange(len(grid))]
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                prefix[i+1][j+1] = prefix[i+1][j]+prefix[i][j+1]-prefix[i][j]+(1^grid[i][j])
                if i+1 &gt;= stampHeight and j+1 &gt;= stampWidth:
                    x, y = i+1-stampHeight, j+1-stampWidth
                    fit[i][j] = int(prefix[i+1][j+1]-prefix[x][j+1]-prefix[i+1][y]+prefix[x][y] == stampWidth*stampHeight)
        prefix2 = [[0]*(len(grid[0])+1) for _ in xrange(len(grid)+1)]
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                prefix2[i+1][j+1] = prefix2[i+1][j]+prefix2[i][j+1]-prefix2[i][j]+fit[i][j]
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                x, y = min(i+stampHeight, len(grid)), min(j+stampWidth, len(grid[0]))
                if not grid[i][j] and not prefix2[x][y]-prefix2[i][y]-prefix2[x][j]+prefix2[i][j]:
                    return False
        return True

```



----------------------------------------------------------------------------------------

### Array - 2155 - https://leetcode.com/problems/all-divisions-with-the-highest-score-of-a-binary-array/
Time: O(n)  Space: O(1)   Medium
.Python/all-divisions-with-the-highest-score-of-a-binary-array.py


```python
# Time:  O(n)
# Space: O(1)

# prefix sum
class Solution(object):
    def maxScoreIndices(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        result = []
        mx = zeros = 0
        total = sum(nums)
        for i in xrange(len(nums)+1):
            zeros += ((nums[i-1] if i else 0) == 0)
            if zeros+(total-(i-zeros)) &gt; mx:
                mx = zeros+(total-(i-zeros))
                result = []
            if zeros+(total-(i-zeros)) == mx:
                result.append(i)
        return result

```



----------------------------------------------------------------------------------------

### Array - 2194 - https://leetcode.com/problems/cells-in-a-range-on-an-excel-sheet/
Time: O(26^2)  Space: O(1)   Easy
.Python/cells-in-a-range-on-an-excel-sheet.py


```python
# Time:  O(26^2)
# Space: O(1)

# enumeration
class Solution(object):
    def cellsInRange(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        return [chr(x)+chr(y) for x in xrange(ord(s[0]), ord(s[3])+1) for y in xrange(ord(s[1]), ord(s[4])+1)]

```



----------------------------------------------------------------------------------------

### Array - 2202 - https://leetcode.com/problems/maximize-the-topmost-element-after-k-moves/
Time: O(min(n, k))  Space: O(1)   Medium
.Python/maximize-the-topmost-element-after-k-moves.py


```python
# Time:  O(min(n, k))
# Space: O(1)

# constructive algorithms
class Solution(object):
    def maximumTop(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        if len(nums) == 1 == k%2:
            return -1
        if k &lt;= 1:
            return nums[k]
        return max(nums[i] for i in xrange(min(k+1, len(nums))) if i != k-1)

```



----------------------------------------------------------------------------------------

### Array - 2210 - https://leetcode.com/problems/count-hills-and-valleys-in-an-array/
Time: O(n)  Space: O(1)   Easy
.Python/count-hills-and-valleys-in-an-array.py


```python
# Time:  O(n)
# Space: O(1)

# simulation, array
class Solution(object):
    def countHillValley(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result, inc = 0, -1
        for i in xrange(len(nums)-1):
            if nums[i] &lt; nums[i+1]:
                result += int(inc == 0)
                inc = 1
            elif nums[i] &gt; nums[i+1]:
                result += int(inc == 1)
                inc = 0
        return result

```



----------------------------------------------------------------------------------------

### Array - 2219 - https://leetcode.com/problems/maximum-sum-score-of-array/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-sum-score-of-array.py


```python
# Time:  O(n)
# Space: O(1)

# prefix sum, math
class Solution(object):
    def maximumSumScore(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        prefix = suffix = 0
        result = float("-inf")
        right = len(nums)-1
        for left in xrange(len(nums)):
            prefix += nums[left]
            suffix += nums[right]
            right -= 1
            result = max(result, prefix, suffix)
        return result

    
# Time:  O(n)
# Space: O(1)
# prefix sum
class Solution2(object):
    def maximumSumScore(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        total = sum(nums)
        prefix = 0
        result = float("-inf")
        for x in nums:
            prefix += x
            result = max(result, prefix, total-prefix+x)
        return result

```



----------------------------------------------------------------------------------------

### Array - 2237 - https://leetcode.com/problems/count-positions-on-street-with-required-brightness/
Time: O(n + l)  Space: O(min(n, l))   Medium
.Python/count-positions-on-street-with-required-brightness.py


```python
# Time:  O(n + l)
# Space: O(min(n, l))

import collections


# line sweep
class Solution(object):
    def meetRequirement(self, n, lights, requirement):
        """
        :type n: int
        :type lights: List[List[int]]
        :type requirement: List[int]
        :rtype: int
        """
        cnt = collections.defaultdict(int)
        for p, r in lights:
            cnt[max(p-r, 0)] += 1
            cnt[min(p+r, n-1)+1] -= 1
        result = curr = 0
        for i, r in enumerate(requirement):
            curr += cnt.get(i, 0)
            if curr &gt;= r:
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Array - 2239 - https://leetcode.com/problems/find-closest-number-to-zero/
Time: O(n)  Space: O(1)   Easy
.Python/find-closest-number-to-zero.py


```python
# Time:  O(n)
# Space: O(1)

# array
class Solution(object):
    def findClosestNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return max(nums, key=lambda x:(-abs(x), x))

```



----------------------------------------------------------------------------------------

### Array - 2245 - https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/
Time: O(m * n)  Space: O(m * n)   Medium
.Python/maximum-trailing-zeros-in-a-cornered-path.py


```python
# Time:  O(m * n)
# Space: O(m * n)

import itertools


# prefix sum
class Solution(object):
    def maxTrailingZeros(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        def factor(x):
            cnt = [0]*2
            for i, p in enumerate([2, 5]):
                while x and x%p == 0:
                    x //= p
                    cnt[i] += 1
            return cnt

        def add(a, b):
            return [x+y for x, y in itertools.izip(a, b)]

        def sub(a, b):
            return [x-y for x, y in itertools.izip(a, b)]

        left = [[None for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))]
        for i in xrange(len(grid)):
            left[i][0] = factor(grid[i][0])
            for j in xrange(1, len(grid[0])):
                left[i][j] = add(left[i][j-1], factor(grid[i][j]))
        result = 0
        for j in xrange(len(grid[0])):
            total = [0]*2
            for i in xrange(len(grid)):
                total = add(total, factor(grid[i][j]))
            up = [0]*2
            for i in xrange(len(grid)):
                right = sub(left[i][-1], left[i][j-1] if j else [0]*2)
                result = max(result, min(add(left[i][j], up)), min(add(right, up)))
                up = add(up, factor(grid[i][j]))
                down = sub(total, up)
                result = max(result, min(add(left[i][j], down)), min(add(right, down)))
        return result

```



----------------------------------------------------------------------------------------

### Array - 2256 - https://leetcode.com/problems/minimum-average-difference/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-average-difference.py


```python
# Time:  O(n)
# Space: O(1)

# prefix sum
class Solution(object):
    def minimumAverageDifference(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        total = sum(nums)
        mn, idx = float("inf"), -1
        prefix = 0
        for i, x in enumerate(nums):
            prefix += x
            a = prefix//(i+1)
            b = (total-prefix)//(len(nums)-(i+1)) if i+1 &lt; len(nums) else 0
            diff = abs(a-b)
            if diff &lt; mn:
                mn, idx = diff, i
        return idx

```



----------------------------------------------------------------------------------------

### Array - 2270 - https://leetcode.com/problems/number-of-ways-to-split-array/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-ways-to-split-array.py


```python
# Time:  O(n)
# Space: O(1)

# prefix sum
class Solution(object):
    def waysToSplitArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        total = sum(nums)
        result = curr = 0
        for i in xrange(len(nums)-1):
            curr += nums[i]
            result += int(curr &gt;= total-curr)
        return result

```



----------------------------------------------------------------------------------------

### Array - 2271 - https://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/
Time: O(nlogn)  Space: O(1)   Medium
.Python/maximum-white-tiles-covered-by-a-carpet.py


```python
# Time:  O(nlogn)
# Space: O(1)

# sliding window, optimized from solution3
class Solution(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        """
        :type tiles: List[List[int]]
        :type carpetLen: int
        :rtype: int
        """
        tiles.sort()
        result = right = gap = 0
        for left, (l, _) in enumerate(tiles):
            if left-1 &gt;= 0:
                gap -= tiles[left][0]-tiles[left-1][1]-1
            r = l+carpetLen-1
            while right+1 &lt; len(tiles) and r+1 &gt;= tiles[right+1][0]:
                right += 1
                gap += tiles[right][0]-tiles[right-1][1]-1
            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)
        return result


# Time:  O(nlogn)
# Space: O(1)
# sliding window, optimized from solution4
class Solution2(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        """
        :type tiles: List[List[int]]
        :type carpetLen: int
        :rtype: int
        """
        tiles.sort()
        result = left = gap = 0
        for right in xrange(len(tiles)):
            if right-1 &gt;= 0:
                gap += tiles[right][0]-tiles[right-1][1]-1
            l = tiles[right][1]-carpetLen+1
            while not (tiles[left][1]+1 &gt;= l):
                left += 1
                gap -= tiles[left][0]-tiles[left-1][1]-1
            result = max(result, min(tiles[right][1]-tiles[left][0]+1, carpetLen)-gap)
        return result


# Time:  O(nlogn)
# Space: O(n)
import bisect


# prefix sum, binary search
class Solution3(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        """
        :type tiles: List[List[int]]
        :type carpetLen: int
        :rtype: int
        """
        tiles.sort()
        prefix = [0]*(len(tiles)+1)
        for i, (l, r) in enumerate(tiles):
            prefix[i+1] = prefix[i]+(r-l+1)
        result = 0
        for left, (l, _) in enumerate(tiles):
            r = l+carpetLen-1
            right = bisect.bisect_right(tiles, [r+1])-1
            extra = max(tiles[right][1]-r, 0)
            result = max(result, (prefix[right+1]-prefix[left])-extra)
        return result


# Time:  O(nlogn)
# Space: O(n)
import bisect


# prefix sum, binary search
class Solution4(object):
    def maximumWhiteTiles(self, tiles, carpetLen):
        """
        :type tiles: List[List[int]]
        :type carpetLen: int
        :rtype: int
        """
        tiles.sort()
        prefix = [0]*(len(tiles)+1)
        for i, (l, r) in enumerate(tiles):
            prefix[i+1] = prefix[i]+(r-l+1)
        result = 0
        for right, (_, r) in enumerate(tiles):
            l = r-carpetLen+1
            left = bisect.bisect_right(tiles, [l])
            if left-1 &gt;= 0 and tiles[left-1][1]+1 &gt;= l:
                left -= 1
            extra = max(l-tiles[left][0], 0)
            result = max(result, (prefix[right+1]-prefix[left])-extra)
        return result

```



----------------------------------------------------------------------------------------

### Array - 2274 - https://leetcode.com/problems/maximum-consecutive-floors-without-special-floors/
Time: O(nlogn)  Space: O(1)   Medium
.Python/maximum-consecutive-floors-without-special-floors.py


```python
# Time:  O(nlogn)
# Space: O(1)

# sort
class Solution(object):
    def maxConsecutive(self, bottom, top, special):
        """
        :type bottom: int
        :type top: int
        :type special: List[int]
        :rtype: int
        """
        special.sort()
        result = max(special[0]-bottom, top-special[-1])
        for i in xrange(1, len(special)):
            result = max(result, special[i]-special[i-1]-1)
        return result

```



----------------------------------------------------------------------------------------

### Array - 2293 - https://leetcode.com/problems/min-max-game/
Time: O(n)  Space: O(1)   Medium
.Python/min-max-game.py


```python
# Time:  O(n)
# Space: O(1)

# simulation, optimized from solution2
class Solution(object):
    def minMaxGame(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        while n != 1:
            new_q = []
            for i in xrange(n//2):
                nums[i] = min(nums[2*i], nums[2*i+1]) if i%2 == 0 else max(nums[2*i], nums[2*i+1])
            n //= 2
        return nums[0]


# Time:  O(n)
# Space: O(n)
# simulation
class Solution2(object):
    def minMaxGame(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        q = nums[:]
        while len(q) != 1:
            new_q = []
            for i in xrange(len(q)//2):
                new_q.append(min(q[2*i], q[2*i+1]) if i%2 == 0 else max(q[2*i], q[2*i+1]))
            q = new_q
        return q[0]

```



----------------------------------------------------------------------------------------

### Array - 2319 - https://leetcode.com/problems/check-if-matrix-is-x-matrix/
Time: O(n^2)  Space: O(1)   Easy
.Python/check-if-matrix-is-x-matrix.py


```python
# Time:  O(n^2)
# Space: O(1)

# array
class Solution(object):
    def checkXMatrix(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: bool
        """
        return all((i-j == 0 or i+j == len(grid)-1) == (grid[i][j] != 0) for i in xrange(len(grid)) for j in xrange(len(grid[0])))

```



----------------------------------------------------------------------------------------

### Array - 2326 - https://leetcode.com/problems/spiral-matrix-iv/
Time: O(m * n)  Space: O(1)   Medium
.Python/spiral-matrix-iv.py


```python
# Time:  O(m * n)
# Space: O(1)

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        pass


# linked list, array
class Solution(object):
    def spiralMatrix(self, m, n, head):
        """
        :type m: int
        :type n: int
        :type head: Optional[ListNode]
        :rtype: List[List[int]]
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        result = [[-1]*n for _ in xrange(m)]
        i = j = d = 0
        while head:
            result[i][j] = head.val
            if not (0 &lt;= i+directions[d][0] &lt; m and 0 &lt;= j+directions[d][1] &lt; n and result[i+directions[d][0]][j+directions[d][1]] == -1):
                d = (d+1)%4
            i, j = i+directions[d][0], j+directions[d][1]
            head = head.next
        return result

```



----------------------------------------------------------------------------------------

### Array - 2373 - https://leetcode.com/problems/largest-local-values-in-a-matrix/
Time: O(n^2)  Space: O(1)   Easy
.Python/largest-local-values-in-a-matrix.py


```python
# Time:  O(m * n)
# Space: O(1)

# array
class Solution(object):
    def largestLocal(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: List[List[int]]
        """
        def find_max(i, j):
            return max(grid[ni][nj] for ni in xrange(i, i+3) for nj in xrange(j, j+3))

        return [[find_max(i, j) for j in xrange(len(grid[0])-2)] for i in xrange(len(grid)-2)]

```



----------------------------------------------------------------------------------------

### String - 1016 - https://leetcode.com/problems/binary-string-with-substrings-representing-1-to-n/
Time: O(n^2)  Space: O(1)   Medium
.Python/binary-string-with-substrings-representing-1-to-n.py


```python
# Time:  O(n^2), n is the length of S
# Space: O(1)

class Solution(object):
    def queryString(self, S, N):
        """
        :type S: str
        :type N: int
        :rtype: bool
        """
        # since S with length n has at most different n-k+1 k-digit numbers
        # =&gt; given S with length n, valid N is at most 2(n-k+1)
        # =&gt; valid N &lt;= 2(n-k+1) &lt; 2n = 2 * S.length
        return all(bin(i)[2:] in S for i in reversed(xrange(N//2, N+1)))

```



----------------------------------------------------------------------------------------

### String - 1023 - https://leetcode.com/problems/camelcase-matching/
Time: O(n * l)  Space: O(1)   Medium
.Python/camelcase-matching.py


```python
# Time:  O(n * l), n is number of quries
#                , l is length of query
# Space: O(1)

class Solution(object):
    def camelMatch(self, queries, pattern):
        """
        :type queries: List[str]
        :type pattern: str
        :rtype: List[bool]
        """
        def is_matched(query, pattern):
            i = 0
            for c in query:
                if i &lt; len(pattern) and pattern[i] == c:
                    i += 1
                elif c.isupper():
                    return False
            return i == len(pattern)
        
        result = []
        for query in queries:
            result.append(is_matched(query, pattern))
        return result

```



----------------------------------------------------------------------------------------

### String - 1061 - https://leetcode.com/problems/lexicographically-smallest-equivalent-string/
Time: O(n)  Space: O(n)   Medium
.Python/lexicographically-smallest-equivalent-string.py


```python
# Time:  O(nlog*n) ~= O(n), n is the length of S
# Space: O(n)

class UnionFind(object):
    def __init__(self, n):
        self.set = range(n)

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        return True
    

class Solution(object):
    def smallestEquivalentString(self, A, B, S):
        """
        :type A: str
        :type B: str
        :type S: str
        :rtype: str
        """
        union_find = UnionFind(26)
        for i in xrange(len(A)):
            union_find.union_set(ord(A[i])-ord('a'), ord(B[i])-ord('a'))
        result = []
        for i in xrange(len(S)):
            parent = union_find.find_set(ord(S[i])-ord('a'))
            result.append(chr(parent+ord('a')))
        return "".join(result)

```



----------------------------------------------------------------------------------------

### String - 1056 - https://leetcode.com/problems/confusing-number/
Time: O(logn)  Space: O(logn)   Easy
.Python/confusing-number.py


```python
# Time:  O(logn)
# Space: O(logn)

class Solution(object):
    def confusingNumber(self, N):
        """
        :type N: int
        :rtype: bool
        """
        lookup = {"0":"0", "1":"1", "6":"9", "8":"8", "9":"6"}
        
        S = str(N)
        result = []
        for i in xrange(len(S)):
            if S[i] not in lookup:
                return False
        for i in xrange((len(S)+1)//2):
            if S[i] != lookup[S[-(i+1)]]:
                return True
        return False

```



----------------------------------------------------------------------------------------

### String - 1071 - https://leetcode.com/problems/greatest-common-divisor-of-strings/
Time: O(m + n)  Space: O(1)   Easy
.Python/greatest-common-divisor-of-strings.py


```python
# Time:  O(m + n)
# Space: O(1)

class Solution(object):
    def gcdOfStrings(self, str1, str2):
        """
        :type str1: str
        :type str2: str
        :rtype: str
        """
        def check(s, common):
            i = 0
            for c in s:
                if c != common[i]:
                    return False
                i = (i+1)%len(common)
            return True
    
        def gcd(a, b):  # Time: O(log(min(a, b)))
            while b:
                a, b = b, a % b
            return a
        
        if not str1 or not str2:
            return ""
        c = gcd(len(str1), len(str2))
        result = str1[:c]
        return result if check(str1, result) and check(str2, result) else ""

```



----------------------------------------------------------------------------------------

### String - 1078 - https://leetcode.com/problems/occurrences-after-bigram/
Time: O(n)  Space: O(1)   Easy
.Python/occurrences-after-bigram.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def findOcurrences(self, text, first, second):
        """
        :type text: str
        :type first: str
        :type second: str
        :rtype: List[str]
        """
        result = []
        first += ' '
        second += ' '
        third = []
        i, j, k = 0, 0, 0
        while k &lt; len(text):
            c = text[k]
            k += 1
            if i != len(first):
                if c == first[i]:
                    i += 1
                else:
                    i = 0
                continue
            if j != len(second):
                if c == second[j]:
                    j += 1
                else:
                    k -= j+1
                    i, j = 0, 0
                continue
            if c != ' ':
                third.append(c)
                continue
            k -= len(second) + len(third) + 1
            i, j = 0, 0
            result.append("".join(third))
            third = []
        if third:
            result.append("".join(third))
        return result

```



----------------------------------------------------------------------------------------

### String - 1100 - https://leetcode.com/problems/find-k-length-substrings-with-no-repeated-characters/
Time: O(n)  Space: O(k)   Medium
.Python/find-k-length-substrings-with-no-repeated-characters.py


```python
# Time:  O(n)
# Space: O(k)

class Solution(object):
    def numKLenSubstrNoRepeats(self, S, K):
        """
        :type S: str
        :type K: int
        :rtype: int
        """
        result, i = 0, 0
        lookup = set()
        for j in xrange(len(S)):
            while S[j] in lookup:
                lookup.remove(S[i])
                i += 1
            lookup.add(S[j])
            result += j-i+1 &gt;= K
        return result

```



----------------------------------------------------------------------------------------

### String - 1108 - https://leetcode.com/problems/defanging-an-ip-address/
Time: O(n)  Space: O(1)   Easy
.Python/defanging-an-ip-address.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def defangIPaddr(self, address):
        """
        :type address: str
        :rtype: str
        """
        result = []
        for c in address:
            if c == '.':
                result.append("[.]")
            else:
                result.append(c)
        return "".join(result)

```



----------------------------------------------------------------------------------------

### String - 1119 - https://leetcode.com/problems/remove-vowels-from-a-string/
Time: O(n)  Space: O(1)   Easy
.Python/remove-vowels-from-a-string.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def removeVowels(self, S):
        """
        :type S: str
        :rtype: str
        """
        lookup = set("aeiou")
        return "".join(c for c in S if c not in lookup)

```



----------------------------------------------------------------------------------------

### String - 1147 - https://leetcode.com/problems/longest-chunked-palindrome-decomposition/
Time: O(n)  Space: O(1)   Hard
.Python/longest-chunked-palindrome-decomposition.py


```python
# Time:  O(n)
# Space: O(1)

# Rabin-Karp Algorithm
class Solution(object):
    def longestDecomposition(self, text):
        """
        :type text: str
        :rtype: int
        """
        def compare(text, l, s1, s2):
            for i in xrange(l):
                if text[s1+i] != text[s2+i]:
                    return False
            return True

        MOD = 10**9+7
        D = 26
        result = 0
        left, right, l, pow_D = 0, 0, 0, 1
        for i in xrange(len(text)):
            left = (D*left + (ord(text[i])-ord('a'))) % MOD
            right = (pow_D*(ord(text[-1-i])-ord('a')) + right) % MOD
            l += 1
            pow_D = (pow_D*D) % MOD 
            if left == right and compare(text, l, i-l+1, len(text)-1-i):
                result += 1
                left, right, l, pow_D = 0, 0, 0, 1
        return result

```



----------------------------------------------------------------------------------------

### String - 1177 - https://leetcode.com/problems/can-make-palindrome-from-substring/
Time: O(m + n)  Space: O(n)   Medium
.Python/can-make-palindrome-from-substring.py


```python
# Time:  O(m + n), m is the number of queries, n is the length of s
# Space: O(n)

import itertools


class Solution(object):
    def canMakePaliQueries(self, s, queries):
        """
        :type s: str
        :type queries: List[List[int]]
        :rtype: List[bool]
        """
        CHARSET_SIZE = 26
        curr, count = [0]*CHARSET_SIZE, [[0]*CHARSET_SIZE]
        for c in s:
            curr[ord(c)-ord('a')] += 1
            count.append(curr[:])
        return [sum((b-a)%2 for a, b in itertools.izip(count[left], count[right+1]))//2 &lt;= k
                for left, right, k in queries]

```



----------------------------------------------------------------------------------------

### String - 1178 - https://leetcode.com/problems/number-of-valid-words-for-each-puzzle/
Time: O(n * l + m * L)  Space: O(L!)   Hard
.Python/number-of-valid-words-for-each-puzzle.py


```python
# Time:  O(n*l + m*L), m is the number of puzzles, L is the length of puzzles
#                    , n is the number of words, l is the max length of words
# Space: O(L!)

class Solution(object):
    def findNumOfValidWords(self, words, puzzles):
        """
        :type words: List[str]
        :type puzzles: List[str]
        :rtype: List[int]
        """
        L = 7
        def search(node, puzzle, start, first, met_first):
            result = 0
            if "_end" in node and met_first:
                result += node["_end"];
            for i in xrange(start, len(puzzle)):
                if puzzle[i] not in node:
                    continue
                result += search(node[puzzle[i]], puzzle, i+1,
                                 first, met_first or (puzzle[i] == first))
            return result

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for word in words:
            count = set(word)
            if len(count) &gt; L:
                continue
            word = sorted(count)
            end = reduce(dict.__getitem__, word, trie)
            end["_end"] = end["_end"]+1 if "_end" in end else 1
        result = []
        for puzzle in puzzles:
            first = puzzle[0]
            result.append(search(trie, sorted(puzzle), 0, first, False))
        return result


# Time:  O(m*2^(L-1) + n*(l+m)), m is the number of puzzles, L is the length of puzzles
#                              , n is the number of words, l is the max length of words
# Space: O(m*2^(L-1))
import collections


class Solution2(object):
    def findNumOfValidWords(self, words, puzzles):
        """
        :type words: List[str]
        :type puzzles: List[str]
        :rtype: List[int]
        """
        L = 7
        lookup = collections.defaultdict(list)
        for i in xrange(len(puzzles)):
            bits = []
            base = 1 &lt;&lt; (ord(puzzles[i][0])-ord('a'))
            for j in xrange(1, L):
                bits.append(ord(puzzles[i][j])-ord('a'))
            for k in xrange(2**len(bits)):
                bitset = base
                for j in xrange(len(bits)):
                    if k &amp; (1&lt;&lt;j):
                        bitset |= 1&lt;&lt;bits[j]
                lookup[bitset].append(i)
        result = [0]*len(puzzles)
        for word in words:
            bitset = 0
            for c in word:
                bitset |= 1&lt;&lt;(ord(c)-ord('a'))
            if bitset not in lookup:
                continue
            for i in lookup[bitset]:
                result[i] += 1
        return result

```



----------------------------------------------------------------------------------------

### String - 1189 - https://leetcode.com/problems/maximum-number-of-balloons/
Time: O(n)  Space: O(1)   Easy
.Python/maximum-number-of-balloons.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def maxNumberOfBalloons(self, text):
        """
        :type text: str
        :rtype: int
        """
        TARGET = "balloon"
        source_count = collections.Counter(text)
        target_count = collections.Counter(TARGET)
        return min(source_count[c]//target_count[c] for c in target_count.iterkeys())

```



----------------------------------------------------------------------------------------

### String - 1233 - https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/
Time: O(n)  Space: O(t)   Medium
.Python/remove-sub-folders-from-the-filesystem.py


```python
# Time:  O(n), n is the total sum of the lengths of folder names
# Space: O(t), t is the number of nodes in trie

import collections
import itertools


class Solution(object):
    def removeSubfolders(self, folder):
        """
        :type folder: List[str]
        :rtype: List[str]
        """
        def dfs(curr, path, result):
            if "_end" in curr:
                result.append("/" + "/".join(path))
                return
            for c in curr:
                if c == "_end":
                    continue
                path.append(c)
                dfs(curr[c], path, result)
                path.pop()

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for f in folder:
            f_list = f.split("/")
            reduce(dict.__getitem__,
                   itertools.islice(f_list, 1, len(f_list)),
                   trie).setdefault("_end")
        result = []
        dfs(trie, [], result)
        return result

```



----------------------------------------------------------------------------------------

### String - 1271 - https://leetcode.com/problems/hexspeak/
Time: O(n)  Space: O(1)   Easy
.Python/hexspeak.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def toHexspeak(self, num):
        """
        :type num: str
        :rtype: str
        """
        lookup = {0:'O', 1:'I'}
        for i in xrange(6):
            lookup[10+i] = chr(ord('A')+i)
        result = []
        n = int(num)
        while n:
            n, r = divmod(n, 16)
            if r not in lookup:
                return "ERROR"
            result.append(lookup[r])
        return "".join(reversed(result))


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def toHexspeak(self, num):
        """
        :type num: str
        :rtype: str
        """
        result = hex(int(num)).upper()[2:].replace('0', 'O').replace('1', 'I')
        return result if all(c in "ABCDEFOI" for c in result) else "ERROR"

```



----------------------------------------------------------------------------------------

### String - 1309 - https://leetcode.com/problems/decrypt-string-from-alphabet-to-integer-mapping/
Time: O(n)  Space: O(1)   Easy
.Python/decrypt-string-from-alphabet-to-integer-mapping.py


```python
# Time:  O(n)
# Space: O(1)

# forward solution
class Solution(object):
    def freqAlphabets(self, s):
        """
        :type s: str
        :rtype: str
        """
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        i = 0
        result = []
        while i &lt; len(s):
            if i+2 &lt; len(s) and s[i+2] == '#':
                result.append(alpha(s[i:i+2]))
                i += 3
            else:
                result.append(alpha(s[i]))
                i += 1
        return "".join(result)


# Time:  O(n)
# Space: O(1)
# backward solution
class Solution2(object):
    def freqAlphabets(self, s):
        """
        :type s: str
        :rtype: str
        """
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        i = len(s)-1
        result = []
        while i &gt;= 0:
            if s[i] == '#':
                result.append(alpha(s[i-2:i]))
                i -= 3
            else:
                result.append(alpha(s[i]))
                i -= 1
        return "".join(reversed(result))

# Time:  O(n)
# Space: O(1)
import re


# regex solution
class Solution3(object):
    def freqAlphabets(self, s):
        """
        :type s: str
        :rtype: str
        """
        def alpha(num):
            return chr(ord('a') + int(num)-1)

        return "".join(alpha(i[:2]) for i in re.findall(r"\d\d#|\d", s))

```



----------------------------------------------------------------------------------------

### String - 1324 - https://leetcode.com/problems/print-words-vertically/
Time: O(n)  Space: O(n)   Medium
.Python/print-words-vertically.py


```python
# Time:  O(n)
# Space: O(n)

import itertools


class Solution(object):
    def printVertically(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        return ["".join(c).rstrip() for c in itertools.izip_longest(*s.split(), fillvalue=' ')]

```



----------------------------------------------------------------------------------------

### String - 1328 - https://leetcode.com/problems/break-a-palindrome/
Time: O(n)  Space: O(1)   Medium
.Python/break-a-palindrome.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def breakPalindrome(self, palindrome):
        """
        :type palindrome: str
        :rtype: str
        """
        for i in xrange(len(palindrome)//2):
            if palindrome[i] != 'a':
                return palindrome[:i] + 'a' + palindrome[i+1:]
        return palindrome[:-1] + 'b' if len(palindrome) &gt;= 2 else ""

```



----------------------------------------------------------------------------------------

### String - 1332 - https://leetcode.com/problems/remove-palindromic-subsequences/
Time: O(n)  Space: O(1)   Easy
.Python/remove-palindromic-subsequences.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def removePalindromeSub(self, s):
        """
        :type s: str
        :rtype: int
        """
        def is_palindrome(s):
            for i in xrange(len(s)//2):
                if s[i] != s[-1-i]:
                    return False
            return True
        
        return 2 - is_palindrome(s) - (s == "")

```



----------------------------------------------------------------------------------------

### String - 1347 - https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-number-of-steps-to-make-two-strings-anagram.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def minSteps(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: int
        """
        diff = collections.Counter(s) - collections.Counter(t)
        return sum(diff.itervalues())

```



----------------------------------------------------------------------------------------

### String - 1370 - https://leetcode.com/problems/increasing-decreasing-string/
Time: O(n)  Space: O(1)   Easy
.Python/increasing-decreasing-string.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def sortString(self, s):
        """
        :type s: str
        :rtype: str
        """
        result, count = [], [0]*26
        for c in s:
            count[ord(c)-ord('a')] += 1
        while len(result) != len(s):
            for c in xrange(len(count)):
                if not count[c]:
                    continue
                result.append(chr(ord('a')+c))
                count[c] -= 1
            for c in reversed(xrange(len(count))):
                if not count[c]:
                    continue
                result.append(chr(ord('a')+c))
                count[c] -= 1
        return "".join(result)


# Time:  O(n)
# Space: O(1)
import collections


class Solution2(object):
    def sortString(self, s):
        """
        :type s: str
        :rtype: str
        """
        result, count, desc = [], collections.Counter(s), False
        while count:
            for c in sorted(count.keys(), reverse=desc):
                result.append(c)
                count[c] -= 1
                if not count[c]:
                    del count[c]
            desc = not desc
        return "".join(result)

```



----------------------------------------------------------------------------------------

### String - 1371 - https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/
Time: O(n)  Space: O(1)   Medium
.Python/find-the-longest-substring-containing-vowels-in-even-counts.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def findTheLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        VOWELS = "aeiou"
        result, mask, lookup = 0, 0, [-2]*(2**len(VOWELS))
        lookup[0] = -1
        for i, c in enumerate(s):
            index = VOWELS.find(c)
            mask ^= (1 &lt;&lt; index) if index &gt;= 0 else 0
            if lookup[mask] == -2:
                lookup[mask] = i
            result = max(result, i-lookup[mask])
        return result

```



----------------------------------------------------------------------------------------

### String - 1374 - https://leetcode.com/problems/generate-a-string-with-characters-that-have-odd-counts/
Time: O(n)  Space: O(1)   Easy
.Python/generate-a-string-with-characters-that-have-odd-counts.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def generateTheString(self, n):
        """
        :type n: int
        :rtype: str
        """
        result = ['a']*(n-1)
        result.append('a' if n%2 else 'b')
        return "".join(result)

```



----------------------------------------------------------------------------------------

### String - 1392 - https://leetcode.com/problems/longest-happy-prefix/
Time: O(n)  Space: O(n)   Hard
.Python/longest-happy-prefix.py


```python
# Time:  O(n)
# Space: O(n)

# kmp solution
class Solution(object):
    def longestPrefix(self, s):
        """
        :type s: str
        :rtype: str
        """
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in xrange(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        return s[:getPrefix(s)[-1]+1]


# Time:  O(n) on average
# Space: O(1)
# rolling-hash solution
class Solution2(object):
    def longestPrefix(self, s):
        """
        :type s: str
        :rtype: str
        """
        M = 10**9+7
        D = 26
        def check(l, s):
            for i in xrange(l):
                if s[i] != s[len(s)-l+i]:
                    return False
            return True
    
        result, prefix, suffix, power = 0, 0, 0, 1
        for i in xrange(len(s)-1):
            prefix = (prefix*D + (ord(s[i])-ord('a'))) % M
            suffix = (suffix + (ord(s[len(s)-(i+1)])-ord('a'))*power) % M
            power = (power*D)%M
            if prefix == suffix:
                # we assume M is a very large prime without hash collision
                # assert(check(i+1, s))
                result = i+1
        return s[:result]

```



----------------------------------------------------------------------------------------

### String - 1408 - https://leetcode.com/problems/string-matching-in-an-array/
Time: O(n)  Space: O(t)   Easy
.Python/string-matching-in-an-array.py


```python
# Time:  O(n + m + z) = O(n), n is the total size of patterns
#                           , m is the total size of query string
#                           , z is the number of all matched strings
#                           , O(n) = O(m) = O(z) in this problem
# Space: O(t), t is the total size of ac automata trie

import collections


class AhoNode(object):
    def __init__(self):
        self.children = collections.defaultdict(AhoNode)
        self.indices = []
        self.suffix = None
        self.output = None


class AhoTrie(object):

    def step(self, letter):
        while self.__node and letter not in self.__node.children:
            self.__node = self.__node.suffix
        self.__node = self.__node.children[letter] if self.__node else self.__root
        return self.__get_ac_node_outputs(self.__node)
    
    def reset(self):
        self.__node = self.__root
    
    def __init__(self, patterns):
        self.__root = self.__create_ac_trie(patterns)
        self.__node = self.__create_ac_suffix_and_output_links(self.__root)
    
    def __create_ac_trie(self, patterns):  # Time:  O(n), Space: O(t)
        root = AhoNode()
        for i, pattern in enumerate(patterns):
            node = root
            for c in pattern:
                node = node.children[c]
            node.indices.append(i)
        return root

    def __create_ac_suffix_and_output_links(self, root):  # Time:  O(n), Space: O(t)
        queue = collections.deque()
        for node in root.children.itervalues():
            queue.append(node)
            node.suffix = root

        while queue:
            node = queue.popleft()
            for c, child in node.children.iteritems():
                queue.append(child)
                suffix = node.suffix
                while suffix and c not in suffix.children:
                    suffix = suffix.suffix
                child.suffix = suffix.children[c] if suffix else root
                child.output = child.suffix if child.suffix.indices else child.suffix.output
                
        return root

    def __get_ac_node_outputs(self, node):  # Time:  O(z)
        result = []
        for i in node.indices:
            result.append(i)
        output = node.output
        while output:
            for i in output.indices:
                result.append(i)
            output = output.output
        return result
    
    
class Solution(object):
    def stringMatching(self, words):
        """
        :type words: List[str]
        :rtype: List[str]
        """
        trie = AhoTrie(words)
        lookup = set()
        for i in xrange(len(words)):
            trie.reset()
            for c in words[i]:
                for j in trie.step(c):
                    if j != i:
                        lookup.add(j)
        return [words[i] for i in lookup]


# Time:  O(n^2 * l), n is the number of strings
# Space: O(l)      , l is the max length of strings
class Solution2(object):
    def stringMatching(self, words):
        """
        :type words: List[str]
        :rtype: List[str]
        """
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in xrange(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
            
        def kmp(text, pattern, prefix):
            if not pattern:
                return 0
            if len(text) &lt; len(pattern):
                return -1
            j = -1
            for i in xrange(len(text)):
                while j != -1 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1
            
        result = []
        for i, pattern in enumerate(words):
            prefix = getPrefix(pattern)
            for j, text in enumerate(words):
                if i != j and kmp(text, pattern, prefix) != -1:
                    result.append(pattern)
                    break
        return result


# Time:  O(n^2 * l^2), n is the number of strings
# Space: O(1)        , l is the max length of strings
class Solution3(object):
    def stringMatching(self, words):
        """
        :type words: List[str]
        :rtype: List[str]
        """
        result = []
        for i, pattern in enumerate(words):
            for j, text in enumerate(words):
                if i != j and pattern in text:
                    result.append(pattern)
                    break
        return result

```



----------------------------------------------------------------------------------------

### String - 1410 - https://leetcode.com/problems/html-entity-parser/
Time: O(n)  Space: O(t)   Medium
.Python/html-entity-parser.py


```python
# Time:  O(n + m + z) = O(m), n is the total size of patterns
#                           , m is the total size of query string
#                           , z is the number of all matched strings
#                           , O(n) = O(1), O(z) = O(m) in this problem
# Space: O(t) = O(1), t is the total size of ac automata trie
#                   , O(t) = O(1) in this problem

import collections


class AhoNode(object):
    def __init__(self):
        self.children = collections.defaultdict(AhoNode)
        self.indices = []
        self.suffix = None
        self.output = None


class AhoTrie(object):

    def step(self, letter):
        while self.__node and letter not in self.__node.children:
            self.__node = self.__node.suffix
        self.__node = self.__node.children[letter] if self.__node else self.__root
        return self.__get_ac_node_outputs(self.__node)
    
    def __init__(self, patterns):
        self.__root = self.__create_ac_trie(patterns)
        self.__node = self.__create_ac_suffix_and_output_links(self.__root)
    
    def __create_ac_trie(self, patterns):  # Time:  O(n), Space: O(t)
        root = AhoNode()
        for i, pattern in enumerate(patterns):
            node = root
            for c in pattern:
                node = node.children[c]
            node.indices.append(i)
        return root

    def __create_ac_suffix_and_output_links(self, root):  # Time:  O(n), Space: O(t)
        queue = collections.deque()
        for node in root.children.itervalues():
            queue.append(node)
            node.suffix = root

        while queue:
            node = queue.popleft()
            for c, child in node.children.iteritems():
                queue.append(child)
                suffix = node.suffix
                while suffix and c not in suffix.children:
                    suffix = suffix.suffix
                child.suffix = suffix.children[c] if suffix else root
                child.output = child.suffix if child.suffix.indices else child.suffix.output
                
        return root

    def __get_ac_node_outputs(self, node):  # Time:  O(z)
        result = []
        for i in node.indices:
            result.append(i)
        output = node.output
        while output:
            for i in output.indices:
                result.append(i)
            output = output.output
        return result


class Solution(object):
    def entityParser(self, text):
        """
        :type text: str
        :rtype: str
        """
        patterns = [""", "'", "&amp;", "&gt;", "&lt;", ""]
        chars = ["\"", "'", "&amp;", "&gt;", "&lt;", "/"]
        trie = AhoTrie(patterns)
        positions = []
        for i in xrange(len(text)):
            for j in trie.step(text[i]):
                positions.append([i-len(patterns[j])+1, j])
        result = []
        i, j = 0, 0
        while i != len(text):
            if j == len(positions) or i != positions[j][0]:                    
                result.append(text[i])
                i += 1
            else:
                result.append(chars[positions[j][1]])
                i += len(patterns[positions[j][1]])
                j += 1
        return "".join(result)


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def entityParser(self, text):
        """
        :type text: str
        :rtype: str
        """
        patterns = [""", "'", "&amp;", "&gt;", "&lt;", ""]
        chars = ["\"", "'", "&amp;", "&gt;", "&lt;", "/"]
        result = []
        i, j = 0, 0
        while i != len(text):
            if text[i] != '&amp;':                    
                result.append(text[i])
                i += 1
            else:
                for j, pattern in enumerate(patterns):
                    if pattern == text[i:i+len(pattern)]:
                        result.append(chars[j])
                        i += len(pattern)
                        break
                else:
                    result.append(text[i])
                    i += 1
        return "".join(result)

```



----------------------------------------------------------------------------------------

### String - 1417 - https://leetcode.com/problems/reformat-the-string/
Time: O(n)  Space: O(1)   Easy
.Python/reformat-the-string.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def reformat(self, s):
        """
        :type s: str
        :rtype: str
        """
        def char_gen(start, end, count):
            for c in xrange(ord(start), ord(end)+1):
                c = chr(c)
                for i in xrange(count[c]):
                    yield c
            yield ''
    
        count = collections.defaultdict(int)
        alpha_cnt = 0
        for c in s:
            count[c] += 1
            if c.isalpha():
                alpha_cnt += 1
        if abs(len(s)-2*alpha_cnt) &gt; 1:
            return ""

        result = []
        it1, it2 = char_gen('a', 'z', count), char_gen('0', '9', count)
        if alpha_cnt &lt; len(s)-alpha_cnt:
            it1, it2 = it2, it1
        while len(result) &lt; len(s):
            result.append(next(it1))
            result.append(next(it2))
        return "".join(result)

```



----------------------------------------------------------------------------------------

### String - 1422 - https://leetcode.com/problems/maximum-score-after-splitting-a-string/
Time: O(n)  Space: O(1)   Easy
.Python/maximum-score-after-splitting-a-string.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxScore(self, s):
        """
        :type s: str
        :rtype: int
        """
        result, zeros, ones = 0, 0, 0
        for i in xrange(1, len(s)-1):
            if s[i] == '0':
                zeros += 1
            else:
                ones += 1
            result = max(result, zeros-ones)
        return result + ones + (s[0] == '0') + (s[-1] == '1')

```



----------------------------------------------------------------------------------------

### String - 1432 - https://leetcode.com/problems/max-difference-you-can-get-from-changing-an-integer/
Time: O(logn)  Space: O(logn)   Medium
.Python/max-difference-you-can-get-from-changing-an-integer.py


```python
# Time:  O(logn)
# Space: O(logn)

class Solution(object):
    def maxDiff(self, num):
        """
        :type num: int
        :rtype: int
        """
        digits = str(num)
        for b in digits:
            if b &lt; '9':
                break
        if digits[0] != '1':
            a = digits[0]
        else:
            for a in digits:
                if a &gt; '1':
                    break
        return int(digits.replace(b, '9')) - \
               int(digits.replace(a, '1' if digits[0] != '1' else '0'))

```



----------------------------------------------------------------------------------------

### String - 1436 - https://leetcode.com/problems/destination-city/
Time: O(n)  Space: O(n)   Easy
.Python/destination-city.py


```python
# Time:  O(n)
# Space: O(n)

import itertools


class Solution(object):
    def destCity(self, paths):
        """
        :type paths: List[List[str]]
        :rtype: str
        """
        A, B = map(set, itertools.izip(*paths))
        return (B-A).pop()

```



----------------------------------------------------------------------------------------

### String - 1446 - https://leetcode.com/problems/consecutive-characters/
Time: O(n)  Space: O(1)   Easy
.Python/consecutive-characters.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxPower(self, s):
        """
        :type s: str
        :rtype: int
        """
        result, count = 1, 1
        for i in xrange(1, len(s)):
            if s[i] == s[i-1]:
                count += 1
            else:
                count = 1
            result = max(result, count)
        return result


# Time:  O(n)
# Space: O(n)
import itertools


class Solution2(object):
    def maxPower(self, s):
        return max(len(list(v)) for _, v in itertools.groupby(s))

```



----------------------------------------------------------------------------------------

### String - 1455 - https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/
Time: O(n)  Space: O(n)   Easy
.Python/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def isPrefixOfWord(self, sentence, searchWord):
        """
        :type sentence: str
        :type searchWord: str
        :rtype: int
        """
        def KMP(text, pattern):
            def getPrefix(pattern):
                prefix = [-1] * len(pattern)
                j = -1
                for i in xrange(1, len(pattern)):
                    while j &gt; -1 and pattern[j + 1] != pattern[i]:
                        j = prefix[j]
                    if pattern[j + 1] == pattern[i]:
                        j += 1
                    prefix[i] = j
                return prefix
    
            prefix = getPrefix(pattern)
            j = -1
            for i in xrange(len(text)):
                while j != -1 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1
        
        if sentence.startswith(searchWord):
            return 1
        p = KMP(sentence, ' ' + searchWord)
        if p == -1:
            return -1
        return 1+sum(sentence[i] == ' ' for i in xrange(p+1))

```



----------------------------------------------------------------------------------------

### String - 1461 - https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/
Time: O(n * k)  Space: O(k * 2^k)   Medium
.Python/check-if-a-string-contains-all-binary-codes-of-size-k.py


```python
# Time:  O(n * k)
# Space: O(k * 2^k)

class Solution(object):
    def hasAllCodes(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: bool
        """
        return 2**k &lt;= len(s) and len({s[i:i+k] for i in xrange(len(s)-k+1)}) == 2**k
    

# Time:  O(n * k)
# Space: O(2^k)
class Solution2(object):
    def hasAllCodes(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: bool
        """
        lookup = set()
        base = 2**k
        if base &gt; len(s):
            return False
        num = 0
        for i in xrange(len(s)):
            num = (num &lt;&lt; 1) + (s[i] == '1')
            if i &gt;= k-1:
                lookup.add(num)
                num -= (s[i-k+1] == '1') * (base//2)
        return len(lookup) == base

```



----------------------------------------------------------------------------------------

### String - 1496 - https://leetcode.com/problems/path-crossing/
Time: O(n)  Space: O(n)   Easy
.Python/path-crossing.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def isPathCrossing(self, path):
        """
        :type path: str
        :rtype: bool
        """
        x = y = 0
        lookup = {(0, 0)}
        for c in path:
            if c == 'E':
                x += 1
            elif c == 'W':
                x -= 1
            elif c == 'N':
                y += 1
            elif c == 'S':
                y -= 1
            if (x, y) in lookup:
                return True
            lookup.add((x, y))
        return False

```



----------------------------------------------------------------------------------------

### String - 1507 - https://leetcode.com/problems/reformat-date/
Time: O(n)  Space: O(1)   Easy
.Python/reformat-date.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def reformatDate(self, date):
        """
        :type date: str
        :rtype: str
        """
        lookup = {"Jan":1, "Feb":2, "Mar":3, "Apr":4,
                  "May":5, "Jun":6, "Jul":7, "Aug":8,
                  "Sep":9, "Oct":10, "Nov":11, "Dec":12}
        return "{:04d}-{:02d}-{:02d}".format(int(date[-4:]), lookup[date[-8:-5]], int(date[:date.index(' ')-2]))

```



----------------------------------------------------------------------------------------

### String - 1528 - https://leetcode.com/problems/shuffle-string/
Time: O(n)  Space: O(1)   Easy
.Python/shuffle-string.py


```python
# Time:  O(n)
# Space: O(1)

# in-place solution
class Solution(object):
    def restoreString(self, s, indices):
        """
        :type s: str
        :type indices: List[int]
        :rtype: str
        """
        result = list(s)
        for i, c in enumerate(result):
            if indices[i] == i:
                continue
            move, j = c, indices[i]
            while j != i:
                result[j], move = move, result[j]
                indices[j], j = j, indices[j]
            result[i] = move
        return "".join(result)


# Time:  O(n)
# Space: O(1)
import itertools


class Solution2(object):
    def restoreString(self, s, indices):
        """
        :type s: str
        :type indices: List[int]
        :rtype: str
        """
        result = ['']*len(s)
        for i, c in itertools.izip(indices, s):
            result[i] = c
        return "".join(result)

```



----------------------------------------------------------------------------------------

### String - 1529 - https://leetcode.com/problems/bulb-switcher-iv/
Time: O(n)  Space: O(1)   Medium
.Python/bulb-switcher-iv.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minFlips(self, target):
        """
        :type target: str
        :rtype: int
        """
        result, curr = 0, '0'
        for c in target:
            if c == curr:
                continue
            curr = c
            result += 1
        return result

```



----------------------------------------------------------------------------------------

### String - 1540 - https://leetcode.com/problems/can-convert-string-in-k-moves/
Time: O(n)  Space: O(1)   Medium
.Python/can-convert-string-in-k-moves.py


```python
# Time:  O(n)
# Space: O(1)

import itertools


class Solution(object):
    def canConvertString(self, s, t, k):
        """
        :type s: str
        :type t: str
        :type k: int
        :rtype: bool
        """
        if len(s) != len(t):
            return False
        cnt = [0]*26
        for a, b in itertools.izip(s, t):
            diff = (ord(b)-ord(a)) % len(cnt)
            if diff != 0 and cnt[diff]*len(cnt) + diff &gt; k:
                return False
            cnt[diff] += 1
        return True

```



----------------------------------------------------------------------------------------

### String - 1542 - https://leetcode.com/problems/find-longest-awesome-substring/
Time: O(n)  Space: O(1)   Hard
.Python/find-longest-awesome-substring.py


```python
# Time:  O(10 * n)
# Space: O(1024)

class Solution(object):
    def longestAwesome(self, s):
        """
        :type s: str
        :rtype: int
        """
        ALPHABET_SIZE = 10
        result, mask, lookup = 0, 0, [len(s)]*(2**ALPHABET_SIZE)
        lookup[0] = -1
        for i, ch in enumerate(s):
            mask ^= 2**(ord(ch)-ord('0'))
            if lookup[mask] == len(s):
                lookup[mask] = i
            result = max(result, i - lookup[mask])
            for d in xrange(ALPHABET_SIZE):
                result = max(result, i - lookup[mask^(2**d)])
        return result

```



----------------------------------------------------------------------------------------

### String - 1544 - https://leetcode.com/problems/make-the-string-great/
Time: O(n)  Space: O(1)   Easy
.Python/make-the-string-great.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def makeGood(self, s):
        """
        :type s: str
        :rtype: str
        """
        stk = []
        for ch in s:
            counter_ch = ch.upper() if ch.islower() else ch.lower()
            if stk and stk[-1] == counter_ch:
                stk.pop()
            else:
                stk.append(ch)
        return "".join(stk)

```



----------------------------------------------------------------------------------------

### String - 1545 - https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/
Time: O(n)  Space: O(1)   Medium
.Python/find-kth-bit-in-nth-binary-string.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def findKthBit(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: str
        """
        flip, l = 0, 2**n-1
        while k &gt; 1:
            if k == l//2+1:
                flip ^= 1
                break
            if k &gt; l//2:
                k = l+1-k
                flip ^= 1
            l //= 2
        return str(flip)

```



----------------------------------------------------------------------------------------

### String - 1554 - https://leetcode.com/problems/strings-differ-by-one-character/
Time: O(n * m)  Space: O(n)   Medium
.Python/strings-differ-by-one-character.py


```python
# Time:  O(n * m)
# Space: O(n)

import collections


class Solution(object):
    def differByOne(self, dict):
        """
        :type dict: List[str]
        :rtype: bool
        """
        MOD, P = 10**9+7, 113

        hashes = [0]*len(dict)
        for i, word in enumerate(dict):
            for c in word:
                hashes[i] = (P*hashes[i] + (ord(c)-ord('a'))) % MOD

        base = 1
        for p in reversed(xrange(len(dict[0]))):        
            lookup = collections.defaultdict(list)
            for i, word in enumerate(dict):
                new_hash = (hashes[i] - base*(ord(word[p])-ord('a'))) % MOD
                if new_hash in lookup:
                    for j in lookup[new_hash]:
                        if dict[j][:p]+dict[j][p+1:] == word[:p]+word[p+1:]:
                            return True
                lookup[new_hash].append(i)
            base = P*base % MOD
        return False

```



----------------------------------------------------------------------------------------

### String - 1556 - https://leetcode.com/problems/thousand-separator/
Time: O(n)  Space: O(1)   Easy
.Python/thousand-separator.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def thousandSeparator(self, n):
        """
        :type n: int
        :rtype: str
        """
        result = []
        s = str(n)
        for i, c in enumerate(str(n)):
            if i and (len(s)-i)%3 == 0:
                result.append(".")
            result.append(c)
        return "".join(result)

```



----------------------------------------------------------------------------------------

### String - 1573 - https://leetcode.com/problems/number-of-ways-to-split-a-string/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-ways-to-split-a-string.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def numWays(self, s):
        """
        :type s: str
        :rtype: int
        """
        MOD = 10**9+7

        ones = s.count('1')
        if ones % 3:
            return 0
        ones //= 3
        if ones == 0:
            return (len(s)-1)*(len(s)-2)//2 % MOD
        count = left = right = 0
        for c in s:
            if c == '1':
                count += 1
            if count == ones:
                left += 1
            elif count == 2*ones:
                right += 1
        return left*right % MOD

```



----------------------------------------------------------------------------------------

### String - 1576 - https://leetcode.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/
Time: O(n)  Space: O(1)   Easy
.Python/replace-all-s-to-avoid-consecutive-repeating-characters.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def modifyString(self, s):
        """
        :type s: str
        :rtype: str
        """
        s = list(s)
        for i in xrange(len(s)):
            if s[i] != '?':
                continue
            for c in ('a', 'b', 'c'):
                if (i == 0 or s[i-1] != c) and (i == len(s)-1 or c != s[i+1]):
                    break
            s[i] = c
        return "".join(s)

```



----------------------------------------------------------------------------------------

### String - 1592 - https://leetcode.com/problems/rearrange-spaces-between-words/
Time: O(n)  Space: O(1)   Easy
.Python/rearrange-spaces-between-words.py


```python
# Time:  O(n)
# Space: O(1)

# inplace solution
class Solution(object):
    def reorderSpaces(self, text):
        """
        :type text: str
        :rtype: str
        """
        text = list(text)
        # count the spaces and words
        space_count, word_count = 0, 0
        for i, c in enumerate(text):
            if c == ' ':
                space_count += 1
            elif i == 0 or text[i-1] == ' ':
                word_count += 1

        # rearrange all the spaces to the right
        left, i = 0, 0
        while i &lt; len(text):
            has_word = False
            while i &lt; len(text) and text[i] != ' ':
                text[left], text[i] = text[i], text[left]
                left += 1
                i += 1
                has_word = True
            if has_word:
                left += 1  # keep one space
            i += 1

        # rearrange all the spaces to the left
        equal_count = space_count//(word_count-1) if word_count-1 &gt; 0 else 0
        extra_count = space_count%(word_count-1) if word_count-1 &gt; 0 else space_count
        right, i = len(text)-1-extra_count, len(text)-1
        while i &gt;= 0:
            has_word = False
            while i &gt;= 0 and text[i] != ' ':
                text[right], text[i] = text[i], text[right]
                right -= 1
                i -= 1
                has_word = True
            if has_word:
                right -= equal_count  # keep equal_count spaces
            i -= 1
        return "".join(text)

```



----------------------------------------------------------------------------------------

### String - 1598 - https://leetcode.com/problems/crawler-log-folder/
Time: O(n)  Space: O(1)   Easy
.Python/crawler-log-folder.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minOperations(self, logs):
        """
        :type logs: List[str]
        :rtype: int
        """
        result = 0
        for log in logs:
            if log == "../":
                if result &gt; 0:
                    result -= 1
            elif log != "./":
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### String - 1614 - https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/
Time: O(n)  Space: O(1)   Easy
.Python/maximum-nesting-depth-of-the-parentheses.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxDepth(self, s):
        """
        :type s: str
        :rtype: int
        """
        result = curr = 0
        for c in s:
            if c == '(':
                curr += 1
                result = max(result, curr)
            elif c == ')':
                curr -= 1
        return result

```



----------------------------------------------------------------------------------------

### String - 1624 - https://leetcode.com/problems/largest-substring-between-two-equal-characters/
Time: O(n)  Space: O(1)   Easy
.Python/largest-substring-between-two-equal-characters.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxLengthBetweenEqualCharacters(self, s):
        """
        :type s: str
        :rtype: int
        """
        result, lookup = -1, {}
        for i, c in enumerate(s):
            result = max(result, i-lookup.setdefault(c, i)-1)
        return result

```



----------------------------------------------------------------------------------------

### String - 1638 - https://leetcode.com/problems/count-substrings-that-differ-by-one-character/
Time: O(m * n)  Space: O(1)   Medium
.Python/count-substrings-that-differ-by-one-character.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def countSubstrings(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: int
        """
        def count(i, j):  # for each possible alignment, count the number of substrs that differ by 1 char
            result = left_cnt = right_cnt = 0  # left and right consecutive same counts relative to the different char
            for k in xrange(min(len(s)-i, len(t)-j)):
                right_cnt += 1
                if s[i+k] != t[j+k]:
                    left_cnt, right_cnt = right_cnt, 0
                    # prev_i = i+k-prev+1
                result += left_cnt  # target substrs are [s[left_i+c:i+k+1] for c in xrange(left_cnt)]
            return result

        return sum(count(i, 0) for i in xrange(len(s))) + \
               sum(count(0, j) for j in xrange(1, len(t)))

```



----------------------------------------------------------------------------------------

### String - 1662 - https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-two-string-arrays-are-equivalent.py


```python
# Time:  O(n), n is the total length of word1 and word2
# Space: O(1)

class Solution(object):
    def arrayStringsAreEqual(self, word1, word2):
        """
        :type word1: List[str]
        :type word2: List[str]
        :rtype: bool
        """
        idx1 = idx2 = arr_idx1 = arr_idx2 = 0
        while arr_idx1 &lt; len(word1) and arr_idx2 &lt; len(word2):
            if word1[arr_idx1][idx1] != word2[arr_idx2][idx2]:
                break
            idx1 += 1
            if idx1 == len(word1[arr_idx1]):
                idx1 = 0
                arr_idx1 += 1
            idx2 += 1
            if idx2 == len(word2[arr_idx2]):
                idx2 = 0
                arr_idx2 += 1
        return arr_idx1 == len(word1) and arr_idx2 == len(word2)

```



----------------------------------------------------------------------------------------

### String - 1668 - https://leetcode.com/problems/maximum-repeating-substring/
Time: O(n)  Space: O(m)   Easy
.Python/maximum-repeating-substring.py


```python
# Time:  O(n), n is the length of sequence
# Space: O(m), m is the length of word

# optimized kmp solution
class Solution(object):
    def maxRepeating(self, sequence, word):
        """
        :type sequence: str
        :type word: str
        :rtype: int
        """
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in xrange(1, len(pattern)):
                while j &gt; -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if len(sequence) &lt; len(word):
            return 0

        prefix = getPrefix(word)
        result, count, j, prev = 0, 0, -1, -1
        for i in xrange(len(sequence)):
            while j &gt; -1 and word[j+1] != sequence[i]:
                j = prefix[j]
            if word[j+1] == sequence[i]:
                j += 1
            if j+1 == len(word):     
                count = count+1 if i-prev == len(word) else 1
                result = max(result, count)
                j, prev = -1, i
        return result


# Time:  O(n), n is the length of sequence
# Space: O(n)
# kmp solution
class Solution2(object):
    def maxRepeating(self, sequence, word):
        """
        :type sequence: str
        :type word: str
        :rtype: int
        """
        def getPrefix(pattern):
            prefix = [-1] * len(pattern)
            j = -1
            for i in xrange(1, len(pattern)):
                while j &gt; -1 and pattern[j + 1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix

        if len(sequence) &lt; len(word):
            return 0

        new_word = word*(len(sequence)//len(word))
        prefix = getPrefix(new_word)
        result, j = 0, -1
        for i in xrange(len(sequence)):
            while j &gt; -1 and new_word[j+1] != sequence[i]:
                j = prefix[j]
            if new_word[j+1] == sequence[i]:
                j += 1
            result = max(result, j+1)
            if j+1 == len(new_word):     
                break
        return result//len(word)

```



----------------------------------------------------------------------------------------

### String - 1678 - https://leetcode.com/problems/goal-parser-interpretation/
Time: O(n)  Space: O(1)   Easy
.Python/goal-parser-interpretation.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def interpret(self, command):
        """
        :type command: str
        :rtype: str
        """
        result, i = [], 0
        while i &lt; len(command):
            if command[i] == 'G':
                result += ["G"]
                i += 1
            elif command[i] == '(' and command[i+1] == ')':
                result += ["o"]
                i += 2
            else:
                result += ["al"]
                i += 4
        return "".join(result)

```



----------------------------------------------------------------------------------------

### String - 1684 - https://leetcode.com/problems/count-the-number-of-consistent-strings/
Time: O(n)  Space: O(1)   Easy
.Python/count-the-number-of-consistent-strings.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countConsistentStrings(self, allowed, words):
        """
        :type allowed: str
        :type words: List[str]
        :rtype: int
        """
        lookup = [False]*26
        for c in allowed:
            lookup[ord(c)-ord('a')] = True
        result = len(words)
        for word in words:
            for c in word:
                if not lookup[ord(c)-ord('a')]:
                    result -= 1
                    break
        return result

```



----------------------------------------------------------------------------------------

### String - 1694 - https://leetcode.com/problems/reformat-phone-number/
Time: O(n)  Space: O(1)   Easy
.Python/reformat-phone-number.py


```python
# Time:  O(n)
# Space: O(1)

# inplace solution
class Solution(object):
    def reformatNumber(self, number):
        """
        :type number: str
        :rtype: str
        """
        number = list(number)
        src_len = 0
        for c in number:  # remove non-digit characters
            if c.isdigit():
                number[src_len] = c
                src_len += 1
        dst_len = src_len + (src_len-1)//3
        if dst_len &gt; len(number):  # resize the buffer to expected final size
            number.extend([0]*(dst_len-len(number)))
        while dst_len &lt; len(number):
            number.pop()
        curr = dst_len-1
        for l, i in enumerate(reversed(xrange(src_len)), (3-src_len%3)%3):
            if l and l%3 == 0:  # group by 3 digits
                number[curr] = '-'
                curr -= 1
            number[curr] = number[i]
            curr -= 1
        if dst_len &gt;= 3 and number[dst_len-2] == '-':  # adjust for the 4 digits case
            number[dst_len-3], number[dst_len-2] = number[dst_len-2], number[dst_len-3]            
        return "".join(number)

```



----------------------------------------------------------------------------------------

### String - 1698 - https://leetcode.com/problems/number-of-distinct-substrings-in-a-string/
Time: O(n^2)  Space: O(t)   Medium
.Python/number-of-distinct-substrings-in-a-string.py


```python
# Time:  O(n^2)
# Space: O(t), t is the number of trie nodes

class Solution(object):
    def countDistinct(self, s):
        """
        :type s: str
        :rtype: int
        """
        count = 0
        trie = {}
        for i in xrange(len(s)):
            curr = trie
            for j in xrange(i, len(s)):
                if s[j] not in curr:
                    count += 1
                    curr[s[j]] = {}
                curr = curr[s[j]]
        return count

```



----------------------------------------------------------------------------------------

### String - 1704 - https://leetcode.com/problems/determine-if-string-halves-are-alike/
Time: O(n)  Space: O(1)   Easy
.Python/determine-if-string-halves-are-alike.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def halvesAreAlike(self, s):
        """
        :type s: str
        :rtype: bool
        """
        vowels = set("aeiouAEIOU")
        cnt1 = cnt2 = 0
        left, right = 0, len(s)-1
        while left &lt; right:
            cnt1 += s[left] in vowels
            cnt2 += s[right] in vowels
            left += 1
            right -= 1
        return cnt1 == cnt2

```



----------------------------------------------------------------------------------------

### String - 1763 - https://leetcode.com/problems/longest-nice-substring/
Time: O(n)  Space: O(n)   Easy
.Python/longest-nice-substring.py


```python
# Time:  O(26 * n) = O(n)
# Space: O(26 * n) = O(n)

class Solution(object):
    def longestNiceSubstring(self, s):
        """
        :type s: str
        :rtype: str
        """
        lookup = set(list(s))
        prev = -1
        result = ""
        for i in xrange(len(s)+1):
            if not (i == len(s) or s[i] not in lookup or s[i].swapcase() not in lookup):
                continue
            if prev == -1 and i == len(s):
                return s
            tmp = self.longestNiceSubstring(s[prev+1:i])
            if len(tmp) &gt; len(result):
                result = tmp
            prev = i
        return result

```



----------------------------------------------------------------------------------------

### String - 1768 - https://leetcode.com/problems/merge-strings-alternately/
Time: O(m + n)  Space: O(1)   Easy
.Python/merge-strings-alternately.py


```python
# Time:  O(m + n)
# Space: O(1)

class Solution(object):
    def mergeAlternately(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: str
        """
        result = []
        i = 0
        while i &lt; len(word1) or i &lt; len(word2):
            if i &lt; len(word1):
                result.append(word1[i])
            if i &lt; len(word2):
                result.append(word2[i])
            i += 1
        return "".join(result)

```



----------------------------------------------------------------------------------------

### String - 1784 - https://leetcode.com/problems/check-if-binary-string-has-at-most-one-segment-of-ones/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-binary-string-has-at-most-one-segment-of-ones.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def checkOnesSegment(self, s):
        """
        :type s: str
        :rtype: bool
        """
        return "01" not in s

```



----------------------------------------------------------------------------------------

### String - 1790 - https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-one-string-swap-can-make-strings-equal.py


```python
# Time:  O(n)
# Space: O(1)

import itertools


class Solution(object):
    def areAlmostEqual(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        diff = []
        for a, b in itertools.izip(s1, s2):
            if a == b:
                continue
            if len(diff) == 2:
                return False
            diff.append([a, b] if not diff else [b, a])
        return not diff or (len(diff) == 2 and diff[0] == diff[1])

```



----------------------------------------------------------------------------------------

### String - 1796 - https://leetcode.com/problems/second-largest-digit-in-a-string/
Time: O(n)  Space: O(1)   Easy
.Python/second-largest-digit-in-a-string.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def secondHighest(self, s):
        """
        :type s: str
        :rtype: int
        """
        first = second = -1
        for c in s:
            if not c.isdigit():
                continue
            d = int(c)
            if d &gt; first:
                first, second = d, first
            elif first &gt; d &gt; second:
                second = d
        return second

```



----------------------------------------------------------------------------------------

### String - 1805 - https://leetcode.com/problems/number-of-different-integers-in-a-string/
Time: O(n)  Space: O(n)   Easy
.Python/number-of-different-integers-in-a-string.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def numDifferentIntegers(self, word):
        """
        :type word: str
        :rtype: int
        """
        result, num = set(), None
        for i in xrange(len(word)+1):
            c = word[i] if i &lt; len(word) else ' '
            if c.isdigit():
                num = 10*num+int(c) if num is not None else int(c)
            elif num is not None:
                result.add(num)
                num = None
        return len(result)

```



----------------------------------------------------------------------------------------

### String - 1813 - https://leetcode.com/problems/sentence-similarity-iii/
Time: O(n)  Space: O(1)   Medium
.Python/sentence-similarity-iii.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def areSentencesSimilar(self, sentence1, sentence2):
        """
        :type sentence1: str
        :type sentence2: str
        :rtype: bool
        """
        if len(sentence1) &gt; len(sentence2):
            sentence1, sentence2 = sentence2, sentence1
        count = 0
        for idx in (lambda x:x, lambda x:-1-x):
            for i in xrange(len(sentence1)+1):
                c1 = sentence1[idx(i)] if i != len(sentence1) else ' '
                c2 = sentence2[idx(i)] if i != len(sentence2) else ' '
                if c1 != c2:
                    break
                if c1 == ' ':
                    count += 1
        return count &gt;= sentence1.count(' ')+1

```



----------------------------------------------------------------------------------------

### String - 1816 - https://leetcode.com/problems/truncate-sentence/
Time: O(n)  Space: O(1)   Easy
.Python/truncate-sentence.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def truncateSentence(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: str
        """
        for i in xrange(len(s)):
            if s[i] == ' ':
                k -= 1
                if not k:
                    return s[:i]
        return s

```



----------------------------------------------------------------------------------------

### String - 1832 - https://leetcode.com/problems/check-if-the-sentence-is-pangram/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-the-sentence-is-pangram.py


```python
# Time:  O(n)
# Space: O(26) = O(1)

class Solution(object):
    def checkIfPangram(self, sentence):
        """
        :type sentence: str
        :rtype: bool
        """
        return len(set(sentence)) == 26

```



----------------------------------------------------------------------------------------

### String - 1839 - https://leetcode.com/problems/longest-substring-of-all-vowels-in-order/
Time: O(n)  Space: O(1)   Medium
.Python/longest-substring-of-all-vowels-in-order.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def longestBeautifulSubstring(self, word):
        """
        :type word: str
        :rtype: int
        """
        result = 0
        l = cnt = 1
        for i in xrange(len(word)-1):
            if word[i] &gt; word[i+1]:
                l = cnt = 1
            else:
                l += 1
                cnt += int(word[i] &lt; word[i+1])
            if cnt == 5:
                result = max(result, l)
        return result

```



----------------------------------------------------------------------------------------

### String - 1844 - https://leetcode.com/problems/replace-all-digits-with-characters/
Time: O(n)  Space: O(1)   Easy
.Python/replace-all-digits-with-characters.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def replaceDigits(self, s):
        """
        :type s: str
        :rtype: str
        """
        return "".join(chr(ord(s[i-1])+int(s[i])) if i%2 else s[i] for i in xrange(len(s)))

```



----------------------------------------------------------------------------------------

### String - 1854 - https://leetcode.com/problems/maximum-population-year/
Time: O(n)  Space: O(1)   Easy
.Python/maximum-population-year.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maximumPopulation(self, logs):
        """
        :type logs: List[List[int]]
        :rtype: int
        """
        MIN_YEAR, MAX_YEAR = 1950, 2050
        years = [0]*(MAX_YEAR-MIN_YEAR+1)
        for s, e in logs:
            years[s-MIN_YEAR] += 1
            years[e-MIN_YEAR] -= 1
        result = 0
        for i in xrange(len(years)):
            if i:
                years[i] += years[i-1]
            if years[i] &gt; years[result]:
                result = i
        return result+MIN_YEAR

```



----------------------------------------------------------------------------------------

### String - 1858 - https://leetcode.com/problems/longest-word-with-all-prefixes/
Time: O(n)  Space: O(t)   Medium
.Python/longest-word-with-all-prefixes.py


```python
# Time:  O(n)
# Space: O(t), t is the number of nodes in trie

import collections
import string


class Solution(object):
    def longestWord(self, words):
        """
        :type words: List[str]
        :rtype: str
        """
        def iter_dfs(words, node):
            result = -1
            stk = [node]
            while stk:
                node = stk.pop()
                if result == -1 or len(words[node["_end"]]) &gt; len(words[result]):
                    result = node["_end"]
                for c in reversed(string.ascii_lowercase):
                    if c not in node or "_end" not in node[c]:
                        continue
                    stk.append(node[c])
            return result       
    
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        trie["_end"] = -1
        for i, word in enumerate(words):
            reduce(dict.__getitem__, word, trie)["_end"] = i
        result = iter_dfs(words, trie)
        return words[result] if result != -1 else "" 


# Time:  O(n)
# Space: O(t), t is the number of nodes in trie
import collections
import string


class Solution2(object):
    def longestWord(self, words):
        """
        :type words: List[str]
        :rtype: str
        """
        def dfs(words, node, result):
            if result[0] == -1 or len(words[node["_end"]]) &gt; len(words[result[0]]):
                result[0] = node["_end"]
            for c in string.ascii_lowercase:
                if c not in node or "_end" not in node[c]:
                    continue
                dfs(words, node[c], result)
    
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        trie["_end"] = -1
        for i, word in enumerate(words):
            reduce(dict.__getitem__, word, trie)["_end"] = i
        result = [-1]
        dfs(words, trie, result)
        return words[result[0]] if result[0] != -1 else ""

```



----------------------------------------------------------------------------------------

### String - 1876 - https://leetcode.com/problems/substrings-of-size-three-with-distinct-characters/
Time: O(n)  Space: O(1)   Easy
.Python/substrings-of-size-three-with-distinct-characters.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def countGoodSubstrings(self, s):
        """
        :type s: str
        :rtype: int
        """
        K = 3

        result = 0
        count = collections.Counter()
        for i in xrange(len(s)):
            if i &gt;= K:
                count[s[i-K]] -= 1
                if not count[s[i-K]]:
                    del count[s[i-K]]
            count[s[i]] += 1
            if len(count) == K:
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### String - 1880 - https://leetcode.com/problems/check-if-word-equals-summation-of-two-words/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-word-equals-summation-of-two-words.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def isSumEqual(self, firstWord, secondWord, targetWord):
        """
        :type firstWord: str
        :type secondWord: str
        :type targetWord: str
        :rtype: bool
        """
        def stoi(s):
            result = 0
            for c in s:
                result = result*10 + ord(c)-ord('a')
            return result
        
        return stoi(firstWord) + stoi(secondWord) == stoi(targetWord)

```



----------------------------------------------------------------------------------------

### String - 1903 - https://leetcode.com/problems/largest-odd-number-in-string/
Time: O(n)  Space: O(1)   Easy
.Python/largest-odd-number-in-string.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def largestOddNumber(self, num):
        """
        :type num: str
        :rtype: str
        """
        for i in reversed(xrange(len(num))):
            if int(num[i])%2:
                return num[:i+1]
        return ""

```



----------------------------------------------------------------------------------------

### String - 1910 - https://leetcode.com/problems/remove-all-occurrences-of-a-substring/
Time: O(n + m)  Space: O(n + m)   Medium
.Python/remove-all-occurrences-of-a-substring.py


```python
# Time:  O(n + m)
# Space: O(n + m)

# kmp solution
class Solution(object):
    def removeOccurrences(self, s, part):
        """
        :type s: str
        :type part: str
        :rtype: str
        """
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in xrange(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        prefix = getPrefix(part)
        result, lookup = [], []
        i = -1
        for c in s:
            while i != -1 and part[i+1] != c:
                i = prefix[i]
            if part[i+1] == c:
                i += 1
            result.append(c)
            lookup.append(i)
            if i == len(part)-1:
                result[len(result)-len(part):] = []
                lookup[len(lookup)-len(part):] = []
                i = lookup[-1] if lookup else -1
        return "".join(result)

```



----------------------------------------------------------------------------------------

### String - 1933 - https://leetcode.com/problems/check-if-string-is-decomposable-into-value-equal-substrings/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-string-is-decomposable-into-value-equal-substrings.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def isDecomposable(self, s):
        """
        :type s: str
        :rtype: bool
        """
        if len(s)%3 != 2:
            return False
        for left in xrange(0, len(s), 3):
            if any(s[i] != s[i-1] for i in xrange(left+1, min(left+3, len(s)))):
                break            
        for right in reversed(xrange(left+1, len(s), 3)):
            if any(s[i] != s[i+1] for i in reversed(xrange(max(right-2, left), right))):
                break
        return right-left == 1


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def isDecomposable(self, s):
        """
        :type s: str
        :rtype: bool
        """
        found, i = False, 0
        while i &lt; len(s):
            l = 1
            for j in xrange(i+1, min(i+3, len(s))):
                if s[j] != s[i]:
                    break
                l += 1
            if l &lt; 2:
                return False
            if l == 2:
                if found:
                    return False
                found = True
            i += l  
        return found
        

# Time:  O(n)
# Space: O(1)
class Solution3(object):
    def isDecomposable(self, s):
        """
        :type s: str
        :rtype: bool
        """
        found, l = False, 0
        for i, c in enumerate(s):
            if not l or c != s[i-1]:
                if l:
                    return False
                l = 1
                continue
            l += 1
            if l == 2:
                if i == len(s)-1 or s[i] != s[i+1]:
                    if found:
                        return False
                    found, l = True, 0
            elif l == 3:
                 l =  0
        return found

```



----------------------------------------------------------------------------------------

### String - 1935 - https://leetcode.com/problems/maximum-number-of-words-you-can-type/
Time: O(n)  Space: O(1)   Easy
.Python/maximum-number-of-words-you-can-type.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def canBeTypedWords(self, text, brokenLetters):
        """
        :type text: str
        :type brokenLetters: str
        :rtype: int
        """
        lookup = set(brokenLetters)
        result, broken = 0, False
        for c in text:
            if c == ' ':
                result += int(broken == False)
                broken = False
            elif c in lookup:
                broken = True
        return result + int(broken == False)

```



----------------------------------------------------------------------------------------

### String - 1957 - https://leetcode.com/problems/delete-characters-to-make-fancy-string/
Time: O(n)  Space: O(1)   Easy
.Python/delete-characters-to-make-fancy-string.py


```python
# Time:  O(n)
# Space: O(1)

# inplace solution
class Solution(object):
    def makeFancyString(self, s):
        """
        :type s: str
        :rtype: str
        """
        s = list(s)
        cnt = j = 0
        for i, c in enumerate(s):
            cnt = cnt+1 if i &gt;= 1 and c == s[i-1] else 1
            if cnt &lt; 3:
                s[j] = c
                j += 1
        s[:] = s[:j]
        return "".join(s)

```



----------------------------------------------------------------------------------------

### String - 1961 - https://leetcode.com/problems/check-if-string-is-a-prefix-of-array/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-string-is-a-prefix-of-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def isPrefixString(self, s, words):
        """
        :type s: str
        :type words: List[str]
        :rtype: bool
        """
        i = j = 0
        for c in s:
            if i == len(words) or words[i][j] != c:
                return False 
            j += 1
            if j == len(words[i]):
                i += 1
                j = 0
        return j == 0


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def isPrefixString(self, s, words):
        """
        :type s: str
        :type words: List[str]
        :rtype: bool
        """
        i = 0
        for word in words:
            for c in word:
                if i == len(s) or s[i] != c:
                    return False
                i += 1
            if i == len(s):
                return True
        return False

```



----------------------------------------------------------------------------------------

### String - 1963 - https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-number-of-swaps-to-make-the-string-balanced.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minSwaps(self, s):
        """
        :type s: str
        :rtype: int
        """
        result = curr = 0
        for c in s:
            if c == ']':
                curr += 1
                result = max(result, curr)
            else:
                curr -= 1
        return (result+1)//2

```



----------------------------------------------------------------------------------------

### String - 1967 - https://leetcode.com/problems/number-of-strings-that-appear-as-substrings-in-word/
Time: O(n * l + m)  Space: O(t)   Easy
.Python/number-of-strings-that-appear-as-substrings-in-word.py


```python
# Time:  O(n * l + m), n is the number of patterns
#                    , l is the max length of patterns
#                    , m is the length of word     
# Space: O(t)        , t is the total size of ac automata trie

import collections


class AhoNode(object):
    def __init__(self):
        self.children = collections.defaultdict(AhoNode)
        self.indices = []
        self.suffix = None
        self.output = None


class AhoTrie(object):
    def step(self, letter):
        while self.__node and letter not in self.__node.children:
            self.__node = self.__node.suffix
        self.__node = self.__node.children[letter] if self.__node else self.__root
        return self.__get_ac_node_outputs(self.__node)
    
    def __init__(self, patterns):
        self.__root = self.__create_ac_trie(patterns)
        self.__node = self.__create_ac_suffix_and_output_links(self.__root)
        self.__lookup = set()  # modified
    
    def __create_ac_trie(self, patterns):  # Time: O(n * l), Space: O(t)
        root = AhoNode()
        for i, pattern in enumerate(patterns):
            node = root
            for c in pattern:
                node = node.children[c]
            node.indices.append(i)
        return root

    def __create_ac_suffix_and_output_links(self, root):  # Time: O(n * l), Space: O(t)
        queue = collections.deque()
        for node in root.children.itervalues():
            queue.append(node)
            node.suffix = root

        while queue:
            node = queue.popleft()
            for c, child in node.children.iteritems():
                queue.append(child)
                suffix = node.suffix
                while suffix and c not in suffix.children:
                    suffix = suffix.suffix
                child.suffix = suffix.children[c] if suffix else root
                child.output = child.suffix if child.suffix.indices else child.suffix.output
                
        return root

    def __get_ac_node_outputs(self, node):  # Total Time: O(n), modified
        result = []
        if node not in self.__lookup:  # modified
            self.__lookup.add(node)  # modified
            for i in node.indices:
                result.append(i)
            output = node.output
            while output and output not in self.__lookup:  # modified
                self.__lookup.add(output)  # modified
                for i in output.indices:
                    result.append(i)
                output = output.output
        return result


# ac automata solution
class Solution(object):
    def numOfStrings(self, patterns, word):
        """
        :type patterns: List[str]
        :type word: str
        :rtype: int
        """
        trie = AhoTrie(patterns)
        return sum(len(trie.step(c)) for c in word)


# Time:  O(n * (l + m)), n is the number of patterns
#                      , l is the max length of patterns
#                      , m is the length of word
# Space: O(l)
# kmp solution
class Solution2(object):
    def numOfStrings(self, patterns, word):
        """
        :type patterns: List[str]
        :type word: str
        :rtype: int
        """
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in xrange(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
            
        def kmp(text, pattern):
            if not pattern:
                return 0
            prefix = getPrefix(pattern)
            if len(text) &lt; len(pattern):
                return -1
            j = -1
            for i in xrange(len(text)):
                while j != -1 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1
        
        return sum(kmp(word, pattern) != -1 for pattern in patterns)


# Time:  O(n * m * l), n is the number of patterns
#                    , l is the max length of patterns
#                    , m is the length of word
# Space: O(1)
# built-in solution
class Solution3(object):
    def numOfStrings(self, patterns, word):
        return sum(pattern in word for pattern in patterns)

```



----------------------------------------------------------------------------------------

### String - 1974 - https://leetcode.com/problems/minimum-time-to-type-word-using-special-typewriter/
Time: O(n)  Space: O(1)   Easy
.Python/minimum-time-to-type-word-using-special-typewriter.py


```python
# Time:  O(n)
# Space; O(1)

class Solution(object):
    def minTimeToType(self, word):
        """
        :type word: str
        :rtype: int
        """
        return (min((ord(word[0])-ord('a'))%26, (ord('a')-ord(word[0]))%26)+1) + \
               sum(min((ord(word[i])-ord(word[i-1]))%26, (ord(word[i-1])-ord(word[i]))%26)+1
                   for i in xrange(1, len(word)))

```



----------------------------------------------------------------------------------------

### String - 2000 - https://leetcode.com/problems/reverse-prefix-of-word/
Time: O(n)  Space: O(1)   Easy
.Python/reverse-prefix-of-word.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def reversePrefix(self, word, ch):
        """
        :type word: str
        :type ch: str
        :rtype: str
        """
        i = word.find(ch)
        return word[:i+1][::-1]+word[i+1:]

```



----------------------------------------------------------------------------------------

### String - 2042 - https://leetcode.com/problems/check-if-numbers-are-ascending-in-a-sentence/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-numbers-are-ascending-in-a-sentence.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def areNumbersAscending(self, s):
        """
        :type s: str
        :rtype: bool
        """
        prev = curr = -1
        for i, c in enumerate(s):
            if c.isdigit():
                curr = max(curr, 0)*10+int(c)
                continue
            if prev != -1 and curr != -1 and prev &gt;= curr:
                return False
            if curr != -1:
                prev = curr
            curr = -1            
        return curr == -1 or prev &lt; curr


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def areNumbersAscending(self, s):
        """
        :type s: str
        :rtype: bool
        """
        nums = [int(x) for x in s.split() if x.isdigit()]
        return all(nums[i] &lt; nums[i+1] for i in xrange(len(nums)-1))

```



----------------------------------------------------------------------------------------

### String - 2047 - https://leetcode.com/problems/number-of-valid-words-in-a-sentence/
Time: O(n)  Space: O(1)   Easy
.Python/number-of-valid-words-in-a-sentence.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countValidWords(self, sentence):
        """
        :type sentence: str
        :rtype: int
        """
        result = token = hyphen = 0
        for i in xrange(len(sentence)+1):
            if i == len(sentence) or sentence[i] == ' ':
                if token == 1:
                    result += 1
                token = hyphen = 0
                continue
            if sentence[i].isdigit() or \
               (sentence[i] in "!.," and not (i == len(sentence)-1 or sentence[i+1] == ' ')) or \
               (sentence[i] == '-' and not (hyphen == 0 and 0 &lt; i &lt; len(sentence)-1 and sentence[i-1].isalpha() and sentence[i+1].isalpha())):
                token = -1
                continue
            if token == 0:
                token = 1
            if sentence[i] == '-':
                hyphen = 1
        return result

```



----------------------------------------------------------------------------------------

### String - 2048 - https://leetcode.com/problems/next-greater-numerically-balanced-number/
Time: O(1)  Space: O(1)   Medium
.Python/next-greater-numerically-balanced-number.py


```python
# Time:  O(logc) = O(1)
# Space: O(c) = O(1)

import bisect


class Solution(object):
    def nextBeautifulNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        # precomputed by generating all balanced's permutations in solution2
        # candidates = sorted(set(int("".join(perm)) for x in [1, 22, 122, 333, 1333, 4444, 14444, 22333, 55555, 122333, 155555, 224444, 666666] for perm in itertools.permutations(str(x)))) + [1224444]
        candidates = [     1,     22,    122,    212,    221,    333  , 1333,   3133,   3313,   3331,
                        4444,  14444,  22333,  23233,  23323,  23332,  32233,  32323,  32332,  33223,
                       33232,  33322,  41444,  44144,  44414,  44441,  55555, 122333, 123233, 123323,
                      123332, 132233, 132323, 132332, 133223, 133232, 133322, 155555, 212333, 213233,
                      213323, 213332, 221333, 223133, 223313, 223331, 224444, 231233, 231323, 231332,
                      232133, 232313, 232331, 233123, 233132, 233213, 233231, 233312, 233321, 242444,
                      244244, 244424, 244442, 312233, 312323, 312332, 313223, 313232, 313322, 321233,
                      321323, 321332, 322133, 322313, 322331, 323123, 323132, 323213, 323231, 323312,
                      323321, 331223, 331232, 331322, 332123, 332132, 332213, 332231, 332312, 332321,
                      333122, 333212, 333221, 422444, 424244, 424424, 424442, 442244, 442424, 442442,
                      444224, 444242, 444422, 515555, 551555, 555155, 555515, 555551, 666666, 1224444]
        return candidates[bisect.bisect_right(candidates, n)]


# Time:  O(l * c) = O(1), c is the count of all balanced's permutations, l is the max length of permutations
# Space: O(l * b) = O(1), b is the count of balanced
class Solution2(object):
    def nextBeautifulNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        def next_permutation(nums, begin, end):
            def reverse(nums, begin, end):
                left, right = begin, end-1
                while left &lt; right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

            k, l = begin-1, begin
            for i in reversed(xrange(begin, end-1)):
                if nums[i] &lt; nums[i+1]:
                    k = i
                    break
            else:
                reverse(nums, begin, end)
                return False
            for i in reversed(xrange(k+1, end)):
                if nums[i] &gt; nums[k]:
                    l = i
                    break
            nums[k], nums[l] = nums[l], nums[k]
            reverse(nums, k+1, end)
            return True

        # obtained by manually enumerating min number of permutations in each length
        balanced = [1,
                    22,
                    122, 333,
                    1333, 4444,
                    14444, 22333, 55555,
                    122333, 155555, 224444, 666666]
        s = list(str(n))
        result = 1224444
        for x in balanced:
            x = list(str(x))
            if len(x) &lt; len(s):
                continue
            if len(x) &gt; len(s):
                result = min(result, int("".join(x)))
                continue
            while True:
                if x &gt; s:
                    result = min(result, int("".join(x)))
                if not next_permutation(x, 0, len(x)):  # distinct permutations
                    break
        return result


# Time:  O(l * c) = O(1), c is the count of all balanced's permutations, l is the max length of permutations
# Space: O(l * b) = O(1), b is the count of balanced
import itertools


class Solution3(object):
    def nextBeautifulNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        # obtained by manually enumerating min number of permutations in each length
        balanced = [1,
                    22,
                    122, 333,
                    1333, 4444,
                    14444, 22333, 55555,
                    122333, 155555, 224444, 666666]
        s = tuple(str(n))
        result = 1224444
        for x in balanced:
            x = tuple(str(x))
            if len(x) &lt; len(s):
                continue
            if len(x) &gt; len(s):
                result = min(result, int("".join(x)))
                continue
            for perm in itertools.permutations(x):  # not distinct permutations
                if perm &gt; s:
                    result = min(result, int("".join(perm)))
        return result

```



----------------------------------------------------------------------------------------

### String - 2081 - https://leetcode.com/problems/sum-of-k-mirror-numbers/
Time: O(10^6)  Space: O(1)   Hard
.Python/sum-of-k-mirror-numbers.py


```python
# Time:  O(10^6), the most times of finding x is 665502 (k = 7, n = 30)
# Space: O(1)

class Solution(object):
    def kMirror(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: int
        """
        def mirror(n, base, odd):
            result = n
            if odd:
                n //= base
            while n:
                result = result*base+n%base
                n //= base
            return result

        def num_gen(base):
            prefix_num, total = [1]*2, [base]*2
            odd = 1
            while True:
                x = mirror(prefix_num[odd], base, odd)
                prefix_num[odd] += 1
                if prefix_num[odd] == total[odd]:
                    total[odd] *= base
                    odd ^= 1
                yield x

        def reverse(n, base):
            result = 0
            while n:
                result = result*base+n%base
                n = n//base
            return result

        def mirror_num(gen, base):
            while True:
                x = next(gen)
                if x == reverse(x, base):
                    break
            return x

        base1, base2 = k, 10  # (10, k) is slower
        gen = num_gen(base1)
        return sum(mirror_num(gen, base2) for _ in xrange(n))


# Time:  O(10^6), the most times of finding x is 665502 (k = 7, n = 30)
# Space: O(1)
class Solution2(object):
    def kMirror(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: int
        """
        def num_gen(k):
            digits = ['0']
            while True:
                for i in xrange(len(digits)//2, len(digits)): 
                    if int(digits[i])+1 &lt; k:
                        digits[i] = digits[-1-i] = str(int(digits[i])+1)
                        break
                    digits[i] = digits[-1-i] = '0'
                else:
                    digits.insert(0, '1')
                    digits[-1] = '1'
                yield "".join(digits)
        
        def mirror_num(gen):
            while True:
                x = int(next(gen, k), k)
                if str(x) == str(x)[::-1]:
                    break
            return x

        gen = num_gen(k)
        return sum(mirror_num(gen) for _ in xrange(n))

```



----------------------------------------------------------------------------------------

### String - 2103 - https://leetcode.com/problems/rings-and-rods/
Time: O(n)  Space: O(1)   Easy
.Python/rings-and-rods.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def countPoints(self, rings):
        """
        :type rings: str
        :rtype: int
        """
        bits = {'R':0b001, 'G':0b010, 'B':0b100}
        rods = collections.defaultdict(int)
        for i in xrange(0, len(rings), 2):
            rods[int(rings[i+1])] |= bits[rings[i]]
        return sum(x == 0b111 for x in rods.itervalues())

```



----------------------------------------------------------------------------------------

### String - 2108 - https://leetcode.com/problems/find-first-palindromic-string-in-the-array/
Time: O(n)  Space: O(1)   Easy
.Python/find-first-palindromic-string-in-the-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def firstPalindrome(self, words):
        """
        :type words: List[str]
        :rtype: str
        """
        def is_palindrome(s):
            i, j = 0, len(s)-1
            while i &lt; j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        for w in words:
            if is_palindrome(w):
                return w
        return ""

 
# Time:  O(n)
# Space: O(l), l is the max length of words
class Solution2(object):
    def firstPalindrome(self, words):
        """
        :type words: List[str]
        :rtype: str
        """
        return next((x for x in words if x == x[::-1]), "")

```



----------------------------------------------------------------------------------------

### String - 2109 - https://leetcode.com/problems/adding-spaces-to-a-string/
Time: O(n)  Space: O(1)   Medium
.Python/adding-spaces-to-a-string.py


```python
# Time:  O(n)
# Space: O(1)

# inplace solution
class Solution(object):
    def addSpaces(self, s, spaces):
        """
        :type s: str
        :type spaces: List[int]
        :rtype: str
        """
        prev = len(s)
        s = list(s)
        s.extend([None]*len(spaces))
        for i in reversed(xrange(len(spaces))):
            for j in reversed(xrange(spaces[i], prev)):
                s[j+1+i] = s[j]
            s[spaces[i]+i] = ' '
            prev = spaces[i]
        return "".join(s)

```



----------------------------------------------------------------------------------------

### String - 2114 - https://leetcode.com/problems/maximum-number-of-words-found-in-sentences/
Time: O(n)  Space: O(1)   Easy
.Python/maximum-number-of-words-found-in-sentences.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def mostWordsFound(self, sentences):
        """
        :type sentences: List[str]
        :rtype: int
        """
        return 1+max(s.count(' ') for s in sentences)

```



----------------------------------------------------------------------------------------

### String - 2116 - https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/
Time: O(n)  Space: O(1)   Medium
.Python/check-if-a-parentheses-string-can-be-valid.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def canBeValid(self, s, locked):
        """
        :type s: str
        :type locked: str
        :rtype: bool
        """
        if len(s)%2:
            return False
        for direction, c in ((lambda x:x, '('), (reversed, ')')):
            cnt = bal = 0
            for i in direction(xrange(len(s))):
                if locked[i] == '0':
                    cnt += 1
                else:
                    bal += 1 if s[i] == c else -1
                    if cnt+bal &lt; 0:
                        return False
        return True

```



----------------------------------------------------------------------------------------

### String - 2124 - https://leetcode.com/problems/check-if-all-as-appears-before-all-bs/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-all-as-appears-before-all-bs.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def checkString(self, s):
        """
        :type s: str
        :rtype: bool
        """
        return "ba" not in s

```



----------------------------------------------------------------------------------------

### String - 2129 - https://leetcode.com/problems/capitalize-the-title/
Time: O(n)  Space: O(1)   Easy
.Python/capitalize-the-title.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def capitalizeTitle(self, title):
        """
        :type title: str
        :rtype: str
        """
        title = list(title)
        j = 0
        for i in xrange(len(title)+1):
            if i &lt; len(title) and title[i] != ' ':
                title[i] = title[i].lower()
                continue
            if i-j &gt; 2:
                title[j] = title[j].upper()
            j = i+1
        return "".join(title)

```



----------------------------------------------------------------------------------------

### String - 2131 - https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/
Time: O(n)  Space: O(n)   Medium
.Python/longest-palindrome-by-concatenating-two-letter-words.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def longestPalindrome(self, words):
        """
        :type words: List[str]
        :rtype: int
        """
        cnt = collections.Counter(words)
        result = remain = 0
        for x, c in cnt.iteritems():
            if x == x[::-1]:
                result += c//2
                remain |= c%2
            elif x &lt; x[::-1] and x[::-1] in cnt:
                result += min(c, cnt[x[::-1]])
        return result*4+remain*2

```



----------------------------------------------------------------------------------------

### String - 2135 - https://leetcode.com/problems/count-words-obtained-after-adding-a-letter/
Time: O(n)  Space: O(n)   Medium
.Python/count-words-obtained-after-adding-a-letter.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def wordCount(self, startWords, targetWords):
        """
        :type startWords: List[str]
        :type targetWords: List[str]
        :rtype: int
        """
        def bitmask(w):
            return reduce(lambda x, y: x|y, (1 &lt;&lt; (ord(c)-ord('a')) for i, c in enumerate(w)))

        lookup = set(bitmask(w) for w in startWords)
        result = 0 
        for w in targetWords: 
            mask = bitmask(w)
            result += any(mask ^ (1 &lt;&lt; ord(c)-ord('a')) in lookup for c in w)
        return result

```



----------------------------------------------------------------------------------------

### String - 2138 - https://leetcode.com/problems/divide-a-string-into-groups-of-size-k/
Time: O(n)  Space: O(1)   Easy
.Python/divide-a-string-into-groups-of-size-k.py


```python
# Time:  O(n)
# Space: O(1)

# string
class Solution(object):
    def divideString(self, s, k, fill):
        """
        :type s: str
        :type k: int
        :type fill: str
        :rtype: List[str]
        """
        return [s[i:i+k] + fill*(i+k-len(s)) for i in xrange(0, len(s), k)]

```



----------------------------------------------------------------------------------------

### String - 2156 - https://leetcode.com/problems/find-substring-with-given-hash-value/
Time: O(n)  Space: O(1)   Medium
.Python/find-substring-with-given-hash-value.py


```python
# Time:  O(n)
# Space: O(1)

# rolling hash
class Solution(object):
    def subStrHash(self, s, power, modulo, k, hashValue):
        """
        :type s: str
        :type power: int
        :type modulo: int
        :type k: int
        :type hashValue: int
        :rtype: str
        """
        h, idx = 0, -1
        pw = pow(power, k-1, modulo)
        for i in reversed(xrange(len(s))):
            if i+k &lt; len(s):
                h = (h-(ord(s[i+k])-ord('a')+1)*pw)%modulo
            h = (h*power+(ord(s[i])-ord('a')+1))%modulo
            if h == hashValue:
                idx = i
        return s[idx:idx+k]

```



----------------------------------------------------------------------------------------

### String - 2157 - https://leetcode.com/problems/groups-of-strings/
Time: O(26 * n)  Space: O(26 * n)   Hard
.Python/groups-of-strings.py


```python
# Time:  O(26 * n)
# Space: O(26 * n)

class UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n
        self.size = [1]*n
        self.total = n

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] &gt; self.rank[y]:  # union by rank
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        self.size[y] += self.size[x]
        self.total -= 1
        return True


# bitmasks, union find
class Solution(object):
    def groupStrings(self, words):
        """
        :type words: List[str]
        :rtype: List[int]
        """
        uf = UnionFind(len(words))
        lookup = {}
        for i, x in enumerate(words):
            mask = reduce(lambda x, y: x|(1&lt;&lt;(ord(y)-ord('a'))), x, 0)
            if mask not in lookup:
                lookup[mask] = i
            uf.union_set(i, lookup[mask])
            bit = 1
            while bit &lt;= mask:
                if mask&amp;bit:
                    if mask^bit not in lookup:
                        lookup[mask^bit] = i
                    uf.union_set(i, lookup[mask^bit])
                bit &lt;&lt;= 1
        return [uf.total, max(uf.size)]

```



----------------------------------------------------------------------------------------

### String - 2168 - https://leetcode.com/problems/unique-substrings-with-equal-digit-frequency/
Time: O(n^2)  Space: O(n^2)   Medium
.Python/unique-substrings-with-equal-digit-frequency.py


```python
# Time:  O(n^2)
# Space: O(n^2)

import collections


# rolling hash
class Solution(object):
    def equalDigitFrequency(self, s):
        """
        :type s: str
        :rtype: int
        """
        MOD = 10**9+7
        D = 27
        lookup = set()
        for i in xrange(len(s)):
            cnt = collections.Counter()
            h = max_cnt = 0
            for j in xrange(i, len(s)):
                d = ord(s[j])-ord('0')+1
                h = (h*D+d)%MOD
                cnt[d] += 1
                max_cnt = max(max_cnt, cnt[d])
                if len(cnt)*max_cnt == j-i+1:
                    lookup.add(h)
        return len(lookup)

```



----------------------------------------------------------------------------------------

### String - 2185 - https://leetcode.com/problems/counting-words-with-a-given-prefix/
Time: O(n * p)  Space: O(1)   Easy
.Python/counting-words-with-a-given-prefix.py


```python
# Time:  O(n * p)
# Space: O(1)

# string
class Solution(object):
    def prefixCount(self, words, pref):
        """
        :type words: List[str]
        :type pref: str
        :rtype: int
        """
        return sum(x.startswith(pref) for x in words)

```



----------------------------------------------------------------------------------------

### String - 2186 - https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-number-of-steps-to-make-two-strings-anagram-ii.py


```python
# Time:  O(n)
# Space: O(1)

import collections


# freq table
class Solution(object):
    def minSteps(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: int
        """
        cnt1, cnt2 = collections.Counter(s), collections.Counter(t)
        return sum((cnt1-cnt2).itervalues())+sum((cnt2-cnt1).itervalues())

```



----------------------------------------------------------------------------------------

### String - 2211 - https://leetcode.com/problems/count-collisions-on-a-road/
Time: O(n)  Space: O(1)   Medium
.Python/count-collisions-on-a-road.py


```python
# Time:  O(n)
# Space: O(1)

# counting, simulation
class Solution(object):
    def countCollisions(self, directions):
        """
        :type directions: str
        :rtype: int
        """
        result = cnt = 0
        smooth = 1
        for x in directions:
            if x == 'R':
                cnt += 1
            elif x == 'S' or (cnt or not smooth):
                result += cnt+int(x == 'L')
                cnt = smooth = 0
        return result

```



----------------------------------------------------------------------------------------

### String - 2213 - https://leetcode.com/problems/longest-substring-of-one-repeating-character/
Time: O(nlogn)  Space: O(n)   Hard
.Python/longest-substring-of-one-repeating-character.py


```python
# Time:  O(nlogn)
# Space: O(n)

import itertools


# Template:
# https://github.com/kamyu104/FacebookHackerCup-2021/blob/main/Round%203/auth_ore_ization.py
class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda _: float("inf"),
                 query_fn=lambda x, y: x if y is None else min(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in xrange(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(xrange(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x &gt; 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])


# segment tree
class Solution(object):
    def longestRepeating(self, s, queryCharacters, queryIndices):
        """
        :type s: str
        :type queryCharacters: str
        :type queryIndices: List[int]
        :rtype: List[int]
        """
        LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = xrange(7)
        def build(i):
            return update(s[i])

        def update(y):
            result = [0]*SIZE
            result[LEFT] = result[RIGHT] = y
            result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1
            return result

        def query(x, y):
            return x if y is None else \
                   [x[LEFT],
                    y[RIGHT],
                    x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0),
                    y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0),
                    x[LEN]+y[LEN],
                    max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)]
        
        result = []
        st = SegmentTree(len(s), build_fn=build, query_fn=query, update_fn=update)
        for c, i in itertools.izip(queryCharacters, queryIndices):
            st.update(i, c)
            result.append(st.tree[1][MAX_LEN])
        return result


# Time:  O(nlogn)
# Space: O(n)
import itertools


# Template:
# https://github.com/kamyu104/FacebookHackerCup-2021/blob/main/Round%203/auth_ore_ization.py
class SegmentTree2(object):
    def __init__(self, N,
                 build_fn=lambda _: float("inf"),
                 query_fn=lambda x, y: y if x is None else x if y is None else min(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in xrange(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(xrange(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x &gt; 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

    def query(self, L, R):
        if L &gt; R:
            return None
        L += self.base
        R += self.base
        left = right = None
        while L &lt;= R:
            if L &amp; 1:
                left = self.query_fn(left, self.tree[L])
                L += 1
            if R &amp; 1 == 0:
                right = self.query_fn(self.tree[R], right)
                R -= 1
            L //= 2
            R //= 2
        return self.query_fn(left, right)


# segment tree
class Solution2(object):
    def longestRepeating(self, s, queryCharacters, queryIndices):
        """
        :type s: str
        :type queryCharacters: str
        :type queryIndices: List[int]
        :rtype: List[int]
        """
        LEFT, RIGHT, LEFT_LEN, RIGHT_LEN, LEN, MAX_LEN, SIZE = xrange(7)
        def build(i):
            return update(s[i])

        def update(y):
            result = [0]*SIZE
            result[LEN] = result[LEFT_LEN] = result[RIGHT_LEN] = result[MAX_LEN] = 1
            result[LEFT] = result[RIGHT] = y
            return result

        def query(x, y):
            return y if x is None else x if y is None else \
                   [x[LEFT],
                    y[RIGHT],
                    x[LEFT_LEN]+(y[LEFT_LEN] if x[LEFT_LEN] == x[LEN] and x[RIGHT] == y[LEFT] else 0),
                    y[RIGHT_LEN]+(x[RIGHT_LEN] if y[RIGHT_LEN] == y[LEN] and y[LEFT] == x[RIGHT] else 0),
                    x[LEN]+y[LEN],
                    max(x[MAX_LEN], y[MAX_LEN], x[RIGHT_LEN]+y[LEFT_LEN] if x[RIGHT] == y[LEFT] else 0)]
        
        result = []
        st = SegmentTree2(len(s), build_fn=build, query_fn=query, update_fn=update)
        for c, i in itertools.izip(queryCharacters, queryIndices):
            st.update(i, c)
            result.append(st.query(0, len(s)-1)[MAX_LEN])
        return result

```



----------------------------------------------------------------------------------------

### String - 2223 - https://leetcode.com/problems/sum-of-scores-of-built-strings/
Time: O(n)  Space: O(n)   Hard
.Python/sum-of-scores-of-built-strings.py


```python
# Time:  O(n)
# Space: O(n)

# z-function
class Solution(object):
    def sumScores(self, s):
        """
        :type s: str
        :rtype: int
        """
        # Template: https://cp-algorithms.com/string/z-function.html
        def z_function(s):  # Time: O(n), Space: O(n)
            z = [0]*len(s)
            l, r = 0, 0
            for i in xrange(1, len(z)):
                if i &lt;= r:
                    z[i] = min(r-i+1, z[i-l])
                while i+z[i] &lt; len(z) and s[z[i]] == s[i+z[i]]:
                    z[i] += 1
                if i+z[i]-1 &gt; r:
                    l, r = i, i+z[i]-1
            return z

        z = z_function(s)
        z[0] = len(s)
        return sum(z)

```



----------------------------------------------------------------------------------------

### String - 2232 - https://leetcode.com/problems/minimize-result-by-adding-parentheses-to-expression/
Time: O(n^2)  Space: O(1)   Medium
.Python/minimize-result-by-adding-parentheses-to-expression.py


```python
# Time:  O(n^2)
# Space: O(1)

import itertools


# brute force
class Solution(object):
    def minimizeResult(self, expression):
        """
        :type expression: str
        :rtype: str
        """
        def stoi(s, i, j):
            result = 0
            for k in xrange(i, j):
                result = result*10+(ord(s[k])-ord('0'))
            return result

        best = None
        min_val = float("inf")
        pos = expression.index('+')
        left, right = stoi(expression, 0, pos), stoi(expression, pos+1, len(expression))
        base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1)
        for i in xrange(pos):
            base2 = base2_init
            for j in xrange(pos+1, len(expression)):
                a, b = divmod(left, base1)
                c, d = divmod(right, base2)
                val = max(a, 1)*(b+c)*max(d, 1)
                if val &lt; min_val:
                    min_val = val
                    best = (i, j)
                base2 //= 10
            base1 //= 10
        return "".join(itertools.chain((expression[i] for i in xrange(best[0])),
                                       '(', (expression[i] for i in xrange(best[0], best[1]+1)), ')',
                                       (expression[i] for i in xrange(best[1]+1, len(expression)))))


# Time:  O(n^2)
# Space: O(n)
# brute force
class Solution2(object):
    def minimizeResult(self, expression):
        """
        :type expression: str
        :rtype: str
        """
        best = None
        min_val = float("inf")
        pos = expression.index('+')
        left, right = int(expression[0:pos]), int(expression[pos+1:])  # Space: O(n)
        base1, base2_init = 10**pos, 10**(len(expression)-(pos+1)-1)
        for i in xrange(pos):
            base2 = base2_init
            for j in xrange(pos+1, len(expression)):
                a, b = divmod(left, base1)
                c, d = divmod(right, base2)
                val = max(a, 1)*(b+c)*max(d, 1)
                if val &lt; min_val:
                    min_val = val
                    best = (i, j)
                base2 //= 10
            base1 //= 10
        return "".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]])  # Space: O(n)

    
# Time:  O(n^3)
# Space: O(n)
# brute force
class Solution3(object):
    def minimizeResult(self, expression):
        """
        :type expression: str
        :rtype: str
        """
        best = None
        min_val = float("inf")
        pos = expression.index('+')
        for i in xrange(pos):
            for j in xrange(pos+1, len(expression)):
                val = (int(expression[:i] or "1")*
                       (int(expression[i:pos])+int(expression[pos+1:j+1]))*
                       int(expression[j+1:] or "1"))  # Space: O(n)
                if val &lt; min_val:
                    min_val = val
                    best = (i, j)
        return "".join([expression[:best[0]], '(', expression[best[0]:best[1]+1], ')', expression[best[1]+1:]])  # Space: O(n)

```



----------------------------------------------------------------------------------------

### String - 2243 - https://leetcode.com/problems/calculate-digit-sum-of-a-string/
Time: O(n)  Space: O(n)   Easy
.Python/calculate-digit-sum-of-a-string.py


```python
# Time:  O(n + n * (log10(9k)/k) + ... + k)
#      = O((n - (log10(9k)/k)*k)/(1-log10(9k)/k))
#      = O(n / (1-log10(9k)/k)) = O(n) for k &gt;= 2
# Space: O(n)

# simulation
class Solution(object):
    def digitSum(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: str
        """
        while len(s) &gt; k:
            s = "".join(map(str, (sum(map(int, s[i:i+k])) for i in xrange(0, len(s), k))))
        return s

```



----------------------------------------------------------------------------------------

### String - 2255 - https://leetcode.com/problems/count-prefixes-of-a-given-string/
Time: O(n * l)  Space: O(1)   Easy
.Python/count-prefixes-of-a-given-string.py


```python
# Time:  O(n * l)
# Space: O(1)

import itertools


# string
class Solution(object):
    def countPrefixes(self, words, s):
        """
        :type words: List[str]
        :type s: str
        :rtype: int
        """
        return sum(itertools.imap(s.startswith, words))

```



----------------------------------------------------------------------------------------

### String - 2264 - https://leetcode.com/problems/largest-3-same-digit-number-in-string/
Time: O(n)  Space: O(1)   Easy
.Python/largest-3-same-digit-number-in-string.py


```python
# Time:  O(n)
# Space: O(1)

# string
class Solution(object):
    def largestGoodInteger(self, num):
        """
        :type num: str
        :rtype: str
        """
        result = ''
        cnt = 0
        for i, x in enumerate(num):
            cnt += 1
            if i+1 &lt; len(num) and num[i] == num[i+1]:
                continue
            if cnt &gt;= 3:
                result = max(result, num[i])
            cnt = 0
        return result*3


# Time:  O(n)
# Space: O(1)
# string
class Solution2(object):
    def largestGoodInteger(self, num):
        """
        :type num: str
        :rtype: str
        """
        return max(num[i] if num[i] == num[i+1] == num[i+2] else '' for i in xrange(len(num)-2))*3

```



----------------------------------------------------------------------------------------

### String - 2269 - https://leetcode.com/problems/find-the-k-beauty-of-a-number/
Time: O(logn)  Space: O(logn)   Easy
.Python/find-the-k-beauty-of-a-number.py


```python
# Time:  O(logn)
# Space: O(logn)

# sliding window
class Solution(object):
    def divisorSubstrings(self, num, k):
        """
        :type num: int
        :type k: int
        :rtype: int
        """
        result = curr = 0
        s = map(int, str(num))
        base = 10**(k-1)
        for i, x in enumerate(s):
            if i-k &gt;= 0:
                curr -= s[i-k]*base
            curr = curr*10+x
            if i+1 &gt;= k:
                result += int(curr and num%curr == 0)
        return result

```



----------------------------------------------------------------------------------------

### String - 2272 - https://leetcode.com/problems/substring-with-largest-variance/
Time: O(a^2 * n)  Space: O(a)   Hard
.Python/substring-with-largest-variance.py


```python
# Time:  O(a^2 * n), a is the size of alphabets
# Space: O(a)

import itertools


# kadane's algorithm
class Solution(object):
    def largestVariance(self, s):
        """
        :type s: str
        :rtype: int
        """
        def modified_kadane(a, x, y):
            result = curr = 0
            lookup = [0]*2
            remain = [a.count(x), a.count(y)]
            for c in a:
                if c not in (x, y):
                    continue
                lookup[c != x] = 1
                remain[c != x] -= 1
                curr += 1 if c == x else -1
                if curr &lt; 0 and remain[0] and remain[1]:
                    curr = lookup[0] = lookup[1] = 0  # reset states if the remain has both x, y
                if lookup[0] and lookup[1]:
                    result = max(result, curr)  # update result if x, y both exist
            return result

        alphabets = set(s)
        return max(modified_kadane(s, x, y) for x, y in itertools.permutations(alphabets, 2)) if len(alphabets) &gt;= 2 else 0

```



----------------------------------------------------------------------------------------

### String - 2273 - https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/
Time: O(n * l)  Space: O(1)   Easy
.Python/find-resultant-array-after-removing-anagrams.py


```python
# Time:  O(n * l)
# Space: O(1)

import collections


# freq table
class Solution(object):
    def removeAnagrams(self, words):
        """
        :type words: List[str]
        :rtype: List[str]
        """
        result = []
        prev = None
        for x in words:
            cnt = collections.Counter(x)
            if prev and prev == cnt:
                continue
            prev = cnt
            result.append(x)
        return result


# Time:  O(n * llogl)
# Space: O(l)
import collections


# sort
class Solution2(object):
    def removeAnagrams(self, words):
        """
        :type words: List[str]
        :rtype: List[str]
        """
        result = []
        prev = None
        for x in words:
            s = sorted(x)
            if prev and prev == s:
                continue
            prev = s
            result.append(x)
        return result


# Time:  O(n * llogl)
# Space: O(l)
import collections


# sort
class Solution3(object):
    def removeAnagrams(self, words):
        """
        :type words: List[str]
        :rtype: List[str]
        """
        return [words[i] for i in xrange(len(words)) if i == 0 or sorted(words[i-1]) != sorted(words[i])]

```



----------------------------------------------------------------------------------------

### String - 2278 - https://leetcode.com/problems/percentage-of-letter-in-string/
Time: O(n)  Space: O(1)   Easy
.Python/percentage-of-letter-in-string.py


```python
# Time:  O(n)
# Space: O(1)

# string
class Solution(object):
    def percentageLetter(self, s, letter):
        """
        :type s: str
        :type letter: str
        :rtype: int
        """
        return 100*s.count(letter)//len(s)

```



----------------------------------------------------------------------------------------

### String - 2288 - https://leetcode.com/problems/apply-discount-to-prices/
Time: O(n)  Space: O(1)   Medium
.Python/apply-discount-to-prices.py


```python
# Time:  O(n)
# Space: O(1)

# string
class Solution(object):
    def discountPrices(self, sentence, discount):
        """
        :type sentence: str
        :type discount: int
        :rtype: str
        """
        result = []
        i = 0
        while i &lt; len(sentence):
            j = sentence.find(' ', i)
            if j == -1: j = len(sentence)
            if sentence[i] == '$' and j-(i+1) &gt; 0 and all(sentence[k].isdigit() for k in xrange(i+1, j)):
                cnt = reduce(lambda x, y: x*10+int(y), (sentence[k] for k in xrange(i+1, j)), 0)
                result.append("${:d}.{:02d}".format(*divmod(cnt*(100-discount), 100)))
            else:
                for k in xrange(i, j):
                    result.append(sentence[k])
            if j != len(sentence):
                result.append(' ')
            i = j+1
        return "".join(result)

    
# Time:  O(n)
# Space: O(n)
# string
class Solution2(object):
    def discountPrices(self, sentence, discount):
        """
        :type sentence: str
        :type discount: int
        :rtype: str
        """
        def format(discount, x):
            return "${:d}.{:02d}".format(*divmod(int(x[1:])*(100-discount), 100)) if x[0] == '$' and x[1:].isdigit() else x

        return " ".join(format(discount, x) for x in sentence.split())

```



----------------------------------------------------------------------------------------

### String - 2299 - https://leetcode.com/problems/strong-password-checker-ii/
Time: O(n)  Space: O(1)   Easy
.Python/strong-password-checker-ii.py


```python
# Time:  O(n)
# Space: O(1)

# string
class Solution(object):
    def strongPasswordCheckerII(self, password):
        """
        :type password: str
        :rtype: bool
        """
        SPECIAL = set("!@#$%^&amp;*()-+")
        return (len(password) &gt;= 8 and
                any(c.islower() for c in password) and
                any(c.isupper() for c in password) and
                any(c.isdigit() for c in password) and
                any(c in SPECIAL for c in password) and
                all(password[i] != password[i+1] for i in xrange(len(password)-1)))

```



----------------------------------------------------------------------------------------

### String - 2301 - https://leetcode.com/problems/match-substring-after-replacement/
Time: O(n * k)  Space: O(m)   Hard
.Python/match-substring-after-replacement.py


```python
# Time:  O(n * k), n = len(s), k = len(sub)
# Space: O(m), m = len(mappings)

import collections


# brute force
class Solution(object):
    def matchReplacement(self, s, sub, mappings):
        """
        :type s: str
        :type sub: str
        :type mappings: List[List[str]]
        :rtype: bool
        """
        def transform(x):
            return ord(x)-ord('0') if x.isdigit() else ord(x)-ord('a')+10 if x.islower() else ord(x)-ord('A')+36

        def check(i):
            return all(sub[j] == s[i+j] or lookup[sub[j]][s[i+j]] for j in xrange(len(sub)))
            
        lookup = [[0]*62 for _ in xrange(62)]
        for a, b in mappings:
            lookup[transform(a)][transform(b)] = 1
        s = map(transform, s)
        sub = map(transform, sub)
        return any(check(i) for i in xrange(len(s)-len(sub)+1))


# Time:  O(n * k), n = len(s), k = len(sub)
# Space: O(m), m = len(mappings)
import collections


# brute force
class Solution2(object):
    def matchReplacement(self, s, sub, mappings):
        """
        :type s: str
        :type sub: str
        :type mappings: List[List[str]]
        :rtype: bool
        """
        def check(i):
            return all(sub[j] == s[i+j] or (sub[j], s[i+j]) in lookup for j in xrange(len(sub)))
            
        lookup = set()
        for a, b in mappings:
            lookup.add((a, b))
        return any(check(i) for i in xrange(len(s)-len(sub)+1))

```



----------------------------------------------------------------------------------------

### String - 2315 - https://leetcode.com/problems/count-asterisks/
Time: O(n)  Space: O(1)   Easy
.Python/count-asterisks.py


```python
# Time:  O(n)
# Space: O(1)

# string
class Solution(object):
    def countAsterisks(self, s):
        """
        :type s: str
        :rtype: int
        """
        result = cnt = 0
        for c in s:
            if c == '|':
                cnt = (cnt+1)%2
                continue
            if c == '*' and cnt == 0:
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Linked List - 1171 - https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/
Time: O(n)  Space: O(n)   Medium
.Python/remove-zero-sum-consecutive-nodes-from-linked-list.py


```python
# Time:  O(n)
# Space: O(n)

import collections


# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def removeZeroSumSublists(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        curr = dummy = ListNode(0)
        dummy.next = head
        prefix = 0
        lookup = collections.OrderedDict()
        while curr:
            prefix += curr.val
            node = lookup.get(prefix, curr)
            while prefix in lookup:
                lookup.popitem()
            lookup[prefix] = node
            node.next = curr.next
            curr = curr.next
        return dummy.next

```



----------------------------------------------------------------------------------------

### Linked List - 1180 - https://leetcode.com/problems/count-substrings-with-only-one-distinct-letter/
Time: O(n)  Space: O(1)   Easy
.Python/count-substrings-with-only-one-distinct-letter.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countLetters(self, S):
        """
        :type S: str
        :rtype: int
        """
        result = len(S)
        left = 0
        for right in xrange(1, len(S)):
            if S[right] == S[left]:
                result += right-left
            else:
                left = right
        return result

```



----------------------------------------------------------------------------------------

### Linked List - 1181 - https://leetcode.com/problems/before-and-after-puzzle/
Time: O(l * rlogr)  Space: O(l * (n + r))   Medium
.Python/before-and-after-puzzle.py


```python
# Time:  O(l * rlogr)  , l is the max length of phrases
#                      , r is the number of result, could be up to O(n^2)
# Space: O(l * (n + r)), n is the number of phrases

import collections


class Solution(object):
    def beforeAndAfterPuzzles(self, phrases):
        """
        :type phrases: List[str]
        :rtype: List[str]
        """
        lookup = collections.defaultdict(list)
        for i, phrase in enumerate(phrases):
            right = phrase.rfind(' ')
            word = phrase if right == -1 else phrase[right+1:]
            lookup[word].append(i)

        result_set = set()
        for i, phrase in enumerate(phrases):
            left = phrase.find(' ')
            word = phrase if left == -1 else phrase[:left]
            if word not in lookup:
                continue
            for j in lookup[word]:
                if j == i:
                    continue
                result_set.add(phrases[j] + phrase[len(word):])
        return sorted(result_set)

```



----------------------------------------------------------------------------------------

### Linked List - 1265 - https://leetcode.com/problems/print-immutable-linked-list-in-reverse/
Time: O(n)  Space: O(sqrt(n))   Medium
.Python/print-immutable-linked-list-in-reverse.py


```python
# Time:  O(n)
# Space: O(sqrt(n))

import math


class Solution(object):
    def printLinkedListInReverse(self, head):
        """
        :type head: ImmutableListNode
        :rtype: None
        """
        def print_nodes(head, count):
            nodes = []
            while head and len(nodes) != count:
                nodes.append(head)
                head = head.getNext()
            for node in reversed(nodes):
                node.printValue()
                   
        count = 0
        curr = head
        while curr:
            curr = curr.getNext()
            count += 1
        bucket_count = int(math.ceil(count**0.5))
        
        buckets = []
        count = 0
        curr = head
        while curr:
            if count % bucket_count == 0:
                buckets.append(curr)
            curr = curr.getNext()
            count += 1
        for node in reversed(buckets):
            print_nodes(node, bucket_count)
            
        
# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def printLinkedListInReverse(self, head):
        """
        :type head: ImmutableListNode
        :rtype: None
        """
        nodes = []
        while head:
            nodes.append(head)
            head = head.getNext()
        for node in reversed(nodes):
            node.printValue()


# Time:  O(n^2)
# Space: O(1)
class Solution3(object):
    def printLinkedListInReverse(self, head):
        """
        :type head: ImmutableListNode
        :rtype: None
        """
        tail = None
        while head != tail:
            curr = head
            while curr.getNext() != tail:
                curr = curr.getNext()
            curr.printValue()
            tail = curr

```



----------------------------------------------------------------------------------------

### Linked List - 1290 - https://leetcode.com/problems/convert-binary-number-in-a-linked-list-to-integer/
Time: O(n)  Space: O(1)   Easy
.Python/convert-binary-number-in-a-linked-list-to-integer.py


```python
# Time:  O(n)
# Space: O(1)

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def getDecimalValue(self, head):
        """
        :type head: ListNode
        :rtype: int
        """
        result = 0
        while head: 
            result = result*2 + head.val 
            head = head.next 
        return result

```



----------------------------------------------------------------------------------------

### Linked List - 1474 - https://leetcode.com/problems/delete-n-nodes-after-m-nodes-of-a-linked-list/
Time: O(n)  Space: O(1)   Easy
.Python/delete-n-nodes-after-m-nodes-of-a-linked-list.py


```python
# Time:  O(n)
# Space: O(1)

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteNodes(self, head, m, n):
        """
        :type head: ListNode
        :type m: int
        :type n: int
        :rtype: ListNode
        """
        head = dummy = ListNode(next=head)
        while head:
            for _ in xrange(m):
                if not head.next:
                    return dummy.next
                head = head.next
            prev = head
            for _ in xrange(n):
                if not head.next:
                    prev.next = None
                    return dummy.next
                head = head.next
            prev.next = head.next
        return dummy.next

```



----------------------------------------------------------------------------------------

### Linked List - 1634 - https://leetcode.com/problems/add-two-polynomials-represented-as-linked-lists/
Time: O(m + n)  Space: O(1)   Medium
.Python/add-two-polynomials-represented-as-linked-lists.py


```python
# Time:  O(m + n)
# Space: O(1)

class PolyNode:
    def __init__(self, x=0, y=0, next=None):
        pass


class Solution:
    def addPoly(self, poly1, poly2):
        """
        :type poly1: PolyNode
        :type poly2: PolyNode
        :rtype: PolyNode
        """
        curr = dummy = PolyNode()
        while poly1 and poly2:
            if poly1.power &gt; poly2.power:
                curr.next = poly1
                curr = curr.next
                poly1 = poly1.next
            elif poly1.power &lt; poly2.power:
                curr.next = poly2
                curr = curr.next
                poly2 = poly2.next
            else:
                coef = poly1.coefficient+poly2.coefficient
                if coef:
                    curr.next = PolyNode(coef, poly1.power)
                    curr = curr.next
                poly1, poly2 = poly1.next, poly2.next
        curr.next = poly1 or poly2
        return dummy.next

```



----------------------------------------------------------------------------------------

### Linked List - 1650 - https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iii/
Time: O(h)  Space: O(1)   Medium
.Python/lowest-common-ancestor-of-a-binary-tree-iii.py


```python
# Time:  O(h)
# Space: O(1)

# Definition for a Node.
class Node:
    def __init__(self, val):
        pass

class Solution(object):
    def lowestCommonAncestor(self, p, q):
        """
        :type node: Node
        :rtype: Node
        """
        a, b = p, q
        while a != b:
            a = a.parent if a else q
            b = b.parent if b else p
        return a


# Time:  O(h)
# Space: O(1)
class Solution2(object):
    def lowestCommonAncestor(self, p, q):
        """
        :type node: Node
        :rtype: Node
        """
        def depth(node):
            d = 0
            while node:
                node = node.parent
                d += 1
            return d
        
        p_d, q_d = depth(p), depth(q)
        while p_d &gt; q_d:
            p = p.parent
            p_d -= 1
        while p_d &lt; q_d:
            q = q.parent
            q_d -= 1
        while p != q:
            p = p.parent
            q = q.parent
        return p

```



----------------------------------------------------------------------------------------

### Linked List - 1669 - https://leetcode.com/problems/merge-in-between-linked-lists/
Time: O(m + n)  Space: O(1)   Medium
.Python/merge-in-between-linked-lists.py


```python
# Time:  O(m + n)
# Space: O(1)

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        pass


class Solution(object):
    def mergeInBetween(self, list1, a, b, list2):
        """
        :type list1: ListNode
        :type a: int
        :type b: int
        :type list2: ListNode
        :rtype: ListNode
        """
        prev_first, last = None, list1
        for i in xrange(b):
            if i == a-1:
                prev_first = last
            last = last.next
        prev_first.next = list2
        while list2.next:
            list2 = list2.next
        list2.next = last.next
        last.next = None
        return list1

```



----------------------------------------------------------------------------------------

### Linked List - 1721 - https://leetcode.com/problems/swapping-nodes-in-a-linked-list/
Time: O(n)  Space: O(1)   Medium
.Python/swapping-nodes-in-a-linked-list.py


```python
# Time:  O(n)
# Space: O(1)

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        pass


class Solution(object):
    def swapNodes(self, head, k):
        """
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        """
        left, right, curr = None, None, head
        while curr:
            k -= 1
            if right:
                right = right.next
            if k == 0:
                left = curr
                right = head
            curr = curr.next
        left.val, right.val = right.val, left.val
        return head

```



----------------------------------------------------------------------------------------

### Linked List - 1836 - https://leetcode.com/problems/remove-duplicates-from-an-unsorted-linked-list/
Time: O(n)  Space: O(n)   Medium
.Python/remove-duplicates-from-an-unsorted-linked-list.py


```python
# Time:  O(n)
# Space: O(n)

import collections


# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteDuplicatesUnsorted(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        count = collections.defaultdict(int)
        curr = head
        while curr:
            count[curr.val] += 1
            curr = curr.next
        curr = dummy = ListNode(0, head)
        while curr.next:
            if count[curr.next.val] == 1:
                curr = curr.next
            else:
                curr.next = curr.next.next
        return dummy.next

```



----------------------------------------------------------------------------------------

### Linked List - 2058 - https://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/
Time: O(n)  Space: O(1)   Medium
.Python/find-the-minimum-and-maximum-number-of-nodes-between-critical-points.py


```python
# Time:  O(n)
# Space: O(1)

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def nodesBetweenCriticalPoints(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: List[int]
        """
        first = last = -1
        result = float("inf")
        i, prev, head = 0, head.val, head.next
        while head.next:
            if max(prev, head.next.val) &lt; head.val or min(prev, head.next.val) &gt; head.val:
                if first == -1:
                    first = i
                if last != -1:
                    result = min(result, i-last)
                last = i
            i += 1
            prev = head.val
            head = head.next
        return [result, last-first] if last != first else [-1, -1]

```



----------------------------------------------------------------------------------------

### Linked List - 2074 - https://leetcode.com/problems/reverse-nodes-in-even-length-groups/
Time: O(n)  Space: O(1)   Medium
.Python/reverse-nodes-in-even-length-groups.py


```python
# Time:  O(n)
# Space: O(1)

class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def reverseEvenLengthGroups(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        prev, l = head, 2
        while prev.next:
            curr, cnt = prev, 0
            for _ in xrange(l):
                if not curr.next:
                    break
                cnt += 1
                curr = curr.next
            l += 1
            if cnt%2:
                prev = curr
                continue
            curr, last = prev.next, None
            for _ in xrange(cnt):
                curr.next, curr, last = last, curr.next, curr
            prev.next.next, prev.next, prev = curr, last, prev.next
        return head

```



----------------------------------------------------------------------------------------

### Linked List - 2095 - https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/
Time: O(n)  Space: O(1)   Medium
.Python/delete-the-middle-node-of-a-linked-list.py


```python
# Time:  O(n)
# Space: O(1)

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def deleteMiddle(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        dummy = ListNode()
        dummy.next = head
        slow = fast = dummy
        while fast.next and fast.next.next:
            slow, fast = slow.next, fast.next.next
        slow.next = slow.next.next
        return dummy.next

```



----------------------------------------------------------------------------------------

### Linked List - 2130 - https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-twin-sum-of-a-linked-list.py


```python
# Time:  O(n)
# Space: O(1)

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def pairSum(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: int
        """
        def reverseList(head):
            dummy = ListNode()
            while head:
                dummy.next, head.next, head = head, dummy.next, head.next
            return dummy.next

        dummy = ListNode(next=head)
        slow = fast = dummy
        while fast.next and fast.next.next:
            slow, fast = slow.next, fast.next.next
        result = 0
        head2 = reverseList(slow)
        while head:
            result = max(result, head.val+head2.val)
            head, head2 = head.next, head2.next
        return result

```



----------------------------------------------------------------------------------------

### Linked List - 2181 - https://leetcode.com/problems/merge-nodes-in-between-zeros/
Time: O(n)  Space: O(1)   Medium
.Python/merge-nodes-in-between-zeros.py


```python
# Time:  O(n)
# Space: O(1)

class ListNode(object):
    def __init__(self, val=0, next=None):
        pass


# linked list
class Solution(object):
    def mergeNodes(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        curr, zero = head.next, head
        while curr:
            if curr.val:
                zero.val += curr.val
            else:
                zero.next = curr if curr.next else None
                zero = curr
            curr = curr.next
        return head

```



----------------------------------------------------------------------------------------

### Stack - 1003 - https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/
Time: O(n)  Space: O(n)   Medium
.Python/check-if-word-is-valid-after-substitutions.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def isValid(self, S):
        """
        :type S: str
        :rtype: bool
        """
        stack = []
        for i in S:
            if i == 'c':
                if stack[-2:] == ['a', 'b']:
                    stack.pop()
                    stack.pop()
                else:
                    return False
            else:
                stack.append(i)
        return not stack

```



----------------------------------------------------------------------------------------

### Stack - 1019 - https://leetcode.com/problems/next-greater-node-in-linked-list/
Time: O(n)  Space: O(n)   Medium
.Python/next-greater-node-in-linked-list.py


```python
# Time:  O(n)
# Space: O(n)

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


class Solution(object):
    def nextLargerNodes(self, head):
        """
        :type head: ListNode
        :rtype: List[int]
        """
        result, stk = [], []
        while head:
            while stk and stk[-1][1] &lt; head.val:
                result[stk.pop()[0]] = head.val
            stk.append([len(result), head.val])
            result.append(0)
            head = head.next
        return result

```



----------------------------------------------------------------------------------------

### Stack - 1021 - https://leetcode.com/problems/remove-outermost-parentheses/
Time: O(n)  Space: O(1)   Easy
.Python/remove-outermost-parentheses.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def removeOuterParentheses(self, S):
        """
        :type S: str
        :rtype: str
        """
        deep = 1
        result, cnt = [], 0
        for c in S:
            if c == '(' and cnt &gt;= deep:
                result.append(c)
            if c == ')' and cnt &gt; deep:
                result.append(c)
            cnt += 1 if c == '(' else -1
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Stack - 1047 - https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/
Time: O(n)  Space: O(n)   Easy
.Python/remove-all-adjacent-duplicates-in-string.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def removeDuplicates(self, S):
        """
        :type S: str
        :rtype: str
        """
        result = []
        for c in S:
            if result and result[-1] == c:
                result.pop()
            else:
                result.append(c)
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Stack - 1063 - https://leetcode.com/problems/number-of-valid-subarrays/
Time: O(n)  Space: O(n)   Hard
.Python/number-of-valid-subarrays.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def validSubarrays(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = 0
        s = []
        for num in nums:
            while s and s[-1] &gt; num:
                s.pop()
            s.append(num);
            result += len(s)
        return result

```



----------------------------------------------------------------------------------------

### Stack - 1130 - https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/
Time: O(n)  Space: O(n)   Medium
.Python/minimum-cost-tree-from-leaf-values.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def mctFromLeafValues(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        result = 0
        stk = [float("inf")]
        for x in arr:
            while stk[-1] &lt;= x:
                result += stk.pop() * min(stk[-1], x)
            stk.append(x)
        while len(stk) &gt; 2:
            result += stk.pop() * stk[-1]
        return result

```



----------------------------------------------------------------------------------------

### Stack - 1190 - https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/
Time: O(n)  Space: O(n)   Medium
.Python/reverse-substrings-between-each-pair-of-parentheses.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def reverseParentheses(self, s):
        """
        :type s: str
        :rtype: str
        """
        stk, lookup = [], {}
        for i, c in enumerate(s):
            if c == '(':
                stk.append(i)
            elif c == ')':
                j = stk.pop()
                lookup[i], lookup[j] = j, i
        result = []
        i, d = 0, 1
        while i &lt; len(s):
            if i in lookup:
                i = lookup[i]
                d *= -1
            else:
                result.append(s[i])
            i += d
        return "".join(result)


# Time:  O(n^2)
# Space: O(n)
class Solution2(object):
    def reverseParentheses(self, s):
        """
        :type s: str
        :rtype: str
        """
        stk = [[]]
        for c in s:
            if c == '(':
                stk.append([])
            elif c == ')':
                end = stk.pop()
                end.reverse()
                stk[-1].extend(end)
            else:
                stk[-1].append(c)
        return "".join(stk.pop())

```



----------------------------------------------------------------------------------------

### Stack - 1209 - https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/
Time: O(n)  Space: O(n)   Medium
.Python/remove-all-adjacent-duplicates-in-string-ii.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def removeDuplicates(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: str
        """
        stk = [['^', 0]]
        for c in s:
            if stk[-1][0] == c:
                stk[-1][1] += 1
                if stk[-1][1] == k:
                    stk.pop()
            else:
                stk.append([c, 1])
        return "".join(c*k for c, k in stk)

```



----------------------------------------------------------------------------------------

### Stack - 1441 - https://leetcode.com/problems/build-an-array-with-stack-operations/
Time: O(n)  Space: O(1)   Easy
.Python/build-an-array-with-stack-operations.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def buildArray(self, target, n):
        """
        :type target: List[int]
        :type n: int
        :rtype: List[str]
        """
        result, curr = [], 1
        for t in target:
            result.extend(["Push", "Pop"]*(t-curr))
            result.append("Push")
            curr = t+1
        return result

```



----------------------------------------------------------------------------------------

### Stack - 1541 - https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-insertions-to-balance-a-parentheses-string.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minInsertions(self, s):
        """
        :type s: str
        :rtype: int
        """
        add, bal = 0, 0
        for c in s:
            if c == '(':
                if bal &gt; 0 and bal%2:
                    add += 1
                    bal -= 1
                bal += 2
            else:
                bal -= 1
                if bal &lt; 0:
                    add += 1
                    bal += 2
        return add + bal

```



----------------------------------------------------------------------------------------

### Stack - 1597 - https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression/
Time: O(n)  Space: O(n)   Medium
.Python/build-binary-expression-tree-from-infix-expression.py


```python
# Time:  O(n)
# Space: O(n)

# Definition for a binary tree node.
class Node(object):
    def __init__(self, val=" ", left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def expTree(self, s):
        """
        :type s: str
        :rtype: Node
        """
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(Node(val=operators.pop(), left=left, right=right))

        precedence = {'+':0, '-':0, '*':1, '/':1}
        operands, operators, operand = [], [], 0
        for i in xrange(len(s)):
            if s[i].isdigit():
                operand = operand*10 + int(s[i])
                if i == len(s)-1 or not s[i+1].isdigit():
                    operands.append(Node(val=str(operand)))
                    operand = 0
            elif s[i] == '(':
                operators.append(s[i])
            elif s[i] == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif s[i] in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] &gt;= precedence[s[i]]:
                    compute(operands, operators)
                operators.append(s[i])
        while operators:
            compute(operands, operators)
        return operands[-1]

```



----------------------------------------------------------------------------------------

### Stack - 1856 - https://leetcode.com/problems/maximum-subarray-min-product/
Time: O(n)  Space: O(n)   Medium
.Python/maximum-subarray-min-product.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def maxSumMinProduct(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        MOD = 10**9+7
        prefix = [0]*(len(nums)+1)
        for i in xrange(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        stk, result = [-1], 0
        for i in xrange(len(nums)+1):
            while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] &gt;= nums[i]):
                result = max(result, nums[stk.pop()]*(prefix[(i-1)+1]-prefix[stk[-1]+1]))
            stk.append(i) 
        return result%MOD

```



----------------------------------------------------------------------------------------

### Stack - 1944 - https://leetcode.com/problems/number-of-visible-people-in-a-queue/
Time: O(n)  Space: O(n)   Hard
.Python/number-of-visible-people-in-a-queue.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def canSeePersonsCount(self, heights):
        """
        :type heights: List[int]
        :rtype: List[int]
        """
        result = [0]*len(heights)
        stk = []
        for i, h in enumerate(heights):
            while stk and heights[stk[-1]] &lt; h:
                result[stk.pop()] += 1
            if stk:
                result[stk[-1]] += 1
            if stk and heights[stk[-1]] == h:
                stk.pop()
            stk.append(i)
        return result


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def canSeePersonsCount(self, heights):
        """
        :type heights: List[int]
        :rtype: List[int]
        """
        result = [0]*len(heights)
        stk = []
        for i in reversed(xrange(len(heights))):
            cnt = 0
            while stk and heights[stk[-1]] &lt; heights[i]:
                stk.pop()
                cnt += 1
            result[i] = cnt+1 if stk else cnt
            if stk and heights[stk[-1]] == heights[i]:
                stk.pop()
            stk.append(i)
        return result

```



----------------------------------------------------------------------------------------

### Stack - 1950 - https://leetcode.com/problems/maximum-of-minimum-values-in-all-subarrays/
Time: O(n)  Space: O(n)   Medium
.Python/maximum-of-minimum-values-in-all-subarrays.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def findMaximums(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        def find_bound(nums, direction, init):
            result = [0]*len(nums)
            stk = [init]
            for i in direction(xrange(len(nums))):
                while stk[-1] != init and nums[stk[-1]] &gt;= nums[i]:
                    stk.pop()
                result[i] = stk[-1]
                stk.append(i)
            return result

        left = find_bound(nums, lambda x: x, -1)
        right = find_bound(nums, reversed, len(nums))
        result = [-1]*len(nums)
        for i, v in enumerate(nums):
            result[((right[i]-1)-left[i])-1] = max(result[((right[i]-1)-left[i])-1], v)
        for i in reversed(xrange(len(nums)-1)):
            result[i] = max(result[i], result[i+1])
        return result

```



----------------------------------------------------------------------------------------

### Stack - 2104 - https://leetcode.com/problems/sum-of-subarray-ranges/
Time: O(n)  Space: O(n)   Medium
.Python/sum-of-subarray-ranges.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def subArrayRanges(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = 0
        stk = []
        for i in xrange(len(nums)+1):
            x = nums[i] if i &lt; len(nums) else float("inf")
            while stk and nums[stk[-1]] &lt;= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result += nums[j]*(j-k)*(i-j)
            stk.append(i)
        stk = []
        for i in xrange(len(nums)+1):
            x = nums[i] if i &lt; len(nums) else float("-inf")
            while stk and nums[stk[-1]] &gt;= x:
                j = stk.pop()
                k = stk[-1] if stk else -1
                result -= nums[j]*(j-k)*(i-j)
            stk.append(i)
        return result

```



----------------------------------------------------------------------------------------

### Stack - 2197 - https://leetcode.com/problems/replace-non-coprime-numbers-in-array/
Time: O(nlogm)  Space: O(1)   Hard
.Python/replace-non-coprime-numbers-in-array.py


```python
# Time:  O(nlogm), m is the max of nums
# Space: O(1)

# math, stack
class Solution(object):
    def replaceNonCoprimes(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        def gcd(a, b):  # Time: O(log(min(a, b)))
            while b:
                a, b = b, a%b
            return a

        result = []
        for x in nums:
            while True:
                g = gcd(result[-1] if result else 1, x)
                if g == 1:
                    break
                x *= result.pop()//g
            result.append(x)
        return result

```



----------------------------------------------------------------------------------------

### Stack - 2281 - https://leetcode.com/problems/sum-of-total-strength-of-wizards/
Time: O(n)  Space: O(n)   Hard
.Python/sum-of-total-strength-of-wizards.py


```python
# Time:  O(n)
# Space: O(n)

# mono stack, prefix sum, optimized from solution2
class Solution(object):
    def totalStrength(self, strength):
        """
        :type strength: List[int]
        :rtype: int
        """
        MOD = 10**9+7
        curr = 0
        prefix = [0]*(len(strength)+1)
        for i in xrange(len(strength)):
            curr = (curr+strength[i])%MOD
            prefix[i+1] = (prefix[i]+curr)%MOD
        stk, result = [-1], 0
        for i in xrange(len(strength)+1):
            while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] &gt;= strength[i]):
                x, y, z = stk[-2]+1, stk.pop(), i-1
                # assert(all(strength[j] &gt;= strength[y] for j in xrange(x, y+1)))
                # assert(all(strength[j] &gt; strength[y] for j in xrange(y+1, z+1)))
                result = (result+(strength[y]*((y-x+1)*(prefix[z+1]-prefix[y])-(z-y+1)*(prefix[y]-prefix[max(x-1, 0)]))))%MOD
            stk.append(i)
        return result


# Time:  O(n)
# Space: O(n)
# mono stack, prefix sum
class Solution2(object):
    def totalStrength(self, strength):
        """
        :type strength: List[int]
        :rtype: int
        """
        MOD = 10**9+7
        prefix, prefix2 = [0]*(len(strength)+1), [0]*(len(strength)+1)
        for i in xrange(len(strength)):
            prefix[i+1] = (prefix[i]+strength[i])%MOD
            prefix2[i+1] = (prefix2[i]+strength[i]*(i+1))%MOD
        suffix, suffix2 = [0]*(len(strength)+1), [0]*(len(strength)+1)
        for i in reversed(xrange(len(strength))):
            suffix[i] = (suffix[i+1]+strength[i])%MOD
            suffix2[i] = (suffix2[i+1]+strength[i]*(len(strength)-i))%MOD
        stk, result = [-1], 0
        for i in xrange(len(strength)+1):
            while stk[-1] != -1 and (i == len(strength) or strength[stk[-1]] &gt;= strength[i]):
                x, y, z = stk[-2]+1, stk.pop(), i-1
                # assert(all(strength[j] &gt;= strength[y] for j in xrange(x, y+1)))
                # assert(all(strength[j] &gt; strength[y] for j in xrange(y+1, z+1)))
                result = (result+(strength[y]*((z-y+1)*((prefix2[y+1]-prefix2[x])-x*(prefix[y+1]-prefix[x]))+
                                               (y-x+1)*((suffix2[y+1]-suffix2[z+1])-(len(strength)-(z+1))*(suffix[y+1]-suffix[z+1])))))%MOD
            stk.append(i)
        return result

```



----------------------------------------------------------------------------------------

### Stack - 2282 - https://leetcode.com/problems/number-of-people-that-can-be-seen-in-a-grid/
Time: O(m * n)  Space: O(m + n)   Medium
.Python/number-of-people-that-can-be-seen-in-a-grid.py


```python
# Time:  O(m * n)
# Space: O(m + n)

# mono stack, optimized from solution2
class Solution(object):
    def seePeople(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: List[List[int]]
        """
        def count(h, stk):
            cnt = 0
            while stk and stk[-1] &lt; h:
                stk.pop()
                cnt += 1
            if stk:
                cnt += 1
            if not stk or stk[-1] != h:
                stk.append(h)
            return cnt
            
        result = [[0]*len(heights[0]) for _ in xrange(len(heights))]
        for i in xrange(len(heights)):
            stk = []
            for j in reversed(xrange(len(heights[0]))):
                result[i][j] += count(heights[i][j], stk)     
        for j in xrange(len(heights[0])):
            stk = []
            for i in reversed(xrange(len(heights))):
                result[i][j] += count(heights[i][j], stk)             
        return result


# Time:  O(m * n)
# Space: O(m + n)
# mono stack
class Solution2(object):
    def seePeople(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: List[List[int]]
        """
        def count(heights, i, stk):
            cnt = 0
            while stk and heights(stk[-1]) &lt; heights(i):
                stk.pop()
                cnt += 1
            if stk:
                cnt += 1
            if stk and heights(stk[-1]) == heights(i):
                stk.pop()
            stk.append(i)
            return cnt
            
        result = [[0]*len(heights[0]) for _ in xrange(len(heights))]
        for i in xrange(len(heights)):
            stk = []
            for j in reversed(xrange(len(heights[0]))):
                result[i][j] += count(lambda x: heights[i][x], j, stk)     
        for j in xrange(len(heights[0])):
            stk = []
            for i in reversed(xrange(len(heights))):
                result[i][j] += count(lambda x: heights[x][j], i, stk)             
        return result


# Time:  O(m * n)
# Space: O(m + n)
# mono stack
class Solution3(object):
    def seePeople(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: List[List[int]]
        """
        def count(heights, i, stk, add):
            while stk and heights(stk[-1]) &lt; heights(i):
                increase(stk.pop())
            if stk:
                increase(stk[-1])
            if stk and heights(stk[-1]) == heights(i):
                stk.pop()
            stk.append(i)
            
        result = [[0]*len(heights[0]) for _ in xrange(len(heights))]
        for i in xrange(len(heights)):
            stk = []
            def increase(x): result[i][x] += 1
            for j in xrange(len(heights[0])):
                count(lambda x: heights[i][x], j, stk, add)
        for j in xrange(len(heights[0])):
            stk = []
            def increase(x): result[x][j] += 1
            for i in xrange(len(heights)):
                count(lambda x: heights[x][j], i, stk, add)
        return result

```



----------------------------------------------------------------------------------------

### Stack - 2334 - https://leetcode.com/problems/subarray-with-elements-greater-than-varying-threshold/
Time: O(n)  Space: O(n)   Hard
.Python/subarray-with-elements-greater-than-varying-threshold.py


```python
# Time:  O(n)
# Space: O(n)

# mono stack
class Solution(object):
    def validSubarraySize(self, nums, threshold):
        """
        :type nums: List[int]
        :type threshold: int
        :rtype: int
        """
        stk = [-1]
        for i in xrange(len(nums)+1):
            while stk[-1] != -1 and (i == len(nums) or nums[stk[-1]] &gt;= nums[i]):
                if nums[stk.pop()]*((i-1)-stk[-1]) &gt; threshold:
                    return (i-1)-stk[-1]
            stk.append(i)
        return -1

```



----------------------------------------------------------------------------------------

### Stack - 2355 - https://leetcode.com/problems/maximum-number-of-books-you-can-take/
Time: O(n)  Space: O(n)   Hard
.Python/maximum-number-of-books-you-can-take.py


```python
# Time:  O(n)
# Space: O(n)

# mono stack
class Solution(object):
    def maximumBooks(self, books):
        """
        :type books: List[int]
        :rtype: int
        """
        def count(right, l):
            left = max(right-l+1, 0)
            return (left+right)*(right-left+1)//2
        
        result = curr = 0
        stk = [-1]
        for i in xrange(len(books)):
            while stk[-1] != -1 and books[stk[-1]] &gt;= books[i]-(i-stk[-1]):
                j = stk.pop()
                curr -= count(books[j], j-stk[-1])
            curr += count(books[i], i-stk[-1])
            stk.append(i)
            result = max(result, curr)
        return result

```



----------------------------------------------------------------------------------------

### Queue - 1424 - https://leetcode.com/problems/diagonal-traverse-ii/
Time: O(m * n)  Space: O(m)   Medium
.Python/diagonal-traverse-ii.py


```python
# Time:  O(m * n)
# Space: O(m)

import itertools
import collections


class Solution(object):
    def findDiagonalOrder(self, nums):
        """
        :type nums: List[List[int]]
        :rtype: List[int]
        """
        result, dq, col = [], collections.deque(), 0
        for i in xrange(len(nums)+max(itertools.imap(len, nums))-1):
            new_dq = collections.deque()
            if i &lt; len(nums):
                dq.appendleft((i, 0))
            for r, c in dq:
                result.append(nums[r][c])
                if c+1 &lt; len(nums[r]):
                    new_dq.append((r, c+1))
            dq = new_dq
        return result


# Time:  O(m * n)
# Space: O(m * n)
class Solution2(object):
    def findDiagonalOrder(self, nums):
        """
        :type nums: List[List[int]]
        :rtype: List[int]
        """
        result = []
        for r, row in enumerate(nums):
            for c, num in enumerate(row):
                if len(result) &lt;= r+c:
                    result.append([])
                result[r+c].append(num)
        return [num for row in result for num in reversed(row)]

```



----------------------------------------------------------------------------------------

### Queue - 1438 - https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/
Time: O(n)  Space: O(n)   Hard
.Python/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def longestSubarray(self, nums, limit):
        """
        :type nums: List[int]
        :type limit: int
        :rtype: int
        """
        max_dq, min_dq = collections.deque(), collections.deque()
        left = 0
        for right, num in enumerate(nums):
            while max_dq and nums[max_dq[-1]] &lt;= num:
                max_dq.pop()
            max_dq.append(right)
            while min_dq and nums[min_dq[-1]] &gt;= num:
                min_dq.pop()
            min_dq.append(right)
            if nums[max_dq[0]]-nums[min_dq[0]] &gt; limit:
                if max_dq[0] == left:
                    max_dq.popleft()
                if min_dq[0] == left:
                    min_dq.popleft()
                left += 1  # advance left by one to not count in result
        return len(nums)-left


# Time:  O(n)
# Space: O(n)
import collections


class Solution2(object):
    def longestSubarray(self, nums, limit):
        """
        :type nums: List[int]
        :type limit: int
        :rtype: int
        """
        max_dq, min_dq = collections.deque(), collections.deque()
        result, left = 0, 0
        for right, num in enumerate(nums):
            while max_dq and nums[max_dq[-1]] &lt;= num:
                max_dq.pop()
            max_dq.append(right)
            while min_dq and nums[min_dq[-1]] &gt;= num:
                min_dq.pop()
            min_dq.append(right)
            while nums[max_dq[0]]-nums[min_dq[0]] &gt; limit:  # both always exist "right" element
                if max_dq[0] == left:
                    max_dq.popleft()
                if min_dq[0] == left:
                    min_dq.popleft()
                left += 1
            result = max(result, right-left+1)
        return result

```



----------------------------------------------------------------------------------------

### Queue - 1499 - https://leetcode.com/problems/max-value-of-equation/
Time: O(n)  Space: O(n)   Hard
.Python/max-value-of-equation.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def findMaxValueOfEquation(self, points, k):
        """
        :type points: List[List[int]]
        :type k: int
        :rtype: int
        """
        result = float("-inf")
        dq = collections.deque()
        for i, (x, y) in enumerate(points):
            while dq and points[dq[0]][0] &lt; x-k:
                dq.popleft()
            if dq:
                result = max(result, (points[dq[0]][1]-points[dq[0]][0])+y+x)
            while dq and points[dq[-1]][1]-points[dq[-1]][0] &lt;= y-x:
                dq.pop()
            dq.append(i)
        return result

```



----------------------------------------------------------------------------------------

### Queue - 1696 - https://leetcode.com/problems/jump-game-vi/
Time: O(n)  Space: O(k)   Medium
.Python/jump-game-vi.py


```python
# Time:  O(n)
# Space: O(k)

import collections


class Solution(object):
    def maxResult(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        score = 0
        dq = collections.deque()
        for i, num in enumerate(nums):
            if dq and dq[0][0] == i-k-1:
                dq.popleft()
            score = num if not dq else dq[0][1]+num
            while dq and dq[-1][1] &lt;= score:
                dq.pop()
            dq.append((i, score))
        return score

```



----------------------------------------------------------------------------------------

### Binary Heap - 1046 - https://leetcode.com/problems/last-stone-weight/
Time: O(nlogn)  Space: O(n)   Easy
.Python/last-stone-weight.py


```python
# Time:  O(nlogn)
# Space: O(n)

import heapq


class Solution(object):
    def lastStoneWeight(self, stones):
        """
        :type stones: List[int]
        :rtype: int
        """
        max_heap = [-x for x in stones]
        heapq.heapify(max_heap)
        for i in xrange(len(stones)-1):
            x, y = -heapq.heappop(max_heap), -heapq.heappop(max_heap)
            heapq.heappush(max_heap, -abs(x-y))
        return -max_heap[0]

```



----------------------------------------------------------------------------------------

### Binary Heap - 1057 - https://leetcode.com/problems/campus-bikes/
Time: O((w * b) * log(w * b))  Space: O(w * b)   Medium
.Python/campus-bikes.py


```python
# Time:  O((w * b) * log(w * b))
# Space: O(w * b)

import heapq


class Solution(object):
    def assignBikes(self, workers, bikes):
        """
        :type workers: List[List[int]]
        :type bikes: List[List[int]]
        :rtype: List[int]
        """
        def manhattan(p1, p2):
            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
        
        distances = [[] for _ in xrange(len(workers))]
        for i in xrange(len(workers)):
            for j in xrange(len(bikes)):
                distances[i].append((manhattan(workers[i], bikes[j]), i, j))
            distances[i].sort(reverse = True)
        
        result = [None] * len(workers)
        lookup = set()
        min_heap = []
        for i in xrange(len(workers)):
            heapq.heappush(min_heap, distances[i].pop())
        while len(lookup) &lt; len(workers):
            _, worker, bike = heapq.heappop(min_heap)
            if bike not in lookup:
                result[worker] = bike
                lookup.add(bike)
            else:
                heapq.heappush(min_heap, distances[worker].pop())
        return result

```



----------------------------------------------------------------------------------------

### Binary Heap - 1383 - https://leetcode.com/problems/maximum-performance-of-a-team/
Time: O(nlogn)  Space: O(n)   Hard
.Python/maximum-performance-of-a-team.py


```python
# Time:  O(nlogn)
# Space: O(n)

import itertools
import heapq


class Solution(object):
    def maxPerformance(self, n, speed, efficiency, k):
        """
        :type n: int
        :type speed: List[int]
        :type efficiency: List[int]
        :type k: int
        :rtype: int
        """
        MOD = 10**9 + 7
        result, s_sum = 0, 0
        min_heap = []
        for e, s in sorted(itertools.izip(efficiency, speed), reverse=True):
            s_sum += s
            heapq.heappush(min_heap, s)
            if len(min_heap) &gt; k:
                s_sum -= heapq.heappop(min_heap)
            result = max(result,s_sum*e)
        return result % MOD

```



----------------------------------------------------------------------------------------

### Binary Heap - 1439 - https://leetcode.com/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows/
Time: O(m * klogk)  Space: O(k)   Hard
.Python/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows.py


```python
# Time:  O(m * klogk)
# Space: O(k)

import heapq


class Solution(object):
    def kthSmallest(self, mat, k):
        """
        :type mat: List[List[int]]
        :type k: int
        :rtype: int
        """
        def kSmallestPairs(nums1, nums2, k):
            result, min_heap = [], []
            for c in xrange(min(len(nums1), k)):
                heapq.heappush(min_heap, (nums1[c]+nums2[0], 0))
                c += 1
            while len(result) != k and min_heap:
                total, c = heapq.heappop(min_heap)
                result.append(total)
                if c+1 == len(nums2):
                    continue
                heapq.heappush(min_heap, (total-nums2[c]+nums2[c+1], c+1))
            return result

        result = mat[0]
        for r in xrange(1, len(mat)):
            result = kSmallestPairs(result, mat[r], k)
        return result[k-1]


# Time:  O((k + m) * log(m * MAX_NUM)) ~ O(k * m * log(m * MAX_NUM))
# Space: O(m)
class Solution2(object):
    def kthSmallest(self, mat, k):
        """
        :type mat: List[List[int]]
        :type k: int
        :rtype: int
        """        
        def countArraysHaveSumLessOrEqual(mat, k, r, target):  # Time: O(k + m) ~ O(k * m)
            if target &lt; 0:
                return 0
            if r == len(mat):
                return 1
            result = 0
            for c in xrange(len(mat[0])):
                cnt = countArraysHaveSumLessOrEqual(mat, k-result, r+1, target-mat[r][c])
                if not cnt:
                    break
                result += cnt
                if result &gt; k:
                    break
            return result
        
        max_num = max(x for row in mat for x in row)
        left, right = len(mat), len(mat)*max_num
        while left &lt;= right:
            mid = left + (right-left)//2
            cnt = countArraysHaveSumLessOrEqual(mat, k, 0, mid)
            if cnt &gt;= k:
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Binary Heap - 1606 - https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/
Time: O(nlogk)  Space: O(k)   Hard
.Python/find-servers-that-handled-most-number-of-requests.py


```python
# Time:  O(nlogk)
# Space: O(k)

import itertools
import heapq


class Solution(object):
    def busiestServers(self, k, arrival, load):
        """
        :type k: int
        :type arrival: List[int]
        :type load: List[int]
        :rtype: List[int]
        """
        count = [0]*k
        min_heap_of_endtimes = []
        min_heap_of_nodes_after_curr = []
        min_heap_of_nodes_before_curr = range(k)
        for i, (t, l) in enumerate(itertools.izip(arrival, load)):
            if i % k == 0:
                min_heap_of_nodes_before_curr, min_heap_of_nodes_after_curr = [], min_heap_of_nodes_before_curr
            while min_heap_of_endtimes and min_heap_of_endtimes[0][0] &lt;= t:
                _, free = heapq.heappop(min_heap_of_endtimes)
                if free &lt; i % k:
                    heapq.heappush(min_heap_of_nodes_before_curr, free)
                else:
                    heapq.heappush(min_heap_of_nodes_after_curr, free)
            min_heap_of_candidates = min_heap_of_nodes_after_curr if min_heap_of_nodes_after_curr else min_heap_of_nodes_before_curr
            if not min_heap_of_candidates:
                continue
            node = heapq.heappop(min_heap_of_candidates)
            count[node] += 1
            heapq.heappush(min_heap_of_endtimes, (t+l, node))
        max_count = max(count)
        return [i for i in xrange(k) if count[i] == max_count]


# Time:  O(nlogk)
# Space: O(k)
import sortedcontainers  # required to do pip install
import itertools
import heapq


# reference: http://www.grantjenks.com/docs/sortedcontainers/sortedlist.html
class Solution2(object):
    def busiestServers(self, k, arrival, load):
        """
        :type k: int
        :type arrival: List[int]
        :type load: List[int]
        :rtype: List[int]
        """
        count = [0]*k 
        min_heap_of_endtimes = []
        availables = sortedcontainers.SortedList(xrange(k))  # O(klogk)
        for i, (t, l) in enumerate(itertools.izip(arrival, load)):
            while min_heap_of_endtimes and min_heap_of_endtimes[0][0] &lt;= t:
                _, free = heapq.heappop(min_heap_of_endtimes)  # O(logk)
                availables.add(free)  # O(logk)
            if not availables: 
                continue
            idx = availables.bisect_left(i % k) % len(availables)  # O(logk)
            node = availables.pop(idx)  # O(logk)
            count[node] += 1
            heapq.heappush(min_heap_of_endtimes, (t+l, node))  # O(logk)
        max_count = max(count)
        return [i for i in xrange(k) if count[i] == max_count]

```



----------------------------------------------------------------------------------------

### Binary Heap - 1642 - https://leetcode.com/problems/furthest-building-you-can-reach/
Time: O(nlogk)  Space: O(k)   Medium
.Python/furthest-building-you-can-reach.py


```python
# Time:  O(nlogk)
# Space: O(k)

import heapq


class Solution(object):
    def furthestBuilding(self, heights, bricks, ladders):
        """
        :type heights: List[int]
        :type bricks: int
        :type ladders: int
        :rtype: int
        """
        min_heap = []
        for i in xrange(len(heights)-1):
            diff = heights[i+1]-heights[i]
            if diff &gt; 0:
                heapq.heappush(min_heap, diff)
            if len(min_heap) &lt;= ladders:  # ladders are reserved for largest diffs
                continue
            bricks -= heapq.heappop(min_heap)  # use bricks if ladders are not enough
            if bricks &lt; 0:  # not enough bricks
                return i
        return len(heights)-1

```



----------------------------------------------------------------------------------------

### Binary Heap - 1675 - https://leetcode.com/problems/minimize-deviation-in-array/
Time: O((n * log(max_num)) * logn)  Space: O(n)   Hard
.Python/minimize-deviation-in-array.py


```python
# Time:  O((n * log(max_num)) * logn)
# Space: O(n)

import heapq


class Solution(object):
    def minimumDeviation(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        max_heap = [-num*2 if num%2 else -num for num in nums]
        heapq.heapify(max_heap)
        min_elem = -max(max_heap)
        result = float("inf")
        while len(max_heap) == len(nums):
            num = -heapq.heappop(max_heap)
            result = min(result, num-min_elem)
            if not num%2:
                min_elem = min(min_elem, num//2)
                heapq.heappush(max_heap, -num//2)
        return result

```



----------------------------------------------------------------------------------------

### Binary Heap - 1792 - https://leetcode.com/problems/maximum-average-pass-ratio/
Time: O(n + mlogn)  Space: O(n)   Medium
.Python/maximum-average-pass-ratio.py


```python
# Time:  O(n + mlogn)
# Space: O(n)

import heapq


class Solution(object):
    def maxAverageRatio(self, classes, extraStudents):
        """
        :type classes: List[List[int]]
        :type extraStudents: int
        :rtype: float
        """
        def profit(a, b):
            return float(a+1)/(b+1)-float(a)/b

        max_heap = [(-profit(a, b), a, b) for a, b in classes]
        heapq.heapify(max_heap)
        while extraStudents:
            v, a, b = heapq.heappop(max_heap)
            a, b = a+1, b+1
            heapq.heappush(max_heap, (-profit(a, b), a, b))
            extraStudents -= 1
        return sum(float(a)/b for v, a, b in max_heap)/len(classes)

```



----------------------------------------------------------------------------------------

### Binary Heap - 1882 - https://leetcode.com/problems/process-tasks-using-servers/
Time: O(n + mlogn)  Space: O(n)   Medium
.Python/process-tasks-using-servers.py


```python
# Time:  O(n + mlogn)
# Space: O(n)

import heapq


class Solution(object):
    def assignTasks(self, servers, tasks):
        """
        :type servers: List[int]
        :type tasks: List[int]
        :rtype: List[int]
        """
        idle = [(servers[i], i) for i in xrange(len(servers))]
        working = []
        heapq.heapify(idle)
        result = []
        t = 0
        for i in xrange(len(tasks)):
            t = max(t, i) if idle else working[0][0]
            while working and working[0][0] &lt;= t:
                _, w, idx = heapq.heappop(working)
                heapq.heappush(idle, (w, idx))
            w, idx = heapq.heappop(idle)
            heapq.heappush(working, (t+tasks[i], w, idx))
            result.append(idx)
        return result

```



----------------------------------------------------------------------------------------

### Binary Heap - 1962 - https://leetcode.com/problems/remove-stones-to-minimize-the-total/
Time: O(klogn)  Space: O(1)   Medium
.Python/remove-stones-to-minimize-the-total.py


```python
# Time:  O(klogn)
# Space: O(1)

import heapq


class Solution(object):
    def minStoneSum(self, piles, k):
        """
        :type piles: List[int]
        :type k: int
        :rtype: int
        """
        for i, x in enumerate(piles):
            piles[i] = -x
        heapq.heapify(piles)
        for i in xrange(k):
            heapq.heappush(piles, heapq.heappop(piles)//2)
        return -sum(piles)

```



----------------------------------------------------------------------------------------

### Binary Heap - 2054 - https://leetcode.com/problems/two-best-non-overlapping-events/
Time: O(nlogn)  Space: O(n)   Medium
.Python/two-best-non-overlapping-events.py


```python
# Time:  O(nlogn)
# Space: O(n)

import heapq


class Solution(object):
    def maxTwoEvents(self, events):
        """
        :type events: List[List[int]]
        :rtype: int
        """
        events.sort()
        result = best = 0
        min_heap = []
        for left, right, v in events:
            heapq.heappush(min_heap, (right, v))
            while min_heap and min_heap[0][0] &lt; left:
                best = max(best, heapq.heappop(min_heap)[1])
            result = max(result, best+v)
        return result

```



----------------------------------------------------------------------------------------

### Binary Heap - 2163 - https://leetcode.com/problems/minimum-difference-in-sums-after-removal-of-elements/
Time: O(nlogn)  Space: O(n)   Hard
.Python/minimum-difference-in-sums-after-removal-of-elements.py


```python
# Time:  O(nlogn)
# Space: O(n)

import heapq


# heap, prefix sum
class Solution(object):
    def minimumDifference(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        max_heap = []
        for i in xrange(len(nums)//3):
            heapq.heappush(max_heap, -nums[i])
        prefix = [0]*(len(nums)//3+1)
        prefix[0] = -sum(max_heap)
        for i in xrange(len(nums)//3):
            x = -heapq.heappushpop(max_heap, -nums[i+len(nums)//3])
            prefix[i+1] = prefix[i]-x+nums[i+len(nums)//3]

        min_heap = []
        for i in reversed(xrange(len(nums)//3*2, len(nums))):
            heapq.heappush(min_heap, nums[i])
        suffix = sum(min_heap)
        result = prefix[len(nums)//3]-suffix
        for i in reversed(xrange(len(nums)//3)):
            x = heapq.heappushpop(min_heap, nums[i+len(nums)//3])
            suffix += -x+nums[i+len(nums)//3]
            result = min(result, prefix[i]-suffix)
        return result

```



----------------------------------------------------------------------------------------

### Binary Heap - 2208 - https://leetcode.com/problems/minimum-operations-to-halve-array-sum/
Time: O(nlogn)  Space: O(n)   Medium
.Python/minimum-operations-to-halve-array-sum.py


```python
# Time:  O(nlogn)
# Space: O(n)

import heapq


# heap
class Solution(object):
    def halveArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        target = sum(nums)/2.0
        max_heap = [-x for x in nums]
        heapq.heapify(max_heap)
        result = 1
        while max_heap:
            x = -heapq.heappop(max_heap)/2.0
            target -= x
            if target &lt;= 0.0:
                break
            heapq.heappush(max_heap, -x)
            result += 1
        return result

```



----------------------------------------------------------------------------------------

### Tree - 1008 - https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/
Time: O(n)  Space: O(h)   Medium
.Python/construct-binary-search-tree-from-preorder-traversal.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def bstFromPreorder(self, preorder):
        """
        :type preorder: List[int]
        :rtype: TreeNode
        """
        def bstFromPreorderHelper(preorder, left, right, index):
            if index[0] == len(preorder) or \
               preorder[index[0]] &lt; left or \
               preorder[index[0]] &gt; right:
                return None

            root = TreeNode(preorder[index[0]])
            index[0] += 1
            root.left = bstFromPreorderHelper(preorder, left, root.val, index)
            root.right = bstFromPreorderHelper(preorder, root.val, right, index)
            return root
        
        return bstFromPreorderHelper(preorder, float("-inf"), float("inf"), [0])

```



----------------------------------------------------------------------------------------

### Tree - 1022 - https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/
Time: O(n)  Space: O(h)   Easy
.Python/sum-of-root-to-leaf-binary-numbers.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sumRootToLeaf(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        M = 10**9 + 7
        def sumRootToLeafHelper(root, val):
            if not root:
                return 0
            val = (val*2 + root.val) % M
            if not root.left and not root.right:
                return val
            return (sumRootToLeafHelper(root.left, val) +
                    sumRootToLeafHelper(root.right, val)) % M
        
        return sumRootToLeafHelper(root, 0)

```



----------------------------------------------------------------------------------------

### Tree - 1026 - https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/
Time: O(n)  Space: O(h)   Medium
.Python/maximum-difference-between-node-and-ancestor.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


# iterative stack solution
class Solution(object):
    def maxAncestorDiff(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        result = 0
        stack = [(root, 0, float("inf"))]
        while stack:
            node, mx, mn = stack.pop()
            if not node:
                continue
            result = max(result, mx-node.val, node.val-mn)
            mx = max(mx, node.val)
            mn = min(mn, node.val)
            stack.append((node.left, mx, mn))
            stack.append((node.right, mx, mn))
        return result


# Time:  O(n)
# Space: O(h)
# recursive solution
class Solution2(object):
    def maxAncestorDiff(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def maxAncestorDiffHelper(node, mx, mn): 
            if not node:
                return 0
            result = max(mx-node.val, node.val-mn)
            mx = max(mx, node.val)
            mn = min(mn, node.val)
            result = max(result, maxAncestorDiffHelper(node.left, mx, mn))
            result = max(result, maxAncestorDiffHelper(node.right, mx, mn))
            return result

        return maxAncestorDiffHelper(root, 0, float("inf"))

```



----------------------------------------------------------------------------------------

### Tree - 1028 - https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/
Time: O(n)  Space: O(h)   Hard
.Python/recover-a-tree-from-preorder-traversal.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


# iterative stack solution
class Solution(object):
    def recoverFromPreorder(self, S):
        """
        :type S: str
        :rtype: TreeNode
        """
        i = 0
        stack = []
        while i &lt; len(S):
            level = 0
            while i &lt; len(S) and S[i] == '-':
                level += 1
                i += 1
            while len(stack) &gt; level:
                stack.pop()
            val = []
            while i &lt; len(S) and S[i] != '-':
                val.append(S[i])
                i += 1
            node = TreeNode(int("".join(val)))
            if stack:
                if stack[-1].left is None:
                    stack[-1].left = node
                else:
                    stack[-1].right = node
            stack.append(node)
        return stack[0]


# Time:  O(n)
# Space: O(h)
# recursive solution
class Solution2(object):
    def recoverFromPreorder(self, S):
        """
        :type S: str
        :rtype: TreeNode
        """
        def recoverFromPreorderHelper(S, level, i):
            j = i[0]
            while j &lt; len(S) and S[j] == '-':
                j += 1 
            if level != j - i[0]:
                return None
            i[0] = j
            while j &lt; len(S) and S[j] != '-':
                j += 1
            node = TreeNode(int(S[i[0]:j]))
            i[0] = j
            node.left = recoverFromPreorderHelper(S, level+1, i)
            node.right = recoverFromPreorderHelper(S, level+1, i)
            return node

        return recoverFromPreorderHelper(S, 0, [0])

```



----------------------------------------------------------------------------------------

### Tree - 1032 - https://leetcode.com/problems/stream-of-characters/
Time: ctor: O(n)  query: O(m)  Space: O(t)   Hard
.Python/stream-of-characters.py


```python
# Time:  ctor:  O(n)    , n is the total size of patterns
#        query: O(m + z), m is the total size of query string
#                       , z is the number of all matched strings
#                       , query time could be further improved to O(m) if we don't return all matched patterns
# Space: O(t), t is the total size of ac automata trie
#            , space could be further improved by DAT (double-array trie)

# AhoCorasick automata
# reference:
# 1. http://web.stanford.edu/class/archive/cs/cs166/cs166.1166/lectures/02/Small02.pdf
# 2. http://algo.pw/algo/64/python

import collections


class AhoNode(object):
    def __init__(self):
        self.children = collections.defaultdict(AhoNode)
        self.indices = []
        self.suffix = None
        self.output = None


class AhoTrie(object):

    def step(self, letter):
        while self.__node and letter not in self.__node.children:
            self.__node = self.__node.suffix
        self.__node = self.__node.children[letter] if self.__node else self.__root
        return self.__get_ac_node_outputs(self.__node)
    
    def __init__(self, patterns):
        self.__root = self.__create_ac_trie(patterns)
        self.__node = self.__create_ac_suffix_and_output_links(self.__root)
    
    def __create_ac_trie(self, patterns):  # Time:  O(n), Space: O(t)
        root = AhoNode()
        for i, pattern in enumerate(patterns):
            node = root
            for c in pattern:
                node = node.children[c]
            node.indices.append(i)
        return root

    def __create_ac_suffix_and_output_links(self, root):  # Time:  O(n), Space: O(t)
        queue = collections.deque()
        for node in root.children.itervalues():
            queue.append(node)
            node.suffix = root

        while queue:
            node = queue.popleft()
            for c, child in node.children.iteritems():
                queue.append(child)
                suffix = node.suffix
                while suffix and c not in suffix.children:
                    suffix = suffix.suffix
                child.suffix = suffix.children[c] if suffix else root
                child.output = child.suffix if child.suffix.indices else child.suffix.output
                
        return root

    def __get_ac_node_outputs(self, node):  # Time:  O(z), in this question, it could be improved to O(1)
                                            # if we only return a matched pattern without all matched ones
        result = []
        for i in node.indices:
            result.append(i)
            # return result
        output = node.output
        while output:
            for i in output.indices:
                result.append(i)
                # return result
            output = output.output
        return result


class StreamChecker(object):

    def __init__(self, words):
        """
        :type words: List[str]
        """
        self.__trie = AhoTrie(words)

    def query(self, letter):  # O(m) times
        """
        :type letter: str
        :rtype: bool
        """
        return len(self.__trie.step(letter)) &gt; 0
        

# Your StreamChecker object will be instantiated and called as such:
# obj = StreamChecker(words)
# param_1 = obj.query(letter)

```



----------------------------------------------------------------------------------------

### Tree - 1038 - https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/
Time: O(n)  Space: O(h)   Medium
.Python/binary-search-tree-to-greater-sum-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def bstToGst(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        def bstToGstHelper(root, prev):
            if not root:
                return root
            bstToGstHelper(root.right, prev)
            root.val += prev[0]
            prev[0] = root.val
            bstToGstHelper(root.left, prev)
            return root
        
        prev = [0]
        return bstToGstHelper(root, prev)

```



----------------------------------------------------------------------------------------

### Tree - 1065 - https://leetcode.com/problems/index-pairs-of-a-string/
Time: O(n + m + z)  Space: O(t)   Easy
.Python/index-pairs-of-a-string.py


```python
# Time:  O(n + m + z), n is the total size of patterns
#                    , m is the total size of query string
#                    , z is the number of all matched strings
# Space: O(t), t is the total size of ac automata trie

import collections


class AhoNode(object):
    def __init__(self):
        self.children = collections.defaultdict(AhoNode)
        self.indices = []
        self.suffix = None
        self.output = None


class AhoTrie(object):

    def step(self, letter):
        while self.__node and letter not in self.__node.children:
            self.__node = self.__node.suffix
        self.__node = self.__node.children[letter] if self.__node else self.__root
        return self.__get_ac_node_outputs(self.__node)
    
    def __init__(self, patterns):
        self.__root = self.__create_ac_trie(patterns)
        self.__node = self.__create_ac_suffix_and_output_links(self.__root)
    
    def __create_ac_trie(self, patterns):  # Time:  O(n), Space: O(t)
        root = AhoNode()
        for i, pattern in enumerate(patterns):
            node = root
            for c in pattern:
                node = node.children[c]
            node.indices.append(i)
        return root

    def __create_ac_suffix_and_output_links(self, root):  # Time:  O(n), Space: O(t)
        queue = collections.deque()
        for node in root.children.itervalues():
            queue.append(node)
            node.suffix = root

        while queue:
            node = queue.popleft()
            for c, child in node.children.iteritems():
                queue.append(child)
                suffix = node.suffix
                while suffix and c not in suffix.children:
                    suffix = suffix.suffix
                child.suffix = suffix.children[c] if suffix else root
                child.output = child.suffix if child.suffix.indices else child.suffix.output
                
        return root

    def __get_ac_node_outputs(self, node):  # Time:  O(z)
        result = []
        for i in node.indices:
            result.append(i)
        output = node.output
        while output:
            for i in output.indices:
                result.append(i)
            output = output.output
        return result
    

class Solution(object):
    def indexPairs(self, text, words):
        """
        :type text: str
        :type words: List[str]
        :rtype: List[List[int]]
        """
        result = []
        reversed_words = [w[::-1] for w in words]
        trie = AhoTrie(reversed_words)
        for i in reversed(xrange(len(text))):
            for j in trie.step(text[i]):
                result.append([i, i+len(reversed_words[j])-1])
        result.reverse()
        return result

```



----------------------------------------------------------------------------------------

### Tree - 1080 - https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/
Time: O(n)  Space: O(h)   Medium
.Python/insufficient-nodes-in-root-to-leaf-paths.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sufficientSubset(self, root, limit):
        """
        :type root: TreeNode
        :type limit: int
        :rtype: TreeNode
        """
        if not root:
            return None
        if not root.left and not root.right:
            return None if root.val &lt; limit else root
        root.left = self.sufficientSubset(root.left, limit-root.val)
        root.right = self.sufficientSubset(root.right, limit-root.val)
        if not root.left and not root.right:
            return None
        return root

```



----------------------------------------------------------------------------------------

### Tree - 1104 - https://leetcode.com/problems/path-in-zigzag-labelled-binary-tree/
Time: O(logn)  Space: O(logn)   Easy
.Python/path-in-zigzag-labelled-binary-tree.py


```python
# Time:  O(logn)
# Space: O(logn)

class Solution(object):
    def pathInZigZagTree(self, label):
        """
        :type label: int
        :rtype: List[int]
        """
        count = 2**label.bit_length()
        result = []
        while label &gt;= 1:
            result.append(label)
            label = ((count//2) + ((count-1)-label)) // 2
            count //= 2
        result.reverse()
        return result

```



----------------------------------------------------------------------------------------

### Tree - 1120 - https://leetcode.com/problems/maximum-average-subtree/
Time: O(n)  Space: O(h)   Easy
.Python/maximum-average-subtree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maximumAverageSubtree(self, root):
        """
        :type root: TreeNode
        :rtype: float
        """
        def maximumAverageSubtreeHelper(root, result):
            if not root:
                return [0.0, 0]
            s1, n1 = maximumAverageSubtreeHelper(root.left, result)
            s2, n2 = maximumAverageSubtreeHelper(root.right, result)
            s = s1+s2+root.val
            n = n1+n2+1
            result[0] = max(result[0], s / n)
            return [s, n]

        result = [0]
        maximumAverageSubtreeHelper(root, result)
        return result[0]

```



----------------------------------------------------------------------------------------

### Tree - 1123 - https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/
Time: O(n)  Space: O(h)   Medium
.Python/lowest-common-ancestor-of-deepest-leaves.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def lcaDeepestLeaves(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        def lcaDeepestLeavesHelper(root):
            if not root:
                return 0, None
            d1, lca1 = lcaDeepestLeavesHelper(root.left)
            d2, lca2 = lcaDeepestLeavesHelper(root.right)
            if d1 &gt; d2:
                return d1+1, lca1
            if d1 &lt; d2:
                return d2+1, lca2
            return d1+1, root

        return lcaDeepestLeavesHelper(root)[1]

```



----------------------------------------------------------------------------------------

### Tree - 1145 - https://leetcode.com/problems/binary-tree-coloring-game/
Time: O(n)  Space: O(h)   Medium
.Python/binary-tree-coloring-game.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def btreeGameWinningMove(self, root, n, x):
        """
        :type root: TreeNode
        :type n: int
        :type x: int
        :rtype: bool
        """
        def count(node, x, left_right):
            if not node:
                return 0
            left, right = count(node.left, x, left_right), count(node.right, x, left_right)
            if node.val == x:
                left_right[0], left_right[1] = left, right
            return left + right + 1

        left_right = [0, 0]
        count(root, x, left_right)
        blue = max(max(left_right), n-(sum(left_right)+1))
        return blue &gt; n-blue

```



----------------------------------------------------------------------------------------

### Tree - 1257 - https://leetcode.com/problems/smallest-common-region/
Time: O(m * n)  Space: O(n)   Medium
.Python/smallest-common-region.py


```python
# Time:  O(m * n)
# Space: O(n)

class Solution(object):
    def findSmallestRegion(self, regions, region1, region2):
        """
        :type regions: List[List[str]]
        :type region1: str
        :type region2: str
        :rtype: str
        """
        parents = {region[i] : region[0]
                   for region in regions
                   for i in xrange(1, len(region))}
        lookup = {region1}
        while region1 in parents:
            region1 = parents[region1]
            lookup.add(region1)
        while region2 not in lookup:
            region2 = parents[region2]
        return region2

```



----------------------------------------------------------------------------------------

### Tree - 1261 - https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/
Time: O(n)  Space: O(h)   Medium
.Python/find-elements-in-a-contaminated-binary-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class FindElements(object):

    def __init__(self, root):
        """
        :type root: TreeNode
        """
        def dfs(node, v, lookup):
            if not node:
                return
            node.val = v    
            lookup.add(v)
            dfs(node.left, 2*v+1, lookup)
            dfs(node.right, 2*v+2, lookup)

        self.__lookup = set()
        dfs(root, 0, self.__lookup)

    def find(self, target):
        """
        :type target: int
        :rtype: bool
        """
        return target in self.__lookup

```



----------------------------------------------------------------------------------------

### Tree - 1325 - https://leetcode.com/problems/delete-leaves-with-a-given-value/
Time: O(n)  Space: O(h)   Medium
.Python/delete-leaves-with-a-given-value.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def removeLeafNodes(self, root, target):
        """
        :type root: TreeNode
        :type target: int
        :rtype: TreeNode
        """
        if not root:
            return None
        root.left = self.removeLeafNodes(root.left, target)
        root.right = self.removeLeafNodes(root.right, target)
        return None if root.left == root.right and root.val == target else root

```



----------------------------------------------------------------------------------------

### Tree - 1339 - https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/
Time: O(n)  Space: O(h)   Medium
.Python/maximum-product-of-splitted-binary-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def maxProduct(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        MOD = 10**9 + 7
        def dfs(root, total, result):
            if not root:
                return 0
            subtotal = dfs(root.left, total, result)+dfs(root.right, total, result)+root.val
            result[0] = max(result[0], subtotal*(total-subtotal) )
            return subtotal

        result = [0]
        dfs(root, dfs(root, 0, result), result)
        return result[0] % MOD

```



----------------------------------------------------------------------------------------

### Tree - 1409 - https://leetcode.com/problems/queries-on-a-permutation-with-key/
Time: O(nlogn)  Space: O(n)   Medium
.Python/queries-on-a-permutation-with-key.py


```python
# Time:  O(nlogn)
# Space: O(n)

class BIT(object):  # Fenwick Tree, 1-indexed
    def __init__(self, n):
        self.__bit = [0] * n

    def add(self, i, val):
        while i &lt; len(self.__bit):
            self.__bit[i] += val
            i += (i &amp; -i)

    def sum(self, i):
        result = 0
        while i &gt; 0:
            result += self.__bit[i]
            i -= (i &amp; -i)
        return result


class Solution(object):
    def processQueries(self, queries, m):
        """
        :type queries: List[int]
        :type m: int
        :rtype: List[int]
        """
        bit = BIT(2*m+1)
        lookup = {}
        for i in xrange(1, m+1):
            bit.add(m+i, 1)
            lookup[i] = m+i
        result, curr = [], m
        for q in queries:
            i = lookup.pop(q)
            result.append(bit.sum(i-1))
            bit.add(i, -1)
            lookup[q] = curr
            bit.add(curr, 1)
            curr -= 1
        return result

```



----------------------------------------------------------------------------------------

### Tree - 1430 - https://leetcode.com/problems/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree/
Time: O(n)  Space: O(h)   Medium
.Python/check-if-a-string-is-a-valid-sequence-from-root-to-leaves-path-in-a-binary-tree.py


```python
# Time:  O(n)
# Space: O(w)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


# bfs solution
class Solution(object):
    def isValidSequence(self, root, arr):
        """
        :type root: TreeNode
        :type arr: List[int]
        :rtype: bool
        """
        q = [root]
        for depth in xrange(len(arr)):
            new_q = []
            while q:
                node = q.pop()
                if not node or node.val != arr[depth]:
                    continue
                if depth+1 == len(arr) and node.left == node.right:
                    return True
                new_q.extend(child for child in (node.left, node.right))
            q = new_q
        return False


# Time:  O(n)
# Space: O(h)
# dfs solution with stack
class Solution2(object):
    def isValidSequence(self, root, arr):
        """
        :type root: TreeNode
        :type arr: List[int]
        :rtype: bool
        """
        s = [(root, 0)]
        while s:
            node, depth = s.pop()
            if not node or depth == len(arr) or node.val != arr[depth]:
                continue
            if depth+1 == len(arr) and node.left == node.right:
                return True
            s.append((node.right, depth+1))
            s.append((node.left, depth+1))
        return False


# Time:  O(n)
# Space: O(h)
# dfs solution with recursion
class Solution3(object):
    def isValidSequence(self, root, arr):
        """
        :type root: TreeNode
        :type arr: List[int]
        :rtype: bool
        """
        def dfs(node, arr, depth):
            if not node or depth == len(arr) or node.val != arr[depth]:
                return False
            if depth+1 == len(arr) and node.left == node.right:
                return True
            return dfs(node.left, arr, depth+1) or dfs(node.right, arr, depth+1)

        return dfs(root, arr, 0)

```



----------------------------------------------------------------------------------------

### Tree - 1443 - https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/
Time: O(n)  Space: O(n)   Medium
.Python/minimum-time-to-collect-all-apples-in-a-tree.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def minTime(self, n, edges, hasApple):
        """
        :type n: int
        :type edges: List[List[int]]
        :type hasApple: List[bool]
        :rtype: int
        """
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        result = [0, 0]
        s = [(1, (-1, 0, result))]
        while s:
            step, params = s.pop()
            if step == 1:
                par, node, ret = params
                ret[:] = [0, int(hasApple[node])]
                for nei in reversed(graph[node]):
                    if nei == par:
                        continue
                    new_ret = [0, 0]
                    s.append((2, (new_ret, ret)))
                    s.append((1, (node, nei, new_ret)))
            else:
                new_ret, ret = params
                ret[0] += new_ret[0]+new_ret[1]
                ret[1] |= bool(new_ret[0]+new_ret[1])
        return 2*result[0]


# Time:  O(n)
# Space: O(n)
class Solution_Recu(object):
    def minTime(self, n, edges, hasApple):
        """
        :type n: int
        :type edges: List[List[int]]
        :type hasApple: List[bool]
        :rtype: int
        """
        def dfs(graph, par, node, hasApple):
            result, extra = 0, int(hasApple[node])
            for nei in graph[node]:
                if nei == par:
                    continue
                count, found = dfs(graph, node, nei, hasApple)
                result += count+found
                extra |= bool(count+found)
            return result, extra
        
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        return 2*dfs(graph, -1, 0, hasApple)[0]


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def minTime(self, n, edges, hasApple):
        """
        :type n: int
        :type edges: List[List[int]]
        :type hasApple: List[bool]
        :rtype: int
        """
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        result = [0]
        s = [(1, (-1, 0, result))]
        while s:
            step, params = s.pop()
            if step == 1:
                par, node, ret = params
                tmp = [int(hasApple[node])]
                s.append((3, (tmp, ret)))
                for nei in reversed(graph[node]):
                    if nei == par:
                        continue
                    new_ret = [0]
                    s.append((2, (new_ret, tmp, ret)))
                    s.append((1, (node, nei, new_ret)))
            elif step == 2:
                new_ret, tmp, ret = params
                ret[0] += new_ret[0]
                tmp[0] |= bool(new_ret[0])
            else:
                tmp, ret = params
                ret[0] += tmp[0]
        return 2*max(result[0]-1, 0)


# Time:  O(n)
# Space: O(n)
class Solution2_Recu(object):
    def minTime(self, n, edges, hasApple):
        """
        :type n: int
        :type edges: List[List[int]]
        :type hasApple: List[bool]
        :rtype: int
        """
        def dfs(graph, par, node, has_subtree):
            result, extra = 0, int(hasApple[node])
            for nei in graph[node]:
                if nei == par:
                    continue
                count = dfs(graph, node, nei, hasApple)
                result += count
                extra |= bool(count)
            return result+extra
        
        graph = collections.defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        return 2*max(dfs(graph, -1, 0, hasApple)-1, 0)

```



----------------------------------------------------------------------------------------

### Tree - 1448 - https://leetcode.com/problems/count-good-nodes-in-binary-tree/
Time: O(n)  Space: O(h)   Medium
.Python/count-good-nodes-in-binary-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def goodNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        result = 0
        stk = [(root, root.val)]
        while stk:
            node, curr_max = stk.pop()
            if not node:
                continue
            curr_max = max(curr_max, node.val)
            result += int(curr_max &lt;= node.val)
            stk.append((node.right, curr_max))
            stk.append((node.left, curr_max))
        return result


# Time:  O(n)
# Space: O(h)
class Solution2(object):
    def goodNodes(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(node, curr_max):
            if not node:
                return 0
            curr_max = max(curr_max, node.val)
            return (int(curr_max &lt;= node.val) +
                    dfs(node.left, curr_max) + dfs(node.right, curr_max))
        
        return dfs(root, root.val)

```



----------------------------------------------------------------------------------------

### Tree - 1457 - https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/
Time: O(n)  Space: O(h)   Medium
.Python/pseudo-palindromic-paths-in-a-binary-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def pseudoPalindromicPaths (self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        result = 0
        stk = [(root, 0)]
        while stk:
            node, count = stk.pop()
            if not node:
                continue
            count ^= 1 &lt;&lt; (node.val-1)
            result += int(node.left == node.right and count&amp;(count-1) == 0)
            stk.append((node.right, count))
            stk.append((node.left, count))
        return result
    

# Time:  O(n)
# Space: O(h)
class Solution2(object):
    def pseudoPalindromicPaths (self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(node, count):
            if not root:
                return 0
            count ^= 1 &lt;&lt; (node.val-1)
            return int(node.left == node.right and count&amp;(count-1) == 0) + \
                   dfs(node.left, count) + dfs(node.right, count)
        return dfs(root, 0)

```



----------------------------------------------------------------------------------------

### Tree - 1469 - https://leetcode.com/problems/find-all-the-lonely-nodes/
Time: O(n)  Space: O(h)   Easy
.Python/find-all-the-lonely-nodes.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def getLonelyNodes(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        result = []
        stk = [root]
        while stk:
            node = stk.pop()
            if not node:
                continue
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            stk.append(node.right)
            stk.append(node.left)
        return result


# Time:  O(n)
# Space: O(h)
class Solution2(object):
    def getLonelyNodes(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        def dfs(node, result):
            if not node:
                return
            if node.left and not node.right:
                result.append(node.left.val)
            elif node.right and not node.left:
                result.append(node.right.val)
            dfs(node.left, result)
            dfs(node.right, result)

        result = []
        dfs(root, result)
        return result

```



----------------------------------------------------------------------------------------

### Tree - 1490 - https://leetcode.com/problems/clone-n-ary-tree/
Time: O(n)  Space: O(h)   Medium
.Python/clone-n-ary-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []


class Solution(object):
    def cloneTree(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        result = [None]
        stk = [(1, (root, result))]
        while stk:
            step, params = stk.pop()
            if step == 1:
                node, ret = params
                if not node:
                    continue
                ret[0] = Node(node.val)
                for child in reversed(node.children):
                    ret1 = [None]
                    stk.append((2, (ret1, ret)))
                    stk.append((1, (child, ret1)))
            else:
                ret1, ret = params
                ret[0].children.append(ret1[0])
        return result[0]


# Time:  O(n)
# Space: O(h)
class Solution2(object):
    def cloneTree(self, root):
        """
        :type root: Node
        :rtype: Node
        """
        def dfs(node):
            if not node:
                return None
            copy = Node(node.val)
            for child in node.children:
                copy.children.append(dfs(child))
            return copy
        
        return dfs(root)

```



----------------------------------------------------------------------------------------

### Tree - 1505 - https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits/
Time: O(nlogn)  Space: O(n)   Hard
.Python/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class BIT(object):  # Fenwick Tree, 1-indexed
    def __init__(self, n):
        self.__bit = [0] * n

    def add(self, i, val):
        while i &lt; len(self.__bit):
            self.__bit[i] += val
            i += (i &amp; -i)

    def sum(self, i):
        result = 0
        while i &gt; 0:
            result += self.__bit[i]
            i -= (i &amp; -i)
        return result


class Solution(object):
    def minInteger(self, num, k):
        """
        :type num: str
        :type k: int
        :rtype: str
        """
        lookup = collections.defaultdict(list)
        bit = BIT(len(num)+1)
        for i in reversed(xrange(len(num))):
            bit.add(i+1, 1)
            lookup[int(num[i])].append(i+1)
        result = []
        for _ in xrange(len(num)):
            for d in xrange(10):
                if lookup[d] and bit.sum(lookup[d][-1]-1) &lt;= k:
                    k -= bit.sum(lookup[d][-1]-1)
                    bit.add(lookup[d].pop(), -1)
                    result.append(d)
                    break
        return "".join(map(str, result))

```



----------------------------------------------------------------------------------------

### Tree - 1506 - https://leetcode.com/problems/find-root-of-n-ary-tree/
Time: O(n)  Space: O(1)   Medium
.Python/find-root-of-n-ary-tree.py


```python
# Time:  O(n)
# Space: O(1)

# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        pass


class Solution(object):
    def findRoot(self, tree):
        """
        :type tree: List['Node']
        :rtype: 'Node'
        """
        root = 0
        for node in tree:
            root ^= id(node)
            for child in node.children:
                root ^= id(child)
        for node in tree:
            if id(node) == root:
                return node
        return None


class Solution2(object):
    def findRoot(self, tree):
        """
        :type tree: List['Node']
        :rtype: 'Node'
        """
        root = 0
        for node in tree:
            root ^= node.val
            for child in node.children:
                root ^= child.val
        for node in tree:
            if node.val == root:
                return node
        return None


class Solution3(object):
    def findRoot(self, tree):
        """
        :type tree: List['Node']
        :rtype: 'Node'
        """
        root = 0
        for node in tree:
            root += node.val-sum(child.val for child in node.children)
        for node in tree:
            if node.val == root:
                return node
        return None

```



----------------------------------------------------------------------------------------

### Tree - 1516 - https://leetcode.com/problems/move-sub-tree-of-n-ary-tree/
Time: O(n)  Space: O(h)   Hard
.Python/move-sub-tree-of-n-ary-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []


# one pass solution without recursion
class Solution(object):
    def moveSubTree(self, root, p, q):
        """
        :type root: Node
        :type p: Node
        :type q: Node
        :rtype: Node
        """
        def iter_find_parents(node, parent, p, q, is_ancestor, lookup):
            stk = [(1, [node, None, False])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent, is_ancestor = params
                    if node in (p, q):
                        lookup[node] = parent
                        if len(lookup) == 2:
                            return is_ancestor
                    stk.append((2, [node, is_ancestor, reversed(node.children)]))
                else:
                    node, is_ancestor, it = params
                    child = next(it, None)
                    if not child:
                        continue
                    stk.append((2, [node, is_ancestor, it]))
                    stk.append((1, [child, node, is_ancestor or node == p]))
            assert(False)
            return False

        lookup = {}
        is_ancestor = iter_find_parents(root, None, p, q, False, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor:
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root


# Time:  O(n)
# Space: O(h)
# one pass solution with recursion (bad in deep tree)
class Solution_Recu(object):
    def moveSubTree(self, root, p, q):
        """
        :type root: Node
        :type p: Node
        :type q: Node
        :rtype: Node
        """
        def find_parents(node, parent, p, q, is_ancestor, lookup):
            if node in (p, q):
                lookup[node] = parent
                if len(lookup) == 2:
                    return True, is_ancestor
            for child in node.children:
                found, new_is_ancestor = find_parents(child, node, p, q, is_ancestor or node == p, lookup)
                if found:
                    return True, new_is_ancestor
            return False, False

        lookup = {}
        is_ancestor = find_parents(root, None, p, q, False, lookup)[1]
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor:
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root


# Time:  O(n)
# Space: O(h)
# two pass solution without recursion
class Solution2(object):
    def moveSubTree(self, root, p, q):
        """
        :type root: Node
        :type p: Node
        :type q: Node
        :rtype: Node
        """
        def iter_find_parents(node, parent, p, q, lookup):
            stk = [(1, [node, None])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent = params
                    if node in (p, q):
                        lookup[node] = parent
                        if len(lookup) == 2:
                            return
                    stk.append((2, [node, reversed(node.children)]))
                else:
                    node, it = params
                    child = next(it, None)
                    if not child:
                        continue
                    stk.append((2, [node, it]))
                    stk.append((1, [child, node]))

        def iter_is_ancestor(node, q):
            stk = [(1, [node])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node = params[0]
                    stk.append((2, [reversed(node.children)]))
                else:
                    it = params[0]
                    child = next(it, None)
                    if not child:
                        continue
                    if child == q:
                        return True
                    stk.append((2, [it]))
                    stk.append((1, [child]))
            return False

        lookup = {}
        iter_find_parents(root, None, p, q, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not iter_is_ancestor(p, q):
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root


# Time:  O(n)
# Space: O(h)
# two pass solution with recursion (bad in deep tree)
class Solution2_Recu(object):
    def moveSubTree(self, root, p, q):
        """
        :type root: Node
        :type p: Node
        :type q: Node
        :rtype: Node
        """
        def find_parents(node, parent, p, q, lookup):
            if node in (p, q):
                lookup[node] = parent
                if len(lookup) == 2:
                    return True
            for child in node.children:
                if find_parents(child, node, p, q, lookup):
                    return True
            return False

        def is_ancestor(node, q):
            for child in node.children:
                if node == q or is_ancestor(child, q):
                    return True
            return False

        lookup = {}
        find_parents(root, None, p, q, lookup)
        if p in lookup and lookup[p] == q:
            return root
        q.children.append(p)
        if not is_ancestor(p, q):
            lookup[p].children.remove(p)
        else:
            lookup[q].children.remove(q)
            if p == root:
                root = q
            else:
                lookup[p].children[lookup[p].children.index(p)] = q
        return root

```



----------------------------------------------------------------------------------------

### Tree - 1519 - https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/
Time: O(n)  Space: O(h)   Medium
.Python/number-of-nodes-in-the-sub-tree-with-the-same-label.py


```python
# Time:  O(n)
# Space: O(h)

class Solution(object):
    def countSubTrees(self, n, edges, labels):
        """
        :type n: int
        :type edges: List[List[int]]
        :type labels: str
        :rtype: List[int]
        """
        def iter_dfs(labels, adj, node, parent, result):
            stk = [(1, (node, parent, [0]*26))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, parent, ret = params
                    stk.append((4, (node, ret)))
                    stk.append((2, (node, parent, reversed(adj[node]), ret)))
                elif step == 2:
                    node, parent, it, ret = params
                    child = next(it, None)
                    if not child or child == parent:
                        continue
                    ret2 = [0]*26
                    stk.append((2, (node, parent, it, ret)))
                    stk.append((3, (ret2, ret)))
                    stk.append((1, (child, node, ret2)))
                elif step == 3:
                    ret2, ret = params
                    for k in xrange(len(ret2)):
                        ret[k] += ret2[k]
                else:
                    node, ret = params
                    ret[ord(labels[node]) - ord('a')] += 1
                    result[node] += ret[ord(labels[node]) - ord('a')]
        
        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*n
        iter_dfs(labels, adj, 0, -1, result)
        return result


# Time:  O(n)
# Space: O(h)
import collections


class Solution2(object):
    def countSubTrees(self, n, edges, labels):
        """
        :type n: int
        :type edges: List[List[int]]
        :type labels: str
        :rtype: List[int]
        """
        def dfs(labels, adj, node, parent, result):
            count = [0]*26
            for child in adj[node]:
                if child == parent:
                    continue
                new_count = dfs(labels, adj, child, node, result)
                for k in xrange(len(new_count)):
                    count[k] += new_count[k]
            count[ord(labels[node]) - ord('a')] += 1
            result[node] = count[ord(labels[node]) - ord('a')]
            return count
        
        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [0]*n
        dfs(labels, adj, 0, -1, result)
        return result

```



----------------------------------------------------------------------------------------

### Tree - 1522 - https://leetcode.com/problems/diameter-of-n-ary-tree/
Time: O(n)  Space: O(h)   Medium
.Python/diameter-of-n-ary-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a Node.
class Node(object):
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []


class Solution(object):
    def diameter(self, root):
        """
        :type root: 'Node'
        :rtype: int
        """
        def iter_dfs(root):
            result = [0]*2
            stk = [(1, (root, result))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    for child in reversed(node.children):
                        ret2 = [0]*2
                        stk.append((2, (ret2, ret)))
                        stk.append((1, (child, ret2)))
                else:
                    ret2, ret = params
                    ret[0] = max(ret[0], ret2[0], ret[1]+ret2[1]+1)
                    ret[1] = max(ret[1], ret2[1]+1)
            return result
        
        return iter_dfs(root)[0]


# Time:  O(n)
# Space: O(h)
class Solution2(object):
    def diameter(self, root):
        """
        :type root: 'Node'
        :rtype: int
        """
        def dfs(node):
            max_dia, max_depth = 0, 0
            for child in node.children:
                child_max_dia, child_max_depth = dfs(child)
                max_dia = max(max_dia, child_max_dia, max_depth+child_max_depth+1)
                max_depth = max(max_depth, child_max_depth+1)
            return max_dia, max_depth
        
        return dfs(root)[0]

```



----------------------------------------------------------------------------------------

### Tree - 1530 - https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/
Time: O(n)  Space: O(h)   Medium
.Python/number-of-good-leaf-nodes-pairs.py


```python
# Time:  O(n)
# Space: O(h)

import collections


# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def countPairs(self, root, distance):
        """
        :type root: TreeNode
        :type distance: int
        :rtype: int
        """
        def iter_dfs(distance, root):
            result = 0
            stk = [(1, (root, [collections.Counter()]))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    if not node.left and not node.right:
                        ret[0][0] = 1
                        continue
                    left, right = [collections.Counter()], [collections.Counter()]
                    stk.append((2, (left, right, ret)))
                    stk.append((1, (node.right, right)))
                    stk.append((1, (node.left, left)))
                else:
                    left, right, ret = params
                    for left_d, left_c in left[0].iteritems():
                        for right_d,right_c in right[0].iteritems():
                            if left_d+right_d+2 &lt;= distance:
                                result += left_c*right_c
                    ret[0] = collections.Counter({k+1:v for k,v in (left[0]+right[0]).iteritems()})
            return result
        
        return iter_dfs(distance, root)


# Time:  O(n)
# Space: O(h)
import collections


class Solution2(object):
    def countPairs(self, root, distance):
        """
        :type root: TreeNode
        :type distance: int
        :rtype: int
        """
        def dfs(distance, node):
            if not node:
                return 0, collections.Counter()
            if not node.left and not node.right:
                return 0, collections.Counter([0])
            left, right = dfs(distance, node.left), dfs(distance, node.right)
            result = left[0]+right[0]
            for left_d, left_c in left[1].iteritems():
                for right_d,right_c in right[1].iteritems():
                    if left_d+right_d+2 &lt;= distance:
                        result += left_c*right_c
            return result, collections.Counter({k+1:v for k,v in (left[1]+right[1]).iteritems()})
        
        return dfs(distance, root)[0]

```



----------------------------------------------------------------------------------------

### Tree - 1612 - https://leetcode.com/problems/check-if-two-expression-trees-are-equivalent/
Time: O(n)  Space: O(1)   Medium
.Python/check-if-two-expression-trees-are-equivalent.py


```python
# Time:  O(n)
# Space: O(1)

import collections
import functools


# Definition for a binary tree node.
class Node(object):
    def __init__(self, val=" ", left=None, right=None):
        pass


# morris traversal
class Solution(object):
    def checkEquivalence(self, root1, root2):
        """
        :type root1: Node
        :type root2: Node
        :rtype: bool
        """
        def add_counter(counter, prev, d, val):
            if val.isalpha():
                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d
            prev[0] = val
    
        def morris_inorder_traversal(root, cb):
            curr = root
            while curr:
                if curr.left is None:
                    cb(curr.val)
                    curr = curr.right
                else:
                    node = curr.left
                    while node.right and node.right != curr:
                        node = node.right
                    if node.right is None:
                        node.right = curr
                        curr = curr.left
                    else:
                        cb(curr.val)
                        node.right = None
                        curr = curr.right

        counter = collections.defaultdict(int)
        morris_inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))
        morris_inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))
        return all(v == 0 for v in counter.itervalues())


# Time:  O(n)
# Space: O(h)
import collections
import functools


class Solution2(object):
    def checkEquivalence(self, root1, root2):
        """
        :type root1: Node
        :type root2: Node
        :rtype: bool
        """
        def add_counter(counter, prev, d, val):
            if val.isalpha():
                counter[ord(val)-ord('a')] += d if prev[0] == '+' else -d
            prev[0] = val

        def inorder_traversal(root, cb):
            def traverseLeft(node, stk):
                while node:
                    stk.append(node)
                    node = node.left 

            stk = []
            traverseLeft(root, stk)
            while stk:
                curr = stk.pop()
                cb(curr.val)
                traverseLeft(curr.right, stk)
                
        counter = collections.defaultdict(int)
        inorder_traversal(root1, functools.partial(add_counter, counter, ['+'], 1))
        inorder_traversal(root2, functools.partial(add_counter, counter, ['+'], -1))
        return all(v == 0 for v in counter.itervalues())

```



----------------------------------------------------------------------------------------

### Tree - 1649 - https://leetcode.com/problems/create-sorted-array-through-instructions/
Time: O(nlogn)  Space: O(n)   Hard
.Python/create-sorted-array-through-instructions.py


```python
# Time:  O(nlogm)
# Space: O(m)

class BIT(object):  # 0-indexed.
    def __init__(self, n):
        self.__bit = [0]*(n+1)  # Extra one for dummy node.

    def add(self, i, val):
        i += 1  # Extra one for dummy node.
        while i &lt; len(self.__bit):
            self.__bit[i] += val
            i += (i &amp; -i)

    def query(self, i):
        i += 1  # Extra one for dummy node.
        ret = 0
        while i &gt; 0:
            ret += self.__bit[i]
            i -= (i &amp; -i)
        return ret

class Solution(object):
    def createSortedArray(self, instructions):
        """
        :type instructions: List[int]
        :rtype: int
        """
        MOD = 10**9 + 7
        bit = BIT(max(instructions))
        result = 0
        for i, inst in enumerate(instructions):
            inst -= 1
            result += min(bit.query(inst-1), i-bit.query(inst))
            bit.add(inst, 1)
        return result % MOD


# Time:  O(nlogn)
# Space: O(n)
import itertools
class Solution_TLE(object):
    def createSortedArray(self, instructions):
        """
        :type instructions: List[int]
        :rtype: int
        """
        MOD = 10**9 + 7
        def smallerMergeSort(idxs, start, end, counts):
            if end - start &lt;= 0:  # The size of range [start, end] less than 2 is always with count 0.
                return 0

            mid = start + (end - start) // 2
            smallerMergeSort(idxs, start, mid, counts)
            smallerMergeSort(idxs, mid + 1, end, counts)
            r = start
            tmp = []
            for i in xrange(mid+1, end + 1):
                # Merge the two sorted arrays into tmp.
                while r &lt;= mid and idxs[r][0] &lt; idxs[i][0]:
                    tmp.append(idxs[r])
                    r += 1
                tmp.append(idxs[i])
                counts[idxs[i][1]] += r - start
            while r &lt;= mid:
                tmp.append(idxs[r])
                r += 1
            # Copy tmp back to idxs
            idxs[start:start+len(tmp)] = tmp
        
        def largerMergeSort(idxs, start, end, counts):
            if end - start &lt;= 0:  # The size of range [start, end] less than 2 is always with count 0.
                return 0

            mid = start + (end - start) // 2
            largerMergeSort(idxs, start, mid, counts)
            largerMergeSort(idxs, mid + 1, end, counts)
            r = start
            tmp = []
            for i in xrange(mid+1, end + 1):
                # Merge the two sorted arrays into tmp.
                while r &lt;= mid and idxs[r][0] &lt;= idxs[i][0]:
                    tmp.append(idxs[r])
                    r += 1
                if r &lt;= mid:
                    tmp.append(idxs[i])
                counts[idxs[i][1]] += mid - r + 1
            while r &lt;= mid:
                tmp.append(idxs[r])
                r += 1
            # Copy tmp back to idxs
            idxs[start:start+len(tmp)] = tmp

        idxs = []
        smaller_counts, larger_counts = [[0] * len(instructions) for _ in xrange(2)]
        for i, inst in enumerate(instructions):
            idxs.append((inst, i))
        smallerMergeSort(idxs[:], 0, len(idxs)-1, smaller_counts)
        largerMergeSort(idxs, 0, len(idxs)-1, larger_counts)
        return sum(min(s, l) for s, l in itertools.izip(smaller_counts, larger_counts)) % MOD

```



----------------------------------------------------------------------------------------

### Tree - 1666 - https://leetcode.com/problems/change-the-root-of-a-binary-tree/
Time: O(h)  Space: O(1)   Medium
.Python/change-the-root-of-a-binary-tree.py


```python
# Time:  O(h)
# Space: O(1)

# Definition for a Node.
class Node:
    def __init__(self, val):
        pass


class Solution(object):
    def flipBinaryTree(self, root, leaf):
        """
        :type node: Node
        :rtype: Node
        """
        curr, parent = leaf, None
        while True:
            child = curr.parent
            curr.parent = parent
            if curr.left == parent:
                curr.left = None
            else:
                curr.right = None
            if curr == root:
                break
            if curr.left:
                curr.right = curr.left
            curr.left = child
            curr, parent = child, curr
        return leaf

```



----------------------------------------------------------------------------------------

### Tree - 1834 - https://leetcode.com/problems/single-threaded-cpu/
Time: O(nlogn)  Space: O(n)   Medium
.Python/single-threaded-cpu.py


```python
# Time:  O(nlogn)
# Space: O(n)

import heapq


class Solution(object):
    def getOrder(self, tasks):
        """
        :type tasks: List[List[int]]
        :rtype: List[int]
        """
        idx = range(len(tasks))
        idx.sort(key=lambda x: tasks[x][0])
        result, min_heap = [], []
        i, time = 0, tasks[idx[0]][0]
        while i &lt; len(idx) or min_heap:
            while i &lt; len(idx) and tasks[idx[i]][0] &lt;= time:
                heapq.heappush(min_heap, (tasks[idx[i]][1], idx[i]))
                i += 1
            if not min_heap:
                time = tasks[idx[i]][0]
                continue
            t, j = heapq.heappop(min_heap)
            time += t
            result.append(j)
        return result

```



----------------------------------------------------------------------------------------

### Tree - 1938 - https://leetcode.com/problems/maximum-genetic-difference-query/
Time: O(nlogk + mlogk)  Space: O(n + logk)   Hard
.Python/maximum-genetic-difference-query.py


```python
# Time:  O(nlogk + mlogk), k is max(max(vals), n-1)
# Space: O(n + logk)

import collections


class Trie(object):
    def __init__(self, bit_count):
        self.__root = {}
        self.__bit_count = bit_count
        
    def insert(self, num, v):
        node = self.__root
        for i in reversed(xrange(self.__bit_count)):
            curr = (num&gt;&gt;i) &amp; 1
            new_node = node.setdefault(curr, collections.defaultdict(int))
            new_node["_cnt"] += v
            if not new_node["_cnt"]:
                del node[curr]
                break
            node = new_node
                
    def query(self, num):
        node, result = self.__root, 0
        for i in reversed(xrange(self.__bit_count)):
            curr = (num&gt;&gt;i) &amp; 1
            if 1^curr in node:
                node = node[1^curr]
                result |= 1&lt;
<i """="" #="" (node,="" +="" -1)="" 1)="" :rtype:="" :type="" __init__(self,="" adj="collections.defaultdict(list)" adj[-1][0])]="" adj[parent].append(node)="" bit_count):="" child="" child))="" class="" collections="" curr="(num" def="" elif="" else:="" enumerate(parents):="" enumerate(queries):="" for="" i="" i,="" if="" import="" in="" insert(self,="" is="" iter_dfs(adj,="" k="" list[int]="" list[list[int]]="" logk)="" max(max(vals),="" max_val="max(max_val," maxgeneticdifference(self,="" mlogk),="" n-1)="" node="self.__root" node))="" node,="" num,="" o(n="" o(nlogk="" parent="" parents,="" parents:="" qs="collections.defaultdict(list)" qs,="" qs[node].append((i,="" qs[node]:="" queries):="" queries:="" result="" result)="" result):="" result[i]="trie.query(val)" return="" reversed(adj[node]):="" reversed(xrange(self.__bit_count)):="" self.__bit_count="bit_count" self.__root="{}" solution(object):="" space:="" step="2:" step,="" stk="[(1," stk.append((1,="" stk.append((2,="" stk:="" time:="" trie(max_val.bit_length()),="" trie(object):="" trie,="" trie.insert(node,="" v):="" val="" val)="" val))="" while="">
 &gt;i) &amp; 1
            new_node = node.setdefault(curr, collections.defaultdict(int))
            new_node["_cnt"] += v
            if not new_node["_cnt"]:
                del node[curr]
                break
            node = new_node
                
    def query(self, num):
        node, result = self.__root, 0
        for i in reversed(xrange(self.__bit_count)):
            curr = (num&gt;&gt;i) &amp; 1
            if 1^curr in node:
                node = node[1^curr]
                result |= 1&lt;&lt;i
            else:
                node = node[curr]
        return result


class Solution2(object):
    def maxGeneticDifference(self, parents, queries):
        """
        :type parents: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        def dfs(adj, qs, node, trie, result):
            trie.insert(node, 1)
            for i, val in qs[node]:
                result[i] = trie.query(val)
            for child in adj[node]:
                dfs(adj, qs, child, trie, result)
            trie.insert(node, -1)

        adj = collections.defaultdict(list)
        for node, parent in enumerate(parents):
            adj[parent].append(node)
        qs = collections.defaultdict(list)
        max_val = len(parents)-1
        for i, (node, val) in enumerate(queries):
            qs[node].append((i, val))
            max_val = max(max_val, val)
        result = [0]*len(queries)
        dfs(adj, qs, adj[-1][0], Trie(max_val.bit_length()), result)
        return result
</i>
```



----------------------------------------------------------------------------------------

### Tree - 1948 - https://leetcode.com/problems/delete-duplicate-folders-in-system/
Time: O(n * m * l + tlogt + l * t)  Space: O(l * t)   Hard
.Python/delete-duplicate-folders-in-system.py


```python
# Time:  O(n * m * l + tlogt + l * t), m is the max number of folders in a path,
#                                    , n is the number of paths
#                                    , l is the max length of folder name
#                                    , t is the size of trie
# Space: O(l * t)

import collections


class Solution(object):
    def deleteDuplicateFolder(self, paths):
        """
        :type paths: List[List[str]]
        :rtype: List[List[str]]
        """
        def mark(node, lookup, node_ids):
            id_pairs = []
            for subfolder_id, child in node.iteritems():
                if child == "_del":
                    continue
                id_pairs.append((subfolder_id, mark(child, lookup, node_ids)))
            id_pairs.sort()
            node_id = node_ids[tuple(id_pairs)]
            if node_id:
                if node_id in lookup:
                    lookup[node_id]["_del"]
                    node["_del"]
                else:
                    lookup[node_id] = node
            return node_id

        def sweep(node, id_folders, path, result):
            if path:
                result.append([id_folders[i] for i in path])
            for subfolder_id, child in node.iteritems():
                if "_del" in child:
                    continue
                path.append(subfolder_id)
                sweep(child, id_folders, path, result)
                path.pop()

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        folder_ids = collections.defaultdict()
        folder_ids.default_factory = folder_ids.__len__
        id_folders = {}
        for path in paths:
            node = trie
            for folder in path:
                if folder_ids[folder] not in id_folders:
                    id_folders[folder_ids[folder]] = folder
                node = node[folder_ids[folder]]
        node_ids = collections.defaultdict()
        node_ids.default_factory = node_ids.__len__
        mark(trie, {}, node_ids)
        result = []
        sweep(trie, id_folders, [], result)
        return result


# Time:  O(n * m * l + l * tlogt + l * t^2), m is the max number of folders in a path,
#                                          , n is the number of paths
#                                          , l is the max length of folder name
#                                          , t is the size of trie
# Space: O(l * t^2)
import collections


class Solution2(object):
    def deleteDuplicateFolder(self, paths):
        """
        :type paths: List[List[str]]
        :rtype: List[List[str]]
        """
        def mark(node, lookup):
            serialized_tree = "(" + "".join(subfolder + mark(child, lookup) for subfolder, child in sorted(node.iteritems()) if child != "_del") + ")"
            if serialized_tree != "()":
                if serialized_tree in lookup:
                    lookup[serialized_tree]["_del"]
                    node["_del"]
                else:
                    lookup[serialized_tree] = node
            return serialized_tree
        
        def sweep(node, path, result):
            if path:
                result.append(path[:])
            for subfolder, child in node.iteritems():
                if "_del" in child:
                    continue
                path.append(subfolder)
                sweep(child, path, result)
                path.pop()

        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        for path in paths:
            reduce(dict.__getitem__, path, trie)
        mark(trie, {})
        result = []
        sweep(trie, [], result)
        return result

```



----------------------------------------------------------------------------------------

### Tree - 2003 - https://leetcode.com/problems/smallest-missing-genetic-value-in-each-subtree/
Time: O(n)  Space: O(n)   Hard
.Python/smallest-missing-genetic-value-in-each-subtree.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def smallestMissingValueSubtree(self, parents, nums):
        """
        :type parents: List[int]
        :type nums: List[int]
        :rtype: List[int]
        """
        def iter_dfs(adj, nums, i, lookup):
            stk = [i]
            while stk:
                i = stk.pop()
                if nums[i] in lookup:
                    continue
                lookup.add(nums[i])
                for j in adj[i]:
                    stk.append(j)

        result = [1]*len(parents)
        i = next((i for i in xrange(len(nums)) if nums[i] == 1), -1)
        if i == -1:
            return result
        adj = [[] for _ in xrange(len(parents))]
        for j in xrange(1, len(parents)):
            adj[parents[j]].append(j)
        lookup = set()
        miss = 1
        while i &gt;= 0:
            iter_dfs(adj, nums, i, lookup)
            while miss in lookup:
                miss += 1
            result[i] = miss
            i = parents[i]
        return result

```



----------------------------------------------------------------------------------------

### Tree - 2096 - https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/
Time: O(n)  Space: O(h)   Medium
.Python/step-by-step-directions-from-a-binary-tree-node-to-another.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def getDirections(self, root, startValue, destValue):
        """
        :type root: Optional[TreeNode]
        :type startValue: int
        :type destValue: int
        :rtype: str
        """
        def iter_dfs(root, val):
            path = []
            stk = [(1, (root,))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node = args[0]
                    if node.val == val:
                        path.reverse()
                        return path
                    for i, child in enumerate((node.left, node.right)):
                        if not child:
                            continue
                        stk.append((3, None))
                        stk.append((1, (child,)))
                        stk.append((2, ("LR"[i],)))
                elif step == 2:
                    path.append(args[0])
                elif step == 3:
                    path.pop()
            return []
    
        src = iter_dfs(root, startValue)
        dst = iter_dfs(root, destValue)
        while len(src) and len(dst) and src[-1] == dst[-1]:
            src.pop()
            dst.pop()
        dst.reverse()
        return "".join(['U']*len(src) + dst)


# Time:  O(n)
# Space: O(h)
class Solution2(object):
    def getDirections(self, root, startValue, destValue):
        """
        :type root: Optional[TreeNode]
        :type startValue: int
        :type destValue: int
        :rtype: str
        """
        def dfs(node, val, path):
            if node.val == val:
                return True
            if node.left and dfs(node.left, val, path):
                path.append('L')
            elif node.right and dfs(node.right, val, path):
                path.append('R')
            return path

        src, dst = [], []
        dfs(root, startValue, src)
        dfs(root, destValue, dst)
        while len(src) and len(dst) and src[-1] == dst[-1]:
            src.pop()
            dst.pop()
        dst.reverse()
        return "".join(['U']*len(src) + dst)

```



----------------------------------------------------------------------------------------

### Tree - 2179 - https://leetcode.com/problems/count-good-triplets-in-an-array/
Time: O(nlogn)  Space: O(n)   Hard
.Python/count-good-triplets-in-an-array.py


```python
# Time:  O(nlogn)
# Space: O(n)

class BIT(object):  # 0-indexed.
    def __init__(self, n):
        self.__bit = [0]*(n+1)  # Extra one for dummy node.

    def add(self, i, val):
        i += 1  # Extra one for dummy node.
        while i &lt; len(self.__bit):
            self.__bit[i] += val
            i += (i &amp; -i)

    def query(self, i):
        i += 1  # Extra one for dummy node.
        ret = 0
        while i &gt; 0:
            ret += self.__bit[i]
            i -= (i &amp; -i)
        return ret


# bit, fenwick tree, combinatorics
class Solution(object):
    def goodTriplets(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        lookup = [0]*len(nums1)
        for i, x in enumerate(nums1):
            lookup[x] = i
        result = 0
        bit = BIT(len(nums1))
        for i, x in enumerate(nums2):
            smaller = bit.query(lookup[x]-1)
            larger = (len(nums1)-(lookup[x]+1))-(i-smaller)
            result += smaller*larger
            bit.add(lookup[x], 1)
        return result

```



----------------------------------------------------------------------------------------

### Tree - 2196 - https://leetcode.com/problems/create-binary-tree-from-descriptions/
Time: O(n)  Space: O(n)   Medium
.Python/create-binary-tree-from-descriptions.py


```python
# Time:  O(n)
# Space: O(n)

# tree
class Solution(object):
    def createBinaryTree(self, descriptions):
        """
        :type descriptions: List[List[int]]
        :rtype: Optional[TreeNode]
        """
        nodes = {}
        children = set()
        for p, c, l in descriptions:
            parent = nodes.setdefault(p, TreeNode(p))
            child = nodes.setdefault(c, TreeNode(c))
            if l:
                parent.left = child
            else:
                parent.right = child
            children.add(c)
        return nodes[next(p for p in nodes.iterkeys() if p not in children)]

```



----------------------------------------------------------------------------------------

### Tree - 2236 - https://leetcode.com/problems/root-equals-sum-of-children/
Time: O(1)  Space: O(1)   Easy
.Python/root-equals-sum-of-children.py


```python
# Time:  O(1)
# Space: O(1)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


# tree
class Solution(object):
    def checkTree(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        return root.val == root.left.val+root.right.val

```



----------------------------------------------------------------------------------------

### Tree - 2277 - https://leetcode.com/problems/closest-node-to-path-in-tree/
Time: O(n + q)  Space: O(n)   Hard
.Python/closest-node-to-path-in-tree.py


```python
# Time:  O(n + q)
# Space: O(n)

import collections
from functools import partial


# Template:
# https://github.com/kamyu104/GoogleKickStart-2021/blob/main/Round%20H/dependent_events3.py
# Tarjan's Offline LCA Algorithm
class UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n
        self.ancestor = range(n)  # added

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] &gt; self.rank[y]:  # union by rank
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True

    def find_ancestor_of_set(self, x):  # added
        return self.ancestor[self.find_set(x)]

    def update_ancestor_of_set(self, x):  # added
        self.ancestor[self.find_set(x)] = x


class TreeInfos(object):  # Time: O(N), Space: O(N + Q), N is the number of nodes
    def __init__(self, children, pairs):
        def preprocess(curr, parent):
            # depth of the node i
            D[curr] = 1 if parent == -1 else D[parent]+1

        def divide(curr, parent):
            stk.append(partial(postprocess, curr))
            for i in reversed(xrange(len(children[curr]))):
                child = children[curr][i]
                if child == parent:
                    continue
                stk.append(partial(conquer, child, curr))
                stk.append(partial(divide, child, curr))
            stk.append(partial(preprocess, curr, parent))

        def conquer(curr, parent):
            uf.union_set(curr, parent)
            uf.update_ancestor_of_set(parent)

        def postprocess(u):
            lookup[u] = True
            for v in pairs[u]:
                if not lookup[v]:
                    continue
                lca[min(u, v), max(u, v)] = uf.find_ancestor_of_set(v)

        N = len(children)
        D, uf, lca = [0]*N, UnionFind(N), {}
        stk, lookup = [], [False]*N
        stk.append(partial(divide, 0, -1))
        while stk:
            stk.pop()()
        self.D, self.lca = D, lca


# Tarjan's Offline LCA Algorithm
class Solution(object):
    def closestNode(self, n, edges, query):
        """
        :type n: int
        :type edges: List[List[int]]
        :type query: List[List[int]]
        :rtype: List[int]
        """
        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v), adj[v].append(u)
        pairs = collections.defaultdict(set)
        for start, end, node in query:
            pairs[start].add(end), pairs[end].add(start)
            pairs[start].add(node), pairs[node].add(start)
            pairs[end].add(node), pairs[node].add(end)
        tree_infos = TreeInfos(adj, pairs)
        return [max((tree_infos.lca[min(x, y), max(x, y)] for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query]


# Time:  O(nlogn + qlogn)
# Space: O(nlogn)
from functools import partial


# Template:
# https://github.com/kamyu104/GoogleKickStart-2021/blob/main/Round%20H/dependent_events2.py
class TreeInfos2(object):  # Time: O(NlogN), Space: O(NlogN), N is the number of nodes
    def __init__(self, children):  # modified
        def preprocess(curr, parent):
            # depth of the node i
            D[curr] = 1 if parent == -1 else D[parent]+1
            # ancestors of the node i
            if parent != -1:
                P[curr].append(parent)
            i = 0
            while i &lt; len(P[curr]) and i &lt; len(P[P[curr][i]]):
                P[curr].append(P[P[curr][i]][i])
                i += 1
            # the subtree of the node i is represented by traversal index L[i]..R[i]
            C[0] += 1
            L[curr] = C[0]

        def divide(curr, parent):
            stk.append(partial(postprocess, curr))
            for i in reversed(xrange(len(children[curr]))):
                child = children[curr][i]
                if child == parent:
                    continue
                stk.append(partial(divide, child, curr))
            stk.append(partial(preprocess, curr, parent))

        def postprocess(curr):
            R[curr] = C[0]

        N = len(children)
        L, R, D, P, C = [0]*N, [0]*N, [0]*N, [[] for _ in xrange(N)], [-1]
        stk = []
        stk.append(partial(divide, 0, -1))
        while stk:
            stk.pop()()
        assert(C[0] == N-1)
        self.L, self.R, self.D, self.P = L, R, D, P

    # Template:
    # https://github.com/kamyu104/FacebookHackerCup-2019/blob/master/Final%20Round/little_boat_on_the_sea.py
    def is_ancestor(self, a, b):  # includes itself
        return self.L[a] &lt;= self.L[b] &lt;= self.R[b] &lt;= self.R[a]

    def lca(self, a, b):
        if self.D[a] &gt; self.D[b]:
            a, b = b, a
        if self.is_ancestor(a, b):
            return a
        for i in reversed(xrange(len(self.P[a]))):  # O(logN)
            if i &lt; len(self.P[a]) and not self.is_ancestor(self.P[a][i], b):
                a = self.P[a][i]
        return self.P[a][0]


# binary lifting (online lca algorithm)
class Solution2(object):
    def closestNode(self, n, edges, query):
        """
        :type n: int
        :type edges: List[List[int]]
        :type query: List[List[int]]
        :rtype: List[int]
        """
        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v), adj[v].append(u)
        tree_infos = TreeInfos2(adj)
        return [max((tree_infos.lca(x, y) for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query]


# Time:  O(n + q * h)
# Space: O(n)
from functools import partial


# Template:
# https://github.com/kamyu104/GoogleKickStart-2021/blob/main/Round%20H/dependent_events2.py
class TreeInfos3(object):  # Time: O(N), Space: O(N), N is the number of nodes
    def __init__(self, children):  # modified
        def preprocess(curr, parent):
            # depth of the node i
            D[curr] = 1 if parent == -1 else D[parent]+1
            # ancestors of the node i
            P[curr] = parent

        def divide(curr, parent):
            for i in reversed(xrange(len(children[curr]))):
                child = children[curr][i]
                if child == parent:
                    continue
                stk.append(partial(divide, child, curr))
            stk.append(partial(preprocess, curr, parent))

        N = len(children)
        D, P = [0]*N, [0]*N
        stk = []
        stk.append(partial(divide, 0, -1))
        while stk:
            stk.pop()()
        self.D, self.P = D, P

    def lca(self, a, b):  # Time: O(logh)
        while self.D[a] &gt; self.D[b]:
            a = self.P[a]
        while self.D[a] &lt; self.D[b]:
            b = self.P[b]
        while a != b:
            a, b = self.P[a], self.P[b]
        return a


# lca
class Solution3(object):
    def closestNode(self, n, edges, query):
        """
        :type n: int
        :type edges: List[List[int]]
        :type query: List[List[int]]
        :rtype: List[int]
        """
        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v), adj[v].append(u)
        tree_infos = TreeInfos3(adj)
        return [max((tree_infos.lca(x, y) for x, y in ((start, end), (start, node), (end, node))), key=lambda x: tree_infos.D[x]) for start, end, node in query]


# Time:  O(n^2 + q * n)
# Space: O(n^2)
# bfs
class Solution4(object):
    def closestNode(self, n, edges, query):
        """
        :type n: int
        :type edges: List[List[int]]
        :type query: List[List[int]]
        :rtype: List[int]
        """
        def bfs(adj, root):
            dist = [len(adj)]*len(adj)
            q = [root]
            dist[root] = 0
            d = 0
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if d+1 &gt;= dist[v]:
                            continue
                        dist[v] = d+1
                        new_q.append(v)
                q = new_q
                d += 1
            return dist

        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v), adj[v].append(u)
        dist = [bfs(adj, i) for i in xrange(n)]
        result = []
        for start, end, node in query:
            x = end
            while start != end:
                if dist[node][start] &lt; dist[node][x]:
                    x = start
                start = next(u for u in adj[start] if dist[u][end] &lt; dist[start][end])
            result.append(x)
        return result


# Time:  O(n^2 + q * n)
# Space: O(n^2)
# bfs
class Solution5(object):
    def closestNode(self, n, edges, query):
        """
        :type n: int
        :type edges: List[List[int]]
        :type query: List[List[int]]
        :rtype: List[int]
        """
        def bfs(adj, root):
            dist = [len(adj)]*len(adj)
            q = [root]
            dist[root] = 0
            d = 0
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if d+1 &gt;= dist[v]:
                            continue
                        dist[v] = d+1
                        new_q.append(v)
                q = new_q
                d += 1
            return dist

        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v), adj[v].append(u)
        dist = [bfs(adj, i) for i in xrange(n)]
        return [max((i for i in xrange(n) if dist[start][node]+dist[node][end]-2*dist[node][i] == dist[start][i]+dist[i][end]), key=lambda x: dist[node][x]) for start, end, node in query]

```



----------------------------------------------------------------------------------------

### Hash Table - 1001 - https://leetcode.com/problems/grid-illumination/
Time: O(l + q)  Space: O(l)   Hard
.Python/grid-illumination.py


```python
# Time:  O(l + q)
# Space: O(l)

import collections


class Solution(object):
    def gridIllumination(self, N, lamps, queries):
        """
        :type N: int
        :type lamps: List[List[int]]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        lookup = set()
        row = collections.defaultdict(int)
        col = collections.defaultdict(int)
        diag = collections.defaultdict(int)
        anti = collections.defaultdict(int)
        
        for r, c in lamps:
            if (r, c) in lookup:
                continue
            lookup.add((r, c))
            row[r] += 1
            col[c] += 1
            diag[r-c] += 1
            anti[r+c] += 1
        
        result = []
        for r, c in queries:
            if not (row[r] or col[c] or diag[r-c] or anti[r+c]):
                result.append(0)
                continue
            result.append(1)                
            for nr in xrange(max(r-1, 0), min(r+1, N-1)+1):
                for nc in xrange(max(c-1, 0), min(c+1, N-1)+1):
                    if (nr, nc) not in lookup:
                        continue
                    lookup.remove((nr, nc))
                    row[nr] -= 1
                    col[nc] -= 1
                    diag[nr-nc] -= 1
                    anti[nr+nc] -= 1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1124 - https://leetcode.com/problems/longest-well-performing-interval/
Time: O(n)  Space: O(n)   Medium
.Python/longest-well-performing-interval.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def longestWPI(self, hours):
        """
        :type hours: List[int]
        :rtype: int
        """
        result, accu = 0, 0
        lookup = {}
        for i, h in enumerate(hours):
            accu = accu+1 if h &gt; 8 else accu-1
            if accu &gt; 0:
                result = i+1
            elif accu-1 in lookup:
                # lookup[accu-1] is the leftmost idx with smaller accu,
                # because for i from 1 to some positive k,
                # lookup[accu-i] is a strickly increasing sequence
                result = max(result, i-lookup[accu-1])
            lookup.setdefault(accu, i)
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1133 - https://leetcode.com/problems/largest-unique-number/
Time: O(n)  Space: O(n)   Easy
.Python/largest-unique-number.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def largestUniqueNumber(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        A.append(-1)
        return max(k for k,v in collections.Counter(A).items() if v == 1)

```



----------------------------------------------------------------------------------------

### Hash Table - 1152 - https://leetcode.com/problems/analyze-user-website-visit-pattern/
Time: O(n^3)  Space: O(n^3)   Medium
.Python/analyze-user-website-visit-pattern.py


```python
# Time:  O(n^3)
# Space: O(n^3)

import collections
import itertools


class Solution(object):
    def mostVisitedPattern(self, username, timestamp, website):
        """
        :type username: List[str]
        :type timestamp: List[int]
        :type website: List[str]
        :rtype: List[str]
        """
        lookup = collections.defaultdict(list)
        A = zip(timestamp, username, website)
        A.sort()
        for t, u, w in A:
            lookup[u].append(w)
        count = sum([collections.Counter(set(itertools.combinations(lookup[u], 3))) for u in lookup], collections.Counter())
        return list(min(count, key=lambda x: (-count[x], x)))

```



----------------------------------------------------------------------------------------

### Hash Table - 1153 - https://leetcode.com/problems/string-transforms-into-another-string/
Time: O(n)  Space: O(1)   Hard
.Python/string-transforms-into-another-string.py


```python
# Time:  O(n)
# Space: O(1)

import itertools


class Solution(object):
    def canConvert(self, str1, str2):
        """
        :type str1: str
        :type str2: str
        :rtype: bool
        """
        if str1 == str2:
            return True
        lookup = {}
        for i, j in itertools.izip(str1, str2):
            if lookup.setdefault(i, j) != j:
                return False
        return len(set(str2)) &lt; 26

```



----------------------------------------------------------------------------------------

### Hash Table - 1160 - https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/
Time: O(m * n)  Space: O(1)   Easy
.Python/find-words-that-can-be-formed-by-characters.py


```python
# Time:  O(m * n), m is the length of chars, n is the number of words
# Space: O(1)

import collections


class Solution(object):
    def countCharacters(self, words, chars):
        """
        :type words: List[str]
        :type chars: str
        :rtype: int
        """
        def check(word, chars, count):
            if len(word) &gt; len(chars):
                return False
            curr_count = collections.Counter()
            for c in word:
                curr_count[c] += 1
                if c not in count or count[c] &lt; curr_count[c]:
                    return False
            return True
        
        count = collections.Counter(chars)
        return sum(len(word) for word in words if check(word, chars, count))

```



----------------------------------------------------------------------------------------

### Hash Table - 1165 - https://leetcode.com/problems/single-row-keyboard/
Time: O(n)  Space: O(1)   Easy
.Python/single-row-keyboard.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def calculateTime(self, keyboard, word):
        """
        :type keyboard: str
        :type word: str
        :rtype: int
        """
        lookup = {c:i for i, c in enumerate(keyboard)}
        result, prev = 0, 0
        for c in word:
            result += abs(lookup[c]-prev)
            prev = lookup[c]
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1198 - https://leetcode.com/problems/find-smallest-common-element-in-all-rows/
Time: O(m * n)  Space: O(n)   Medium
.Python/find-smallest-common-element-in-all-rows.py


```python
# Time:  O(m * n)
# Space: O(n)

class Solution(object):
    def smallestCommonElement(self, mat):
        """
        :type mat: List[List[int]]
        :rtype: int
        """
        # values could be duplicated in each row
        intersections = set(mat[0])
        for i in xrange(1, len(mat)):
            intersections &amp;= set(mat[i])
            if not intersections:
                return -1
        return min(intersections)


# Time:  O(m * n)
# Space: O(n)
import collections


class Solution2(object):
    def smallestCommonElement(self, mat):
        """
        :type mat: List[List[int]]
        :rtype: int
        """
        # assumed value is unique in each row
        counter = collections.Counter()
        for row in mat:
            for c in row:
                counter[c] += 1
                if counter[c] == len(mat):
                    return c
        return -1

```



----------------------------------------------------------------------------------------

### Hash Table - 1207 - https://leetcode.com/problems/unique-number-of-occurrences/
Time: O(n)  Space: O(n)   Easy
.Python/unique-number-of-occurrences.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def uniqueOccurrences(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        count = collections.Counter(arr)
        lookup = set()
        for v in count.itervalues():
            if v in lookup:
                return False
            lookup.add(v)
        return True


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def uniqueOccurrences(self, arr):
        """
        :type arr: List[int]
        :rtype: bool
        """
        count = collections.Counter(arr)
        return len(count) == len(set(count.itervalues()))

```



----------------------------------------------------------------------------------------

### Hash Table - 1224 - https://leetcode.com/problems/maximum-equal-frequency/
Time: O(n)  Space: O(n)   Hard
.Python/maximum-equal-frequency.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def maxEqualFreq(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = 0
        count = collections.Counter()
        freq = [0 for _ in xrange(len(nums)+1)]
        for i, n in enumerate(nums, 1):
            freq[count[n]] -= 1
            freq[count[n]+1] += 1
            count[n] += 1
            c = count[n]
            if freq[c]*c == i and i &lt; len(nums):
                result = i+1
            remain = i-freq[c]*c
            if freq[remain] == 1 and remain in [1, c+1]:
                result = i
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1418 - https://leetcode.com/problems/display-table-of-food-orders-in-a-restaurant/
Time: O(n + tlogt + flogf)  Space: O(n)   Medium
.Python/display-table-of-food-orders-in-a-restaurant.py


```python
# Time:  O(n + tlogt + flogf)
# Space: O(n)

import collections


class Solution(object):
    def displayTable(self, orders):
        """
        :type orders: List[List[str]]
        :rtype: List[List[str]]
        """
        table_count = collections.defaultdict(collections.Counter)
        for _, table, food in orders:
            table_count[int(table)][food] += 1
        foods = sorted({food for _, _, food in orders})
        result = [["Table"]]
        result[0].extend(foods)
        for table in sorted(table_count):
            result.append([str(table)])
            result[-1].extend(str(table_count[table][food]) for food in foods)
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1452 - https://leetcode.com/problems/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list/
Time: O(n * m * l + n^2 * m)  Space: O(n * m * l)   Medium
.Python/people-whose-list-of-favorite-companies-is-not-a-subset-of-another-list.py


```python
# Time:  O(n * m * l + n^2 * m), n is favoriteCompanies.length
#                              , m is the max of favoriteCompanies[i].length
#                              , l is the max of favoriteCompanies[i][j].length
# Space: O(n * m * l)

class Solution(object):
    def peopleIndexes(self, favoriteCompanies):
        """
        :type favoriteCompanies: List[List[str]]
        :rtype: List[int]
        """
        lookup, comps = {}, []
        for cs in favoriteCompanies:
            comps.append(set())
            for c in cs:
                if c not in lookup:
                    lookup[c] = len(lookup)
                comps[-1].add(lookup[c])
        return [i for i, c1 in enumerate(comps)
                if not any(i != j and len(c1) &lt; len(c2) and c1 &lt; c2
                           for j, c2 in enumerate(comps))]
    


# Time:  O(n * m * l + n^2 * m * log*(n)), n is favoriteCompanies.length
#                                        , m is the max of favoriteCompanies[i].length
#                                        , l is the max of favoriteCompanies[i][j].length
# Space: O(n * m * l)
class UnionFind(object):
    def __init__(self, data):
        self.data = [set(d) for d in data]
        self.set = range(len(data))

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return
        if len(self.data[x_root]) &gt; len(self.data[y_root]) and \
           self.data[x_root] &gt; self.data[y_root]:
            self.set[y_root] = x_root
        elif len(self.data[x_root]) &lt; len(self.data[y_root]) and \
           self.data[x_root] &lt; self.data[y_root]:
            self.set[x_root] = y_root


class Solution2(object):
    def peopleIndexes(self, favoriteCompanies):
        """
        :type favoriteCompanies: List[List[str]]
        :rtype: List[int]
        """
        lookup, comps = {}, []
        for cs in favoriteCompanies:
            comps.append(set())
            for c in cs:
                if c not in lookup:
                    lookup[c] = len(lookup)
                comps[-1].add(lookup[c])
        union_find = UnionFind(comps)
        for i in xrange(len(comps)):
            for j in xrange(len(comps)):
                if j == i:
                    continue
                union_find.union_set(i, j)
        return [x for i, x in enumerate(union_find.set) if x == i]

```



----------------------------------------------------------------------------------------

### Hash Table - 1487 - https://leetcode.com/problems/making-file-names-unique/
Time: O(n)  Space: O(n)   Medium
.Python/making-file-names-unique.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def getFolderNames(self, names):
        """
        :type names: List[str]
        :rtype: List[str]
        """
        count = collections.Counter()
        result, lookup = [], set()
        for name in names:
            while True:
                name_with_suffix = "{}({})".format(name, count[name]) if count[name] else name
                count[name] += 1
                if name_with_suffix not in lookup:
                    break
            result.append(name_with_suffix)
            lookup.add(name_with_suffix)
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1577 - https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/
Time: O(m * n)  Space: O(m + n)   Medium
.Python/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers.py


```python
# Time:  O(m * n)
# Space: O(m + n)

import collections


class Solution(object):
    def numTriplets(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        def two_product(nums, i):
            count = 0
            lookup = collections.defaultdict(int)
            for num in nums:
                if i%num:
                    continue
                count += lookup[i//num]
                lookup[num] += 1
            return count
        
        result = 0
        for num in nums1:
            result += two_product(nums2, num**2)
        for num in nums2:
            result += two_product(nums1, num**2)
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1590 - https://leetcode.com/problems/make-sum-divisible-by-p/
Time: O(n)  Space: O(p)   Medium
.Python/make-sum-divisible-by-p.py


```python
# Time:  O(n)
# Space: O(p)

class Solution(object):
    def minSubarray(self, nums, p):
        """
        :type nums: List[int]
        :type p: int
        :rtype: int
        """
        residue = sum(nums) % p
        if not residue:
            return 0
        result = len(nums)
        curr, lookup = 0, {0: -1}
        for i, num in enumerate(nums):
            curr = (curr+num) % p
            lookup[curr] = i
            if (curr-residue) % p in lookup:
                result = min(result, i-lookup[(curr-residue)%p])
        return result if result &lt; len(nums) else -1

```



----------------------------------------------------------------------------------------

### Hash Table - 1640 - https://leetcode.com/problems/check-array-formation-through-concatenation/
Time: O(n)  Space: O(n)   Easy
.Python/check-array-formation-through-concatenation.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def canFormArray(self, arr, pieces):
        """
        :type arr: List[int]
        :type pieces: List[List[int]]
        :rtype: bool
        """
        lookup = {x[0]: i for i, x in enumerate(pieces)}
        i = 0
        while i &lt; len(arr): 
            if arr[i] not in lookup:
                return False
            for c in pieces[lookup[arr[i]]]:
                if i == len(arr) or arr[i] != c:
                    return False
                i += 1
        return True

```



----------------------------------------------------------------------------------------

### Hash Table - 1657 - https://leetcode.com/problems/determine-if-two-strings-are-close/
Time: O(n)  Space: O(1)   Medium
.Python/determine-if-two-strings-are-close.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def closeStrings(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: bool
        """
        if len(word1) != len(word2):
            return False 
        
        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)   # Reuse of keys
        return set(cnt1.iterkeys()) == set(cnt2.iterkeys()) and \
               collections.Counter(cnt1.itervalues()) == collections.Counter(cnt2.itervalues())

```



----------------------------------------------------------------------------------------

### Hash Table - 1679 - https://leetcode.com/problems/max-number-of-k-sum-pairs/
Time: O(n)  Space: O(n)   Medium
.Python/max-number-of-k-sum-pairs.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def maxOperations(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        count = collections.Counter()
        result = 0
        for x in nums:
            if k-x in count and count[k-x]:
                count[k-x] -= 1
                result += 1
            else:
                count[x] += 1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1711 - https://leetcode.com/problems/count-good-meals/
Time: O(n)  Space: O(1)   Medium
.Python/count-good-meals.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def countPairs(self, deliciousness):
        """
        :type deliciousness: List[int]
        :rtype: int
        """
        def floor_log2_x(x):
            return x.bit_length()-1

        MOD = 10**9+7
        max_pow = floor_log2_x(max(deliciousness))+1
        cnt = collections.Counter()
        result = 0
        for d in deliciousness:
            p = 1
            for i in xrange(max_pow+1):
                result = (result+cnt[p-d])%MOD
                p &lt;&lt;= 1
            cnt[d] += 1    
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1748 - https://leetcode.com/problems/sum-of-unique-elements/
Time: O(n)  Space: O(n)   Easy
.Python/sum-of-unique-elements.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def sumOfUnique(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return sum(x for x, c in collections.Counter(nums).iteritems() if c == 1)

```



----------------------------------------------------------------------------------------

### Hash Table - 1781 - https://leetcode.com/problems/sum-of-beauty-of-all-substrings/
Time: O(n^2)  Space: O(1)   Medium
.Python/sum-of-beauty-of-all-substrings.py


```python
# Time:  O(n^2)
# Space: O(1)

class Solution(object):
    def beautySum(self, s):
        """
        :type s: str
        :rtype: int
        """
        result = 0 
        for i in xrange(len(s)):
            lookup = [0]*26
            for j in xrange(i, len(s)):
                lookup[ord(s[j])-ord('a')] += 1
                result += max(lookup) - min(x for x in lookup if x)
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1807 - https://leetcode.com/problems/evaluate-the-bracket-pairs-of-a-string/
Time: O(n + m)  Space: O(n + m)   Medium
.Python/evaluate-the-bracket-pairs-of-a-string.py


```python
# Time:  O(n + m)
# Space: O(n + m)

class Solution(object):
    def evaluate(self, s, knowledge):
        """
        :type s: str
        :type knowledge: List[List[str]]
        :rtype: str
        """
        lookup = {k: v for k, v in knowledge}
        result, curr = [], []
        has_pair = False
        for c in s:
            if c == '(':
                has_pair = True
            elif c == ')':
                has_pair = False
                result.append(lookup.get("".join(curr), '?'))
                curr = []
            elif has_pair:
                curr.append(c)
            else:
                result.append(c)
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Hash Table - 1814 - https://leetcode.com/problems/count-nice-pairs-in-an-array/
Time: O(nlogm)  Space: O(n)   Medium
.Python/count-nice-pairs-in-an-array.py


```python
# Time:  O(nlogm), m is max of nums
# Space: O(n)

import collections


class Solution(object):
    def countNicePairs(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        MOD = 10**9 + 7

        def rev(x):
            result = 0
            while x:
                x, r = divmod(x, 10)
                result = result*10+r
            return result
        
        result = 0
        lookup = collections.defaultdict(int)
        for num in nums:
            result = (result + lookup[num-rev(num)])%MOD
            lookup[num-rev(num)] += 1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1817 - https://leetcode.com/problems/finding-the-users-active-minutes/
Time: O(n)  Space: O(n)   Medium
.Python/finding-the-users-active-minutes.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def findingUsersActiveMinutes(self, logs, k):
        """
        :type logs: List[List[int]]
        :type k: int
        :rtype: List[int]
        """
        lookup = collections.defaultdict(set)
        for u, t in logs:
            lookup[u].add(t)
        result = [0]*k
        for _, ts in lookup.iteritems():
            result[len(ts)-1] += 1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1915 - https://leetcode.com/problems/number-of-wonderful-substrings/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-wonderful-substrings.py


```python
# Time:  O(n)
# Space: O(2^10)

class Solution(object):
    def wonderfulSubstrings(self, word):
        """
        :type word: str
        :rtype: int
        """
        ALPHABET_SIZE = 10
        count = [0]*(2**ALPHABET_SIZE)
        count[0] = 1
        result = curr = 0
        for c in word:
            curr ^= 1&lt;&lt;(ord(c)-ord('a'))
            result += count[curr]
            result += sum(count[curr^(1&lt;&lt;i)] for i in xrange(ALPHABET_SIZE))
            count[curr] += 1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1923 - https://leetcode.com/problems/longest-common-subpath/
Time: O(m * nlogn)  Space: O(n)   Hard
.Python/longest-common-subpath.py


```python
# Time:  O(m * nlogn)
# Space: O(n)

class Solution(object):
    def longestCommonSubpath(self, n, paths):
        """
        :type n: int
        :type paths: List[List[int]]
        :rtype: int
        """
        def RabinKarp(arr, x):  # double hashing
            hashes = tuple([reduce(lambda h,x: (h*p+x)%MOD, (arr[i] for i in xrange(x)), 0) for p in P])
            powers = [pow(p, x, MOD) for p in P]
            lookup = {hashes}
            for i in xrange(x, len(arr)):
                hashes = tuple([(hashes[j]*P[j] - arr[i-x]*powers[j] + arr[i])%MOD for j in xrange(len(P))])  # in smaller datasets, tuple from list is much faster than tuple from generator, see https://stackoverflow.com/questions/16940293/why-is-there-no-tuple-comprehension-in-python
                lookup.add(hashes)
            return lookup
        
        def check(paths, x):
            intersect = RabinKarp(paths[0], x)
            for i in xrange(1, len(paths)):
                intersect = set.intersection(intersect, RabinKarp(paths[i], x))
                if not intersect:
                    return False
            return True

        MOD, P = 10**9+7, (113, 109)  # MOD could be the min prime of 7-digit number (10**6+3), P could be (2, 3)
        left, right = 1, min(len(p) for p in paths)
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(paths, mid):
                right = mid-1
            else:
                left = mid+1
        return right


# Time:  O(m * nlogn)
# Space: O(n)
class Solution2(object):
    def longestCommonSubpath(self, n, paths):
        """
        :type n: int
        :type paths: List[List[int]]
        :rtype: int
        """
        def RabinKarp(arr, x):
            h = reduce(lambda h,x: (h*P+x)%MOD, (arr[i] for i in xrange(x)), 0)
            power = pow(P, x, MOD)
            lookup = {h}
            for i in xrange(x, len(arr)):
                h = (h*P - arr[i-x]*power + arr[i])%MOD
                lookup.add(h)
            return lookup
        
        def check(paths, x):
            intersect = RabinKarp(paths[0], x)
            for i in xrange(1, len(paths)):
                intersect = set.intersection(intersect, RabinKarp(paths[i], x))
                if not intersect:
                    return False
            return True

        MOD, P = 10**11+19, max(x for p in paths for x in p)+1  # MOD is the min prime of 12-digit number
        left, right = 1, min(len(p) for p in paths)
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(paths, mid):
                right = mid-1
            else:
                left = mid+1
        return right

```



----------------------------------------------------------------------------------------

### Hash Table - 1925 - https://leetcode.com/problems/count-square-sum-triples/
Time: O(n^2)  Space: O(n)   Easy
.Python/count-square-sum-triples.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def countTriples(self, n):
        """
        :type n: int
        :rtype: int
        """
        lookup = set()
        for i in xrange(1, n+1):
            lookup.add(i**2)
        result = 0
        for i in xrange(1, n+1):
            for j in xrange(1, n+1):
                result += int(i**2+j**2 in lookup)
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 1930 - https://leetcode.com/problems/unique-length-3-palindromic-subsequences/
Time: O(n)  Space: O(1)   Medium
.Python/unique-length-3-palindromic-subsequences.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countPalindromicSubsequence(self, s):
        """
        :type s: str
        :rtype: int
        """
        first, last = [len(s)]*26, [-1]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        return sum(len(set(s[i] for i in xrange(first[c]+1, last[c]))) for c in xrange(26))

```



----------------------------------------------------------------------------------------

### Hash Table - 1941 - https://leetcode.com/problems/check-if-all-characters-have-equal-number-of-occurrences/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-all-characters-have-equal-number-of-occurrences.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def areOccurrencesEqual(self, s):
        """
        :type s: str
        :rtype: bool
        """
        return len(set(collections.Counter(s).itervalues())) == 1

```



----------------------------------------------------------------------------------------

### Hash Table - 1995 - https://leetcode.com/problems/count-special-quadruplets/
Time: O(n^3)  Space: O(n)   Easy
.Python/count-special-quadruplets.py


```python
# Time:  O(n^3)
# Space: O(n)

import collections


class Solution(object):
    def countQuadruplets(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = 0
        lookup = collections.defaultdict(int)
        lookup[nums[-1]] = 1
        for c in reversed(xrange(2, len(nums)-1)):
            for b in xrange(1, c):
                for a in xrange(b):
                    if nums[a]+nums[b]+nums[c] in lookup:
                        result += lookup[nums[a]+nums[b]+nums[c]]
            lookup[nums[c]] += 1
        return result

    
# Time:  O(n^2) ~ O(n^4)
# Space: O(n^2)
import collections


class Solution2(object):
    def countQuadruplets(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        lookup = collections.defaultdict(list)
        for d in xrange(3, len(nums)):
            for c in xrange(2, d):
                lookup[nums[d]-nums[c]].append(c)
        return sum(sum(b &lt; c for c in lookup[nums[a]+nums[b]]) for b in xrange(1, len(nums)-2) for a in xrange(b))

```



----------------------------------------------------------------------------------------

### Hash Table - 2006 - https://leetcode.com/problems/count-number-of-pairs-with-absolute-difference-k/
Time: O(n)  Space: O(n)   Easy
.Python/count-number-of-pairs-with-absolute-difference-k.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def countKDifference(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        lookup = collections.defaultdict(int)
        result = 0
        for x in nums:
            if x-k in lookup:
                result += lookup[x-k]
            if x+k in lookup:
                result += lookup[x+k]
            lookup[x] += 1            
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2023 - https://leetcode.com/problems/number-of-pairs-of-strings-with-concatenation-equal-to-target/
Time: O(n * l)  Space: O(n)   Medium
.Python/number-of-pairs-of-strings-with-concatenation-equal-to-target.py


```python
# Time:  O(n * l), n is the size of nums, l is the average length of the digit string in nums
# Space: O(n)

import collections


class Solution(object):
    def numOfPairs(self, nums, target):
        """
        :type nums: List[str]
        :type target: str
        :rtype: int
        """
        lookup = collections.Counter()
        result = 0
        for num in nums:
            cnt1, cnt2 = lookup[-(len(target)-len(num))], lookup[len(target)-len(num)]
            if target.startswith(num):
                result += cnt1
                lookup[len(num)] += 1
            if target.endswith(num):
                result += cnt2
                lookup[-len(num)] += 1
        return result


# Time:  O(n * l), n is the size of nums, l is the average length of the digit string in nums
# Space: O(n)
import collections


class Solution2(object):
    def numOfPairs(self, nums, target):
        """
        :type nums: List[str]
        :type target: str
        :rtype: int
        """
        prefix, suffix = collections.Counter(), collections.Counter()
        result = 0
        for num in nums:
            if target.startswith(num):
                result += suffix[len(target)-len(num)]
            if target.endswith(num):
                result += prefix[len(target)-len(num)]
            if target.startswith(num):
                prefix[len(num)] += 1
            if target.endswith(num):
                suffix[len(num)] += 1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2025 - https://leetcode.com/problems/maximum-number-of-ways-to-partition-an-array/
Time: O(n)  Space: O(n)   Hard
.Python/maximum-number-of-ways-to-partition-an-array.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def waysToPartition(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        total = sum(nums)
        right = collections.Counter()
        prefix = 0
        for i in xrange(len(nums)-1):
            prefix += nums[i]
            right[prefix-(total-prefix)] += 1
        result = right[0]
        left = collections.Counter()
        prefix = 0
        for x in nums:
            result = max(result, left[k-x]+right[-(k-x)])
            prefix += x
            left[prefix-(total-prefix)] += 1
            right[prefix-(total-prefix)] -= 1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2032 - https://leetcode.com/problems/two-out-of-three/
Time: O(n)  Space: O(min(n, r))   Easy
.Python/two-out-of-three.py


```python
# Time:  O(n)
# Space: O(min(n, r)), r is the range size of nums

import collections


class Solution(object):
    def twoOutOfThree(self, nums1, nums2, nums3):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :type nums3: List[int]
        :rtype: List[int]
        """
        K = 2
        cnt = collections.Counter()
        for nums in nums1, nums2, nums3:
            cnt.update(set(nums))
        return [x for x, c in cnt.iteritems() if c &gt;= K]


# Time:  O(n)
# Space: O(min(n, r)), r is the range size of nums
import collections


class Solution2(object):
    def twoOutOfThree(self, nums1, nums2, nums3):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :type nums3: List[int]
        :rtype: List[int]
        """
        K = 2
        cnt = collections.Counter()
        result = []
        for nums in nums1, nums2, nums3:
            for x in set(nums):
                cnt[x] += 1
                if cnt[x] == K:
                    result.append(x)
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2053 - https://leetcode.com/problems/kth-distinct-string-in-an-array/
Time: O(n)  Space: O(n)   Easy
.Python/kth-distinct-string-in-an-array.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def kthDistinct(self, arr, k):
        """
        :type arr: List[str]
        :type k: int
        :rtype: str
        """
        count = collections.Counter(arr)
        arr = [x for x in arr if count[x] == 1]
        return arr[k-1] if k-1 &lt; len(arr) else ""

```



----------------------------------------------------------------------------------------

### Hash Table - 2068 - https://leetcode.com/problems/check-whether-two-strings-are-almost-equivalent/
Time: O(n)  Space: O(1)   Easy
.Python/check-whether-two-strings-are-almost-equivalent.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def checkAlmostEquivalent(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: bool
        """
        k = 3
        cnt1, cnt2 = collections.Counter(word1), collections.Counter(word2)
        return all(abs(cnt1[c]-cnt2[c]) &lt;= k for c in set(cnt1.keys()+cnt2.keys()))

```



----------------------------------------------------------------------------------------

### Hash Table - 2085 - https://leetcode.com/problems/count-common-words-with-one-occurrence/
Time: O(m + n)  Space: O(m + n)   Easy
.Python/count-common-words-with-one-occurrence.py


```python
# Time:  O(m + n)
# Space: O(m + n)

import collections


class Solution(object):
    def countWords(self, words1, words2):
        """
        :type words1: List[str]
        :type words2: List[str]
        :rtype: int
        """
        cnt = collections.Counter(words1)
        for c in words2:
            if cnt[c] &lt; 2:
                cnt[c] -= 1
        return sum(v == 0 for v in cnt.itervalues())

```



----------------------------------------------------------------------------------------

### Hash Table - 2120 - https://leetcode.com/problems/execution-of-all-suffix-instructions-staying-in-a-grid/
Time: O(m)  Space: O(m)   Medium
.Python/execution-of-all-suffix-instructions-staying-in-a-grid.py


```python
# Time:  O(m)
# Space: O(m)

import collections


class Solution(object):
    def executeInstructions(self, n, startPos, s):
        """
        :type n: int
        :type startPos: List[int]
        :type s: str
        :rtype: List[int]
        """
        directions = {'U':(-1, 0), 'R':(0, 1), 'D':(1, 0), 'L':(0, -1)}
        (x0, y0), (x, y) = startPos, (0, 0)
        result = range(len(s), 0, -1)
        lookup_x = collections.defaultdict(list)
        lookup_y = collections.defaultdict(list)
        lookup_x[x0-x].append(0)
        lookup_y[y0-y].append(0)
        for i, d in enumerate(s):
            dx, dy = directions[d]
            x, y = x+dx, y+dy
            for k in n-x, -x-1:
                if k not in lookup_x:
                    continue
                for j in lookup_x[k]:
                    result[j] = min(result[j], i-j)
                lookup_x[k] = []
            for k in n-y, -y-1:
                if k not in lookup_y:
                    continue
                for j in lookup_y[k]:
                    result[j] = min(result[j], i-j)
                lookup_y[k] = []
            lookup_x[x0-x].append(i+1)
            lookup_y[y0-y].append(i+1)
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2150 - https://leetcode.com/problems/find-all-lonely-numbers-in-the-array/
Time: O(n)  Space: O(n)   Medium
.Python/find-all-lonely-numbers-in-the-array.py


```python
# Time:  O(n)
# Space: O(n)

# freq table
class Solution(object):
    def findLonely(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        cnt = collections.Counter(nums)
        return [x for x in nums if cnt[x] == 1 and x-1 not in cnt and x+1 not in cnt]

```



----------------------------------------------------------------------------------------

### Hash Table - 2154 - https://leetcode.com/problems/keep-multiplying-found-values-by-two/
Time: O(n)  Space: O(n)   Easy
.Python/keep-multiplying-found-values-by-two.py


```python
# Time:  O(n)
# Space: O(n)

# hash table
class Solution(object):
    def findFinalValue(self, nums, original):
        """
        :type nums: List[int]
        :type original: int
        :rtype: int
        """
        lookup = set(nums)
        while original in lookup:
            original *= 2
        return original

```



----------------------------------------------------------------------------------------

### Hash Table - 2170 - https://leetcode.com/problems/minimum-operations-to-make-the-array-alternating/
Time: O(n)  Space: O(n)   Medium
.Python/minimum-operations-to-make-the-array-alternating.py


```python
# Time:  O(n)
# Space: O(n)
import collections


# freq table
class Solution(object):
    def minimumOperations(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        even_top = collections.Counter(nums[i] for i in xrange(0, len(nums), 2)).most_common(2)  # Time: O(nlogk)
        odd_top = collections.Counter(nums[i] for i in xrange(1, len(nums), 2)).most_common(2)  # Time: O(nlogk)
        if not odd_top or even_top[0][0] != odd_top[0][0]:
            return len(nums)-even_top[0][1]-(odd_top[0][1] if odd_top else 0)
        return min(len(nums)-even_top[0][1]-(odd_top[1][1] if len(odd_top) == 2 else 0),
                   len(nums)-odd_top[0][1]-(even_top[1][1] if len(even_top) == 2 else 0))

```



----------------------------------------------------------------------------------------

### Hash Table - 2190 - https://leetcode.com/problems/most-frequent-number-following-key-in-an-array/
Time: O(n)  Space: O(n)   Easy
.Python/most-frequent-number-following-key-in-an-array.py


```python
# Time:  O(n)
# Space: O(n)

import collections


# freq table
class Solution(object):
    def mostFrequent(self, nums, key):
        """
        :type nums: List[int]
        :type key: int
        :rtype: int
        """
        return collections.Counter(nums[i+1] for i in xrange(len(nums)-1) if nums[i] == key).most_common(1)[0][0]

```



----------------------------------------------------------------------------------------

### Hash Table - 2201 - https://leetcode.com/problems/count-artifacts-that-can-be-extracted/
Time: O(a + d)  Space: O(d)   Medium
.Python/count-artifacts-that-can-be-extracted.py


```python
# Time:  O(a + d), a is the number of grids covered by artifacts, d is the size of dig
# Space: O(d)

# hash table
class Solution(object):
    def digArtifacts(self, n, artifacts, dig):
        """
        :type n: int
        :type artifacts: List[List[int]]
        :type dig: List[List[int]]
        :rtype: int
        """
        lookup = set(map(tuple, dig))
        return sum(all((i, j) in lookup for i in xrange(r1, r2+1) for j in xrange(c1, c2+1)) for r1, c1, r2, c2 in artifacts)
    

# Time:  O(a + d), a is the number of grids covered by artifacts, d is the size of dig
# Space: O(a)
# hash table
class Solution2(object):
    def digArtifacts(self, n, artifacts, dig):
        """
        :type n: int
        :type artifacts: List[List[int]]
        :type dig: List[List[int]]
        :rtype: int
        """
        lookup = {(i, j):idx for idx, (r1, c1, r2, c2) in enumerate(artifacts) for i in xrange(r1, r2+1) for j in xrange(c1, c2+1)}
        cnt = [(r2-r1+1)*(c2-c1+1) for r1, c1, r2, c2 in artifacts]
        result = 0
        for i, j in dig:
            if (i, j) not in lookup:
                continue
            cnt[lookup[i, j]] -= 1
            if not cnt[lookup[i, j]]:
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2206 - https://leetcode.com/problems/divide-array-into-equal-pairs/
Time: O(n)  Space: O(n)   Easy
.Python/divide-array-into-equal-pairs.py


```python
# Time:  O(n)
# Space: O(n)

import collections


# freq table
class Solution(object):
    def divideArray(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        return all(cnt%2 == 0 for cnt in collections.Counter(nums).itervalues())

```



----------------------------------------------------------------------------------------

### Hash Table - 2215 - https://leetcode.com/problems/find-the-difference-of-two-arrays/
Time: O(n)  Space: O(n)   Easy
.Python/find-the-difference-of-two-arrays.py


```python
# Time:  O(n)
# Space: O(n)

# hash table
class Solution(object):
    def findDifference(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: List[List[int]]
        """
        lookup = [set(nums1), set(nums2)]
        return [list(lookup[0]-lookup[1]), list(lookup[1]-lookup[0])]

```



----------------------------------------------------------------------------------------

### Hash Table - 2225 - https://leetcode.com/problems/find-players-with-zero-or-one-losses/
Time: O(nlogn)  Space: O(n)   Medium
.Python/find-players-with-zero-or-one-losses.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


# hash, sort
class Solution(object):
    def findWinners(self, matches):
        """
        :type matches: List[List[int]]
        :rtype: List[List[int]]
        """
        lose = collections.defaultdict(int)
        players_set = set()
        for x, y in matches:
            lose[y] += 1
            players_set.add(x)
            players_set.add(y)
        return [[x for x in sorted(players_set) if lose[x] == i] for i in xrange(2)]

```



----------------------------------------------------------------------------------------

### Hash Table - 2229 - https://leetcode.com/problems/check-if-an-array-is-consecutive/
Time: O(n)  Space: O(n)   Easy
.Python/check-if-an-array-is-consecutive.py


```python
# Time:  O(n)
# Space: O(n)

# hash table
class Solution(object):
    def isConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        return max(nums)-min(nums)+1 == len(nums) == len(set(nums))


# Time:  O(nlogn)
# Space: O(1)
# sort
class Solution2(object):
    def isConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        nums.sort()
        return all(nums[i]+1 == nums[i+1] for i in xrange(len(nums)-1))

```



----------------------------------------------------------------------------------------

### Hash Table - 2260 - https://leetcode.com/problems/minimum-consecutive-cards-to-pick-up/
Time: O(n)  Space: O(n)   Medium
.Python/minimum-consecutive-cards-to-pick-up.py


```python
# Time:  O(n)
# Space: O(n)

# hash table
class Solution(object):
    def minimumCardPickup(self, cards):
        """
        :type cards: List[int]
        :rtype: int
        """
        lookup = {}
        result = float("inf")
        for i, x in enumerate(cards):
            if x in lookup:
                result = min(result, i-lookup[x]+1)
            lookup[x] = i
        return result if result != float("inf") else -1

```



----------------------------------------------------------------------------------------

### Hash Table - 2261 - https://leetcode.com/problems/k-divisible-elements-subarrays/
Time: O(n^2)  Space: O(t)   Medium
.Python/k-divisible-elements-subarrays.py


```python
# Time:  O(n^2)
# Space: O(t), t is the size of trie

# trie
class Solution(object):
    def countDistinct(self, nums, k, p):
        """
        :type nums: List[int]
        :type k: int
        :type p: int
        :rtype: int
        """
        _trie = lambda: collections.defaultdict(_trie)
        trie = _trie()
        result = 0
        for i in xrange(len(nums)):
            cnt = 0
            curr = trie
            for j in xrange(i, len(nums)):
                cnt += (nums[j]%p == 0)
                if cnt &gt; k:
                    break
                if nums[j] not in curr:
                    result += 1
                curr = curr[nums[j]]
        return result


# Time:  O(n^2) on average, worst is O(n^3)
# Space: O(n)
import collections


# rolling hash
class Solution2(object):
    def countDistinct(self, nums, k, p):
        """
        :type nums: List[int]
        :type k: int
        :type p: int
        :rtype: int
        """
        MOD, P = 10**9+7, 113
        def check(nums, lookup, l, i):
            return all(any(nums[i+k] != nums[j+k] for k in xrange(l)) for j in lookup)

        result = 0
        cnt, h = [0]*len(nums), [0]*len(nums)
        for l in xrange(1, len(nums)+1):
            lookup = collections.defaultdict(list)
            for i in xrange(len(nums)-l+1):
                cnt[i] += (nums[i+l-1]%p == 0)
                if cnt[i] &gt; k:
                    continue
                h[i] = (h[i]*P+nums[i+l-1])%MOD
                if not check(nums, lookup[h[i]], l, i):
                    continue
                lookup[h[i]].append(i)
                result += 1
        return result


# Time:  O(n^2)
# Space: O(n)
# rolling hash
class Solution3(object):
    def countDistinct(self, nums, k, p):
        """
        :type nums: List[int]
        :type k: int
        :type p: int
        :rtype: int
        """
        MOD, P = 10**9+7, 200
        result = 0
        cnt, h = [0]*len(nums), [0]*len(nums)
        for l in xrange(1, len(nums)+1):
            lookup = set()
            for i in xrange(len(nums)-l+1):
                cnt[i] += (nums[i+l-1]%p == 0)
                if cnt[i] &gt; k:
                    continue
                h[i] = (h[i]*P+nums[i+l-1])%MOD
                lookup.add(h[i])
            result += len(lookup)
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2283 - https://leetcode.com/problems/check-if-number-has-equal-digit-count-and-digit-value/
Time: O(n)  Space: O(1)   Easy
.Python/check-if-number-has-equal-digit-count-and-digit-value.py


```python
# Time:  O(n)
# Space: O(1)

import collections


# freq table
class Solution(object):
    def digitCount(self, num):
        """
        :type num: str
        :rtype: bool
        """
        cnt = collections.Counter(num)
        return all(cnt[str(i)] == int(x) for i, x in enumerate(num))

```



----------------------------------------------------------------------------------------

### Hash Table - 2284 - https://leetcode.com/problems/sender-with-largest-word-count/
Time: O(n * l)  Space: O(n)   Medium
.Python/sender-with-largest-word-count.py


```python
# Time:  O(n * l)
# Space: O(n)

import collections
import itertools


# freq table
class Solution(object):
    def largestWordCount(self, messages, senders):
        """
        :type messages: List[str]
        :type senders: List[str]
        :rtype: str
        """
        cnt = collections.Counter()
        for m, s in itertools.izip(messages, senders):
            cnt[s] += m.count(' ')+1
        return max((k for k in cnt.iterkeys()), key=lambda x: (cnt[x], x))

```



----------------------------------------------------------------------------------------

### Hash Table - 2287 - https://leetcode.com/problems/rearrange-characters-to-make-target-string/
Time: O(n + m)  Space: O(1)   Easy
.Python/rearrange-characters-to-make-target-string.py


```python
# Time:  O(n + m)
# Space: O(1)

import collections


# freq table
class Solution(object):
    def rearrangeCharacters(self, s, target):
        """
        :type s: str
        :type target: str
        :rtype: int
        """
        cnt1 = collections.Counter(s)
        cnt2 = collections.Counter(target)
        return min(cnt1[k]//v for k, v in cnt2.iteritems())

```



----------------------------------------------------------------------------------------

### Hash Table - 2295 - https://leetcode.com/problems/replace-elements-in-an-array/
Time: O(n + m)  Space: O(n)   Medium
.Python/replace-elements-in-an-array.py


```python
# Time:  O(n + m)
# Space: O(n)

# hash table, optimized from solution2
class Solution(object):
    def arrayChange(self, nums, operations):
        """
        :type nums: List[int]
        :type operations: List[List[int]]
        :rtype: List[int]
        """
        lookup = {x:i for i, x in enumerate(nums)}
        for x, y in operations:
            lookup[y] = lookup.pop(x)
        for x, i in lookup.iteritems():
            nums[i] = x
        return nums


# Time:  O(n + m)
# Space: O(n)
# hash table
class Solution2(object):
    def arrayChange(self, nums, operations):
        """
        :type nums: List[int]
        :type operations: List[List[int]]
        :rtype: List[int]
        """
        lookup = {x:i for i, x in enumerate(nums)}
        for x, y in operations:
            nums[lookup[x]] = y
            lookup[y] = lookup.pop(x)
        return nums

```



----------------------------------------------------------------------------------------

### Hash Table - 2306 - https://leetcode.com/problems/naming-a-company/
Time: O(26 * n * l)  Space: O(n * l)   Hard
.Python/naming-a-company.py


```python
# Time:  O(26 * n * l)
# Space: O(n * l)

# hash table, math
class Solution(object):
    def distinctNames(self, ideas):
        """
        :type ideas: List[str]
        :rtype: int
        """
        lookup = [set() for _ in xrange(26)]
        for x in ideas:
            lookup[ord(x[0])-ord('a')].add(x[1:])
        result = 0
        for i in xrange(len(lookup)):
            for j in xrange(i+1, len(lookup)):
                common = len(lookup[i]&amp;lookup[j])
                result += (len(lookup[i])-common)*(len(lookup[j])-common)
        return result*2

```



----------------------------------------------------------------------------------------

### Hash Table - 2309 - https://leetcode.com/problems/greatest-english-letter-in-upper-and-lower-case/
Time: O(n)  Space: O(1)   Easy
.Python/greatest-english-letter-in-upper-and-lower-case.py


```python
# Time:  O(n)
# Space: O(1)

# string, hash table
class Solution(object):
    def greatestLetter(self, s):
        """
        :type s: str
        :rtype: str
        """
        lookup = set(s)
        result = ""
        for c in s:
            if c.isupper() and lower(c) in s:
                if c &gt; result:
                    result = c
        return result


# Time:  O(n)
# Space: O(1)
import itertools
import string


# string, hash table
class Solution2(object):
    def greatestLetter(self, s):
        """
        :type s: str
        :rtype: str
        """
        lookup = set(s)
        return next((C for c, C in itertools.izip(reversed(string.ascii_lowercase), reversed(string.ascii_uppercase)) if c in lookup and C in lookup), "")

```



----------------------------------------------------------------------------------------

### Hash Table - 2325 - https://leetcode.com/problems/decode-the-message/
Time: O(n + m)  Space: O(1)   Easy
.Python/decode-the-message.py


```python
# Time:  O(n + m)
# Space: O(1)

import itertools


# string, hash table
class Solution(object):
    def decodeMessage(self, key, message):
        """
        :type key: str
        :type message: str
        :rtype: str
        """
        f = lambda x: ord(x)-ord('a')
        lookup = [-1]*26
        i = 0
        for x in itertools.imap(f, key):
            if x &lt; 0 or lookup[x] != -1:
                continue
            lookup[x] = i
            i += 1
        return "".join(itertools.imap(lambda x: chr(ord('a')+x), (lookup[x] if x &gt;= 0 else x for x in itertools.imap(f, message))))

```



----------------------------------------------------------------------------------------

### Hash Table - 2341 - https://leetcode.com/problems/maximum-number-of-pairs-in-array/
Time: O(n)  Space: O(r)   Easy
.Python/maximum-number-of-pairs-in-array.py


```python
# Time:  O(n)
# Space: O(r), r = max(nums)

# freq table
class Solution(object):
    def numberOfPairs(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        cnt = [0]*(max(nums)+1)
        pair_cnt = 0
        for x in nums:
            cnt[x] ^= 1
            if not cnt[x]:
                pair_cnt += 1
        return [pair_cnt, len(nums)-2*pair_cnt]


# Time:  O(n)
# Space: O(r), r = max(nums)
import collections


# freq table
class Solution2(object):
    def numberOfPairs(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        cnt = collections.Counter(nums);
        pair_cnt = sum(x//2 for x in cnt.itervalues())
        return [pair_cnt, len(nums)-2*pair_cnt]

```



----------------------------------------------------------------------------------------

### Hash Table - 2342 - https://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/
Time: O(nlogr)  Space: O(n)   Medium
.Python/max-sum-of-a-pair-with-equal-sum-of-digits.py


```python
# Time:  O(nlogr), r is max(nums)
# Space: O(n)

# greedy
class Solution(object):
    def maximumSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def sum_digits(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result

        lookup = {}
        result = -1
        for x in nums:
            k = sum_digits(x)
            if k not in lookup:
                lookup[k] = x
                continue
            result = max(result, lookup[k]+x)
            if x &gt; lookup[k]:
                lookup[k] = x
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2347 - https://leetcode.com/problems/best-poker-hand/
Time: O(1)  Space: O(1)   Easy
.Python/best-poker-hand.py


```python
# Time:  O(1)
# Space: O(1)

# freq table
class Solution(object):
    def bestHand(self, ranks, suits):
        """
        :type ranks: List[int]
        :type suits: List[str]
        :rtype: str
        """
        LOOKUP = ["", "High Card", "Pair", "Three of a Kind", "Three of a Kind", "Three of a Kind"]
        if all(suits[i] == suits[0] for i in xrange(1, len(suits))):
            return "Flush"
        cnt = [0]*13
        for x in ranks:
            cnt[x-1] += 1
        return LOOKUP[max(cnt)]

```



----------------------------------------------------------------------------------------

### Hash Table - 2351 - https://leetcode.com/problems/first-letter-to-appear-twice/
Time: O(n)  Space: O(1)   Easy
.Python/first-letter-to-appear-twice.py


```python
# Time:  O(n)
# Space: O(1)

# hash table
class Solution(object):
    def repeatedCharacter(self, s):
        """
        :type s: str
        :rtype: str
        """
        lookup = set()
        for c in s:
            if c in lookup:
                break
            lookup.add(c)
        return c

```



----------------------------------------------------------------------------------------

### Hash Table - 2352 - https://leetcode.com/problems/equal-row-and-column-pairs/
Time: O(n^2)  Space: O(n^2)   Medium
.Python/equal-row-and-column-pairs.py


```python
# Time:  O(n^2)
# Space: O(n^2)

import collections
import itertools


# hash table
class Solution(object):
    def equalPairs(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        cnt1 = collections.Counter(tuple(row) for row in grid)
        cnt2 = collections.Counter(tuple(col) for col in itertools.izip(*grid))
        return sum(cnt1[k]*cnt2[k] for k in cnt1.iterkeys() if k in cnt2)

```



----------------------------------------------------------------------------------------

### Hash Table - 2354 - https://leetcode.com/problems/number-of-excellent-pairs/
Time: O(n)  Space: O(n)   Hard
.Python/number-of-excellent-pairs.py


```python
# Time:  O(n + (logn)^2) = O(n)
# Space: O(n + logn) = O(n)

import collections


# bit manipulation, freq table, combinatorics
class Solution(object):
    def countExcellentPairs(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def popcount(x):
            return bin(x)[2:].count('1')

        cnt = collections.Counter(popcount(x) for x in set(nums))
        return sum(cnt[i]*cnt[j] for i in cnt.iterkeys() for j in cnt.iterkeys() if i+j &gt;= k)


# Time:  O(nlogn)
# Space: O(n)
# bit manipulation, sort, two pointers
class Solution2(object):
    def countExcellentPairs(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def popcount(x):
            return bin(x)[2:].count('1')

        sorted_cnts = sorted(popcount(x) for x in set(nums))
        result = 0
        left, right = 0, len(sorted_cnts)-1
        while left &lt;= right:
            if sorted_cnts[left]+sorted_cnts[right] &lt; k:
                left += 1
            else:
                result += 1+2*((right-1)-left+1)
                right -= 1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2357 - https://leetcode.com/problems/make-array-zero-by-subtracting-equal-amounts/
Time: O(n)  Space: O(n)   Easy
.Python/make-array-zero-by-subtracting-equal-amounts.py


```python
# Time:  O(n)
# Space: O(n)

# hash table
class Solution(object):
    def minimumOperations(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return len({x for x in nums if x})

```



----------------------------------------------------------------------------------------

### Hash Table - 2363 - https://leetcode.com/problems/merge-similar-items/
Time: O((m + n) * log(m + n))  Space: O(m + n)   Easy
.Python/merge-similar-items.py


```python
# Time:  O((m + n) * log(m + n))
# Space: O(m + n)

# freq table, sort
class Solution(object):
    def mergeSimilarItems(self, items1, items2):
        """
        :type items1: List[List[int]]
        :type items2: List[List[int]]
        :rtype: List[List[int]]
        """
        return sorted((Counter(dict(items1))+Counter(dict(items2))).iteritems())

```



----------------------------------------------------------------------------------------

### Hash Table - 2364 - https://leetcode.com/problems/count-number-of-bad-pairs/
Time: O(n)  Space: O(n)   Medium
.Python/count-number-of-bad-pairs.py


```python
# Time:  O(n)
# Space: O(n)

import collections


# freq table
class Solution(object):
    def countBadPairs(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = len(nums)*(len(nums)-1)//2
        cnt = collections.Counter()
        for i, x in enumerate(nums):
            result -= cnt[x-i]
            cnt[x-i] += 1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2365 - https://leetcode.com/problems/task-scheduler-ii/
Time: O(n)  Space: O(n)   Medium
.Python/task-scheduler-ii.py


```python
# Time:  O(n)
# Space: O(n)

import collections


# hash table
class Solution(object):
    def taskSchedulerII(self, tasks, space):
        """
        :type tasks: List[int]
        :type space: int
        :rtype: int
        """
        lookup = collections.defaultdict(int)
        result = 0
        for t in tasks:
            result = max(lookup[t], result+1)
            lookup[t] = result+space+1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2367 - https://leetcode.com/problems/number-of-arithmetic-triplets/
Time: O(n)  Space: O(n)   Easy
.Python/number-of-arithmetic-triplets.py


```python
# Time:  O(n)
# Space: O(n)

# hash table
class Solution(object):
    def arithmeticTriplets(self, nums, diff):
        """
        :type nums: List[int]
        :type diff: int
        :rtype: int
        """
        lookup = set(nums)
        return sum((x-diff in lookup) and (x-2*diff in lookup) for x in nums)

    
# Time:  O(n)
# Space: O(n)
import collections


# dp
class Solution2(object):
    def arithmeticTriplets(self, nums, diff):
        """
        :type nums: List[int]
        :type diff: int
        :rtype: int
        """
        result = 0
        cnt1 = collections.Counter()
        cnt2 = collections.Counter()
        for x in nums:
            result += cnt2[x-diff]
            cnt2[x] += cnt1[x-diff]
            cnt1[x] += 1
        return result

```



----------------------------------------------------------------------------------------

### Hash Table - 2374 - https://leetcode.com/problems/node-with-highest-edge-score/
Time: O(n)  Space: O(n)   Medium
.Python/node-with-highest-edge-score.py


```python
# Time:  O(n)
# Space: O(n)

# freq table
class Solution(object):
    def edgeScore(self, edges):
        """
        :type edges: List[int]
        :rtype: int
        """
        score = [0]*len(edges)
        for u, v in enumerate(edges):
            score[v] += u
        return max(xrange(len(edges)), key=lambda x:score[x])

```



----------------------------------------------------------------------------------------

### Math - 1006 - https://leetcode.com/problems/clumsy-factorial/
Time: O(1)  Space: O(1)   Medium
.Python/clumsy-factorial.py


```python
# Time:  O(1)
# Space: O(1)

# observation:
# i*(i-1)/(i-2) = i+1+2/(i-2)
#     if i = 3  =&gt; i*(i-1)/(i-2) = i + 3
#     if i = 4  =&gt; i*(i-1)/(i-2) = i + 2
#     if i &gt;= 5 =&gt; i*(i-1)/(i-2) = i + 1
#
# clumsy(N):
#     if N = 1 =&gt; N
#     if N = 2 =&gt; N
#     if N = 3 =&gt; N + 3
#     if N = 4 =&gt; N + 2 + 1 = N + 3
#     if N &gt; 4 and N % 4 == 1 =&gt; N + 1 + (... = 0) + 2 - 1           = N + 2
#     if N &gt; 4 and N % 4 == 2 =&gt; N + 1 + (... = 0) + 3 - 2 * 1       = N + 2
#     if N &gt; 4 and N % 4 == 3 =&gt; N + 1 + (... = 0) + 4 - 3 * 2 / 1   = N - 1
#     if N &gt; 4 and N % 4 == 0 =&gt; N + 1 + (... = 0) + 5 - (4*3/2) + 1 = N + 1

class Solution(object):
    def clumsy(self, N):
        """
        :type N: int
        :rtype: int
        """
        if N &lt;= 2:
            return N
        if N &lt;= 4:
            return N+3
        
        if N % 4 == 0:
            return N+1
        elif N % 4 &lt;= 2:
            return N+2
        return N-1

```



----------------------------------------------------------------------------------------

### Math - 1009 - https://leetcode.com/problems/complement-of-base-10-integer/
Time: O(logn)  Space: O(1)   Easy
.Python/complement-of-base-10-integer.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def bitwiseComplement(self, N):
        """
        :type N: int
        :rtype: int
        """
        mask = 1
        while N &gt; mask:
            mask = mask*2+1
        return mask-N

```



----------------------------------------------------------------------------------------

### Math - 1012 - https://leetcode.com/problems/numbers-with-repeated-digits/
Time: O(logn)  Space: O(logn)   Hard
.Python/numbers-with-repeated-digits.py


```python
# Time:  O(logn)
# Space: O(logn)

class Solution(object):
    def numDupDigitsAtMostN(self, N):
        """
        :type N: int
        :rtype: int
        """
        def P(m, n):
            result = 1
            for _ in xrange(n):
                result *= m
                m -= 1
            return result

        digits = map(int, str(N+1))
        result = 0

        # Given 321
        #
        # 1. count numbers without repeated digits:
        # - X
        # - XX
        for i in xrange(1, len(digits)):
            result += P(9, 1)*P(9, i-1)
        
        # 2. count numbers without repeated digits:
        # - 1XX ~ 3XX
        # - 30X ~ 32X
        # - 320 ~ 321
        prefix_set = set()
        for i, x in enumerate(digits):
            for y in xrange(1 if i == 0 else 0, x):
                if y in prefix_set:
                    continue
                result += P(9-i, len(digits)-i-1)
            if x in prefix_set:
                break
            prefix_set.add(x)
        return N-result

```



----------------------------------------------------------------------------------------

### Math - 1015 - https://leetcode.com/problems/smallest-integer-divisible-by-k/
Time: O(k)  Space: O(1)   Medium
.Python/smallest-integer-divisible-by-k.py


```python
# Time:  O(k)
# Space: O(1)

class Solution(object):
    def smallestRepunitDivByK(self, K):
        """
        :type K: int
        :rtype: int
        """
        # by observation, K % 2 = 0 or K % 5 = 0, it is impossible
        if K % 2 == 0 or K % 5 == 0:
            return -1

        # let f(N) is a N-length integer only containing digit 1
        # if there is no N in range (1..K) s.t. f(N) % K = 0
        # =&gt; there must be K remainders of f(N) % K in range (1..K-1) excluding 0
        # =&gt; due to pigeonhole principle, there must be at least 2 same remainders
        # =&gt; there must be some x, y in range (1..K) and x &gt; y s.t. f(x) % K = f(y) % K
        # =&gt; (f(x) - f(y)) % K = 0
        # =&gt; (f(x-y) * 10^y) % K = 0
        # =&gt; due to (x-y) in range (1..K)
        # =&gt; f(x-y) % K != 0
        # =&gt; 10^y % K = 0
        # =&gt; K % 2 = 0 or K % 5 = 0
        # =&gt; -&gt;&lt;-
        # it proves that there must be some N in range (1..K) s.t. f(N) % K = 0
        result = 0
        for N in xrange(1, K+1):
            result = (result*10+1) % K
            if not result:
                return N
        assert(False)
        return -1  # never reach

```



----------------------------------------------------------------------------------------

### Math - 1017 - https://leetcode.com/problems/convert-to-base-2/
Time: O(logn)  Space: O(1)   Medium
.Python/convert-to-base-2.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def baseNeg2(self, N):
        """
        :type N: int
        :rtype: str
        """
        result = []
        while N:
            result.append(str(-N &amp; 1))  # N % -2
            N = -(N &gt;&gt; 1)  # N //= -2
        result.reverse()
        return "".join(result) if result else "0"


# Time:  O(logn)
# Space: O(1)
class Solution2(object):
    def baseNeg2(self, N):
        """
        :type N: int
        :rtype: str
        """
        BASE = -2
        result = []
        while N:
            N, r = divmod(N, BASE)
            if r &lt; 0:
                r -= BASE
                N += 1
            result.append(str(r))
        result.reverse()
        return "".join(result) if result else "0"

```



----------------------------------------------------------------------------------------

### Math - 1025 - https://leetcode.com/problems/divisor-game/
Time: O(1)  Space: O(1)   Easy
.Python/divisor-game.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def divisorGame(self, N):
        """
        :type N: int
        :rtype: bool
        """
        # 1. if we get an even, we can choose x = 1
        #    to make the opponent always get an odd
        # 2. if the opponent gets an odd, he can only choose x = 1 or other odds
        #    and we can still get an even
        # 3. at the end, the opponent can only choose x = 1 and we win
        # 4. in summary, we win if only if we get an even and 
        #    keeps even until the opponent loses
        return N % 2 == 0


# Time:  O(n^3/2)
# Space: O(n)
# dp solution
class Solution2(object):
    def divisorGame(self, N):
        """
        :type N: int
        :rtype: bool
        """
        def memoization(N, dp):
            if N == 1:
                return False
            if N not in dp:
                result = False
                for i in xrange(1, N+1):
                    if i*i &gt; N:
                        break
                    if N % i == 0:
                        if not memoization(N-i, dp):
                            result = True
                            break
                dp[N] = result
            return dp[N]
        
        return memoization(N, {})

```



----------------------------------------------------------------------------------------

### Math - 1037 - https://leetcode.com/problems/valid-boomerang/
Time: O(1)  Space: O(1)   Easy
.Python/valid-boomerang.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def isBoomerang(self, points):
        """
        :type points: List[List[int]]
        :rtype: bool
        """
        return (points[0][0] - points[1][0]) * (points[0][1] - points[2][1]) - \
               (points[0][0] - points[2][0]) * (points[0][1] - points[1][1]) != 0

```



----------------------------------------------------------------------------------------

### Math - 1041 - https://leetcode.com/problems/robot-bounded-in-circle/
Time: O(n)  Space: O(1)   Medium
.Python/robot-bounded-in-circle.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def isRobotBounded(self, instructions):
        """
        :type instructions: str
        :rtype: bool
        """
        directions = [[ 1, 0], [0, -1], [-1, 0], [0, 1]]
        x, y, i = 0, 0, 0
        for instruction in instructions:
            if instruction == 'R':
                i = (i+1) % 4;
            elif instruction == 'L':
                i = (i-1) % 4;
            else:
                x += directions[i][0]
                y += directions[i][1]
        return (x == 0 and y == 0) or i &gt; 0

```



----------------------------------------------------------------------------------------

### Math - 1067 - https://leetcode.com/problems/digit-count-in-range/
Time: O(logn)  Space: O(1)   Hard
.Python/digit-count-in-range.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def digitsCount(self, d, low, high):
        """
        :type d: int
        :type low: int
        :type high: int
        :rtype: int
        """
        def digitsCount(n, k):
            pivot, result = 1, 0
            while n &gt;= pivot:
                result += (n//(10*pivot))*pivot + \
                           min(pivot, max(n%(10*pivot) - k*pivot + 1, 0))
                if k == 0:
                    result -= pivot
                pivot *= 10
            return result+1
        
        return digitsCount(high, d) - digitsCount(low-1, d)

```



----------------------------------------------------------------------------------------

### Math - 1073 - https://leetcode.com/problems/adding-two-negabinary-numbers/
Time: O(n)  Space: O(n)   Medium
.Python/adding-two-negabinary-numbers.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def addNegabinary(self, arr1, arr2):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :rtype: List[int]
        """
        result = []
        carry = 0
        while arr1 or arr2 or carry:
            if arr1:
                carry += arr1.pop()
            if arr2:
                carry += arr2.pop()
            result.append(carry &amp; 1)
            carry = -(carry &gt;&gt; 1)
        while len(result) &gt; 1 and result[-1] == 0:
            result.pop()
        result.reverse()
        return result

```



----------------------------------------------------------------------------------------

### Math - 1079 - https://leetcode.com/problems/letter-tile-possibilities/
Time: O(n^2)  Space: O(n)   Medium
.Python/letter-tile-possibilities.py


```python
# Time:  O(n^2)
# Space: O(n)

import collections


class Solution(object):
    def numTilePossibilities(self, tiles):
        """
        :type tiles: str
        :rtype: int
        """
        fact = [0.0]*(len(tiles)+1)
        fact[0] = 1.0;
        for i in xrange(1, len(tiles)+1):
            fact[i] = fact[i-1]*i
        count = collections.Counter(tiles)

        # 1. we can represent each alphabet 1..26 as generating functions:
        #    G1(x) = 1 + x^1/1! + x^2/2! + x^3/3! + ... + x^count1/count1!
        #    G2(x) = 1 + x^1/1! + x^2/2! + x^3/3! + ... + x^count2/count2!
        #    ...
        #    G26(x) = 1 + x^1/1! + x^2/2! + x^3/3! + ... + x^count26/count26!
        #
        # 2. let G1(x)*G2(x)*...*G26(x) = c0 + c1*x1 + ... + ck*x^k, k is the max number s.t. ck != 0
        #    =&gt; ci (1 &lt;= i &lt;= k) is the number we need to divide when permuting i letters
        #    =&gt; the answer will be : c1*1! + c2*2! + ... + ck*k!
        
        coeff = [0.0]*(len(tiles)+1)
        coeff[0] = 1.0
        for i in count.itervalues():
            new_coeff = [0.0]*(len(tiles)+1)
            for j in xrange(len(coeff)):
                for k in xrange(i+1):
                    if k+j &gt;= len(new_coeff):
                        break
                    new_coeff[j+k] += coeff[j]*1.0/fact[k]
            coeff = new_coeff

        result = 0
        for i in xrange(1, len(coeff)):
            result += int(round(coeff[i]*fact[i]))
        return result


# Time:  O(r), r is the value of result
# Space: O(n)
class Solution2(object):
    def numTilePossibilities(self, tiles):
        """
        :type tiles: str
        :rtype: int
        """
        def backtracking(counter):
            total = 0
            for k, v in counter.iteritems():
                if not v:
                    continue
                counter[k] -= 1
                total += 1+backtracking(counter)
                counter[k] += 1
            return total

        return backtracking(collections.Counter(tiles))

```



----------------------------------------------------------------------------------------

### Math - 1088 - https://leetcode.com/problems/confusing-number-ii/
Time: O(logn)  Space: O(logn)   Hard
.Python/confusing-number-ii.py


```python
# Time:  O(logn)
# Space: O(logn)

class Solution(object):
    def confusingNumberII(self, n):
        """
        :type n: int
        :rtype: int
        """
        lookup = {"0":"0", "1":"1", "6":"9", "8":"8", "9":"6"}
        centers = {"0":"0", "1":"1", "8":"8"}
        def totalCount(n):  # count all numbers in the pattern of [01689]{1,len(n)} in the range of [1, n]
            s = str(n)
            total = 0 
            p = len(lookup)**(len(s)-1)
            for i in xrange(len(s)+1):
                if i == len(s):
                    total += 1
                    break
                smaller = sum(int(c &lt; s[i]) for c in lookup.iterkeys())
                total += smaller * p
                if s[i] not in lookup:
                    break
                p //= len(lookup)
            return total-1  # exclude 0

        def validCountInLessLength(n):  # count unconfusing numbers in the pattern of [01689]{1,len(n)-1} in the range of [1, n]
            s = str(n)
            valid = 0
            total = len(centers)
            for i in xrange(1, len(s), 2):  # count unconfusing numbers for each odd length less than s
                if i == 1:
                    valid += len({c for c in centers.iterkeys() if c != '0'})
                else:
                    valid += total * (len(lookup)-1)
                    total *= len(lookup)
            total = 1
            for i in xrange(2, len(s), 2):  # count unconfusing numbers for each even length less than s
                valid += total * (len(lookup)-1)
                total *= len(lookup)
            return valid

        def validCountInFullLength(n):  # count unconfusing numbers in the pattern of [01689]{len(n)} in the range of [1, n]
            s = str(n)
            half_s = s[:(len(s)+1)//2]
            total = 0
            choices = centers if (len(s) % 2) else lookup
            p = int(len(lookup)**(len(half_s)-2) * len(choices))
            for i in xrange(len(half_s)):
                if i == len(half_s)-1:
                    total += sum(int(c &lt; half_s[i]) for c in choices.iterkeys() if i != 0 or c != '0')
                    if half_s[i] not in choices:
                        break
                    tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(xrange(len(half_s)-(len(s) % 2)))]
                    total += 0 &lt; int("".join(tmp)) &lt;= n
                    break
                smaller = sum(int(c &lt; half_s[i]) for c in lookup.iterkeys() if i != 0 or c != '0')
                total += smaller * p
                if half_s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n)


# Time:  O(logn)
# Space: O(logn)
class Solution2(object):
    def confusingNumberII(self, n):
        """
        :type n: int
        :rtype: int
        """
        lookup = {"0":"0", "1":"1", "6":"9", "8":"8", "9":"6"}
        centers = {"0":"0", "1":"1", "8":"8"}
        def totalCount(n):  # count all numbers in the pattern of [01689]{1,len(n)} in the range of [0, n]
            s = str(n)
            total = 0 
            p = len(lookup)**(len(s)-1)
            for i in xrange(len(s)+1):
                if i == len(s):
                    total += 1
                    break
                smaller = sum(int(c &lt; s[i]) for c in lookup.iterkeys())
                total += smaller * p
                if s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        def validCountInLessLength(n):  # count unconfusing numbers in the pattern of [01689]{1,len(n)-1} in the range of [0, n]
            s = str(n)
            valid = 0
            total = len(centers)
            for i in xrange(1, len(s), 2):  # count unconfusing numbers for each odd length less than s
                if i == 1:
                    valid += len(centers)
                else:
                    valid += total * (len(lookup)-1)
                    total *= len(lookup)
            total = 1
            for i in xrange(2, len(s), 2):  # count unconfusing numbers for each even length less than s
                valid += total * (len(lookup)-1)
                total *= len(lookup)
            return valid

        def validCountInFullLength(n):  # count unconfusing numbers in the pattern of [01689]{len(n)} in the range of [0, n]
            s = str(n)
            half_s = s[:(len(s)+1)//2]
            total = 0
            choices = centers if (len(s) % 2) else lookup
            p = int(len(lookup)**(len(half_s)-2) * len(choices))
            for i in xrange(len(half_s)):
                if i == len(half_s)-1:
                    total += sum(int(c &lt; half_s[i]) for c in choices.iterkeys() if len(s) != 2 or c != '0')
                    if half_s[i] not in choices:
                        break
                    tmp = list(half_s)+[lookup[half_s[i]] for i in reversed(xrange(len(half_s)-(len(s) % 2)))]
                    total += int("".join(tmp)) &lt;= n
                    break
                smaller = sum(int(c &lt; half_s[i]) for c in lookup.iterkeys() if i != 0 or c != '0')
                total += smaller * p
                if half_s[i] not in lookup:
                    break
                p //= len(lookup)
            return total

        def f(n):  # count confusing numbers in the range of [0, n]
            return totalCount(n) - validCountInLessLength(n) - validCountInFullLength(n)

        return f(n) - f(0)  # f(0) is always 0 and could be ignored

```



----------------------------------------------------------------------------------------

### Math - 1103 - https://leetcode.com/problems/distribute-candies-to-people/
Time: O(n + logc)  Space: O(1)   Easy
.Python/distribute-candies-to-people.py


```python
# Time:  O(n + logc), c is the number of candies
# Space: O(1)

class Solution(object):
    def distributeCandies(self, candies, num_people):
        """
        :type candies: int
        :type num_people: int
        :rtype: List[int]
        """
        # find max integer p s.t. sum(1 + 2 + ... + p) &lt;= C
        # =&gt; remaining : 0 &lt;= C-(1+p)*p/2 &lt; p+1
        # =&gt; -2p-2 &lt; p^2+p-2C &lt;= 0
        # =&gt; 2C+1/4 &lt; (p+3/2)^2 and (p+1/2)^2 &lt;= 2C+1/4
        # =&gt; sqrt(2C+1/4)-3/2 &lt; p &lt;= sqrt(2C+1/4)-1/2
        # =&gt; p = floor(sqrt(2C+1/4)-1/2)
        p = int((2*candies + 0.25)**0.5 - 0.5) 
        remaining = candies - (p+1)*p//2
        rows, cols = divmod(p, num_people)
        
        result = [0]*num_people
        for i in xrange(num_people):
            result[i] = (i+1)*(rows+1) + (rows*(rows+1)//2)*num_people if i &lt; cols else \
                        (i+1)*rows + ((rows-1)*rows//2)*num_people
        result[cols] += remaining
        return result


# Time:  O(n + logc), c is the number of candies
# Space: O(1)
class Solution2(object):
    def distributeCandies(self, candies, num_people):
        """
        :type candies: int
        :type num_people: int
        :rtype: List[int]
        """
        # find max integer p s.t. sum(1 + 2 + ... + p) &lt;= C
        left, right = 1, candies
        while left &lt;= right:
            mid = left + (right-left)//2
            if not ((mid &lt;= candies*2 // (mid+1))):
                right = mid-1
            else:
                left = mid+1
        p = right
        remaining = candies - (p+1)*p//2
        rows, cols = divmod(p, num_people)
        
        result = [0]*num_people
        for i in xrange(num_people):
            result[i] = (i+1)*(rows+1) + (rows*(rows+1)//2)*num_people if i &lt; cols else \
                        (i+1)*rows + ((rows-1)*rows//2)*num_people
        result[cols] += remaining
        return result


# Time:  O(sqrt(c)), c is the number of candies
# Space: O(1)
class Solution3(object):
    def distributeCandies(self, candies, num_people):
        """
        :type candies: int
        :type num_people: int
        :rtype: List[int]
        """
        result = [0]*num_people
        i = 0
        while candies != 0:
            result[i % num_people] += min(candies, i+1)
            candies -= min(candies, i+1)
            i += 1
        return result

```



----------------------------------------------------------------------------------------

### Math - 1118 - https://leetcode.com/problems/number-of-days-in-a-month/
Time: O(1)  Space: O(1)   Easy
.Python/number-of-days-in-a-month.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def numberOfDays(self, Y, M):
        """
        :type Y: int
        :type M: int
        :rtype: int
        """
        leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
        return (28+leap if (M == 2) else 31-(M-1)%7%2)

```



----------------------------------------------------------------------------------------

### Math - 1121 - https://leetcode.com/problems/divide-array-into-increasing-sequences/
Time: O(n)  Space: O(1)   Hard
.Python/divide-array-into-increasing-sequences.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def canDivideIntoSubsequences(self, nums, K):
        """
        :type nums: List[int]
        :type K: int
        :rtype: bool
        """
        curr, max_count = 1, 1
        for i in xrange(1, len(nums)):
            curr = 1 if nums[i-1] &lt; nums[i] else curr+1
            max_count = max(max_count, curr)
        return K*max_count &lt;= len(nums)

```



----------------------------------------------------------------------------------------

### Math - 1128 - https://leetcode.com/problems/number-of-equivalent-domino-pairs/
Time: O(n)  Space: O(n)   Easy
.Python/number-of-equivalent-domino-pairs.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def numEquivDominoPairs(self, dominoes):
        """
        :type dominoes: List[List[int]]
        :rtype: int
        """
        counter = collections.Counter((min(x), max(x)) for x in dominoes)
        return sum(v*(v-1)//2 for v in counter.itervalues())

```



----------------------------------------------------------------------------------------

### Math - 1131 - https://leetcode.com/problems/maximum-of-absolute-value-expression/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-of-absolute-value-expression.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxAbsValExpr(self, arr1, arr2):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :rtype: int
        """
        # 1. max(|arr1[i]-arr1[j]| + |arr2[i]-arr2[j]| + |i-j| for i &gt; j)
        #    = max(|arr1[i]-arr1[j]| + |arr2[i]-arr2[j]| + |i-j| for j &gt; i)
        # 2. for i &gt; j:
        #        (|arr1[i]-arr1[j]| + |arr2[i]-arr2[j]| + |i-j|)
        #        &gt;= c1*(arr1[i]-arr1[j]) + c2*(arr2[i]-arr2[j]) + i-j for c1 in (1, -1), c2 in (1, -1)
        #        = (c1*arr1[i]+c2*arr2[i]+i) - (c1*arr1[j]+c2*arr2[j]+j) for c1 in (1, -1), c2 in (1, -1)
        # 1 + 2 =&gt; max(|arr1[i]-arr1[j]| + |arr2[i]-arr2[j]| + |i-j| for i != j)
        #          = max((c1*arr1[i]+c2*arr2[i]+i) - (c1*arr1[j]+c2*arr2[j]+j)
        #                for c1 in (1, -1), c2 in (1, -1) for i &gt; j)
        result = 0
        for c1 in [1, -1]:
            for c2 in [1, -1]:
                min_prev = float("inf")
                for i in xrange(len(arr1)):
                    curr = c1*arr1[i] + c2*arr2[i] + i
                    result = max(result, curr-min_prev)
                    min_prev = min(min_prev, curr)
        return result

    
# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def maxAbsValExpr(self, arr1, arr2):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :rtype: int
        """
        return max(max(c1*arr1[i] + c2*arr2[i] + i for i in xrange(len(arr1))) -
                   min(c1*arr1[i] + c2*arr2[i] + i for i in xrange(len(arr1)))
                   for c1 in [1, -1] for c2 in [1, -1])

```



----------------------------------------------------------------------------------------

### Math - 1134 - https://leetcode.com/problems/armstrong-number/
Time: O(klogk)  Space: O(k)   Easy
.Python/armstrong-number.py


```python
# Time:  O(klogk)
# Space: O(k)

class Solution(object):
    def isArmstrong(self, N):
        """
        :type N: int
        :rtype: bool
        """
        n_str = str(N)
        return sum(int(i)**len(n_str) for i in n_str) == N

```



----------------------------------------------------------------------------------------

### Math - 1150 - https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/
Time: O(nlogn)  Space: O(1)   Easy
.Python/check-if-a-number-is-majority-element-in-a-sorted-array.py


```python
# Time:  O(logn)
# Space: O(1)

import bisect


class Solution(object):
    def isMajorityElement(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: bool
        """
        if len(nums) % 2:
            if nums[len(nums)//2] != target:
                return False
        else:
            if not (nums[len(nums)//2-1] == nums[len(nums)//2] == target):
                return False

        left = bisect.bisect_left(nums, target)
        right= bisect.bisect_right(nums, target)
        return (right-left)*2 &gt; len(nums)

```



----------------------------------------------------------------------------------------

### Math - 1157 - https://leetcode.com/problems/online-majority-element-in-subarray/
Time: ctor: O(n)query: O(klogn)  Space: O(n)   Hard
.Python/online-majority-element-in-subarray.py


```python
# Time:  ctor:  O(n)
#        query: O(klogn), k = log2(Q/ERROR_RATE)
# Space: O(n)

import collections
import random
import bisect


class MajorityChecker(object):

    def __init__(self, arr):
        """
        :type arr: List[int]
        """
        Q, ERROR_RATE = 10000, 0.001
        self.__K = int(Q/ERROR_RATE).bit_length()  # floor(log2(Q/ERROR_RATE))+1 = 24
        self.__arr = arr
        self.__inv_idx = collections.defaultdict(list)
        for i, x in enumerate(self.__arr):
            self.__inv_idx[x].append(i)

    def query(self, left, right, threshold):
        """
        :type left: int
        :type right: int
        :type threshold: int
        :rtype: int
        """
        def count(inv_idx, m, left, right):
            return bisect.bisect_right(inv_idx[m], right) - \
                   bisect.bisect_left(inv_idx[m], left)

        for _ in xrange(self.__K):
            m = self.__arr[random.randint(left, right)]
            if count(self.__inv_idx, m, left, right) &gt;= threshold:
                return m
        return -1


# Time:  ctor:  O(n)
#        query: O(sqrt(n)*logn)
# Space: O(n)
import collections
import bisect


class MajorityChecker2(object):

    def __init__(self, arr):
        """
        :type arr: List[int]
        """
        self.__arr = arr
        self.__inv_idx = collections.defaultdict(list)
        for i, x in enumerate(self.__arr):
            self.__inv_idx[x].append(i)
        self.__bound = int(round((len(arr)**0.5)))
        self.__majorities = [i for i, group in self.__inv_idx.iteritems() if len(group) &gt;= self.__bound]

    def query(self, left, right, threshold):
        """
        :type left: int
        :type right: int
        :type threshold: int
        :rtype: int
        """
        def count(inv_idx, m, left, right):
            return bisect.bisect_right(inv_idx[m], right) - \
                   bisect.bisect_left(inv_idx[m], left)

        def boyer_moore_majority_vote(nums, left, right):
            m, cnt = nums[left], 1
            for i in xrange(left+1, right+1):
                if m == nums[i]:
                    cnt += 1
                else:
                    cnt -= 1
                    if cnt == 0:
                        m = nums[i]
                        cnt = 1
            return m

        if right-left+1 &lt; self.__bound:
            m = boyer_moore_majority_vote(self.__arr, left, right)
            if count(self.__inv_idx, m, left, right) &gt;= threshold:
                return m
        else:
            for m in self.__majorities:
                if count(self.__inv_idx, m, left, right) &gt;= threshold:
                    return m
        return -1


# Time:  ctor:  O(nlogn)
#        query: O((logn)^2)
# Space: O(n)
import functools


class SegmentTreeRecu(object):  # 0-based index
    def __init__(self, nums, count):
        """
        initialize your data structure here.
        :type nums: List[int]
        """
        N = len(nums)
        self.__original_length = N
        self.__tree_length = 2**(N.bit_length() + (N&amp;(N-1) != 0))-1
        self.__tree = [-1 for _ in range(self.__tree_length)]
        self.__count = count
        self.__constructTree(nums, 0, self.__original_length-1, 0)

    def query(self, i, j):
        return self.__queryRange(i, j, 0, self.__original_length-1, 0)

    def __constructTree(self, nums, left, right, idx):
        if left &gt; right:
             return
        if left == right:
            self.__tree[idx] = nums[left]
            return 
        mid = left + (right-left)//2
        self.__constructTree(nums, left, mid, idx*2 + 1)
        self.__constructTree(nums, mid+1, right, idx*2 + 2)
        if self.__tree[idx*2 + 1] != -1 and \
           self.__count(self.__tree[idx*2 + 1], left, right)*2 &gt; right-left+1:
            self.__tree[idx] = self.__tree[idx*2 + 1] 
        elif self.__tree[idx*2 + 2] != -1 and \
             self.__count(self.__tree[idx*2 + 2], left, right)*2 &gt; right-left+1:
            self.__tree[idx] = self.__tree[idx*2 + 2] 

    def __queryRange(self, range_left, range_right, left, right, idx):
        if left &gt; right:
            return (-1, -1)
        if right &lt; range_left or left &gt; range_right:
            return (-1, -1)
        if range_left &lt;= left and right &lt;= range_right:
            if self.__tree[idx] != -1:
                c = self.__count(self.__tree[idx], range_left, range_right)
                if c*2 &gt; range_right-range_left+1:
                    return (self.__tree[idx], c)
        else:
            mid = left + (right-left)//2
            result = self.__queryRange(range_left, range_right, left, mid, idx*2 + 1)
            if result[0] != -1:
                return result
            result = self.__queryRange(range_left, range_right, mid + 1, right, idx*2 + 2)
            if result[0] != -1:
                return result
        return (-1, -1)


class MajorityChecker3(object):

    def __init__(self, arr):
        """
        :type arr: List[int]
        """
        def count(inv_idx, m, left, right):
            return bisect.bisect_right(inv_idx[m], right) - \
                   bisect.bisect_left(inv_idx[m], left)

        self.__arr = arr
        self.__inv_idx = collections.defaultdict(list)
        for i, x in enumerate(self.__arr):
            self.__inv_idx[x].append(i)
        self.__segment_tree = SegmentTreeRecu(arr, functools.partial(count, self.__inv_idx))

    def query(self, left, right, threshold):
        """
        :type left: int
        :type right: int
        :type threshold: int
        :rtype: int
        """
        result = self.__segment_tree.query(left, right)
        if result[1] &gt;= threshold:
            return result[0]
        return -1


# Time:  ctor:  O(n)
#        query: O(sqrt(n)*logn)
# Space: O(n)
import collections
import bisect


class MajorityChecker4(object):

    def __init__(self, arr):
        """
        :type arr: List[int]
        """
        self.__arr = arr
        self.__inv_idx = collections.defaultdict(list)
        for i, x in enumerate(self.__arr):
            self.__inv_idx[x].append(i)
        self.__bucket_size = int(round((len(arr)**0.5)))
        self.__bucket_majorities = []
        for left in xrange(0, len(self.__arr), self.__bucket_size):
            right = min(left+self.__bucket_size-1, len(self.__arr)-1)
            self.__bucket_majorities.append(self.__boyer_moore_majority_vote(self.__arr, left, right))

    def query(self, left, right, threshold):
        """
        :type left: int
        :type right: int
        :type threshold: int
        :rtype: int
        """
        def count(inv_idx, m, left, right):
            return bisect.bisect_right(inv_idx[m], right) - \
                   bisect.bisect_left(inv_idx[m], left)

        l, r = left//self.__bucket_size, right//self.__bucket_size;
        if l == r:
            m = self.__boyer_moore_majority_vote(self.__arr, left, right)
            if count(self.__inv_idx, m, left, right) &gt;= threshold:
                return m
            return -1
        else:
            m = self.__boyer_moore_majority_vote(self.__arr, left, (l+1)*self.__bucket_size-1)
            if count(self.__inv_idx, m, left, right) &gt;= threshold:
                return m
            m = self.__boyer_moore_majority_vote(self.__arr, r*self.__bucket_size, right)
            if count(self.__inv_idx, m, left, right) &gt;= threshold:
                return m;
            for i in xrange(l+1, r):
                if count(self.__inv_idx, self.__bucket_majorities[i], left, right) &gt;= threshold:
                    return self.__bucket_majorities[i]
            return -1
    
    def __boyer_moore_majority_vote(self, nums, left, right):
            m, cnt = nums[left], 1
            for i in xrange(left+1, right+1):
                if m == nums[i]:
                    cnt += 1
                else:
                    cnt -= 1
                    if cnt == 0:
                        m = nums[i]
                        cnt = 1
            return m

```



----------------------------------------------------------------------------------------

### Math - 1154 - https://leetcode.com/problems/day-of-the-year/
Time: O(1)  Space: O(1)   Easy
.Python/day-of-the-year.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def __init__(self):
        def dayOfMonth(M):
            return (28 if (M == 2) else 31-(M-1)%7%2)

        self.__lookup = [0]*12
        for M in xrange(1, len(self.__lookup)):
            self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M)
            
    def dayOfYear(self, date):
        """
        :type date: str
        :rtype: int
        """
        Y, M, D = map(int, date.split("-"))
        leap = 1 if M &gt; 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0
        return self.__lookup[M-1]+D+leap


# Time:  O(1)
# Space: O(1)
class Solution2(object):
    def dayOfYear(self, date):
        """
        :type date: str
        :rtype: int
        """
        def numberOfDays(Y, M):
            leap = 1 if ((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0) else 0
            return (28+leap if (M == 2) else 31-(M-1)%7%2)

        Y, M, result = map(int, date.split("-"))
        for i in xrange(1, M):
            result += numberOfDays(Y, i)
        return result

```



----------------------------------------------------------------------------------------

### Math - 1175 - https://leetcode.com/problems/prime-arrangements/
Time: O(nlog(logn))  Space: O(n)   Easy
.Python/prime-arrangements.py


```python
# Time:  O(n/2 + n/3 + ... + n/p) = O(nlog(logn)), see https://mathoverflow.net/questions/4596/on-the-series-1-2-1-3-1-5-1-7-1-11
# Space: O(n)

class Solution(object):
    def numPrimeArrangements(self, n):
        """
        :type n: int
        :rtype: int
        """
        def count_primes(n):
            if n &lt;= 1:
                return 0
            is_prime = [True]*((n+1)//2)
            cnt = len(is_prime)
            for i in xrange(3, n+1, 2):
                if i*i &gt; n:
                    break
                if not is_prime[i//2]:
                    continue
                for j in xrange(i*i, n+1, 2*i):
                    if not is_prime[j//2]:
                        continue
                    cnt -= 1
                    is_prime[j//2] = False
            return cnt
        
        def factorial(n):
            result = 1
            for i in xrange(2, n+1):
                result = (result*i)%MOD
            return result

        MOD = 10**9+7
        cnt = count_primes(n)
        return factorial(cnt) * factorial(n-cnt) % MOD

```



----------------------------------------------------------------------------------------

### Math - 1185 - https://leetcode.com/problems/day-of-the-week/
Time: O(1)  Space: O(1)   Easy
.Python/day-of-the-week.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def dayOfTheWeek(self, day, month, year):
        """
        :type day: int
        :type month: int
        :type year: int
        :rtype: str
        """
        DAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", \
                "Thursday", "Friday", "Saturday"]

        # Zeller Formula
        if month &lt; 3:
            month += 12
            year -= 1
        c, y = divmod(year, 100)
        w = (c//4 - 2*c + y + y//4 + 13*(month+1)//5 + day - 1) % 7
        return DAYS[w]

```



----------------------------------------------------------------------------------------

### Math - 1197 - https://leetcode.com/problems/minimum-knight-moves/
Time: O(1)  Space: O(1)   Medium
.Python/minimum-knight-moves.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def minKnightMoves(self, x, y):
        """
        :type x: int
        :type y: int
        :rtype: int
        """
        # we can observe from:
        # [0]
        # [3, 2]
        # [2,(1),4]
        # [3, 2, 3, 2]
        # [2, 3,(2) 3, 4]
        # [3, 4, 3, 4, 3, 4]
        # [4, 3, 4,(3),4, 5, 4]
        # [5, 4, 5, 4, 5, 4, 5, 6]
        # [4, 5, 4, 5,(4),5, 6, 5, 6]
        # [5, 6, 5, 6, 5, 6, 5, 6, 7, 6]
        # [6, 5, 6, 5, 6,(5),6, 7, 6, 7, 8]
        # [7, 6, 7, 6, 7, 6, 7, 6, 7, 8, 7, 8]
        # [6, 7, 6, 7, 6, 7,(6),7, 8, 7, 8, 9, 8]
        # [7, 8, 7, 8, 7, 8, 7, 8, 7, 8, 9, 8, 9, 10]
        # [8, 7, 8, 7, 8, 7, 8,(7),8, 9, 8, 9, 10, 9, 10]
        # [9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 10, 9, 10, 11, 10]

        x, y = abs(x), abs(y)
        if x &lt; y:
            x, y = y, x
        lookup = {(0, 0):0, (1, 0):3, (2, 2):4}  # special cases
        if (x, y) in lookup:
            return lookup[(x, y)]
        k = x-y
        if y &gt; k:
            # if 2y &gt; x, every period 3 of y (or k) with fixed another is increased by 2 (or 1)
            # and start from (2k, k) with (k) when y = k (diagonal line)
            # ex. (0, 0) ~ (12, 12) ~ ... : 0 =&gt; 2,4(special case),2 =&gt; 4,4,4 =&gt; 6,6,6 =&gt; 8,8,8 =&gt; ...
            # ex. (2, 1) ~ (14, 13) ~ ... : 1 =&gt; 3,3,3 =&gt; 5,5,5 =&gt; 7,7,7 =&gt; 9,9,9 =&gt; ...
            return k - 2*((k-y)//3)
        # if 2y &lt;= x, every period 4 of k (or y) with fixed another is increased by 2
        # and start from (2k, k) with (k) when y = k (vertical line)
        # ex. (0, 0) ~ (11, 0) ~ ... : 0,3(special case),2,3 =&gt; 2,3,4,5 =&gt; 4,5,6,7 =&gt; ...
        # ex. (2, 1) ~ (13, 1) ~ ... : 1,2,3,4 =&gt; 3,4,5,6 =&gt; 5,6,7,8 =&gt; ...
        return k - 2*((k-y)//4)


# Time:  O(n^2)
# Space: O(n^2)
class Solution2(object):
    def __init__(self):
        self.__lookup = {(0, 0):0, (1, 1):2, (1, 0):3}  # special cases

    def minKnightMoves(self, x, y):
        """
        :type x: int
        :type y: int
        :rtype: int
        """
        def dp(x, y):
            x, y = abs(x), abs(y)
            if x &lt; y:
                x, y = y, x
            if (x, y) not in self.__lookup:  # greedy, smaller x, y is always better if not special cases
                self.__lookup[(x, y)] = min(dp(x-1, y-2), dp(x-2, y-1)) + 1
            return self.__lookup[(x, y)]
        return dp(x, y)

```



----------------------------------------------------------------------------------------

### Math - 1217 - https://leetcode.com/problems/play-with-chips/
Time: O(n)  Space: O(1)   Medium
.Python/play-with-chips.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minCostToMoveChips(self, chips):
        """
        :type chips: List[int]
        :rtype: int
        """
        count = [0]*2
        for p in chips:
            count[p%2] += 1
        return min(count)

```



----------------------------------------------------------------------------------------

### Math - 1227 - https://leetcode.com/problems/airplane-seat-assignment-probability/
Time: O(1)  Space: O(1)   Medium
.Python/airplane-seat-assignment-probability.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def nthPersonGetsNthSeat(self, n):
        """
        :type n: int
        :rtype: float
        """
        # p(k) = 1 * (prob that 1th passenger takes his own seat) +
        #        0 * (prob that 1th passenger takes kth one's seat) +
        #        1 * (prob that 1th passenger takes the others' seat) * 
        #            (prob that the first k-1 passengers get a seat
        #             which is not kth one's seat)
        #      = 1/k + p(k-1)*(k-2)/k
        #
        # p(1) = 1
        # p(2) = 1/2 + p(1) * (2-2)/2 = 1/2
        # p(3) = 1/3 + p(2) * (3-2)/3 = 1/3 + 1/2 * (3-2)/3 = 1/2
        # ...
        # p(n) = 1/n + 1/2 * (n-2)/n = (2+n-2)/(2n) = 1/2
        return 0.5 if n != 1 else 1.0

# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def nthPersonGetsNthSeat(self, n):
        """
        :type n: int
        :rtype: float
        """
        dp = [0.0]*2
        dp[0] = 1.0  # zero-indexed
        for i in xrange(2, n+1):
            dp[(i-1)%2] = 1.0/i+dp[(i-2)%2]*(i-2)/i
        return dp[(n-1)%2]

```



----------------------------------------------------------------------------------------

### Math - 1232 - https://leetcode.com/problems/check-if-it-is-a-straight-line/
Time: O(1)  Space: O(1)   Easy
.Python/check-if-it-is-a-straight-line.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def checkStraightLine(self, coordinates):
        """
        :type coordinates: List[List[int]]
        :rtype: bool
        """
        i, j = coordinates[:2]
        return all(i[0] * j[1] - j[0] * i[1] +
                   j[0] * k[1] - k[0] * j[1] +
                   k[0] * i[1] - i[0] * k[1] == 0
                   for k in coordinates)

```



----------------------------------------------------------------------------------------

### Math - 1237 - https://leetcode.com/problems/find-positive-integer-solution-for-a-given-equation/
Time: O(n)  Space: O(1)   Easy
.Python/find-positive-integer-solution-for-a-given-equation.py


```python
# Time:  O(n)
# Space: O(1)

"""
   This is the custom function interface.
   You should not implement it, or speculate about its implementation
   class CustomFunction:
       # Returns f(x, y) for any given positive integers x and y.
       # Note that f(x, y) is increasing with respect to both x and y.
       # i.e. f(x, y) &lt; f(x + 1, y), f(x, y) &lt; f(x, y + 1)
       def f(self, x, y):
  
"""
class Solution(object):
    def findSolution(self, customfunction, z):
        """
        :type num: int
        :type z: int
        :rtype: List[List[int]]
        """
        result = []
        x, y = 1, 1
        while customfunction.f(x, y) &lt; z:
            y += 1
        while y &gt; 0:
            while y &gt; 0 and customfunction.f(x, y) &gt; z:
                y -= 1
            if y &gt; 0 and customfunction.f(x, y) == z:
                result.append([x, y])
            x += 1
        return result

```



----------------------------------------------------------------------------------------

### Math - 1238 - https://leetcode.com/problems/circular-permutation-in-binary-representation/
Time: O(2^n)  Space: O(1)   Medium
.Python/circular-permutation-in-binary-representation.py


```python
# Time:  O(2^n)
# Space: O(1)

class Solution(object):
    def circularPermutation(self, n, start):
        """
        :type n: int
        :type start: int
        :rtype: List[int]
        """
        return [start ^ (i&gt;&gt;1) ^ i for i in xrange(1&lt;&lt;n)]

```



----------------------------------------------------------------------------------------

### Math - 1250 - https://leetcode.com/problems/check-if-it-is-a-good-array/
Time: O(n)  Space: O(1)   Hard
.Python/check-if-it-is-a-good-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def isGoodArray(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        # Bzout's identity
        result = nums[0]
        for num in nums:
            result = gcd(result, num)
            if result == 1:
                break
        return result == 1

```



----------------------------------------------------------------------------------------

### Math - 1256 - https://leetcode.com/problems/encode-number/
Time: O(logn)  Space: O(1)   Medium
.Python/encode-number.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def encode(self, num):
        """
        :type num: int
        :rtype: str
        """
        result = []
        while num:
            result.append('0' if num%2 else '1')
            num = (num-1)//2
        return "".join(reversed(result))

```



----------------------------------------------------------------------------------------

### Math - 1259 - https://leetcode.com/problems/handshakes-that-dont-cross/
Time: O(n)  Space: O(1)   Hard
.Python/handshakes-that-dont-cross.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def numberOfWays(self, num_people):
        """
        :type num_people: int
        :rtype: int
        """
        MOD = 10**9+7
        def inv(x, m):  # Euler's Theorem
            return pow(x, m-2, m)  # O(logMOD) = O(1)

        def nCr(n, k, m):
            if n-k &lt; k:
                return nCr(n, n-k, m)
            result = 1
            for i in xrange(1, k+1):
                result = result*(n-k+i)*inv(i, m)%m
            return result

        n = num_people//2
        return nCr(2*n, n, MOD)*inv(n+1, MOD) % MOD  # Catalan number


# Time:  O(n^2)
# Space: O(n)
class Solution2(object):
    def numberOfWays(self, num_people):
        """
        :type num_people: int
        :rtype: int
        """
        MOD = 10**9+7
        dp = [0]*(num_people//2+1)
        dp[0] = 1
        for k in xrange(1, num_people//2+1):
            for i in xrange(k):
                dp[k] = (dp[k] + dp[i]*dp[k-1-i]) % MOD
        return dp[num_people//2]

```



----------------------------------------------------------------------------------------

### Math - 1266 - https://leetcode.com/problems/minimum-time-visiting-all-points/
Time: O(n)  Space: O(1)   Easy
.Python/minimum-time-visiting-all-points.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minTimeToVisitAllPoints(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        return sum(max(abs(points[i+1][0] - points[i][0]),
                       abs(points[i+1][1] - points[i][1]))
                   for i in xrange(len(points)-1))

```



----------------------------------------------------------------------------------------

### Math - 1276 - https://leetcode.com/problems/number-of-burgers-with-no-waste-of-ingredients/
Time: O(1)  Space: O(1)   Medium
.Python/number-of-burgers-with-no-waste-of-ingredients.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def numOfBurgers(self, tomatoSlices, cheeseSlices):
        """
        :type tomatoSlices: int
        :type cheeseSlices: int
        :rtype: List[int]
        """
        # let the number of jumbo burger be x, the number of small burger be y:
        #   4x + 2y = t
        #   x + y = c
        #   =&gt;
        #   x = t/2-c
        #   y = 2c-t/2
        # since x, y are natural numbers
        #   =&gt; t/2 is integer, t/2-c &gt;= 0, 2c-t/2 &gt;= 0
        #   =&gt; t%2 == 0, 2c &lt;= t &lt;= 4c
        return [tomatoSlices//2-cheeseSlices, 2*cheeseSlices - tomatoSlices//2] \
               if tomatoSlices%2 == 0 and 2*cheeseSlices &lt;= tomatoSlices &lt;= 4*cheeseSlices \
               else []

```



----------------------------------------------------------------------------------------

### Math - 1281 - https://leetcode.com/problems/subtract-the-product-and-sum-of-digits-of-an-integer/
Time: O(logn)  Space: O(1)   Easy
.Python/subtract-the-product-and-sum-of-digits-of-an-integer.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def subtractProductAndSum(self, n):
        """
        :type n: int
        :rtype: int
        """
        product, total = 1, 0
        while n:
            n, r = divmod(n, 10)
            product *= r
            total += r
        return product-total


# Time:  O(logn)
# Space: O(logn)
import operator


class Solution2(object):
    def subtractProductAndSum(self, n):
        """
        :type n: int
        :rtype: int
        """
        A = map(int, str(n))
        return reduce(operator.mul, A) - sum(A)

```



----------------------------------------------------------------------------------------

### Math - 1300 - https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/
Time: O(nlogn)  Space: O(1)   Medium
.Python/sum-of-mutated-array-closest-to-target.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def findBestValue(self, arr, target):
        """
        :type arr: List[int]
        :type target: int
        :rtype: int
        """
        arr.sort(reverse=True)
        max_arr = arr[0]
        while arr and arr[-1]*len(arr) &lt;= target:
            target -= arr.pop()
        # let x = ceil(t/n)-1
        # (1) (t/n-1/2) &lt;= x:
        #    return x, which is equal to ceil(t/n)-1 = ceil(t/n-1/2) = (2t+n-1)//2n
        # (2) (t/n-1/2) &gt; x:
        #    return x+1, which is equal to ceil(t/n) = ceil(t/n-1/2) = (2t+n-1)//2n
        # (1) + (2) =&gt; both return (2t+n-1)//2n
        return max_arr if not arr else (2*target+len(arr)-1)//(2*len(arr))


# Time:  O(nlogn)
# Space: O(1)
class Solution2(object):
    def findBestValue(self, arr, target):
        """
        :type arr: List[int]
        :type target: int
        :rtype: int
        """
        arr.sort(reverse=True)
        max_arr = arr[0]
        while arr and arr[-1]*len(arr) &lt;= target:
            target -= arr.pop()
        if not arr:
            return max_arr
        x = (target-1)//len(arr)
        return x if target-x*len(arr) &lt;= (x+1)*len(arr)-target else x+1


# Time:  O(nlogm), m is the max of arr, which may be larger than n
# Space: O(1)
class Solution3(object):
    def findBestValue(self, arr, target):
        """
        :type arr: List[int]
        :type target: int
        :rtype: int
        """
        def total(arr, v):
            result = 0
            for x in arr:
                result += min(v, x)
            return result

        def check(arr, v, target):
            return total(arr, v) &gt;= target
        
        left, right = 1, max(arr)
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(arr, mid, target):
                right = mid-1
            else:
                left = mid+1
        return left-1 if target-total(arr, left-1) &lt;= total(arr, left)-target else left

```



----------------------------------------------------------------------------------------

### Math - 1317 - https://leetcode.com/problems/convert-integer-to-the-sum-of-two-no-zero-integers/
Time: O(logn)  Space: O(1)   Easy
.Python/convert-integer-to-the-sum-of-two-no-zero-integers.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def getNoZeroIntegers(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        a, curr, base = 0, n, 1
        while curr: 
            if curr % 10 == 0 or (curr % 10 == 1 and curr != 1):
                a += base
                curr -= 10  # carry
            a += base
            base *= 10
            curr //= 10
        return [a, n-a]


# Time:  O(nlogn)
# Space: O(logn)
class Solution2(object):
    def getNoZeroIntegers(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        return next([a, n-a] for a in xrange(1, n) if '0' not in '{}{}'.format(a, n-a))

```



----------------------------------------------------------------------------------------

### Math - 1323 - https://leetcode.com/problems/maximum-69-number/
Time: O(logn)  Space: O(1)   Easy
.Python/maximum-69-number.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def maximum69Number (self, num):
        """
        :type num: int
        :rtype: int
        """
        curr, base, change = num, 3, 0
        while curr:
            if curr%10 == 6:
                change = base
            base *= 10
            curr //= 10
        return num+change


# Time:  O(logn)
# Space: O(logn)
class Solution2(object):
    def maximum69Number (self, num):
        """
        :type num: int
        :rtype: int
        """
        return int(str(num).replace('6', '9', 1))

```



----------------------------------------------------------------------------------------

### Math - 1330 - https://leetcode.com/problems/reverse-subarray-to-maximize-array-value/
Time: O(n)  Space: O(1)   Hard
.Python/reverse-subarray-to-maximize-array-value.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxValueAfterReverse(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result, add, max_pair, min_pair = 0, 0, float("-inf"), float("inf")
        for i in xrange(1, len(nums)):
            result += abs(nums[i-1]-nums[i])
            add = max(add,
                      abs(nums[0]-nums[i]) - abs(nums[i-1]-nums[i]),
                      abs(nums[-1]-nums[i-1]) - abs(nums[i-1]-nums[i]))
            min_pair = min(min_pair, max(nums[i-1], nums[i]))
            max_pair = max(max_pair, min(nums[i-1], nums[i]))
        return result + max(add, (max_pair-min_pair)*2)

```



----------------------------------------------------------------------------------------

### Math - 1344 - https://leetcode.com/problems/angle-between-hands-of-a-clock/
Time: O(1)  Space: O(1)   Medium
.Python/angle-between-hands-of-a-clock.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def angleClock(self, hour, minutes):
        """
        :type hour: int
        :type minutes: int
        :rtype: float
        """
        angle1 = (hour % 12 * 60.0 + minutes) / 720.0
        angle2 = minutes / 60.0
        diff = abs(angle1-angle2)
        return min(diff, 1.0-diff) * 360.0

```



----------------------------------------------------------------------------------------

### Math - 1359 - https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/
Time: O(n)  Space: O(1)   Hard
.Python/count-all-valid-pickup-and-delivery-options.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countOrders(self, n):
        """
        :type n: int
        :rtype: int
        """
        MOD = 10**9+7
        result = 1
        for i in reversed(xrange(2, 2*n+1, 2)):
            result = result * i*(i-1)//2 % MOD
        return result

```



----------------------------------------------------------------------------------------

### Math - 1360 - https://leetcode.com/problems/number-of-days-between-two-dates/
Time: O(1)  Space: O(1)   Easy
.Python/number-of-days-between-two-dates.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def __init__(self):
        def dayOfMonth(M):
            return (28 if (M == 2) else 31-(M-1)%7%2)

        self.__lookup = [0]*12
        for M in xrange(1, len(self.__lookup)):
            self.__lookup[M] += self.__lookup[M-1]+dayOfMonth(M)

    def daysBetweenDates(self, date1, date2):
        """
        :type date1: str
        :type date2: str
        :rtype: int
        """
        def num_days(date):
            Y, M, D = map(int, date.split("-"))
            leap = 1 if M &gt; 2 and (((Y % 4 == 0) and (Y % 100 != 0)) or (Y % 400 == 0)) else 0
            return (Y-1)*365 + ((Y-1)//4 - (Y-1)//100 + (Y-1)//400) + self.__lookup[M-1]+D+leap
     
        return abs(num_days(date1) - num_days(date2))


# Time:  O(1)
# Space: O(1)
import datetime


class Solution2(object):
    def daysBetweenDates(self, date1, date2):        
        delta = datetime.datetime.strptime(date1, "%Y-%m-%d")
        delta -= datetime.datetime.strptime(date2, "%Y-%m-%d")
        return abs(delta.days)

```



----------------------------------------------------------------------------------------

### Math - 1362 - https://leetcode.com/problems/closest-divisors/
Time: O(sqrt(n))  Space: O(1)   Medium
.Python/closest-divisors.py


```python
# Time:  O(sqrt(n))
# Space: O(1)

class Solution(object):
    def closestDivisors(self, num):
        """
        :type num: int
        :rtype: List[int]
        """
        def divisors(n):
            for d in reversed(xrange(1, int(n**0.5)+1)):
                if n % d == 0:
                    return d, n//d
            return 1, n

        return min([divisors(num+1), divisors(num+2)], key=lambda x: x[1]-x[0])



# Time:  O(sqrt(n))
# Space: O(1)
class Solution2(object):
    def closestDivisors(self, num):
        """
        :type num: int
        :rtype: List[int]
        """
        result, d = [1, num+1], 1
        while d*d &lt;= num+2:
            if (num+2) % d == 0:
                result = [d, (num+2)//d]
            if (num+1) % d == 0:
                result = [d, (num+1)//d]
            d += 1
        return result

```



----------------------------------------------------------------------------------------

### Math - 1363 - https://leetcode.com/problems/largest-multiple-of-three/
Time: O(n)  Space: O(1)   Hard
.Python/largest-multiple-of-three.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def largestMultipleOfThree(self, digits):
        """
        :type digits: List[int]
        :rtype: str
        """
        lookup = {0: [],
                  1: [(1,), (4,), (7,), (2, 2), (5, 2), (5, 5), (8, 2), (8, 5), (8, 8)],
                  2: [(2,), (5,), (8,), (1, 1), (4, 1), (4, 4), (7, 1), (7, 4), (7, 7)]}
        count = collections.Counter(digits)
        for deletes in lookup[sum(digits)%3]:
            delete_count = collections.Counter(deletes)
            if all(count[k] &gt;= v for k, v in delete_count.iteritems()):
                for k, v in delete_count.iteritems():
                    count[k] -= v
                break
        result = "".join(str(d)*count[d] for d in reversed(xrange(10)))
        return "0" if result and result[0] == '0' else result
    

# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def largestMultipleOfThree(self, digits):
        """
        :type digits: List[int]
        :rtype: str
        """
        def candidates_gen(r):
            if r == 0:
                return
            for i in xrange(10):
                yield [i]
            for i in xrange(10):
                for j in xrange(i+1):
                    yield [i, j]

        count, r = collections.Counter(digits), sum(digits)%3
        for deletes in candidates_gen(r):
            delete_count = collections.Counter(deletes)
            if sum(deletes)%3 == r and \
               all(count[k] &gt;= v for k, v in delete_count.iteritems()):
                for k, v in delete_count.iteritems():
                    count[k] -= v
                break
        result = "".join(str(d)*count[d] for d in reversed(xrange(10)))
        return "0" if result and result[0] == '0' else result

```



----------------------------------------------------------------------------------------

### Math - 1390 - https://leetcode.com/problems/four-divisors/
Time: O(n * sqrt(n))  Space: O(1)   Medium
.Python/four-divisors.py


```python
# Time:  O(n * sqrt(n))
# Space: O(1)

class Solution(object):
    def sumFourDivisors(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = 0
        for num in nums:
            facs, i = [], 1
            while i*i &lt;= num:
                if num % i:
                    i+= 1
                    continue
                facs.append(i)
                if i != num//i:
                    facs.append(num//i)
                    if len(facs) &gt; 4:
                        break
                i += 1
            if len(facs) == 4:            
                result += sum(facs)
        return result 


# Time:  O(n * sqrt(n))
# Space: O(sqrt(n))
import itertools


class Solution2(object):
    def sumFourDivisors(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def factorize(x):
            result = []
            d = 2
            while d*d &lt;= x:
                e = 0
                while x%d == 0:
                    x //= d
                    e += 1
                if e:
                    result.append([d, e])
                d += 1 if d == 2 else 2
            if x &gt; 1:
                result.append([x, 1])
            return result
       
        result = 0
        for facs in itertools.imap(factorize, nums):
            if len(facs) == 1 and facs[0][1] == 3:
                p = facs[0][0]
                result += (p**4-1)//(p-1)  # p^0 + p^1 +p^2 +p^3
            elif len(facs) == 2 and facs[0][1] == facs[1][1] == 1:
                p, q = facs[0][0], facs[1][0]
                result += (1 + p) * (1 + q)
        return result

```



----------------------------------------------------------------------------------------

### Math - 1401 - https://leetcode.com/problems/circle-and-rectangle-overlapping/
Time: O(1)  Space: O(1)   Medium
.Python/circle-and-rectangle-overlapping.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):
        """
        :type radius: int
        :type x_center: int
        :type y_center: int
        :type x1: int
        :type y1: int
        :type x2: int
        :type y2: int
        :rtype: bool
        """
        x1 -= x_center
        y1 -= y_center
        x2 -= x_center
        y2 -= y_center
        x = x1 if x1 &gt; 0 else x2 if x2 &lt; 0 else 0
        y = y1 if y1 &gt; 0 else y2 if y2 &lt; 0 else 0
        return x**2 + y**2 &lt;= radius**2


# Time:  O(1)
# Space: O(1)
class Solution2(object):
    def checkOverlap(self, radius, x_center, y_center, x1, y1, x2, y2):
        """
        :type radius: int
        :type x_center: int
        :type y_center: int
        :type x1: int
        :type y1: int
        :type x2: int
        :type y2: int
        :rtype: bool
        """
        x1 -= x_center
        y1 -= y_center
        x2 -= x_center
        y2 -= y_center        
        x = min(abs(x1), abs(x2)) if x1*x2 &gt; 0 else 0
        y = min(abs(y1), abs(y2)) if y1*y2 &gt; 0 else 0
        return x**2 + y**2 &lt;= radius**2

```



----------------------------------------------------------------------------------------

### Math - 1415 - https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/
Time: O(n)  Space: O(1)   Medium
.Python/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def getHappyString(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: str
        """
        base = 2**(n-1)
        if k &gt; 3*base:
            return ""
        result = [chr(ord('a')+(k-1)//base)]
        while base &gt; 1:
            k -= (k-1)//base*base
            base //= 2
            result.append(('a' if result[-1] != 'a' else 'b') if (k-1)//base == 0 else
                          ('c' if result[-1] != 'c' else 'b'))
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Math - 1442 - https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/
Time: O(n)  Space: O(n)   Medium
.Python/count-triplets-that-can-form-two-arrays-of-equal-xor.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def countTriplets(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        count_sum = collections.defaultdict(lambda: [0, 0])
        count_sum[0] = [1, 0]
        result, prefix = 0, 0
        for i, x in enumerate(arr):
            prefix ^= x
            c, t = count_sum[prefix]
            # sum(i-(j+1) for j in index[prefix])
            # = len(index[prefix])*i - sum((j+1) for j in index[prefix])
            result += c*i - t
            count_sum[prefix] = [c+1, t+i+1]
        return result

```



----------------------------------------------------------------------------------------

### Math - 1447 - https://leetcode.com/problems/simplified-fractions/
Time: O(n^2 * logn)  Space: O(n^2)   Medium
.Python/simplified-fractions.py


```python
# Time:  O(n^2 * logn)
# Space: O(n^2)

import fractions

class Solution(object):
    def simplifiedFractions(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        lookup = set()
        for b in xrange(1, n+1):
            for a in xrange(1, b):
                g = fractions.gcd(a, b)
                lookup.add((a//g, b//g))
        return map(lambda x: "{}/{}".format(*x), lookup)

```



----------------------------------------------------------------------------------------

### Math - 1486 - https://leetcode.com/problems/xor-operation-in-an-array/
Time: O(1)  Space: O(1)   Easy
.Python/xor-operation-in-an-array.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def xorOperation(self, n, start):
        """
        :type n: int
        :type start: int
        :rtype: int
        """
        def xorNums(n, start):
            def xorNumsBeginEven(n, start):
                assert(start%2 == 0)
                # 2*i ^ (2*i+1) = 1
                return ((n//2)%2)^((start+n-1) if n%2 else 0)

            return start^xorNumsBeginEven(n-1, start+1) if start%2 else xorNumsBeginEven(n, start)
        
        return int(n%2 and start%2) + 2*xorNums(n, start//2)


# Time:  O(n)
# Space: O(1)
import operator


class Solution2(object):
    def xorOperation(self, n, start):
        """
        :type n: int
        :type start: int
        :rtype: int
        """
        return reduce(operator.xor, (i for i in xrange(start, start+2*n, 2)))

```



----------------------------------------------------------------------------------------

### Math - 1492 - https://leetcode.com/problems/the-kth-factor-of-n/
Time: O(sqrt(n))  Space: O(1)   Medium
.Python/the-kth-factor-of-n.py


```python
# Time:  O(sqrt(n))
# Space: O(1)

class Solution(object):
    def kthFactor(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: int
        """
        def kth_factor(n, k=0):
            mid = None
            i = 1
            while i*i &lt;= n:
                if not n%i:
                    mid = i
                    k -= 1
                    if not k:
                        break
                i += 1
            return mid, -k
    
        mid, count = kth_factor(n)
        total = 2*count-(mid*mid == n)
        if k &gt; total:
            return -1
        result = kth_factor(n, k if k &lt;= count else total-(k-1))[0]
        return result if k &lt;= count else n//result


# Time:  O(sqrt(n))
# Space: O(sqrt(n))
class Solution2(object):
    def kthFactor(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: int
        """
        result = []
        i = 1
        while i*i &lt;= n:
            if not n%i:
                if i*i != n:
                    result.append(i)
                k -= 1
                if not k:
                    return i
            i += 1
        return -1 if k &gt; len(result) else n//result[-k]

```



----------------------------------------------------------------------------------------

### Math - 1497 - https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/
Time: O(n)  Space: O(k)   Medium
.Python/check-if-array-pairs-are-divisible-by-k.py


```python
# Time:  O(n)
# Space: O(k)

import collections


class Solution(object):
    def canArrange(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: bool
        """
        count = collections.Counter(i%k for i in arr)
        return (0 not in count or not count[0]%2) and \
                all(k-i in count and count[i] == count[k-i] for i in xrange(1, k) if i in count)

```



----------------------------------------------------------------------------------------

### Math - 1512 - https://leetcode.com/problems/number-of-good-pairs/
Time: O(n)  Space: O(1)   Easy
.Python/number-of-good-pairs.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def numIdenticalPairs(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return sum(c*(c-1)//2 for c in collections.Counter(nums).itervalues())

```



----------------------------------------------------------------------------------------

### Math - 1513 - https://leetcode.com/problems/number-of-substrings-with-only-1s/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-substrings-with-only-1s.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def numSub(self, s):
        """
        :type s: str
        :rtype: int
        """
        MOD = 10**9+7
        result, count = 0, 0
        for c in s:
            count = count+1 if c == '1' else 0
            result = (result+count)%MOD
        return result

```



----------------------------------------------------------------------------------------

### Math - 1525 - https://leetcode.com/problems/number-of-good-ways-to-split-a-string/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-good-ways-to-split-a-string.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def numSplits(self, s):
        """
        :type s: str
        :rtype: int
        """
        left_count, right_count = collections.Counter(), collections.Counter(s)
        result = 0
        for c in s:
            left_count[c] += 1
            right_count[c] -= 1
            if not right_count[c]:
                del right_count[c]
            if len(left_count) == len(right_count):
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Math - 1537 - https://leetcode.com/problems/get-the-maximum-score/
Time: O(m + n)  Space: O(1)   Hard
.Python/get-the-maximum-score.py


```python
# Time:  O(m + n)
# Space: O(1)

class Solution(object):
    def maxSum(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        MOD = 10**9+7
        i, j = 0, 0
        result, sum1, sum2 = 0, 0, 0,
        while i != len(nums1) or j != len(nums2):
            if i != len(nums1) and (j == len(nums2) or nums1[i] &lt; nums2[j]):
                sum1 += nums1[i]
                i += 1
            elif j != len(nums2) and (i == len(nums1) or nums1[i] &gt; nums2[j]):
                sum2 += nums2[j]
                j += 1
            else:
                result = (result + (max(sum1, sum2) + nums1[i])) % MOD
                sum1, sum2 = 0, 0
                i += 1
                j += 1
        return (result + max(sum1, sum2)) % MOD

```



----------------------------------------------------------------------------------------

### Math - 1551 - https://leetcode.com/problems/minimum-operations-to-make-array-equal/
Time: O(1)  Space: O(1)   Medium
.Python/minimum-operations-to-make-array-equal.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def minOperations(self, n):
        """
        :type n: int
        :rtype: int
        """
        # total = (2i+1 for i in xrange(n)) = n^2
        # left_half_total = (2i+1 for i in xrange(n//2)) = (n//2)^2
        # result = (n//2) * (total//n) - left_half_total = (n//2)*(n-n//2) = (n//2)*((n+1)//2)
        return (n//2)*((n+1)//2)

```



----------------------------------------------------------------------------------------

### Math - 1611 - https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/
Time: O(logn)  Space: O(1)   Hard
.Python/minimum-one-bit-operations-to-make-integers-zero.py


```python
# Time:  O(logn)
# Space: O(1)

# reference: https://en.wikipedia.org/wiki/Gray_code
class Solution(object):
    def minimumOneBitOperations(self, n):
        """
        :type n: int
        :rtype: int
        """
        def gray_to_binary(n):
            result = 0
            while n:
                result ^= n
                n &gt;&gt;= 1
            return result
        
        # [observation]
        # n    f(n)
        # 000    0
        # 001    1
        # 011    2
        # 010    3
        # 110    4
        # 111    5
        # 101    6
        # 100    7
	# f(0XX...X) + f(1XX...X) = f(100...0) implies n is a gray code
        # =&gt; f(n) is actually the inverse of gray code
        return gray_to_binary(n)


# Time:  O(logn)
# Space: O(1)
class Solution2(object):
    def minimumOneBitOperations(self, n):
        """
        :type n: int
        :rtype: int
        """
        # [observation1]:
        # f(1) = 1
        # f(10) = 2 * f(1) + 1 = 3
        # f(100) = 2 * f(10) + 1 = 7
        # by mathematical induction
        # =&gt; f(2^k) = 2^(k+1)-1
        #
        # [observation2]
        # n    f(n)
        # 000    0
        # 001    1
        # 011    2
        # 010    3
        # 110    4
        # 111    5
        # 101    6
        # 100    7
        # let pos be an array of positions where the bit is 1 in ascending order:
	# f(0XX...X) + f(1XX...X) = f(100...0)
        # f(1XX...X) = f(100...0) - f(0XX...X)
        #            = (2^(pos[k-1]+1)-1) - f(0XX...X)
        # by mathematical induction
        # =&gt; f(n) = (2^(pos[k-1]+1)-1) - (2^(pos[k-2])+1) + ... + (-1)^(k-1) * (2^(pos[0]+1)-1)
        result = 0
        while n:
            result = -result - (n^(n-1))  # 2^(pos[i]+1)-1
            n &amp;= n-1
        return abs(result)

```



----------------------------------------------------------------------------------------

### Math - 1641 - https://leetcode.com/problems/count-sorted-vowel-strings/
Time: O(1)  Space: O(1)   Medium
.Python/count-sorted-vowel-strings.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def countVowelStrings(self, n):
        """
        :type n: int
        :rtype: int
        """
        def nCr(n, r):  # Time: O(n), Space: O(1)
            if n-r &lt; r:
                return nCr(n, n-r)
            c = 1
            for k in xrange(1, r+1):
                c *= n-k+1
                c //= k
            return c
    
        return nCr(n+4, 4)  # H(5, n) = C(n+5-1, n) = C(n+4, 4)

```



----------------------------------------------------------------------------------------

### Math - 1643 - https://leetcode.com/problems/kth-smallest-instructions/
Time: O((m + n)^2)  Space: O(1)   Hard
.Python/kth-smallest-instructions.py


```python
# Time:  O((m + n)^2)
# Space: O(1)

class Solution(object):
    def kthSmallestPath(self, destination, k):
        """
        :type destination: List[int]
        :type k: int
        :rtype: str
        """
        def nCr(n, r):  # Time: O(n), Space: O(1)
            if n &lt; r:
                return 0
            if n-r &lt; r:
                return nCr(n, n-r)
            c = 1
            for k in xrange(1, r+1):
                c *= n-k+1
                c //= k
            return c

        r, c = destination        
        result = []
        while r+c:
            count = nCr(r+(c-1), r)  # the number of HX..X combinations
            if k &lt;= count:  # the kth instruction is one of HX..X combinations, so go right
                c -= 1
                result.append('H')
            else:  # the kth instruction is one of VX..X combinations, so go down
                k -= count  # the kth one of XX..X combinations is the (k-count)th one of VX..X combinations
                r -= 1
                result.append('V')
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Math - 1735 - https://leetcode.com/problems/count-ways-to-make-array-with-product/
Time: O(sqrt(m) + n + q * (logm + sqrt(m)/log(sqrt(m))))  Space: O(sqrt(m) + n + logm)   Hard
.Python/count-ways-to-make-array-with-product.py


```python
# Time:  O(sqrt(m) + n + q * (logm + sqrt(m)/log(sqrt(m)))), m is max(k for _, k in queries)
# Space: O(sqrt(m) + n + logm)

import collections


class Solution(object):
    def waysToFillArray(self, queries):
        """
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in xrange(3)]
        def nCr(n, k):
            while len(inv) &lt;= n:  # lazy initialization
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)
            primes = []
            spf = [-1]*(n+1)  # the smallest prime factor
            for i in xrange(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p &gt; n or p &gt; spf[i]:
                        break
                    spf[i*p] = p
            return primes

        def prime_factors(x):
            factors = collections.Counter()
            for p in primes:
                if x &lt; p:
                    break
                while x%p == 0:
                    factors[p] += 1
                    x //= p
            if x != 1:
                factors[x] += 1
            return factors

        primes = linear_sieve_of_eratosthenes(int(max(k for _, k in queries)**0.5))
        result = []
        for n, k in queries:
            total = 1
            for c in prime_factors(k).itervalues():
                total *= nCr(n+c-1, c)  # H(n, c) = nCr(n+c-1, n)
            result.append(total % MOD)
        return result

```



----------------------------------------------------------------------------------------

### Math - 1739 - https://leetcode.com/problems/building-boxes/
Time: O(1)  Space: O(1)   Hard
.Python/building-boxes.py


```python
# Time:  O(1)
# Space: O(1)

import math


class Solution(object):
    def minimumBoxes(self, n):
        """
        :type n: int
        :rtype: int
        """
        # find max h s.t. sum(k*(k+1)//2 for k in xrange(1, h+1)) &lt;= n
        # =&gt; find max h s.t. h*(h+1)*(h+2)//6 &lt;= n
        h = int((6*n)**(1.0/3))  
        if h*(h+1)*(h+2) &gt; 6*n:
            # (h-1)*h*(h+1) &lt; h^3 &lt;= 6n &lt; h*(h+1)*(h+2) &lt; (h+1)^3
            h -= 1
        n -= h*(h+1)*(h+2)//6
        d = int(math.ceil((-1+(1+8*n)**0.5)/2))  # find min d s.t. d*(d+1)//2 &gt;= n
        return h*(h+1)//2 + d

```



----------------------------------------------------------------------------------------

### Math - 1744 - https://leetcode.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/
Time: O(n)  Space: O(n)   Medium
.Python/can-you-eat-your-favorite-candy-on-your-favorite-day.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def canEat(self, candiesCount, queries):
        """
        :type candiesCount: List[int]
        :type queries: List[List[int]]
        :rtype: List[bool]
        """
        prefix = [0]*(len(candiesCount)+1)
        for i, c in enumerate(candiesCount):
            prefix[i+1] = prefix[i]+c
        return [prefix[t]//c &lt; d+1 &lt;= prefix[t+1]//1 for t, d, c in queries]

```



----------------------------------------------------------------------------------------

### Math - 1753 - https://leetcode.com/problems/maximum-score-from-removing-stones/
Time: O(1)  Space: O(1)   Medium
.Python/maximum-score-from-removing-stones.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def maximumScore(self, a, b, c):
        """
        :type a: int
        :type b: int
        :type c: int
        :rtype: int
        """
        # assumed c is the max size
        # case1: a+b &gt; c
        # =&gt; (a+b-c)//2 + c = (a+b+c)//2 &lt; a+b
        # case2: a+b &lt;= c
        # =&gt; a+b &lt;= (a+b+c)//2
        return min((a+b+c)//2, a+b+c - max(a, b, c))

```



----------------------------------------------------------------------------------------

### Math - 1776 - https://leetcode.com/problems/car-fleet-ii/
Time: O(n)  Space: O(n)   Hard
.Python/car-fleet-ii.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def getCollisionTimes(self, cars):
        """
        :type cars: List[List[int]]
        :rtype: List[float]
        """
        stk = []
        result = [-1.0]*len(cars)
        for i in reversed(xrange(len(cars))):
            p, s = cars[i]
            while stk and (cars[stk[-1]][1] &gt;= s or 
                           0 &lt; result[stk[-1]] &lt;= float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])):
                stk.pop()
            if stk:
                result[i] = float(cars[stk[-1]][0]-p)/(s-cars[stk[-1]][1])
            stk.append(i)
        return result

```



----------------------------------------------------------------------------------------

### Math - 1780 - https://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/
Time: O(logn)  Space: O(1)   Medium
.Python/check-if-number-is-a-sum-of-powers-of-three.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def checkPowersOfThree(self, n):
        """
        :type n: int
        :rtype: bool
        """
        while n &gt; 0:
            if n%3 == 2:
                return False
            n //= 3
        return True

```



----------------------------------------------------------------------------------------

### Math - 1806 - https://leetcode.com/problems/minimum-number-of-operations-to-reinitialize-a-permutation/
Time: O(sqrt(n))  Space: O(sqrt(n))   Medium
.Python/minimum-number-of-operations-to-reinitialize-a-permutation.py


```python
# Time:  O(sqrt(n))
# Space: O(sqrt(n))

class Solution(object):
    def reinitializePermutation(self, n):
        """
        :type n: int
        :rtype: int
        """
        # reference: https://cp-algorithms.com/algebra/discrete-log.html
        def discrete_log(a, b, m):
            a %= m
            b %= m
            n = int(m**0.5)+1
            an = pow(a, n, m)
            vals = {}
            curr = b
            for q in xrange(n+1):
                vals[curr] = q
                curr = curr*a % m
            curr = 1
            for p in xrange(1, n+1):
                curr = curr*an % m
                if curr in vals:
                    return n*p-vals[curr]
            return -1

        return 1+discrete_log(2, n//2, n-1)  # find min x s.t. 2^x mod (n-1) = n/2, result is x + 1


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def reinitializePermutation(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 2:
            return 1
        result, i = 0, 1
        while not result or i != 1:
            i = (i*2)%(n-1)
            result += 1
        return result


# Time:  O(n)
# Space: O(1)
class Solution3(object):
    def reinitializePermutation(self, n):
        """
        :type n: int
        :rtype: int
        """
        result, i = 0, 1
        while not result or i != 1:  # find cycle length
            i = (i//2 if not i%2 else n//2+(i-1)//2)
            result += 1
        return result

```



----------------------------------------------------------------------------------------

### Math - 1808 - https://leetcode.com/problems/maximize-number-of-nice-divisors/
Time: O(logn)  Space: O(1)   Medium
.Python/maximize-number-of-nice-divisors.py


```python
# Time:  O(logn)
# Space: O(1)

# variant of "343. integer break"
class Solution(object):
    def maxNiceDivisors(self, primeFactors):
        """
        :type primeFactors: int
        :rtype: int
        """
        # given a1 + a2 + ... + ak &lt;= n, find max of a1 * a2 * ... * ak 
        # =&gt; given a1 + a2 + ... + ak = n, find max of a1 * a2 * ... * ak 
        # =&gt; ai is either 3 or 2, see proof in "343. integer break"
        MOD = 10**9 + 7
        if primeFactors &lt;= 3:
            return primeFactors
        if primeFactors % 3 == 0:  # 6 =&gt; 3*3
            return pow(3, primeFactors//3, MOD)
        if primeFactors % 3 == 1:  # 4 =&gt; 2*2 
            return (2*2*pow(3, (primeFactors-4)//3, MOD)) % MOD
        return (2*pow(3, (primeFactors-2)//3, MOD)) % MOD  # 5 =&gt; 2*3

```



----------------------------------------------------------------------------------------

### Math - 1812 - https://leetcode.com/problems/determine-color-of-a-chessboard-square/
Time: O(1)  Space: O(1)   Easy
.Python/determine-color-of-a-chessboard-square.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def squareIsWhite(self, coordinates):
        """
        :type coordinates: str
        :rtype: bool
        """
        return (ord(coordinates[0])-ord('a'))%2 != (ord(coordinates[1])-ord('1'))%2

```



----------------------------------------------------------------------------------------

### Math - 1819 - https://leetcode.com/problems/number-of-different-subsequences-gcds/
Time: O(n + mlogm)  Space: O(n)   Hard
.Python/number-of-different-subsequences-gcds.py


```python
# Time:  O(n + m * (1 + 1/2 + 1/3 + ... + 1/m)) = O(n + mlogm), m is max of nums
# Space: O(n)

import fractions


class Solution(object):
    def countDifferentSubsequenceGCDs(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        max_num, nums_set = max(nums), set(nums)
        result = 0
        for i in xrange(1, max_num+1):
            d = 0
            for x in xrange(i, max_num+1, i):
                if x not in nums_set:
                    continue
                d = fractions.gcd(d, x)  # total time: O(log(min(d, x)) = O(logd), where d keeps the same or gets smaller
                if d == i:
                    result += 1
                    break
        return result

```



----------------------------------------------------------------------------------------

### Math - 1822 - https://leetcode.com/problems/sign-of-the-product-of-an-array/
Time: O(n)  Space: O(1)   Easy
.Python/sign-of-the-product-of-an-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def arraySign(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        flag = 0
        for x in nums:
            if not x:
                return 0
            if x &lt; 0:
                flag ^= 1
        return -1 if flag else 1

```



----------------------------------------------------------------------------------------

### Math - 1823 - https://leetcode.com/problems/find-the-winner-of-the-circular-game/
Time: O(n)  Space: O(1)   Medium
.Python/find-the-winner-of-the-circular-game.py


```python
# Time:  O(n)
# Space: O(1)

# bottom-up solution
class Solution(object):
    def findTheWinner(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: int
        """
        return reduce(lambda idx, n:(idx+k)%(n+1), xrange(1, n), 0)+1


# Time:  O(n)
# Space: O(n)
# top-down solution
class Solution2(object):
    def findTheWinner(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: int
        """
        def f(idx, n, k):
            if n == 1:
                return 0
            return (k+f((idx+k)%n, n-1, k))%n
        
        return f(0, n, k)+1

```



----------------------------------------------------------------------------------------

### Math - 1828 - https://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/
Time: O(q * n)  Space: O(1)   Medium
.Python/queries-on-number-of-points-inside-a-circle.py


```python
# Time:  O(q * n)
# Space: O(1)

class Solution(object):
    def countPoints(self, points, queries):
        """
        :type points: List[List[int]]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        result = []
        for i, j, r in queries:
            result.append(0)
            for x, y in points:
                if (x-i)**2+(y-j)**2 &lt;= r**2:
                    result[-1] += 1
        return result

```



----------------------------------------------------------------------------------------

### Math - 1830 - https://leetcode.com/problems/minimum-number-of-operations-to-make-string-sorted/
Time: O(n)  Space: O(max_n)   Hard
.Python/minimum-number-of-operations-to-make-string-sorted.py


```python
# Time:  O(26 * n) = O(n)
# Space: O(max_n) = O(max_n)

inv = [0, 1]


class Solution(object):
    def makeStringSorted(self, s):  # count of prev_permutation
        """
        :type s: str
        :rtype: int
        """
        def inverse(n, m):
            i = len(inv)
            while len(inv) &lt;= n:  # lazy initialization
                inv.append(inv[m%i]*(m-m//i) % m)  # https://cp-algorithms.com/algebra/module-inverse.html
                i += 1
            return inv[n]
    
        MOD = 10**9+7
        count, result, comb_total = [0]*26, 0, 1
        for i in reversed(xrange(len(s))):
            num = ord(s[i])-ord('a') 
            count[num] += 1
            comb_total = (comb_total*(len(s)-i))*inverse(count[num], MOD)
            result = (result + (comb_total*sum(count[:num]))*inverse(len(s)-i, MOD)) % MOD
        return result

```



----------------------------------------------------------------------------------------

### Math - 1835 - https://leetcode.com/problems/find-xor-sum-of-all-pairs-bitwise-and/
Time: O(n)  Space: O(1)   Hard
.Python/find-xor-sum-of-all-pairs-bitwise-and.py


```python
# Time:  O(n)
# Space: O(1)

import operator


class Solution(object):
    def getXORSum(self, arr1, arr2):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :rtype: int
        """
        return reduce(operator.xor, arr1) &amp; reduce(operator.xor, arr2)

```



----------------------------------------------------------------------------------------

### Math - 1837 - https://leetcode.com/problems/sum-of-digits-in-base-k/
Time: O(logn)  Space: O(1)   Easy
.Python/sum-of-digits-in-base-k.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def sumBase(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: int
        """
        result = 0
        while n:
            n, r = divmod(n, k)
            result += r
        return result

```



----------------------------------------------------------------------------------------

### Math - 1860 - https://leetcode.com/problems/incremental-memory-leak/
Time: O(1)  Space: O(1)   Medium
.Python/incremental-memory-leak.py


```python
# Time:  O(1)
# Space: O(1)

# Same problem from https://codingcompetitions.withgoogle.com/codejam/round/000000000019ffb9/00000000003384ea
class Solution(object):
    def memLeak(self, memory1, memory2):
        """
        :type memory1: int
        :type memory2: int
        :rtype: List[int]
        """
        def s(a, d, n):
            return (2*a + (n-1)*d)*n//2

        def f(a, d, x):
            r = int((-(2*a-d)+((2*a-d)**2+8*d*x)**0.5)/(2*d))
            if s(a, d, r) &gt; x:  # adjust float accuracy
                r -= 1
            return r

        is_swapped = False
        if memory1 &lt; memory2:
            memory1, memory2 = memory2, memory1
            is_swapped = True
        n = f(1, 1, memory1-memory2)
        memory1 -= s(1, 1, n)
        if memory1 == memory2:
            is_swapped = False
        l = f(n+1, 2, memory1)
        r = f(n+2, 2, memory2)
        memory1 -= s(n+1, 2, l)
        memory2 -= s(n+2, 2, r)
        if is_swapped:
            memory1, memory2 = memory2, memory1
        return [n+l+r+1, memory1, memory2]

```



----------------------------------------------------------------------------------------

### Math - 1862 - https://leetcode.com/problems/sum-of-floored-pairs/
Time: O(nlogn)  Space: O(n)   Hard
.Python/sum-of-floored-pairs.py


```python
# Time:  O(n/1+n/2+...+n/n) = O(nlogn), n is the max of nums
# Space: O(n)

import collections


class Solution(object):
    def sumOfFlooredPairs(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        MOD = 10**9+7
        prefix, counter = [0]*(max(nums)+1), collections.Counter(nums)
        for num, cnt in counter.iteritems():
            for j in xrange(num, len(prefix), num):
                prefix[j] += counter[num]
        for i in xrange(len(prefix)-1):
            prefix[i+1] += prefix[i]
        return reduce(lambda total, num: (total+prefix[num])%MOD, nums, 0)

```



----------------------------------------------------------------------------------------

### Math - 1863 - https://leetcode.com/problems/sum-of-all-subset-xor-totals/
Time: O(n)  Space: O(1)   Easy
.Python/sum-of-all-subset-xor-totals.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def subsetXORSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # given there are k (k &gt;= 1) nums of which ith bit is 1,
        # the bit contributes to sum is:
        # (nCr(k, 1) + nCr(k, 3) + ...) * (nCr(n - k, 0) + nCr(n - k, 1) + ...) * 2^i
        # = 2^(k-1) * 2^(n-k) = 2^(n-1) * 2^i
        result = 0
        for x in nums:
            result |= x
        return result * 2**(len(nums)-1)

```



----------------------------------------------------------------------------------------

### Math - 1884 - https://leetcode.com/problems/egg-drop-with-2-eggs-and-n-floors/
Time: O(1)  Space: O(1)   Medium
.Python/egg-drop-with-2-eggs-and-n-floors.py


```python
# Time:  O(1)
# Space: O(1)

import math


# see the proof: https://www.geeksforgeeks.org/puzzle-set-35-2-eggs-and-100-floors/
class Solution(object):
    def twoEggDrop(self, n):
        """
        :type n: int
        :rtype: int
        """
        return int(math.ceil((-1+(1+8*n)**0.5)/2))
    

# Time:  O(k * n^2)
# Space: O(n)
class Solution2(object):
    def twoEggDrop(self, n):
        """
        :type n: int
        :rtype: int
        """
        K = 2
        dp = [[float("inf") for j in xrange(n+1)] for _ in xrange(2)]
        dp[1] = [j for j in xrange(n+1)]
        for i in xrange(2, K+1):
            dp[i%2][0] = 0
            for j in xrange(1, n+1):
                for k in xrange(1, j+1):
                    dp[i%2][j] = min(dp[i%2][j], 1+max(dp[(i-1)%2][k-1], dp[i%2][j-k]))
        return dp[K%2][n]

```



----------------------------------------------------------------------------------------

### Math - 1904 - https://leetcode.com/problems/the-number-of-full-rounds-you-have-played/
Time: O(1)  Space: O(1)   Medium
.Python/the-number-of-full-rounds-you-have-played.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def numberOfRounds(self, startTime, finishTime):
        """
        :type startTime: str
        :type finishTime: str
        :rtype: int
        """
        h1, m1 = map(int, startTime.split(":"))
        h2, m2 = map(int, finishTime.split(":"))
        start = h1*60+m1
        finish = h2*60+m2
        if start &gt; finish:
            finish += 1440
        return max(finish//15-(start+15-1)//15, 0)


# Time:  O(1)
# Space: O(1)
class Solution2(object):
    def numberOfRounds(self, startTime, finishTime):
        """
        :type startTime: str
        :type finishTime: str
        :rtype: int
        """
        h1, m1 = map(int, startTime.split(":"))
        h2, m2 = map(int, finishTime.split(":"))
        if m1 &gt; m2:
            h2 -= 1
            m2 += 60
        return max((h2-h1)%24*4 + m2//15 - (m1+15-1)//15, 0)

```



----------------------------------------------------------------------------------------

### Math - 1916 - https://leetcode.com/problems/count-ways-to-build-rooms-in-an-ant-colony/
Time: O(n)  Space: O(n)   Hard
.Python/count-ways-to-build-rooms-in-an-ant-colony.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def waysToBuildRooms(self, prevRoom):
        """
        :type prevRoom: List[int]
        :rtype: int
        """
        MOD = 10**9+7
        fact = [1, 1]
        inv = [0, 1]
        inv_fact = [1, 1]
        def nCr(n, k):
            while len(inv) &lt;= n:  # lazy initialization
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def dfs(adj, curr):
            total_ways, total_cnt = 1, 0
            for child in adj[curr]:
                ways, cnt = dfs(adj, child)
                total_cnt += cnt
                total_ways = (((total_ways*ways) % MOD)*nCr(total_cnt, cnt)) % MOD
            return total_ways, total_cnt+1

        adj = [[] for _ in xrange(len(prevRoom))]
        for i in xrange(1, len(prevRoom)):
            adj[prevRoom[i]].append(i)
        return dfs(adj, 0)[0]

```



----------------------------------------------------------------------------------------

### Math - 1922 - https://leetcode.com/problems/count-good-numbers/
Time: O(logn)  Space: O(1)   Medium
.Python/count-good-numbers.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def countGoodNumbers(self, n):
        """
        :type n: int
        :rtype: int
        """
        def powmod(a, b, mod):
            a %= mod
            result = 1
            while b:
                if b&amp;1:
                    result = (result*a)%mod
                a = (a*a)%mod
                b &gt;&gt;= 1
            return result

        MOD = 10**9 + 7
        return powmod(5, (n+1)//2%(MOD-1), MOD)*powmod(4, n//2%(MOD-1), MOD) % MOD


# Time:  O(logn)
# Space: O(1)
class Solution2(object):
    def countGoodNumbers(self, n):
        """
        :type n: int
        :rtype: int
        """
        MOD = 10**9 + 7
        return pow(5, (n+1)//2%(MOD-1), MOD)*pow(4, n//2%(MOD-1), MOD) % MOD

```



----------------------------------------------------------------------------------------

### Math - 1945 - https://leetcode.com/problems/sum-of-digits-of-string-after-convert/
Time: O(n)  Space: O(1)   Easy
.Python/sum-of-digits-of-string-after-convert.py


```python
# Time:  O(n + logn + log(logn) + ...) = O(n)
# Space: O(1)

class Solution(object):
    def getLucky(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: int
        """
        total = reduce(lambda total, x: total+sum(divmod((ord(x)-ord('a')+1), 10)), s, 0)
        while k &gt; 1 and total &gt; 9:
            new_total = 0
            while total:
                total, x = divmod(total, 10)
                new_total += x
            total = new_total
            k -= 1
        return total

```



----------------------------------------------------------------------------------------

### Math - 1952 - https://leetcode.com/problems/three-divisors/
Time: O(sqrt(n))  Space: O(1)   Easy
.Python/three-divisors.py


```python
# Time:  O(sqrt(n))
# Space: O(1)

class Solution(object):
    def isThree(self, n):
        """
        :type n: int
        :rtype: bool
        """
        cnt = 0
        i = 1
        while i*i &lt;= n and cnt &lt;= 3:
            if n%i == 0:
                cnt += 1 if i*i == n else 2
            i += 1
        return cnt == 3

```



----------------------------------------------------------------------------------------

### Math - 1954 - https://leetcode.com/problems/minimum-garden-perimeter-to-collect-enough-apples/
Time: O(1)  Space: O(1)   Medium
.Python/minimum-garden-perimeter-to-collect-enough-apples.py


```python
# Time:  O(1)
# Space: O(1)

import math


class Solution(object):
    def minimumPerimeter(self, neededApples):
        """
        :type neededApples: int
        :rtype: int
        """
        # find min r, s.t. 4r^3+6r^2+2r-neededApples &gt;= 0
        # =&gt; by depressed cubic (https://en.wikipedia.org/wiki/Cubic_equation#Depressed_cubic)
        #    let x = r+(6/(3*4)), r = x-(1/2)
        #    4(x-(1/2))^3+6(x-(1/2))^2+2(x-(1/2))-neededApples
        #    = 4(x^3-3/2x^2+3/4x-1/8)
        #      + 6(x^2-x+1/4)
        #      + 2(x-1/2)
        #    = 4x^3-x-neededApples &gt;= 0
        #
        # find x, s.t. 4x^3-x-neededApples = 0 &lt;=&gt; x^3+(-1/4)x+(-neededApples/4) = 0
        # =&gt; by Cardano's formula (https://en.wikipedia.org/wiki/Cubic_equation#Cardano's_formula)
        #    x^3 + px + q = 0, p = (-1/4), q = (-neededApples/4)
        #    since (q/2)^2+(p/3)^3 = neededApples^2/64-1/1728 &gt; 0 =&gt; only one real root
        #    =&gt; x = (-q/2 + ((q/2)^2+(p/3)^3)^(1/2)) + (-q/2 - ((q/2)^2+(p/3)^3)^(1/2))
        #       r = x-(1/2)
        # =&gt; min r = ceil(r)

        a, b, c, d = 4.0, 6.0, 2.0, float(-neededApples)
        p = (3*a*c-b**2)/(3*a**2)  # -1/4.0
        q = (2*b**3-9*a*b*c+27*a**2*d)/(27*a**3)  # -neededApples/4.0
        assert((q/2)**2+(p/3)**3 &gt; 0)  # case of only one real root
        x = (-q/2 + ((q/2)**2+(p/3)**3)**0.5)**(1.0/3) + \
            (-q/2 - ((q/2)**2+(p/3)**3)**0.5)**(1.0/3)
        return 8*int(math.ceil(x - b/(3*a)))
                             

# Time:  O(1)
# Space: O(1)
class Solution2(object):
    def minimumPerimeter(self, neededApples):
        """
        :type neededApples: int
        :rtype: int
        """
        # r+r    , (r-1)+r, ..., 1+r, 0+r    , 1+r, ..., (r-1)+r, r+r
        # r+(r-1),                    0+(r-1),                    r+(r-1)
        #  .                           .                           .    
        #  .                           .                           .    
        #  .                           .                           .    
        # r+1    , (r-1)+1, ..., 1+1, 1+0    , 1+1, ..., (r-1)+1, r+1
        # r+0    , (r-1)+0, ..., 1+0, 0+0    , 1+0, ..., (r-1)+0, r+0
        # r+1    , (r-1)+1, ..., 1+1, 1+0    , 1+1, ..., (r-1)+1, r+1
        #  .                           .                           .    
        #  .                           .                           .    
        #  .                           .                           .       
        # r+(r-1),                    0+(r-1),                    r+(r-1)
        # r+r    , (r-1)+r, ..., 1+r, 0+r    , 1+r, ..., r+(r-1), r+r
        #
        # each up/down direction forms an arithmetic sequence, there are 2r+1 columns
        # =&gt; 2*(1+r)*r/2 * (2r+1)
        #
        # each left/right direction forms an arithmetic sequence, there are 2r+1 rows
        # =&gt; 2*(1+r)*r/2 * (2r+1)
        #
        # =&gt; total = 2 * 2*(1+r)*r/2 * (2r+1) = r*(2r+1)*(2r+2) = 4r^3+6r^2+2r
        # =&gt; find min r, s.t. (2r)(2r+1)*(2r+2) &gt;= 2*neededApples
        # =&gt; find min x = 2r+2, s.t. (x-2)(x-1)(x) &gt;= 2*neededApples

        x = int((2*neededApples)**(1.0/3))
        x -= x%2
        assert((x-2)*(x-1)*x &lt; 2*neededApples &lt; (x+2)**3)
        x += 2
        if (x-2)*(x-1)*x &lt; 2*neededApples:
            x += 2
        return 8*(x-2)//2


# Time:  O(logn)
# Space: O(1)
class Solution3(object):
    def minimumPerimeter(self, neededApples):
        """
        :type neededApples: int
        :rtype: int
        """
        # 2r  , 2r-1, ..., r+1, r  , r+1, ..., 2*r-1, 2*r
        # 2r-1,                 r-1,                  2r-1
        # .                     .                     .    
        # .                     .                     .    
        # .                     .                     .    
        # r+1 ,    r, ...,   2, 1  ,   2, ...,   r  , r+1
        # r   ,  r-1, ...,   1, 0  ,   1, ...,   r-1, r
        # r+1 ,    r, ...,   2, 1  ,   2, ...,   r  , r+1
        # .                     .                     .    
        # .                     .                     .    
        # .                     .                     .    
        # 2r-1,                 r-1,                  2r-1
        # 2r  , 2r-1, ..., r+1, r  , r+1, ..., 2*r-1, 2*r
        #
        # the sum of each row/col forms an arithmetic sequence
        # =&gt; let ai = (((r + (r-1) + ... + r + 0) + (0 + 1 + 2 + ... + r)) - 0) + i*(2r+1)
        #           = (2*(0+r)*(r+1)/2-0) + i*(2r+1)
        #           = r*(r+1) + i*(2r+1)
        # =&gt; total  = 2*(a0 + a1 + ... ar) - a0
        #           = 2*(r*(r+1) + r*(r+1) + r*(2r+1)))*(r+1)/2 - r*(r+1)
        #           = r*(4r+3)*(r+1)-r*(r+1)
        #           = 4r^3+6r^2+2r
        # =&gt; find min r, s.t. 4r^3+6r^2+2r &gt;= neededApples

        def check(neededApples, x):
            return r*(2*r+1)*(2*r+2) &gt;= neededApples

        left, right = 1, int((neededApples/4.0)**(1.0/3))
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(neededApples, mid):
                right = mid-1
            else:
                left = mid+1
        return 8*left

```



----------------------------------------------------------------------------------------

### Math - 1969 - https://leetcode.com/problems/minimum-non-zero-product-of-the-array-elements/
Time: O(min(p, logM))  Space: O(1)   Medium
.Python/minimum-non-zero-product-of-the-array-elements.py


```python
# Time:  O(min(p, logM))
# Space: O(1)

class Solution(object):
    def minNonZeroProduct(self, p):
        """
        :type p: int
        :rtype: int
        """
        MOD = 10**9+7

        # max_num = 2^p-1
        max_num_mod = (pow(2, p, MOD)-1)%MOD  # max_num % MOD

        # pair_product = max_num-1
        pair_product_mod = (max_num_mod-1)%MOD  # (max_num_mod-1) % MOD

        # since pair_product^MOD % MOD = pair_product_mod^MOD % MOD  = pair_product_mod
        # =&gt; pair_product_mod^(MOD-1) % MOD = 1
        # =&gt; pair_product_mod^(pair_cnt) % MOD = pair_product_mod^(pair_cnt%(MOD-1)) %MOD
        pair_cnt_mod_m_1 = (pow(2, p-1, MOD-1)-1) % (MOD-1)  # pair_cnt%(MOD-1)

        # the ans is:
        #   max_num * pair_product^pair_cnt % MOD
        # = max_num_mod * pair_product_mod^(pair_cnt_mod_m_1) % MOD
        return (max_num_mod*pow(pair_product_mod, pair_cnt_mod_m_1, MOD)) % MOD

```



----------------------------------------------------------------------------------------

### Math - 1979 - https://leetcode.com/problems/find-greatest-common-divisor-of-array/
Time: O(n)  Space: O(1)   Easy
.Python/find-greatest-common-divisor-of-array.py


```python
# Time:  O(n)
# Space: O(1)

import fractions


class Solution(object):
    def findGCD(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        return fractions.gcd(min(nums), max(nums))

```



----------------------------------------------------------------------------------------

### Math - 1980 - https://leetcode.com/problems/find-unique-binary-string/
Time: O(n)  Space: O(1)   Medium
.Python/find-unique-binary-string.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def findDifferentBinaryString(self, nums):
        """
        :type nums: List[str]
        :rtype: str
        """
        return "".join("01"[nums[i][i] == '0'] for i in xrange(len(nums)))


# Time:  O(k * n) = O(n^2), k is len(nums)
#                         , n is len(nums[0])
# Space: O(k) = O(n)
class Solution2(object):
    def findDifferentBinaryString(self, nums):
        """
        :type nums: List[str]
        :rtype: str
        """
        lookup = set(map(lambda x: int(x, 2), nums))  # Time: O(k * n) = O(n^2)
        return next(bin(i)[2:].zfill(len(nums[0])) for i in xrange(2**len(nums[0])) if i not in lookup)  # Time: O(k + n) = O(n)


# Time:  O(k * n + n * 2^n) = O(n * 2^n), k is len(nums)
#                                       , n is len(nums[0])
# Space: O(k) = O(1) ~ O(2^n)
class Solution_Extra(object):
    def findAllDifferentBinaryStrings(self, nums):
        """
        :type nums: List[str]
        :rtype: List[str]
        """
        lookup = set(map(lambda x: int(x, 2), nums))  # Time: O(k * n) = O(n * 2^n)
        return [bin(i)[2:].zfill(len(nums[0])) for i in xrange(2**len(nums[0])) if i not in lookup]  # Time: O(2^n + n * (2^n - k))

```



----------------------------------------------------------------------------------------

### Math - 1982 - https://leetcode.com/problems/find-array-given-subset-sums/
Time: O(n * 2^n)  Space: O(1)   Hard
.Python/find-array-given-subset-sums.py


```python
# Time:  O(n * 2^n), len(sums) = 2^n
# Space: O(1)

# [proof]
# - let d = sorted_sums[0]-sorted_sums[1] and d != -d (d = 0 is trival), where one of +d/-d is the smallest positive or largest negative number of the original solution of [S1, ..., S(2^n)]
# - given Sp-d = 0 for some p in [1, 2^n] and Sq-(-d) = 0 for some q in [1, 2^n]
#   assume d is a number of the original solution of [S1, ..., S(2^n)] (the proof where -d is a number of the original solution is vice versa)
#   let Sq = x1+...+xi where 1 &lt;= i &lt;= n-1
#   let [d]+[x1, ..., xi]+[x(i+1), ..., x(n-1)] be the original solution
#   =&gt; new_sums([S1, ..., S(2^n)], d)
#      = subset_sums([x1, ..., xi]+[x(i+1), ..., x(n-1)])
#   if we choose -d as a number of a solution of [S1, ..., S(2^n)]
#   =&gt; new_sums([S1, ..., S(2^n)], -d)
#      = new_sums([S1, ..., S(2^n)], -(x1+...+xi))
#      = subset_sums([(-x1), ..., (-xi)]+[x(i+1), ..., x(n-1)])
#      =&gt; [-d]+[(-x1), ..., (-xi)]+[x(i+1), ..., x(n-1)] is also a solution
#
# [conclusion]
# - if new_sums with +d/-d (including d = 0) both contain zero, we can choose either one
# - if only one of new_sums with +d/-d contains zero, we can only choose the one with zero since subset_sums must contain zero

# optimized from solution4 (not using dict), runtime: 1040 ms
class Solution(object):
    def recoverArray(self, n, sums):
        """
        :type n: int
        :type sums: List[int]
        :rtype: List[int]
        """
        sums.sort()  # Time: O(2^n * log(2^n)) = O(n * 2^n)
        shift, l = 0, len(sums)
        result = []
        for _ in xrange(n):  # log(2^n) times, each time costs O(2^(n-len(result))), Total Time: O(2^n)
            new_shift = sums[0]-sums[1]
            assert(new_shift &lt;= 0)
            has_zero, j, k = False, 0, 0
            for i in xrange(l):
                if k &lt; j and sums[k] == sums[i]:  # skip shifted one
                    k += 1
                else:
                    if shift == sums[i]-new_shift:
                        has_zero = True
                    sums[j] = sums[i]-new_shift
                    j += 1
            if has_zero:  # contain 0, choose this side
                result.append(new_shift)
            else:  # contain no 0, choose another side and shift 0 offset
                result.append(-new_shift)
                shift -= new_shift
            l //= 2
        return result


# Time:  O(2^n + n * r), len(sums) = 2^n
#                      , r = max(sums)-min(sums)
# Space: O(2^n + r)
import collections


# optimized from solution4 (not using dict), runtime: 968 ms
class Solution2(object):
    def recoverArray(self, n, sums):
        """
        :type n: int
        :type sums: List[int]
        :rtype: List[int]
        """
        min_sum, max_sum = min(sums), max(sums)
        dp = [0]*(max_sum-min_sum+1)
        for x in sums:
            dp[x-min_sum] += 1
        sorted_sums = [x for x in xrange(min_sum, max_sum+1) if dp[x-min_sum]]  # Time: O(r)
        shift = 0
        result = []
        for _ in xrange(n):  # log(2^n) times, each time costs O(2^(n-len(result)))+O(r), Total Time: O(2^n + n * r)
            new_dp = [0]*(max_sum-min_sum+1)
            new_sorted_sums = []
            new_shift = sorted_sums[0]-sorted_sums[1] if dp[sorted_sums[0]-min_sum] == 1 else 0
            assert(new_shift &lt;= 0)
            for x in sorted_sums:
                if not dp[x-min_sum]:
                    continue
                dp[(x-new_shift)-min_sum] -= dp[x-min_sum] if new_shift else dp[x-min_sum]//2
                new_dp[(x-new_shift)-min_sum] = dp[x-min_sum]
                new_sorted_sums.append(x-new_shift)
            dp = new_dp
            sorted_sums = new_sorted_sums
            if dp[shift-min_sum]:  # contain 0, choose this side
                result.append(new_shift)
            else:  # contain no 0, choose another side and shift 0 offset
                result.append(-new_shift)
                shift -= new_shift
        return result


# Time:  O(n * 2^n), len(sums) = 2^n
# Space: O(2^n)
import collections
import operator


# optimized from solution4, runtime: 1044 ms
class Solution3(object):
    def recoverArray(self, n, sums):
        """
        :type n: int
        :type sums: List[int]
        :rtype: List[int]
        """
        dp = {k: v for k, v in collections.Counter(sums).iteritems()}
        total = reduce(operator.ior, dp.itervalues(), 0)
        basis = total&amp;-total  # find rightmost bit 1
        if basis &gt; 1:
            for k in dp.iterkeys():
                dp[k] //= basis
        sorted_sums = sorted(dp.iterkeys())  # Time: O(2^n * log(2^n)) = O(n * 2^n)
        shift = 0
        result = [0]*(basis.bit_length()-1)
        for _ in xrange(n-len(result)):  # log(2^n) times, each time costs O(2^(n-len(result))), Total Time: O(2^n)
            new_dp = {}
            new_sorted_sums = []
            new_shift = sorted_sums[0]-sorted_sums[1]
            assert(new_shift &lt; 0)
            for x in sorted_sums:
                if not dp[x]:
                    continue
                dp[x-new_shift] -= dp[x]
                new_dp[x-new_shift] = dp[x]
                new_sorted_sums.append(x-new_shift)
            dp = new_dp
            sorted_sums = new_sorted_sums
            if shift in dp:  # contain 0, choose this side
                result.append(new_shift)
            else:  # contain no 0, choose another side and shift 0 offset
                result.append(-new_shift)
                shift -= new_shift
        return result


# Time:  O(n * 2^n), len(sums) = 2^n
# Space: O(2^n)
import collections


# optimized from solution4 (not using OrderedDict), runtime: 1024 ms
class Solution4(object):
    def recoverArray(self, n, sums):
        """
        :type n: int
        :type sums: List[int]
        :rtype: List[int]
        """
        dp = {k: v for k, v in collections.Counter(sums).iteritems()}
        sorted_sums = sorted(dp.iterkeys())  # Time: O(2^n * log(2^n)) = O(n * 2^n)
        shift = 0
        result = []
        for _ in xrange(n):  # log(2^n) times, each time costs O(2^(n-len(result))), Total Time: O(2^n)
            new_dp = {}
            new_sorted_sums = []
            new_shift = sorted_sums[0]-sorted_sums[1] if dp[sorted_sums[0]] == 1 else 0
            assert(new_shift &lt;= 0)
            for x in sorted_sums:
                if not dp[x]:
                    continue
                dp[x-new_shift] -= dp[x] if new_shift else dp[x]//2
                new_dp[x-new_shift] = dp[x]
                new_sorted_sums.append(x-new_shift)
            dp = new_dp
            sorted_sums = new_sorted_sums
            if shift in dp:  # contain 0, choose this side
                result.append(new_shift)
            else:  # contain no 0, choose another side and shift 0 offset
                result.append(-new_shift)
                shift -= new_shift
        return result


# Time:  O(n * 2^n), len(sums) = 2^n
# Space: O(2^n)
import collections


# runtime: 1720 ms
class Solution5(object):
    def recoverArray(self, n, sums):
        """
        :type n: int
        :type sums: List[int]
        :rtype: List[int]
        """
        dp = OrderedDict(sorted(collections.Counter(sums).iteritems()))  # Time: O(2^n * log(2^n)) = O(n * 2^n)
        shift = 0
        result = []
        for _ in xrange(n):  # log(2^n) times, each time costs O(2^(n-len(result))), Total Time: O(2^n)
            new_dp = OrderedDict()
            it = iter(dp)
            min_sum = next(it)
            new_shift = min_sum-next(it) if dp[min_sum] == 1 else 0
            assert(new_shift &lt;= 0)
            for x in dp.iterkeys():
                if not dp[x]:
                    continue
                dp[x-new_shift] -= dp[x] if new_shift else dp[x]//2
                new_dp[x-new_shift] = dp[x]
            dp = new_dp
            if shift in dp:  # contain 0, choose this side
                result.append(new_shift)
            else:  # contain no 0, choose another side and shift 0 offset
                result.append(-new_shift)
                shift -= new_shift
        return result

```



----------------------------------------------------------------------------------------

### Math - 2001 - https://leetcode.com/problems/number-of-pairs-of-interchangeable-rectangles/
Time: O(n)  Space: O(n)   Medium
.Python/number-of-pairs-of-interchangeable-rectangles.py


```python
# Time:  O(n)
# Space: O(n)

import collections
import fractions


class Solution(object):
    def interchangeableRectangles(self, rectangles):
        """
        :type rectangles: List[List[int]]
        :rtype: int
        """
        count = collections.defaultdict(int)
        for w, h in rectangles:
            g = fractions.gcd(w, h)  # Time: O(logx) ~= O(1)
            count[(w//g, h//g)] += 1
        return sum(c*(c-1)//2 for c in count.itervalues())

```



----------------------------------------------------------------------------------------

### Math - 2005 - https://leetcode.com/problems/subtree-removal-game-with-fibonacci-tree/
Time: O(1)  Space: O(1)   Hard
.Python/subtree-removal-game-with-fibonacci-tree.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def findGameWinner(self, n):
        """
        :type n: int
        :rtype: bool
        """ 
        # a pattern appears every 6 grundy numbers in binary forms:
        # 0000,       (0000)01,       (0000)11,                 ((0000)^(0000+1))10,       (0000)11,       (0000)11
        # 0000,     (0000+1)01,     (0000+1)11,           ((0000+1)^((0000+1)+1))10,     (0000+1)11,     (0000+1)11
        # 0000, ((0000+1)+1)01, ((0000+1)+1)11,   (((0000+1)+1)^(((0000+1)+1)+1))10, ((0000+1)+1)11, ((0000+1)+1)11
        # ...
        # 0000,       (XXXX)01,       (XXXX)11,                 ((XXXX)^(XXXX+1))10,       (XXXX)11,       (XXXX)11
        # 0000,     (XXXX+1)01,     (XXXX+1)11,           ((XXXX+1)^((XXXX+1)+1))10,     (XXXX+1)11,     (XXXX+1)11
        # =&gt; grundy[6k+1] = 0
        #    grundy[6k+2] = 4k+1
        #    grundy[6k+3] = 4k+3
        #    grundy[6k+4] = 4(k^(k+1))+2
        #    grundy[6k+5] = 4k+3
        #    grundy[6k+6] = 4k+3
        return n%6 != 1


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def findGameWinner(self, n):
        """
        :type n: int
        :rtype: bool
        """ 
        grundy = [0, 1]  # 0-indexed
        for i in xrange(2, n):
            grundy[i%2] = (grundy[(i-1)%2]+1)^(grundy[(i-2)%2]+1)  # colon principle, replace the branches by a non-branching stalk of length equal to their nim sum
        return grundy[(n-1)%2] &gt; 0

```



----------------------------------------------------------------------------------------

### Math - 2028 - https://leetcode.com/problems/find-missing-observations/
Time: O(n)  Space: O(1)   Medium
.Python/find-missing-observations.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def missingRolls(self, rolls, mean, n):
        """
        :type rolls: List[int]
        :type mean: int
        :type n: int
        :rtype: List[int]
        """
        MAX_V = 6
        MIN_V = 1
        total = sum(rolls)
        missing = mean*(n+len(rolls))-total
        if missing &lt; MIN_V*n or missing &gt; MAX_V*n:
            return []
        q, r = divmod(missing, n)
        return [q+int(i &lt; r) for i in xrange(n)]


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def missingRolls(self, rolls, mean, n):
        """
        :type rolls: List[int]
        :type mean: int
        :type n: int
        :rtype: List[int]
        """
        MAX_V = 6
        MIN_V = 1
        total = sum(rolls)
        missing = mean*(n+len(rolls))-total
        if missing &lt; MIN_V*n or missing &gt; MAX_V*n:
            return []
        q, r = divmod(missing-MIN_V*n, (MAX_V-MIN_V))
        return [MAX_V if i &lt; q else MIN_V+r if i == q else MIN_V  for i in xrange(n)]

```



----------------------------------------------------------------------------------------

### Math - 2029 - https://leetcode.com/problems/stone-game-ix/
Time: O(n)  Space: O(1)   Medium
.Python/stone-game-ix.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def stoneGameIX(self, stones):
        """
        :type stones: List[int]
        :rtype: bool
        """
        count = collections.Counter(x%3 for x in stones)
        if count[0]%2 == 0:
            # iff both counts are not zero, then alice takes the least one at first, the remains are deterministic for bob to lose:
            # - assumed count[1] is the least one:
            #   1(,1,2)*,2,(,2)* =&gt; bob loses
            #            ^
            # - assumed count[2] is the least one:
            #   2(,2,1)*,1,(,1)* =&gt; bob loses
            #            ^
            return count[1] and count[2]
        # iff abs(count[1] - count[2]) &gt;= 3, then alice takes the most one at first, the remains are deterministic for bob to lose:
        # - assumed count[1] is the most one
        #   1(,1,2)*,0,1(,2,1)*,1,(,1)* =&gt; bob loses
        #                       ^
        #   1(,1,2)*,1,0,1,(,1)* =&gt; bob loses
        #                ^
        # - assumed count[2] is the most one
        #   2(,2,1)*,0,2(,1,2)*,2,(,2)* =&gt; bob loses
        #                       ^
        #   2(,2,1)*,2,0,2,(,2)* =&gt; bob loses
        #                ^
        return abs(count[1]-count[2]) &gt;= 3

```



----------------------------------------------------------------------------------------

### Math - 2063 - https://leetcode.com/problems/vowels-of-all-substrings/
Time: O(n)  Space: O(1)   Medium
.Python/vowels-of-all-substrings.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countVowels(self, word):
        """
        :type word: str
        :rtype: int
        """
        VOWELS = set("aeiou")
        return sum((i-0+1) * ((len(word)-1)-i+1) for i, c in enumerate(word) if c in VOWELS)

```



----------------------------------------------------------------------------------------

### Math - 2073 - https://leetcode.com/problems/time-needed-to-buy-tickets/
Time: O(n)  Space: O(1)   Easy
.Python/time-needed-to-buy-tickets.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def timeRequiredToBuy(self, tickets, k):
        """
        :type tickets: List[int]
        :type k: int
        :rtype: int
        """
        return sum(min(x, tickets[k] if i &lt;= k else tickets[k]-1) for i, x in enumerate(tickets))

```



----------------------------------------------------------------------------------------

### Math - 2083 - https://leetcode.com/problems/substrings-that-begin-and-end-with-the-same-letter/
Time: O(n)  Space: O(1)   Medium
.Python/substrings-that-begin-and-end-with-the-same-letter.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def numberOfSubstrings(self, s):
        """
        :type s: str
        :rtype: int
        """
        result = 0
        cnt = collections.Counter()
        for c in s:
            cnt[c] += 1
            result += cnt[c]
        return result


# Time:  O(n)
# Space: O(1)
import collections


class Solution(object):
    def numberOfSubstrings(self, s):
        """
        :type s: str
        :rtype: int
        """
        return sum(v*(v+1)//2 for v in collections.Counter(s).itervalues())

```



----------------------------------------------------------------------------------------

### Math - 2091 - https://leetcode.com/problems/removing-minimum-and-maximum-from-array/
Time: O(n)  Space: O(1)   Medium
.Python/removing-minimum-and-maximum-from-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minimumDeletions(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        i, j = nums.index(min(nums)), nums.index(max(nums))
        if i &gt; j:
            i, j = j, i
        return min((i+1)+(len(nums)-j), j+1, len(nums)-i)

```



----------------------------------------------------------------------------------------

### Math - 2110 - https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-smooth-descent-periods-of-a-stock.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def getDescentPeriods(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        result = l = 0
        for i in xrange(len(prices)):
            l += 1
            if i+1 == len(prices) or prices[i]-1 != prices[i+1]:
                result += l*(l+1)//2
                l = 0
        return result

```



----------------------------------------------------------------------------------------

### Math - 2117 - https://leetcode.com/problems/abbreviating-the-product-of-a-range/
Time: O(r - l)  Space: O(1)   Hard
.Python/abbreviating-the-product-of-a-range.py


```python
# Time:  O(r - l)
# Space: O(1)

import math


class Solution(object):
    def abbreviateProduct(self, left, right):
        """
        :type left: int
        :type right: int
        :rtype: str
        """
        PREFIX_LEN = SUFFIX_LEN = 5
        MOD = 10**(PREFIX_LEN+SUFFIX_LEN)
        curr, zeros = 1, 0
        abbr = False
        for i in xrange(left, right+1):
            curr *= i
            while not curr%10:
                curr //= 10
                zeros += 1
            q, curr = divmod(curr, MOD)
            if q:
                abbr = True
        if not abbr:
            return "%se%s" % (curr, zeros)
        decimal = reduce(lambda x, y: (x+y)%1, (math.log10(i) for i in xrange(left, right+1)))
        prefix = str(int(10**(decimal+(PREFIX_LEN-1))))
        suffix = str(curr % 10**SUFFIX_LEN).zfill(SUFFIX_LEN)
        return "%s...%se%s" % (prefix, suffix, zeros)

```



----------------------------------------------------------------------------------------

### Math - 2119 - https://leetcode.com/problems/a-number-after-a-double-reversal/
Time: O(1)  Space: O(1)   Easy
.Python/a-number-after-a-double-reversal.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def isSameAfterReversals(self, num):
        """
        :type num: int
        :rtype: bool
        """
        return num == 0 or num%10

```



----------------------------------------------------------------------------------------

### Math - 2125 - https://leetcode.com/problems/number-of-laser-beams-in-a-bank/
Time: O(m * n)  Space: O(1)   Medium
.Python/number-of-laser-beams-in-a-bank.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def numberOfBeams(self, bank):
        """
        :type bank: List[str]
        :rtype: int
        """
        result = prev = 0
        for x in bank:
            cnt = x.count('1')
            if not cnt:
                continue
            result += prev*cnt
            prev = cnt
        return result

```



----------------------------------------------------------------------------------------

### Math - 2133 - https://leetcode.com/problems/check-if-every-row-and-column-contains-all-numbers/
Time: O(n^2)  Space: O(n)   Easy
.Python/check-if-every-row-and-column-contains-all-numbers.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def checkValid(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: bool
        """
        return all(len(set(row)) == len(matrix) for row in matrix) and all(len(set(matrix[i][j] for i in xrange(len(matrix)))) == len(matrix) for j in xrange(len(matrix[0])))


# Time:  O(n^2)
# Space: O(1)
# [[1,3,3,4,4],[4,1,3,3,4],[4,4,1,3,3],[3,4,4,1,3],[3,3,4,4,1]]
class Solution_Wrong(object):
    def checkValid(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: bool
        """
        return all(reduce(lambda x, y: x^y, (matrix[i][j]^(j+1) for j in xrange(len(matrix[0])))) == 0 for i in xrange(len(matrix))) and \
               all(reduce(lambda x, y: x^y, (matrix[i][j]^(i+1) for i in xrange(len(matrix)))) == 0 for j in xrange(len(matrix[0])))

```



----------------------------------------------------------------------------------------

### Math - 2145 - https://leetcode.com/problems/count-the-hidden-sequences/
Time: O(n)  Space: O(1)   Medium
.Python/count-the-hidden-sequences.py


```python
# Time:  O(n)
# Space: O(1)

# math
class Solution(object):
    def numberOfArrays(self, differences, lower, upper):
        """
        :type differences: List[int]
        :type lower: int
        :type upper: int
        :rtype: int
        """
        total = mn = mx = 0
        for x in differences:
            total += x
            mn = min(mn, total)
            mx = max(mx, total)
        return max((upper-lower)-(mx-mn)+1, 0)

```



----------------------------------------------------------------------------------------

### Math - 2148 - https://leetcode.com/problems/count-elements-with-strictly-smaller-and-greater-elements/
Time: O(n)  Space: O(1)   Easy
.Python/count-elements-with-strictly-smaller-and-greater-elements.py


```python
# Time:  O(n)
# Space: O(1)

# math
class Solution(object):
    def countElements(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        mn = min(nums)
        mx = max(nums)
        return sum(mn &lt; x &lt; mx for x in nums)

```



----------------------------------------------------------------------------------------

### Math - 2152 - https://leetcode.com/problems/minimum-number-of-lines-to-cover-points/
Time: O(n * 2^n)  Space: O(n^2)   Medium
.Python/minimum-number-of-lines-to-cover-points.py


```python
# Time:  O(n^2 + n*2^n) = O(n*2^n)
# Space: O(n^2)

import collections


# math, hash table, bitmasks
class Solution(object):
    def minimumLines(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        def gcd(a, b):  # Time: O(log(a + b))
            while b:
                a, b = b, a % b
            return a

        def popcount(x):
            result = 0
            while x:
                x &amp;= (x-1)
                result += 1
            return result

        def ceil_divide(a, b):
            return (a+b-1)//b
        
        lookup = collections.defaultdict(set)               
        for i, (x1, y1) in enumerate(points):
            for j in xrange(i+1, len(points)):
                x2, y2 = points[j]
                # (x-x1)/(x2-x1) = (y-y1)/(y2-y1)
                # =&gt; (y2-y1)x - (x2-x1)y = x1(y2-y1) - y1(x2-x1)
                a, b, c = (y2-y1), -(x2-x1), x1*(y2-y1)-y1*(x2-x1) 
                g = gcd(gcd(a, b), c)
                a, b, c = a//g, b//g, c//g
                lookup[(a, b, c)].add((x1, y1))
                lookup[(a, b, c)].add((x2, y2))
        lines = [l for l, p in lookup.iteritems() if len(p) &gt; 2]  # filter to improve complexity
        assert(len(lines) &lt;= (len(points))//2)  # 1 extra colinear point per 2 points
        result = float("inf")
        for mask in xrange(1&lt;&lt;len(lines)):
            covered = set()
            bit, i = 1, 0
            while bit &lt;= mask:
                if mask&amp;bit:
                    covered.update(lookup[lines[i]])
                bit &lt;&lt;= 1                        
                i += 1
            result = min(result, popcount(mask) + ceil_divide(len(points)-len(covered), 2))
        return result

```



----------------------------------------------------------------------------------------

### Math - 2169 - https://leetcode.com/problems/count-operations-to-obtain-zero/
Time: O(log(min(m, n)))  Space: O(1)   Easy
.Python/count-operations-to-obtain-zero.py


```python
# Time:  O(log(min(m, n)))
# Space: O(1)

# gcd-like solution
class Solution(object):
    def countOperations(self, num1, num2):
        """
        :type num1: int
        :type num2: int
        :rtype: int
        """
        result = 0
        while num2:
            result += num1//num2
            num1, num2 = num2, num1%num2
        return result

```



----------------------------------------------------------------------------------------

### Math - 2171 - https://leetcode.com/problems/removing-minimum-number-of-magic-beans/
Time: O(nlogn)  Space: O(1)   Medium
.Python/removing-minimum-number-of-magic-beans.py


```python
# Time:  O(nlogn)
# Space: O(1)

# math
class Solution(object):
    def minimumRemoval(self, beans):
        """
        :type beans: List[int]
        :rtype: int
        """
        beans.sort()
        return sum(beans) - max(x*(len(beans)-i)for i, x in enumerate(beans))

```



----------------------------------------------------------------------------------------

### Math - 2176 - https://leetcode.com/problems/count-equal-and-divisible-pairs-in-an-array/
Time: O(nlogk + n * sqrt(k))  Space: O(n + sqrt(k))   Easy
.Python/count-equal-and-divisible-pairs-in-an-array.py


```python
# Time:  O(nlogk + n * sqrt(k))
# Space: O(n + sqrt(k)), number of factors of k is at most sqrt(k)

import collections


# math, number theory
class Solution(object):
    def countPairs(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def gcd(x, y):
            while y:
                x, y = y, x%y
            return x
    
        idxs = collections.defaultdict(list)
        for i, x in enumerate(nums):
            idxs[x].append(i)
        result = 0
        for idx in idxs.itervalues():
            gcds = collections.Counter()
            for i in idx:
                gcd_i = gcd(i, k)
                result += sum(cnt for gcd_j, cnt in gcds.iteritems() if gcd_i*gcd_j%k == 0)
                gcds[gcd_i] += 1
        return result


# Time:  O(nlogk + n * sqrt(k)^2) = O(n * k)
# Space: O(n * sqrt(k)), number of factors of k is at most sqrt(k)
import collections


# math, number theory
class Solution2(object):
    def countPairs(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def gcd(x, y):
            while y:
                x, y = y, x%y
            return x
    
        cnts = collections.defaultdict(collections.Counter)
        for i, x in enumerate(nums):
            cnts[x][gcd(i, k)] += 1
        result = 0
        for cnt in cnts.itervalues():
            for x in cnt.iterkeys():
                for y in cnt.iterkeys():
                    if x &gt; y or x*y%k:
                        continue
                    result += cnt[x]*cnt[y] if x != y else cnt[x]*(cnt[x]-1)//2
        return result


# Time:  O(n^2)
# Space: O(n)
import collections


# brute force
class Solution3(object):
    def countPairs(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        idxs = collections.defaultdict(list)
        for i, x in enumerate(nums):
            idxs[x].append(i)
        return sum(idx[i]*idx[j]%k == 0 for idx in idxs.itervalues() for i in xrange(len(idx)) for j in xrange(i+1, len(idx)))

```



----------------------------------------------------------------------------------------

### Math - 2177 - https://leetcode.com/problems/find-three-consecutive-integers-that-sum-to-a-given-number/
Time: O(1)  Space: O(1)   Medium
.Python/find-three-consecutive-integers-that-sum-to-a-given-number.py


```python
# Time:  O(1)
# Space: O(1)

# math
class Solution(object):
    def sumOfThree(self, num):
        """
        :type num: int
        :rtype: List[int]
        """
        return [num//3-1, num//3, num//3+1] if num%3 == 0 else []

```



----------------------------------------------------------------------------------------

### Math - 2180 - https://leetcode.com/problems/count-integers-with-even-digit-sum/
Time: O(logn)  Space: O(1)   Easy
.Python/count-integers-with-even-digit-sum.py


```python
# Time:  O(logn)
# Space: O(1)

# math
class Solution(object):
    def countEven(self, num):
        """
        :type num: int
        :rtype: int
        """
        def parity(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result%2

        return (num-parity(num))//2


# Time:  O(nlogn)
# Space: O(1)
# brute force
class Solution2(object):
    def countEven(self, num):
        """
        :type num: int
        :rtype: int
        """
        def parity(x):
            result = 0
            while x:
                result += x%10
                x //= 10
            return result%2

        return sum(parity(x) == 0 for x in xrange(1, num+1))


# Time:  O(nlogn)
# Space: O(logn)
# brute force
class Solution3(object):
    def countEven(self, num):
        """
        :type num: int
        :rtype: int
        """
        return sum(sum(map(int, str(x)))%2 == 0 for x in xrange(1, num+1))

```



----------------------------------------------------------------------------------------

### Math - 2183 - https://leetcode.com/problems/count-array-pairs-divisible-by-k/
Time: O(nlogk + k)  Space: O(sqrt(k))   Hard
.Python/count-array-pairs-divisible-by-k.py


```python
# Time:  O(nlogk + sqrt(k)^2) = O(nlogk + k)
# Space: O(sqrt(k)), number of factors of k is at most sqrt(k)

import collections


# math, number theory
class Solution(object):
    def countPairs(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def gcd(x, y):
            while y:
                x, y = y, x%y
            return x
    
        cnt = collections.Counter()
        for x in nums:
            cnt[gcd(x, k)] += 1
        result = 0
        for x in cnt.iterkeys():
            for y in cnt.iterkeys():
                if x &gt; y or x*y%k:
                    continue
                result += cnt[x]*cnt[y] if x != y else cnt[x]*(cnt[x]-1)//2
        return result


# Time:  O(nlogk + n * sqrt(k))
# Space: O(sqrt(k)), number of factors of k is at most sqrt(k)
import collections


# math, number theory
class Solution2(object):
    def countPairs(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def gcd(x, y):
            while y:
                x, y = y, x%y
            return x

        result = 0
        gcds = collections.Counter()
        for x in nums:
            gcd_i = gcd(x, k)
            result += sum(cnt for gcd_j, cnt in gcds.iteritems() if gcd_i*gcd_j%k == 0)
            gcds[gcd_i] += 1
        return result

```



----------------------------------------------------------------------------------------

### Math - 2198 - https://leetcode.com/problems/number-of-single-divisor-triplets/
Time: O(d^3)  Space: O(d)   Medium
.Python/number-of-single-divisor-triplets.py


```python
# Time:  O(d^3), d is the number of distinct nums
# Space: O(d)

import collections
import itertools

# combinatorics
class Solution(object):
    def singleDivisorTriplet(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def check(a, b, c):
            return sum((a+b+c)%x == 0 for x in (a, b, c)) == 1

        cnt = collections.Counter(nums)
        return 6*(sum(cnt[a]*cnt[b]*cnt[c] for a, b, c in itertools.combinations(cnt.keys(), 3) if check(a, b, c)) +
                  sum(cnt[a]*(cnt[a]-1)//2*cnt[b] for a, b in itertools.permutations(cnt.keys(), 2) if check(a, a, b)))

```



----------------------------------------------------------------------------------------

### Math - 2217 - https://leetcode.com/problems/find-palindrome-with-fixed-length/
Time: O(n * l)  Space: O(1)   Medium
.Python/find-palindrome-with-fixed-length.py


```python
# Time:  O(n * l)
# Space: O(1)

# math
class Solution(object):
    def kthPalindrome(self, queries, intLength):
        """
        :type queries: List[int]
        :type intLength: int
        :rtype: List[int]
        """
        def reverse(x):
            result = 0
            while x:
                result = result*10+x%10
                x //= 10
            return result

        def f(l, x):
            x = 10**((l-1)//2)+(x-1)
            if x &gt; 10**((l+1)//2)-1:
                return -1
            return x*10**(l//2)+reverse(x//10 if l%2 else x)

        return [f(intLength, x) for x in queries]


# Time:  O(n * l)
# Space: O(l)
# math
class Solution2(object):
    def kthPalindrome(self, queries, intLength):
        """
        :type queries: List[int]
        :type intLength: int
        :rtype: List[int]
        """
        def f(l, x):
            if 10**((l-1)//2)+(x-1) &gt; 10**((l+1)//2)-1:
                return -1
            s = str(10**((l-1)//2)+(x-1))
            return int(s+s[::-1][l%2:])

        return [f(intLength, x) for x in queries]

```



----------------------------------------------------------------------------------------

### Math - 2221 - https://leetcode.com/problems/find-triangular-sum-of-an-array/
Time: O(n)  Space: O(1)   Medium
.Python/find-triangular-sum-of-an-array.py


```python
# Time:  O(n)
# Space: O(1)

# combinatorics, number theory
class Solution(object):
    def triangularSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def exp_mod(p, mod):
            result = [p]
            while result[-1]*p%10 != result[0]:
                 result.append(result[-1]*p%10)
            return [result[-1]]+result[:-1]

        def inv_mod(x, mod):
            y = x
            while y*x%10 != 1:
                y = y*x%10
            return y

        def factor_p(x, p, cnt, diff):
            if x == 0:
                return x, cnt
            while x%p == 0:
                x //= p
                cnt += diff
            return x, cnt
    
        EXP = {p:exp_mod(p, 10) for p in (2, 5)}  # {2:[6, 2, 4, 8], 5:[5]}           
        INV = {i:inv_mod(i, 10) for i in xrange(1, 10) if i%2 and i%5}  # {1:1, 3:7, 7:3, 9:9}
        result = 0
        nCr = 1
        cnt = {2:0, 5:0}
        for i in xrange(len(nums)):
            if not cnt[2] and not cnt[5]:
                result = (result + nCr*nums[i])%10
            elif cnt[2] and not cnt[5]:
                result = (result + nCr*EXP[2][cnt[2]%len(EXP[2])]*nums[i])%10
            elif not cnt[2] and cnt[5]:
                result = (result + nCr*EXP[5][cnt[5]%len(EXP[5])]*nums[i])%10
            mul, cnt[2] = factor_p((len(nums)-1)-i, 2, cnt[2], 1)
            mul, cnt[5] = factor_p(mul, 5, cnt[5], 1)
            div, cnt[2] = factor_p(i+1, 2, cnt[2], -1)
            div, cnt[5] = factor_p(div, 5, cnt[5], -1)
            nCr = nCr*mul%10
            nCr = nCr*INV[div%10]%10
        return result

    
# Time:  O(n^2)
# Space: O(n)
# combinatorics
class Solution2(object):
    def triangularSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = 0
        nCr = 1
        for i in xrange(len(nums)):
            result = (result+nCr*nums[i])%10
            nCr *= (len(nums)-1)-i
            nCr //= i+1
        return result


# Time:  O(n^2)
# Space: O(1)
# simulation
class Solution3(object):
    def triangularSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        for i in reversed(xrange(len(nums))):
            for j in xrange(i):
                nums[j] = (nums[j]+nums[j+1])%10
        return nums[0]

```



----------------------------------------------------------------------------------------

### Math - 2235 - https://leetcode.com/problems/add-two-integers/
Time: O(1)  Space: O(1)   Easy
.Python/add-two-integers.py


```python
# Time:  O(1)
# Space: O(1)

# math
class Solution(object):
    def sum(self, num1, num2):
        """
        :type num1: int
        :type num2: int
        :rtype: int
        """
        return num1+num2

```



----------------------------------------------------------------------------------------

### Math - 2240 - https://leetcode.com/problems/number-of-ways-to-buy-pens-and-pencils/
Time: O(sqrt(t))  Space: O(1)   Medium
.Python/number-of-ways-to-buy-pens-and-pencils.py


```python
# Time:  O(min(t / c1, c2 / g)) = O(sqrt(t)), c1 = max(cost1, cost2)
#                                           , c2 = min(cost1, cost2)
#                                           ,  g = gcd(c1, c2)
# Space: O(1)

# math
class Solution(object):
    def waysToBuyPensPencils(self, total, cost1, cost2):
        """
        :type total: int
        :type cost1: int
        :type cost2: int
        :rtype: int
        """
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a
        
        def ceil_divide(a, b):
            return (a+b-1)//b

        def arithmetic_progression_sum(a, d, l):
            return (a+(a+(l-1)*d))*l//2
            
        if cost1 &lt; cost2:
            cost1, cost2 = cost2, cost1
        lcm = cost1*cost2//gcd(cost1, cost2)
        result = 0
        d = lcm//cost2
        for i in xrange(min(total//cost1+1, lcm//cost1)):
            # total, cost1, cost2 = 120, 7, 5
            # =&gt; cnt decreases by a fixed value every lcm(cost1, cost2) 
            # =&gt; arithmetic progressions of cnts are as follows
            #      ----- l -----  x
            #  |   24, 17, 10, 3 120
            #  |   22, 15,  8, 1 113
            # cnt  21, 14,  7,   106
            #  |   19, 12,  5,    99
            #  |   18, 11,  4,    92
            cnt = (total-i*cost1)//cost2+1
            l = ceil_divide(cnt, d)
            result += arithmetic_progression_sum(cnt, -d, l)
        return result


# Time:  O(t / c1), c1 = max(cost1, cost2)
#                 , c2 = min(cost1, cost2)
# Space: O(1)
# math
class Solution2(object):
    def waysToBuyPensPencils(self, total, cost1, cost2):
        """
        :type total: int
        :type cost1: int
        :type cost2: int
        :rtype: int
        """
        if cost1 &lt; cost2:
            cost1, cost2 = cost2, cost1
        return sum((total-i*cost1)//cost2+1 for i in xrange(total//cost1+1))

```



----------------------------------------------------------------------------------------

### Math - 2244 - https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/
Time: O(n)  Space: O(n)   Medium
.Python/minimum-rounds-to-complete-all-tasks.py


```python
# Time:  O(n)
# Space: O(n)

import collections


# math, freq table
class Solution(object):
    def minimumRounds(self, tasks):
        """
        :type tasks: List[int]
        :rtype: int
        """
        cnt = collections.Counter(tasks)
        return sum((x+2)//3 for x in cnt.itervalues()) if 1 not in cnt.itervalues() else -1

```



----------------------------------------------------------------------------------------

### Math - 2249 - https://leetcode.com/problems/count-lattice-points-inside-a-circle/
Time: O(n * r^2)  Space: O(min(n * r^2, max_x * max_y))   Medium
.Python/count-lattice-points-inside-a-circle.py


```python
# Time:  O(n * r^2)
# Space: O(min(n * r^2, max_x * max_y))

# math, hash table
class Solution(object):
    def countLatticePoints(self, circles):
        """
        :type circles: List[List[int]]
        :rtype: int
        """
        lookup = set()
        for x, y, r in circles:
            for i in xrange(-r, r+1):
                for j in xrange(-r, r+1):
                    if i**2+j**2 &lt;= r**2:
                        lookup.add(((x+i), (y+j)))
        return len(lookup)


# Time:  O(n * max_x * max_y)
# Space: O(1)
# math
class Solution2(object):
    def countLatticePoints(self, circles):
        """
        :type circles: List[List[int]]
        :rtype: int
        """
        max_x = max(x+r for x, _, r in circles)
        max_y = max(y+r for _, y, r in circles)
        result = 0
        for i in xrange(max_x+1):
            for j in xrange(max_y+1):
                if any((i-x)**2+(j-y)**2 &lt;= r**2 for x, y, r in circles):
                    result += 1
        return result

```



----------------------------------------------------------------------------------------

### Math - 2262 - https://leetcode.com/problems/total-appeal-of-a-string/
Time: O(n)  Space: O(26)   Hard
.Python/total-appeal-of-a-string.py


```python
# Time:  O(n)
# Space: O(26)

# combinatorics
class Solution(object):
    def appealSum(self, s):
        """
        :type s: str
        :rtype: int
        """
        result = curr = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            result += (i-lookup[ord(c)-ord('a')])*(len(s)-i)
            lookup[ord(c)-ord('a')] = i
        return result


# Time:  O(n)
# Space: O(26)
# counting
class Solution2(object):
    def appealSum(self, s):
        """
        :type s: str
        :rtype: int
        """
        result = cnt = 0
        lookup = [-1]*26
        for i, c in enumerate(s):
            cnt += i-lookup[ord(c)-ord('a')]
            lookup[ord(c)-ord('a')] = i
            result += cnt
        return result

```



----------------------------------------------------------------------------------------

### Math - 2280 - https://leetcode.com/problems/minimum-lines-to-represent-a-line-chart/
Time: O(nlogn)  Space: O(1)   Medium
.Python/minimum-lines-to-represent-a-line-chart.py


```python
# Time:  O(nlogn)
# Space: O(1)

# sort, math, gcd
class Solution(object):
    def minimumLines(self, stockPrices):
        """
        :type stockPrices: List[List[int]]
        :rtype: int
        """
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a
    
        stockPrices.sort()
        result = 0
        prev = None
        for i in xrange(1, len(stockPrices)):
            dy, dx = stockPrices[i][1]-stockPrices[i-1][1], stockPrices[i][0]-stockPrices[i-1][0]
            g = gcd(dy, dx)
            if not prev or prev != (dy//g, dx//g):
                prev = (dy//g, dx//g)
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Math - 2310 - https://leetcode.com/problems/sum-of-numbers-with-units-digit-k/
Time: O(1)  Space: O(1)   Medium
.Python/sum-of-numbers-with-units-digit-k.py


```python
# Time:  O(1)
# Space: O(1)

# math
class Solution(object):
    def minimumNumbers(self, num, k):
        """
        :type num: int
        :type k: int
        :rtype: int
        """
        return next((i for i in xrange(1, (min(num//k, 10) if k else 1)+1) if (num-i*k)%10 == 0), -1) if num else 0

```



----------------------------------------------------------------------------------------

### Math - 2335 - https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/
Time: O(1)  Space: O(1)   Easy
.Python/minimum-amount-of-time-to-fill-cups.py


```python
# Time:  O(1)
# Space: O(1)

# math
class Solution(object):
    def fillCups(self, amount):
        """
        :type amount: List[int]
        :rtype: int
        """
        return max(max(amount), (sum(amount)+1)//2)


# Time:  O(1)
# Space: O(1)
# constructive algorithms
class Solution2(object):
    def fillCups(self, amount):
        """
        :type amount: List[int]
        :rtype: int
        """
        mx, total = max(amount), sum(amount)
        return mx if sum(amount)-mx &lt;= mx else (total+1)//2

```



----------------------------------------------------------------------------------------

### Math - 2338 - https://leetcode.com/problems/count-the-number-of-ideal-arrays/
Time: O(sqrt(m) + n + m * (logm + sqrt(m)/log(sqrt(m))))  Space: O(sqrt(m) + n + logm)   Hard
.Python/count-the-number-of-ideal-arrays.py


```python
# Time:  O(sqrt(m) + n + m * (logm + sqrt(m)/log(sqrt(m))))
# Space: O(sqrt(m) + n + logm)

import collections


# dp, factorization, combinatorics
class Solution(object):
    def idealArrays(self, n, maxValue):
        """
        :type n: int
        :type maxValue: int
        :rtype: int
        """
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in xrange(3)]
        def nCr(n, k):
            while len(inv) &lt;= n:  # lazy initialization
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        def linear_sieve_of_eratosthenes(n):  # Time: O(n), Space: O(n)
            primes = []
            spf = [-1]*(n+1)  # the smallest prime factor
            for i in xrange(2, n+1):
                if spf[i] == -1:
                    spf[i] = i
                    primes.append(i)
                for p in primes:
                    if i*p &gt; n or p &gt; spf[i]:
                        break
                    spf[i*p] = p
            return primes

        def prime_factors(x):
            factors = collections.Counter()
            for p in primes:
                if x &lt; p:
                    break
                while x%p == 0:
                    factors[p] += 1
                    x //= p
            if x != 1:
                factors[x] += 1
            return factors

        primes = linear_sieve_of_eratosthenes(int(maxValue**0.5))
        result = 0
        for k in xrange(1, maxValue+1):
            total = 1
            for c in prime_factors(k).itervalues():
                total = (total*nCr(n+c-1, c))%MOD  # H(n, c) = nCr(n+c-1, n)
            result = (result+total)%MOD
        return result


# Time:  O(n * mlogm)
# Space: O(n + m)
import collections


# dp, combinatorics
class Solution2(object):
    def idealArrays(self, n, maxValue):
        """
        :type n: int
        :type maxValue: int
        :rtype: int
        """
        MOD = 10**9+7
        fact, inv, inv_fact = [[1]*2 for _ in xrange(3)]
        def nCr(n, k):
            while len(inv) &lt;= n:  # lazy initialization
                fact.append(fact[-1]*len(inv) % MOD)
                inv.append(inv[MOD%len(inv)]*(MOD-MOD//len(inv)) % MOD)  # https://cp-algorithms.com/algebra/module-inverse.html
                inv_fact.append(inv_fact[-1]*inv[-1] % MOD)
            return (fact[n]*inv_fact[n-k] % MOD) * inv_fact[k] % MOD

        result = 0
        dp = collections.Counter(xrange(1, maxValue+1))
        for i in xrange(n): 
            new_dp = collections.Counter()
            total = 0
            for x, c in dp.iteritems():
                total = (total+c)%MOD
                for y in xrange(x+x, maxValue+1, x): 
                    new_dp[y] += c
            result = (result+total*nCr(n-1, i))%MOD
            dp = new_dp
        return result

```



----------------------------------------------------------------------------------------

### Math - 2344 - https://leetcode.com/problems/minimum-deletions-to-make-array-divisible/
Time: O(n + m + logr)  Space: O(1)   Hard
.Python/minimum-deletions-to-make-array-divisible.py


```python
# Time:  O(n + m + logr), r is max(numsDivide)
# Space: O(1)

# gcd
class Solution(object):
    def minOperations(self, nums, numsDivide):
        """
        :type nums: List[int]
        :type numsDivide: List[int]
        :rtype: int
        """
        def gcd(a, b):  # Time: O(log(min(a, b)))
            while b:
                a, b = b, a%b
            return a

        g = reduce(gcd, numsDivide)
        mn = float("inf")
        for x in nums:
            if g%x == 0:
                mn = min(mn, x)
        return sum(x &lt; mn for x in nums) if mn != float("inf") else -1

```



----------------------------------------------------------------------------------------

### Math - 2345 - https://leetcode.com/problems/finding-the-number-of-visible-mountains/
Time: O(nlogn)  Space: O(1)   Medium
.Python/finding-the-number-of-visible-mountains.py


```python
# Time:  O(nlogn)
# Space: O(1)

# math, sort
class Solution(object):
    def visibleMountains(self, peaks):
        """
        :type peaks: List[List[int]]
        :rtype: int
        """
        peaks.sort(key=lambda x: (x[0]-x[1], -(x[0]+x[1])))  # rotate points by 45 degrees and we only care the largest new y in the same new x
        result = mx = 0
        for i in xrange(len(peaks)):
            if peaks[i][0]+peaks[i][1] &lt;= mx:
                continue
            mx = peaks[i][0]+peaks[i][1]
            if i+1 == len(peaks) or peaks[i+1] != peaks[i]:
                result += 1
        return result


# Time:  O(nlogn)
# Space: O(n)
# sort, mono stack
class Solution2(object):
    def visibleMountains(self, peaks):
        """
        :type peaks: List[List[int]]
        :rtype: int
        """
        def is_covered(a, b):
            x1, y1 = a
            x2, y2 = b
            return x2-y2 &lt;= x1-y1 and x1+y1 &lt;= x2+y2

        peaks.sort()
        stk = []
        for i in xrange(len(peaks)):
            while stk and is_covered(peaks[stk[-1]], peaks[i]):
                stk.pop()
            if (i-1 == -1 or peaks[i-1] != peaks[i]) and (not stk or not is_covered(peaks[i], peaks[stk[-1]])):  # not duplicted and not covered
                stk.append(i)
        return len(stk)

```



----------------------------------------------------------------------------------------

### Math - 2350 - https://leetcode.com/problems/shortest-impossible-sequence-of-rolls/
Time: O(n)  Space: O(k)   Hard
.Python/shortest-impossible-sequence-of-rolls.py


```python
# Time:  O(n)
# Space: O(k)

# constructive algorithms
class Solution(object):
    def shortestSequence(self, rolls, k):
        """
        :type rolls: List[int]
        :type k: int
        :rtype: int
        """
        l = 0
        lookup = set()
        for x in rolls:
            lookup.add(x)
            if len(lookup) != k:
                continue
            lookup.clear()
            l += 1
        return l+1

```



----------------------------------------------------------------------------------------

### Math - 2358 - https://leetcode.com/problems/maximum-number-of-groups-entering-a-competition/
Time: O(1)  Space: O(1)   Medium
.Python/maximum-number-of-groups-entering-a-competition.py


```python
# Time:  O(1)
# Space: O(1)

# math
class Solution(object):
    def maximumGroups(self, grades):
        """
        :type grades: List[int]
        :rtype: int
        """
        # (1+x)*x/2 &lt;= len(grades)
        # =&gt; x &lt;= ((1+8*len(grades))**0.5-1)/2.0
        return int(((1+8*len(grades))**0.5-1)/2.0)

```



----------------------------------------------------------------------------------------

### Math - 2376 - https://leetcode.com/problems/count-special-integers/
Time: O(logn)  Space: O(logn)   Hard
.Python/count-special-integers.py


```python
# Time:  O(logn)
# Space: O(logn)

# combinatorics
class Solution(object):
    def countSpecialNumbers(self, n):
        """
        :type n: int
        :rtype: int
        """
        def P(m, n):
            result = 1
            for _ in xrange(n):
                result *= m
                m -= 1
            return result

        digits = map(int, str(n+1))
        result = sum(P(9, 1)*P(9, i-1) for i in xrange(1, len(digits)))
        lookup = set()
        for i, x in enumerate(digits):
            for y in xrange(int(i == 0), x):
                if y in lookup:
                    continue
                result += P(9-i, len(digits)-i-1)
            if x in lookup:
                break
            lookup.add(x)
        return result

```



----------------------------------------------------------------------------------------

### Sort - 1054 - https://leetcode.com/problems/distant-barcodes/
Time: O(klogk)  Space: O(k)   Medium
.Python/distant-barcodes.py


```python
# Time:  O(klogk), k is the number of distinct barcodes
# Space: O(k)

import collections


class Solution(object):
    def rearrangeBarcodes(self, barcodes):
        """
        :type barcodes: List[int]
        :rtype: List[int]
        """
        cnts = collections.Counter(barcodes)
        sorted_cnts = [[v, k] for k, v in cnts.iteritems()]
        sorted_cnts.sort(reverse=True)

        i = 0
        for v, k in sorted_cnts:
            for _ in xrange(v):
                barcodes[i] = k
                i += 2
                if i &gt;= len(barcodes):
                    i = 1
        return barcodes

```



----------------------------------------------------------------------------------------

### Sort - 1086 - https://leetcode.com/problems/high-five/
Time: O(nlogn)  Space: O(n)   Easy
.Python/high-five.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections
import heapq


class Solution(object):
    def highFive(self, items):
        """
        :type items: List[List[int]]
        :rtype: List[List[int]]
        """
        min_heaps = collections.defaultdict(list)
        for i, val in items:
            heapq.heappush(min_heaps[i], val)
            if len(min_heaps[i]) &gt; 5:
                heapq.heappop(min_heaps[i])
        return [[i, sum(min_heaps[i]) // len(min_heaps[i])] for i in sorted(min_heaps)]

```



----------------------------------------------------------------------------------------

### Sort - 1094 - https://leetcode.com/problems/car-pooling/
Time: O(nlogn)  Space: O(n)   Medium
.Python/car-pooling.py


```python
# Time:  O(nlogn)
# Space: O(n)

class Solution(object):
    def carPooling(self, trips, capacity):
        """
        :type trips: List[List[int]]
        :type capacity: int
        :rtype: bool
        """
        line = [x for num, start, end in trips for x in [[start, num], [end, -num]]]
        line.sort()
        for _, num in line:
            capacity -= num
            if capacity &lt; 0:
                return False
        return True

```



----------------------------------------------------------------------------------------

### Sort - 1122 - https://leetcode.com/problems/relative-sort-array/
Time: O(nlogn)  Space: O(n)   Easy
.Python/relative-sort-array.py


```python
# Time:  O(nlogn)
# Space: O(n)

class Solution(object):
    def relativeSortArray(self, arr1, arr2):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :rtype: List[int]
        """
        lookup = {v: i for i, v in enumerate(arr2)}
        return sorted(arr1, key=lambda i: lookup.get(i, len(arr2)+i))

```



----------------------------------------------------------------------------------------

### Sort - 1229 - https://leetcode.com/problems/meeting-scheduler/
Time: O(nlogn)  Space: O(n)   Medium
.Python/meeting-scheduler.py


```python
# Time:  O(n) ~ O(nlogn)
# Space: O(n)

import heapq


class Solution(object):
    def minAvailableDuration(self, slots1, slots2, duration):
        """
        :type slots1: List[List[int]]
        :type slots2: List[List[int]]
        :type duration: int
        :rtype: List[int]
        """
        min_heap = list(filter(lambda slot: slot[1] - slot[0] &gt;= duration, slots1 + slots2))
        heapq.heapify(min_heap)  # Time: O(n)
        while len(min_heap) &gt; 1:
            left = heapq.heappop(min_heap)  # Time: O(logn)
            right = min_heap[0]
            if left[1]-right[0] &gt;= duration:
                return [right[0], right[0]+duration] 
        return []   


# Time:  O(nlogn)
# Space: O(n)
class Solution2(object):
    def minAvailableDuration(self, slots1, slots2, duration):
        """
        :type slots1: List[List[int]]
        :type slots2: List[List[int]]
        :type duration: int
        :rtype: List[int]
        """
        slots1.sort(key = lambda x: x[0])
        slots2.sort(key = lambda x: x[0])
        i, j = 0, 0
        while i &lt; len(slots1) and j &lt; len(slots2):
            left = max(slots1[i][0], slots2[j][0])
            right = min(slots1[i][1], slots2[j][1])
            if left+duration &lt;= right:
                return [left, left+duration]
            if slots1[i][1] &lt; slots2[j][1]:
                i += 1
            else:
                j += 1
        return []

```



----------------------------------------------------------------------------------------

### Sort - 1356 - https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/
Time: O(nlogn)  Space: O(1)   Easy
.Python/sort-integers-by-the-number-of-1-bits.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def sortByBits(self, arr):
        """
        :type arr: List[int]
        :rtype: List[int]
        """
        def popcount(n):  # Time: O(logn) ~= O(1) if n is a 32-bit number
            result = 0
            while n:
                n &amp;= n - 1
                result += 1
            return result
        
        arr.sort(key=lambda x: (popcount(x), x))
        return arr

```



----------------------------------------------------------------------------------------

### Sort - 1365 - https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/
Time: O(n + m)  Space: O(m)   Easy
.Python/how-many-numbers-are-smaller-than-the-current-number.py


```python
# Time:  O(n + m), m is the max number of nums
# Space: O(m)

import collections


class Solution(object):
    def smallerNumbersThanCurrent(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        count = collections.Counter(nums)
        for i in xrange(max(nums)+1):
            count[i] += count[i-1]
        return [count[i-1] for i in nums]


# Time:  O(nlogn)
# Space: O(n)
import bisect


class Solution2(object):
    def smallerNumbersThanCurrent(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        sorted_nums = sorted(nums)
        return [bisect.bisect_left(sorted_nums, i) for i in nums]

```



----------------------------------------------------------------------------------------

### Sort - 1366 - https://leetcode.com/problems/rank-teams-by-votes/
Time: O(m * (n + mlogm))  Space: O(m^2)   Medium
.Python/rank-teams-by-votes.py


```python
# Time:  O(m * (n + mlogm)), n is the number of votes
#                          , m is the length of vote
# Space: O(m^2)

class Solution(object):
    def rankTeams(self, votes):
        """
        :type votes: List[str]
        :rtype: str
        """
        count = {v: [0]*len(votes[0]) + [v] for v in votes[0]}
        for vote in votes:
            for i, v in enumerate(vote):
                count[v][i] -= 1
        return "".join(sorted(votes[0], key=count.__getitem__))

```



----------------------------------------------------------------------------------------

### Sort - 1451 - https://leetcode.com/problems/rearrange-words-in-a-sentence/
Time: O(nlogn)  Space: O(n)   Medium
.Python/rearrange-words-in-a-sentence.py


```python
# Time:  O(nlogn)
# Space: O(n)

class Solution(object):
    def arrangeWords(self, text):
        """
        :type text: str
        :rtype: str
        """
        result = text.split()
        result[0] = result[0].lower()
        result.sort(key=len) 
        result[0] = result[0].title()
        return " ".join(result)

```



----------------------------------------------------------------------------------------

### Sort - 1481 - https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/
Time: O(n)  Space: O(n)   Medium
.Python/least-number-of-unique-integers-after-k-removals.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def findLeastNumOfUniqueInts(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: int
        """
        count = collections.Counter(arr)
        result, count_count = len(count), collections.Counter(count.itervalues())
        for c in xrange(1, len(arr)+1): 
            if k &lt; c*count_count[c]:
                result -= k//c
                break
            k -= c*count_count[c]
            result -= count_count[c]                
        return result

```



----------------------------------------------------------------------------------------

### Sort - 1509 - https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/
Time: O(n + klogk)  Space: O(1)   Medium
.Python/minimum-difference-between-largest-and-smallest-value-in-three-moves.py


```python
# Time:  O(n + klogk)
# Space: O(k)

import random


class Solution(object):
    def minDifference(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def nth_element(nums, left, n, right, compare=lambda a, b: a &lt; b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in xrange(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx &gt; n:
                    right = new_pivot_idx - 1
                else:  # new_pivot_idx &lt; n
                    left = new_pivot_idx + 1

        k = 4
        if len(nums) &lt;= k:
            return 0
        nth_element(nums, 0, k, len(nums)-1)
        nums[:k] = sorted(nums[:k])
        nth_element(nums, k, max(k, len(nums)-k), len(nums)-1)
        nums[-k:] = sorted(nums[-k:])
        return min(nums[-k+i]-nums[i] for i in xrange(k))

```



----------------------------------------------------------------------------------------

### Sort - 1523 - https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/
Time: O(1)  Space: O(1)   Easy
.Python/count-odd-numbers-in-an-interval-range.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countOdds(self, low, high):
        """
        :type low: int
        :type high: int
        :rtype: int
        """
        return (high+1)//2 - ((low-1)+1)//2

```



----------------------------------------------------------------------------------------

### Sort - 1561 - https://leetcode.com/problems/maximum-number-of-coins-you-can-get/
Time: O(nlogn)  Space: O(1)   Medium
.Python/maximum-number-of-coins-you-can-get.py


```python
# Time:  O(nlogn)
# Space: O(1)

import itertools


class Solution(object):
    def maxCoins(self, piles):
        """
        :type piles: List[int]
        :rtype: int
        """
        piles.sort()
        return sum(itertools.islice(piles, len(piles)//3, len(piles), 2))

```



----------------------------------------------------------------------------------------

### Sort - 1588 - https://leetcode.com/problems/sum-of-all-odd-length-subarrays/
Time: O(n)  Space: O(1)   Easy
.Python/sum-of-all-odd-length-subarrays.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def sumOddLengthSubarrays(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        def ceil_divide(a, b):
            return (a+(b-1))//b
 
        # begin\pos |0   i       (n-1)
        # ----------------------------
        # 0          --101....      
        # 1           -010....    i-0+1
        # i            101....      
        #               (n-1-i+1) 
        #
        # for each number x with its position i, we want to know how many odd length subarrays is with x,
        # as the graph depicted above,
        # (begin, pos) pair represents a subarray arr[begin:pos+1] containing x, marked 1 if odd length else 0,
        # so the total number of 0 and 1 are exactly the total number of subarrays with x, which is (i-0+1)*((len(arr)-1)-i+1),
        # because the number of 1 is always equal to or one more than the number of 0, (always begins with 1010... and alternatively flips)
        # so there are ceil((i-0+1)*((len(arr)-1)-i+1)/2) odd length subarrays with x
        # 
        return sum(x * ceil_divide((i-0+1)*((len(arr)-1)-i+1), 2) for i, x in enumerate(arr))

```



----------------------------------------------------------------------------------------

### Sort - 1608 - https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/
Time: O(n)  Space: O(1)   Easy
.Python/special-array-with-x-elements-greater-than-or-equal-x.py


```python
# Time:  O(n)
# Space: O(1)

# counting sort solution
class Solution(object):
    def specialArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        MAX_NUM = 1000
        count = [0]*(MAX_NUM+1)
        for num in nums:
            count[num] += 1
        n = len(nums)
        for i in xrange(len(count)):
            if i == n:
                return i
            n -= count[i]
        return -1


# Time:  O(n)
# Space: O(1)
# counting sort + binary search solution
class Solution2(object):
    def specialArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        MAX_NUM = 1000
        def inplace_counting_sort(nums, reverse=False):  # Time: O(n)
            count = [0]*(MAX_NUM+1)
            for num in nums:
                count[num] += 1
            for i in xrange(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(xrange(len(nums))):  # inplace but unstable sort
                while nums[i] &gt;= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in xrange(len(nums)):
                nums[i] = ~nums[i]  # restore values
            if reverse:  # unstable sort
                nums.reverse()
    
        inplace_counting_sort(nums, reverse=True)
        left, right = 0, len(nums)-1
        while left &lt;= right:  # Time: O(logn)
            mid = left + (right-left)//2
            if nums[mid] &lt;= mid:
                right = mid-1
            else:
                left = mid+1
        return -1 if left &lt; len(nums) and nums[left] == left else left


# Time:  O(n)
# Space: O(n)
# counting sort + binary search solution
class Solution3(object):
    def specialArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        MAX_NUM = 1000
        def counting_sort(nums, reverse=False):  # Time: O(n), Space: O(n)
            count = [0]*(MAX_NUM+1)
            for num in nums:
                count[num] += 1
            for i in xrange(1, len(count)):
                count[i] += count[i-1]
            result = [0]*len(nums)
            if not reverse:
                for num in reversed(nums):  # stable sort
                    count[num] -= 1
                    result[count[num]] = num
            else:
                for num in nums:  # stable sort
                    count[num] -= 1
                    result[count[num]] = num
                result.reverse()
            return result
    
        nums = counting_sort(nums, reverse=True)  # extra O(n) space for stable sort
        left, right = 0, len(nums)-1
        while left &lt;= right:  # Time: O(logn)
            mid = left + (right-left)//2
            if nums[mid] &lt;= mid:
                right = mid-1
            else:
                left = mid+1
        return -1 if left &lt; len(nums) and nums[left] == left else left


# Time:  O(nlogn)
# Space: O(1)
# sort solution
class Solution4(object):
    def specialArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums.sort(reverse=True)  # Time: O(nlogn)
        for i in xrange(len(nums)):  # Time: O(n)
            if nums[i] &lt;= i:
                break
        else:
            i += 1
        return -1 if i &lt; len(nums) and nums[i] == i else i

```



----------------------------------------------------------------------------------------

### Sort - 1620 - https://leetcode.com/problems/coordinate-with-maximum-network-quality/
Time: O(n^2)  Space: O(1)   Medium
.Python/coordinate-with-maximum-network-quality.py


```python
# Time:  O(n^2)
# Space: O(1)

class Solution(object):
    def bestCoordinate(self, towers, radius):
        """
        :type towers: List[List[int]]
        :type radius: int
        :rtype: List[int]
        """
        min_x = min(towers, key=lambda x:x[0])[0]
        max_x = max(towers, key=lambda x:x[0])[0]
        min_y = min(towers, key=lambda x:x[1])[1]
        max_y = max(towers, key=lambda x:x[1])[1]
        max_quality = 0
        for x in xrange(min_x, max_x+1):
            for y in xrange(min_y, max_y+1):
                q = 0
                for nx, ny, nq in towers:
                    d = ((nx-x)**2+(ny-y)**2)**0.5
                    if d &lt;= radius:
                        q += int(nq/(1+d))
                if q &gt; max_quality:
                    max_quality = q
                    result = x, y
        return result

```



----------------------------------------------------------------------------------------

### Sort - 1621 - https://leetcode.com/problems/number-of-sets-of-k-non-overlapping-line-segments/
Time: O(1)  Space: O(n)   Medium
.Python/number-of-sets-of-k-non-overlapping-line-segments.py


```python
# Time:  O(1), excluding precomputation time
# Space: O(n)

# precompute
MOD = 10**9+7
MAX_N = 1000
fact = [0]*(2*MAX_N-1+1)
inv = [0]*(2*MAX_N-1+1)
inv_fact = [0]*(2*MAX_N-1+1)
fact[0] = inv_fact[0] = fact[1] = inv_fact[1] = inv[1] = 1
for i in xrange(2, len(fact)):
    fact[i] = fact[i-1]*i % MOD
    inv[i] = inv[MOD%i]*(MOD-MOD//i) % MOD  # https://cp-algorithms.com/algebra/module-inverse.html
    inv_fact[i] = inv_fact[i-1]*inv[i] % MOD

class Solution(object):
    def numberOfSets(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: int
        """
        def nCr(n, k, mod):
            return (fact[n]*inv_fact[n-k] % mod) * inv_fact[k] % mod
    
        # find k segments with 1+ length and (k+1) spaces with 0+ length s.t. total length is n-1
        # =&gt; find k segments with 0+ length and (k+1) spaces with 0+ length s.t. total length is n-k-1
        # =&gt; find the number of combinations of 2k+1 variables with total sum n-k-1
        # =&gt; H(2k+1, n-k-1)
        # =&gt; C((2k+1) + (n-k-1) - 1, n-k-1)
        # =&gt; C(n+k-1, n-k-1) = C(n+k-1, 2k)
        return nCr(n+k-1, 2*k, MOD)


# Time:  O(min(k, min(n - k)))
# Space: O(1)
class Solution2(object):
    def numberOfSets(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: int
        """
        MOD = 10**9+7
        def nCr(n, r):  # Time: O(n), Space: O(1)
            if n-r &lt; r:
                return nCr(n, n-r)
            c = 1
            for k in xrange(1, r+1):
                c *= n-k+1
                c //= k
            return c
        
        # find k segments with 1+ length and (k+1) spaces with 0+ length s.t. total length is n-1
        # =&gt; find k segments with 0+ length and (k+1) spaces with 0+ length s.t. total length is n-k-1
        # =&gt; find the number of combinations of 2k+1 variables with total sum n-k-1
        # =&gt; H(2k+1, n-k-1)
        # =&gt; C((2k+1) + (n-k-1) - 1, n-k-1)
        # =&gt; C(n+k-1, n-k-1) = C(n+k-1, 2k)
        return nCr(n+k-1, 2*k) % MOD

```



----------------------------------------------------------------------------------------

### Sort - 1630 - https://leetcode.com/problems/arithmetic-subarrays/
Time: O(n * q)  Space: O(n)   Medium
.Python/arithmetic-subarrays.py


```python
# Time:  O(n * q)
# Space: O(n)

import itertools


class Solution(object):
    def checkArithmeticSubarrays(self, nums, l, r):
        """
        :type nums: List[int]
        :type l: List[int]
        :type r: List[int]
        :rtype: List[bool]
        """
        def is_arith(n):
            mx, mn, lookup = max(n), min(n), set(n)
            if mx == mn:
                return True
            d, r = divmod(mx-mn, len(n)-1)
            if r:
                return False
            return all(i in lookup for i in xrange(mn, mx, d))
    
        result = []
        for left, right in itertools.izip(l, r):
            result.append(is_arith(nums[left:right+1]))
        return result

```



----------------------------------------------------------------------------------------

### Sort - 1636 - https://leetcode.com/problems/sort-array-by-increasing-frequency/
Time: O(nlogn)  Space: O(n)   Easy
.Python/sort-array-by-increasing-frequency.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class Solution(object):
    def frequencySort(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        count = collections.Counter(nums)
        return sorted(nums, key=lambda x: (count[x], -x))

```



----------------------------------------------------------------------------------------

### Sort - 1637 - https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/
Time: O(nlogn)  Space: O(n)   Medium
.Python/widest-vertical-area-between-two-points-containing-no-points.py


```python
# Time:  O(nlogn)
# Space: O(n)

import itertools


class Solution(object):
    def maxWidthOfVerticalArea(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        sorted_x = sorted({x for x, y in points})
        return max([b-a for a, b in itertools.izip(sorted_x, sorted_x[1:])] + [0])

```



----------------------------------------------------------------------------------------

### Sort - 1680 - https://leetcode.com/problems/concatenation-of-consecutive-binary-numbers/
Time: O(n)  Space: O(1)   Medium
.Python/concatenation-of-consecutive-binary-numbers.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def concatenatedBinary(self, n):
        """
        :type n: int
        :rtype: int
        """
        MOD = 10**9+7
        result = l = 0
        for i in xrange(1, n+1):
            if i&amp;(i-1) == 0:
                l += 1
            result = ((result&lt;&lt;l)%MOD+i)%MOD
        return result

```



----------------------------------------------------------------------------------------

### Sort - 1685 - https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/
Time: O(n)  Space: O(1)   Medium
.Python/sum-of-absolute-differences-in-a-sorted-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def getSumAbsoluteDifferences(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        prefix, suffix = 0, sum(nums)
        result = []
        for i, num in enumerate(nums):
            suffix -= num
            result.append((i*num-prefix) + (suffix-((len(nums)-1)-i)*num))
            prefix += num
        return result

```



----------------------------------------------------------------------------------------

### Sort - 1688 - https://leetcode.com/problems/count-of-matches-in-tournament/
Time: O(1)  Space: O(1)   Easy
.Python/count-of-matches-in-tournament.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def numberOfMatches(self, n):
        """
        :type n: int
        :rtype: int
        """
        return n-1

```



----------------------------------------------------------------------------------------

### Sort - 1703 - https://leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/
Time: O(n)  Space: O(n)   Hard
.Python/minimum-adjacent-swaps-for-k-consecutive-ones.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def minMoves(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def moves(i, j):
            return prefix[j+1]-prefix[i]

        idxs = [i for i, x in enumerate(nums) if x]
        prefix = [0]*(len(idxs)+1)
        for i in xrange(len(idxs)):
            prefix[i+1] = prefix[i]+idxs[i]
        result = float("inf")
        for i in xrange(len(idxs)-k+1):
            result = min(result, -moves(i, i+k//2-1) + moves(i+(k+1)//2, i+k-1))  # take each i+k//2 as median, find min dist to median
        result -= (k//2)*((k+1)//2)  # rollback extra moves to the expected positions
        return result

```



----------------------------------------------------------------------------------------

### Sort - 1716 - https://leetcode.com/problems/calculate-money-in-leetcode-bank/
Time: O(1)  Space: O(1)   Easy
.Python/calculate-money-in-leetcode-bank.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def totalMoney(self, n):
        """
        :type n: int
        :rtype: int
        """
        def arithmetic_sequence_sum(a, d, n):
            return (2*a + (n-1)*d) * n //2

        cost, day = 1, 7
        first_week_cost = arithmetic_sequence_sum(cost, cost, day)
        week, remain_day = divmod(n, day)
        return arithmetic_sequence_sum(first_week_cost, cost*day, week) + \
               arithmetic_sequence_sum(cost*(week+1), cost, remain_day)

```



----------------------------------------------------------------------------------------

### Sort - 1772 - https://leetcode.com/problems/sort-features-by-popularity/
Time: O(n)  Space: O(1)   Medium
.Python/sort-features-by-popularity.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class Solution(object):
    def sortFeatures(self, features, responses):
        """
        :type features: List[str]
        :type responses: List[str]
        :rtype: List[str]
        """
        features_set = set(features)
        order = {word: i for i, word in enumerate(features)}
        freq = collections.defaultdict(int)
        for r in responses:
            for word in set(r.split(' ')):
                if word in features_set:
                    freq[word] += 1
        features.sort(key=lambda x: (-freq[x], order[x]))
        return features

```



----------------------------------------------------------------------------------------

### Sort - 1847 - https://leetcode.com/problems/closest-room/
Time: O(nlogn + klogk + klogn)  Space: O(n + k)   Hard
.Python/closest-room.py


```python
# Time:  O(nlogn + klogk + klogn)
# Space: O(n + k)

from sortedcontainers import SortedList


class Solution(object):
    def closestRoom(self, rooms, queries):
        """
        :type rooms: List[List[int]]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        def find_closest(ids, r):
            result, min_dist = -1, float("inf")
            i = ids.bisect_right(r)
            if i-1 &gt;= 0 and abs(ids[i-1]-r) &lt; min_dist:
                min_dist = abs(ids[i-1]-r)
                result = ids[i-1]
            if i &lt; len(ids) and abs(ids[i]-r) &lt; min_dist:
                min_dist = abs(ids[i]-r)
                result = ids[i]
            return result

        rooms.sort(key=lambda x: x[1], reverse=True)
        for i, q in enumerate(queries):
            q.append(i)
        queries.sort(key=lambda x: x[1], reverse=True)
        ids = SortedList()
        i = 0
        result = [-1]*len(queries)
        for r, s, idx in queries:
            while i &lt; len(rooms) and rooms[i][1] &gt;= s:
                ids.add(rooms[i][0])
                i += 1
            result[idx] = find_closest(ids, r)
        return result

    
# Time:  O(nlogn + klogk + klogn)
# Space: O(n + k)
from sortedcontainers import SortedList


class Solution2(object):
    def closestRoom(self, rooms, queries):
        """
        :type rooms: List[List[int]]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        def find_closest(ids, r):
            result, min_dist = -1, float("inf")
            i = ids.bisect_right(r)
            if i-1 &gt;= 0 and abs(ids[i-1]-r) &lt; min_dist:
                min_dist = abs(ids[i-1]-r)
                result = ids[i-1]
            if i &lt; len(ids) and abs(ids[i]-r) &lt; min_dist:
                min_dist = abs(ids[i]-r)
                result = ids[i]
            return result

        rooms.sort(key=lambda x: x[1])
        for i, q in enumerate(queries):
            q.append(i)
        queries.sort(key=lambda x: x[1])
        ids = SortedList(i for i, _ in rooms)        
        i = 0
        result = [-1]*len(queries)
        for r, s, idx in queries:
            while i &lt; len(rooms) and rooms[i][1] &lt; s:
                ids.remove(rooms[i][0])
                i += 1
            result[idx] = find_closest(ids, r)
        return result

```



----------------------------------------------------------------------------------------

### Sort - 1851 - https://leetcode.com/problems/minimum-interval-to-include-each-query/
Time: O(nlogn + klogk + klogn)  Space: O(n + k)   Hard
.Python/minimum-interval-to-include-each-query.py


```python
# Time:  O(nlogn + klogk + klogn)
# space: O(n + k)

import heapq


class Solution(object):
    def minInterval(self, intervals, queries):
        """
        :type intervals: List[List[int]]
        :type queries: List[int]
        :rtype: List[int]
        """
        intervals.sort()
        queries = [(q, i) for i, q in enumerate(queries)]
        queries.sort()
        min_heap = []
        i = 0
        result =[-1]*len(queries)
        for q, idx in queries:
            while i != len(intervals) and intervals[i][0] &lt;= q:
                heapq.heappush(min_heap, [intervals[i][1]-intervals[i][0]+1, i])
                i += 1
            while min_heap and intervals[min_heap[0][1]][1] &lt; q:
                heapq.heappop(min_heap)
            result[idx] = min_heap[0][0] if min_heap else -1
        return result

```



----------------------------------------------------------------------------------------

### Sort - 1859 - https://leetcode.com/problems/sorting-the-sentence/
Time: O(n)  Space: O(n)   Easy
.Python/sorting-the-sentence.py


```python
# Time:  O(n)
# Space: O(n)

import itertools


class Solution(object):
    def sortSentence(self, s):
        """
        :type s: str
        :rtype: str
        """
        words = s.split()
        for i in xrange(len(words)):
            while int(words[i][-1])-1 != i:
                words[int(words[i][-1])-1], words[i] = words[i], words[int(words[i][-1])-1]
        return " ".join(itertools.imap(lambda x: x[:-1], words))

```



----------------------------------------------------------------------------------------

### Sort - 1942 - https://leetcode.com/problems/the-number-of-the-smallest-unoccupied-chair/
Time: O(nlogn)  Space: O(n)   Medium
.Python/the-number-of-the-smallest-unoccupied-chair.py


```python
# Time:  O(nlogn)
# Space: O(n)

import heapq


class Solution(object):
    def smallestChair(self, times, targetFriend):
        """
        :type times: List[List[int]]
        :type targetFriend: int
        :rtype: int
        """
        events = []
        for i, (s, e) in enumerate(times): 
            events.append((s, True, i))
            events.append((e, False, i))
        events.sort()

        lookup = {}
        min_heap = []
        for _, arrival, i in events: 
            if not arrival: 
                heapq.heappush(min_heap, lookup.pop(i))
                continue
            lookup[i] = heapq.heappop(min_heap) if min_heap else len(lookup)
            if i == targetFriend:
                break
        return lookup[targetFriend]

```



----------------------------------------------------------------------------------------

### Sort - 1943 - https://leetcode.com/problems/describe-the-painting/
Time: O(nlogn)  Space: O(n)   Medium
.Python/describe-the-painting.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class Solution(object):
    def splitPainting(self, segments):
        """
        :type segments: List[List[int]]
        :rtype: List[List[int]]
        """
        counts = collections.defaultdict(int)
        for s, e, c in segments:
            counts[s] += c
            counts[e] -= c
        points = sorted(x for x in counts.iteritems())

        result = []
        overlap = prev = 0
        for curr, cnt in points:
            if overlap:
                result.append([prev, curr, overlap])
            overlap += cnt
            prev = curr
        return result

```



----------------------------------------------------------------------------------------

### Sort - 1968 - https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/
Time: O(n)  on average  Space: O(1)   Medium
.Python/array-with-elements-not-equal-to-average-of-neighbors.py


```python
# Time:  O(n) ~ O(n^2), O(n) on average
# Space: O(1)

# Tri Partition (aka Dutch National Flag Problem) with virtual index solution
class Solution(object):
    def rearrangeArray(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        def nth_element(nums, n, compare=lambda a, b: a &lt; b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid &lt;= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left &lt;= right:
                pivot_idx = randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left &lt;= n &lt;= pivot_right:
                    return
                elif pivot_left &gt; n:
                    right = pivot_left-1
                else:  # pivot_right &lt; n.
                    left = pivot_right+1

        def reversedTriPartitionWithVI(nums, val):
            def idx(i, N):
                return (1 + 2 * (i)) % N

            N = len(nums)//2 * 2 + 1
            i, j, n = 0, 0, len(nums) - 1
            while j &lt;= n:
                if nums[idx(j, N)] &gt; val:
                    nums[idx(i, N)], nums[idx(j, N)] = nums[idx(j, N)], nums[idx(i, N)]
                    i += 1
                    j += 1
                elif nums[idx(j, N)] &lt; val:
                    nums[idx(j, N)], nums[idx(n, N)] = nums[idx(n, N)], nums[idx(j, N)]
                    n -= 1
                else:
                    j += 1

        mid = (len(nums)-1)//2
        nth_element(nums, mid)
        reversedTriPartitionWithVI(nums, nums[mid])
        return nums


# Time:  O(nlogn)
# Space: O(n)
# Sorting and reorder solution
class Solution2(object):
    def rearrangeArray(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        nums.sort()
        mid = (len(nums)-1)//2
        nums[::2], nums[1::2] = nums[mid::-1], nums[:mid:-1]
        return nums

```



----------------------------------------------------------------------------------------

### Sort - 1985 - https://leetcode.com/problems/find-the-kth-largest-integer-in-the-array/
Time: O(n) on average  Space: O(n)   Medium
.Python/find-the-kth-largest-integer-in-the-array.py


```python
# Time:  O(n) ~ O(n^2), O(n) on average
# Space: O(1)

import random


class Solution(object):
    def kthLargestNumber(self, nums, k):
        """
        :type nums: List[str]
        :type k: int
        :rtype: str
        """
        def nth_element(nums, n, compare=lambda a, b: a &lt; b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid &lt;= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left &lt;= n &lt;= pivot_right:
                    return
                elif pivot_left &gt; n:
                    right = pivot_left-1
                else:  # pivot_right &lt; n.
                    left = pivot_right+1
        
        nth_element(nums, k-1, compare=lambda a, b: a &gt; b if len(a) == len(b) else len(a) &gt; len(b))
        return nums[k-1]

```



----------------------------------------------------------------------------------------

### Sort - 1996 - https://leetcode.com/problems/the-number-of-weak-characters-in-the-game/
Time: O(nlogn)  Space: O(1)   Medium
.Python/the-number-of-weak-characters-in-the-game.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def numberOfWeakCharacters(self, properties):
        """
        :type properties: List[List[int]]
        :rtype: int
        """
        properties.sort(cmp=lambda a, b: cmp(b[1], a[1]) if a[0] == b[0] else cmp(a[0], b[0]))
        result = max_d = 0
        for a, d in reversed(properties):
            if d &lt; max_d:
                result += 1
            max_d = max(max_d, d)
        return result

    
# Time:  O(nlogn)
# Space: O(n)
import collections


# faster in sort by using more space
class Solution(object):
    def numberOfWeakCharacters(self, properties):
        """
        :type properties: List[List[int]]
        :rtype: int
        """
        lookup = collections.defaultdict(list)
        for a, d in properties:
            lookup[a].append(d)
        result = max_d = 0
        for a in sorted(lookup.iterkeys(), reverse=True):
            result += sum(d &lt; max_d for d in lookup[a])
            max_d = max(max_d, max(lookup[a]))
        return result

```



----------------------------------------------------------------------------------------

### Sort - 2015 - https://leetcode.com/problems/average-height-of-buildings-in-each-segment/
Time: O(nlogn)  Space: O(n)   Medium
.Python/average-height-of-buildings-in-each-segment.py


```python
# Time:  O(nlogn)
# Space: O(n)

class Solution(object):
    def averageHeightOfBuildings(self, buildings):
        """
        :type buildings: List[List[int]]
        :rtype: List[List[int]]
        """
        points = []
        for x, y, h in buildings:
            points.append((x, 1, h))
            points.append((y, -1, h))
        points.sort()
        result = []
        total = cnt = 0
        prev = -1
        for curr, c, h in points:
            if cnt and curr != prev:
                if result and result[-1][1] == prev and result[-1][2] == total//cnt:
                    result[-1][1] = curr
                else:
                    result.append([prev, curr, total//cnt])
            total += h*c
            cnt += c
            prev = curr
        return result


# Time:  O(nlogn)
# Space: O(n)
import collections


class Solution2(object):
    def averageHeightOfBuildings(self, buildings):
        """
        :type buildings: List[List[int]]
        :rtype: List[List[int]]
        """
        count = collections.defaultdict(lambda: (0, 0))
        for x, y, h in buildings:
            count[x] = (count[x][0]+1, count[x][1]+h)
            count[y] = (count[y][0]-1, count[y][1]-h)
        result = []
        total = cnt = 0
        prev = -1
        for curr, (c, h) in sorted(count.iteritems()):
            if cnt:
                if result and result[-1][1] == prev and result[-1][2] == total//cnt:
                    result[-1][1] = curr
                else:
                    result.append([prev, curr, total//cnt])
            total += h
            cnt += c
            prev = curr
        return result

```



----------------------------------------------------------------------------------------

### Sort - 2021 - https://leetcode.com/problems/brightest-position-on-street/
Time: O(nlogn)  Space: O(n)   Medium
.Python/brightest-position-on-street.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class Solution(object):
    def brightestPosition(self, lights):
        """
        :type lights: List[List[int]]
        :rtype: int
        """
        count = collections.Counter()
        for i, r in lights:
            count[i-r] += 1
            count[i+r+1] -= 1
        result = None
        max_cnt = cnt = 0
        for i, c in sorted(count.iteritems()):
            cnt += c
            if cnt &gt; max_cnt:
                max_cnt, result = cnt, i
        return result

```



----------------------------------------------------------------------------------------

### Sort - 2070 - https://leetcode.com/problems/most-beautiful-item-for-each-query/
Time: O(nlogn + qlogn)  Space: O(1)   Medium
.Python/most-beautiful-item-for-each-query.py


```python
# Time:  O(nlogn + qlogn)
# Space: O(1)

import bisect


class Solution(object):
    def maximumBeauty(self, items, queries):
        """
        :type items: List[List[int]]
        :type queries: List[int]
        :rtype: List[int]
        """
        items.sort()
        for i in xrange(len(items)-1):
            items[i+1][1] = max(items[i+1][1], items[i][1])
        result = []
        for q in queries:
            i = bisect.bisect_left(items, [q+1])
            result.append(items[i-1][1] if i else 0)
        return result

```



----------------------------------------------------------------------------------------

### Sort - 2089 - https://leetcode.com/problems/find-target-indices-after-sorting-array/
Time: O(n)  Space: O(1)   Easy
.Python/find-target-indices-after-sorting-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def targetIndices(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        less = sum(x &lt; target for x in nums)
        return range(less, less+sum(x == target for x in nums))

```



----------------------------------------------------------------------------------------

### Sort - 2158 - https://leetcode.com/problems/amount-of-new-area-painted-each-day/
Time: O(nlogr)  Space: O(r)   Hard
.Python/amount-of-new-area-painted-each-day.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections
import heapq


# line sweep, heap
class Solution(object):
    def amountPainted(self, paint):
        """
        :type paint: List[List[int]]
        :rtype: List[int]
        """
        points = collections.defaultdict(list)
        for i, (s, e) in enumerate(paint):
            points[s].append((True, i))
            points[e].append((False, i))
        min_heap = []
        lookup = [False]*len(paint)
        result = [0]*len(paint)
        prev = -1
        for pos in sorted(points.iterkeys()):
            while min_heap and lookup[min_heap[0]]:
                heapq.heappop(min_heap)
            if min_heap:
                result[min_heap[0]] += pos-prev
            prev = pos
            for t, i in points[pos]:
                if t:
                    heapq.heappush(min_heap, i)
                else:
                    lookup[i] = True
        return result
                    
            
# Time:  O(nlogn)
# Space: O(n)
from sortedcontainers import SortedList


# line sweep, sorted list
class Solution2(object):
    def amountPainted(self, paint):
        """
        :type paint: List[List[int]]
        :rtype: List[int]
        """
        points = collections.defaultdict(list)
        for i, (s, e) in enumerate(paint):
            points[s].append((True, i))
            points[e].append((False, i))
        sl = SortedList()
        result = [0]*len(paint)
        prev = -1
        for pos in sorted(points.iterkeys()):
            if sl:
                result[sl[0]] += pos-prev
            prev = pos
            for t, i in points[pos]:
                if t:
                    sl.add(i)
                else:
                    sl.remove(i)
        return result


class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x: 0,
                 query_fn=lambda x, y: y if x is None else x+y,
                 update_fn=lambda x, y: y):
        self.tree = [None]*(2*N)
        self.lazy = [None]*len(self.tree)
        self.base = len(self.tree)//2
        self.H = (self.base-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in xrange(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(xrange(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])
        self.count = [1]*(2*N)
        for i in reversed(xrange(1, N)):
            self.count[i] = self.count[2*i] + self.count[2*i+1]

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val*self.count[x])
        if x &lt; self.base:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def __push(self, x):
        n = 2**self.H
        while n != 1:
            y = x // n
            if self.lazy[y] is not None:
                self.__apply(y*2, self.lazy[y])
                self.__apply(y*2 + 1, self.lazy[y])
                self.lazy[y] = None
            n //= 2

    def update(self, L, R, h):
        def pull(x):
            while x &gt; 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x]*self.count[x])

        if L &gt; R:
            return
        L += self.base
        R += self.base
        self.__push(L)  # key point
        self.__push(R)  # key point
        L0, R0 = L, R
        while L &lt;= R:
            if L &amp; 1:
                self.__apply(L, h)
                L += 1
            if R &amp; 1 == 0:
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):
        result = None
        if L &gt; R:
            return result

        L += self.base
        R += self.base
        self.__push(L)
        self.__push(R)
        while L &lt;= R:
            if L &amp; 1:
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R &amp; 1 == 0:
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result


# Time:  O(nlogr), r is the max position
# Space: O(r)
# segment tree
class SolutionTLE(object):
    def amountPainted(self, paint):
        """
        :type paint: List[List[int]]
        :rtype: List[int]
        """
        result = []
        st = SegmentTree(max(e for _, e in paint))
        for s, e in paint:
            cnt = st.query(s, e-1)
            st.update(s, e-1, 1)
            result.append(st.query(s, e-1)-cnt)
        return result

```



----------------------------------------------------------------------------------------

### Sort - 2164 - https://leetcode.com/problems/sort-even-and-odd-indices-independently/
Time: O(n)  Space: O(c)   Easy
.Python/sort-even-and-odd-indices-independently.py


```python
# Time:  O(n)
# Space: O(c), c is the max of nums

# counting sort, inplace solution
class Solution(object):
    def sortEvenOdd(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        def partition(index, nums):
            for i in xrange(len(nums)):
                j = i
                while nums[i] &gt;= 0:
                    j = index(j)
                    nums[i], nums[j] = nums[j], ~nums[i]  # processed
            for i in xrange(len(nums)):
                nums[i] = ~nums[i]  # restore values

        def inplace_counting_sort(nums, left, right, reverse=False):  # Time: O(n)
            if right-left+1 == 0:
                return
            count = [0]*(max(nums[i] for i in xrange(left, right+1))+1)
            for i in xrange(left, right+1):
                count[nums[i]] += 1
            for i in xrange(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(xrange(left, right+1)):  # inplace but unstable sort
                while nums[i] &gt;= 0:
                    count[nums[i]] -= 1
                    j = left+count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in xrange(left, right+1):
                nums[i] = ~nums[i]  # restore values
            if reverse:  # unstable
                while left &lt; right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

        partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums)
        inplace_counting_sort(nums, 0, (len(nums)+1)//2-1)
        inplace_counting_sort(nums, (len(nums)+1)//2, len(nums)-1, True)
        partition(lambda i: 2*i if i &lt; (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums)
        return nums


# Time:  O(nlogn)
# Space: O(n)
# sort, inplace solution
class Solution2(object):
    def sortEvenOdd(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        def partition(index, nums):
            for i in xrange(len(nums)):
                j = i
                while nums[i] &gt;= 0:
                    j = index(j)
                    nums[i], nums[j] = nums[j], ~nums[i]  # processed
            for i in xrange(len(nums)):
                nums[i] = ~nums[i]  # restore values
        
        partition(lambda i: i//2 if i%2 == 0 else (len(nums)+1)//2+i//2, nums)
        nums[:(len(nums)+1)//2], nums[(len(nums)+1)//2:] = sorted(nums[:(len(nums)+1)//2]), sorted(nums[(len(nums)+1)//2:], reverse=True)
        partition(lambda i: 2*i if i &lt; (len(nums)+1)//2 else 1+2*(i-(len(nums)+1)//2), nums)
        return nums


# Time:  O(nlogn)
# Space: O(n)
# sort
class Solution3(object):
    def sortEvenOdd(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        nums[::2], nums[1::2] = sorted(nums[::2]), sorted(nums[1::2], reverse=True)
        return nums

```



----------------------------------------------------------------------------------------

### Sort - 2191 - https://leetcode.com/problems/sort-the-jumbled-numbers/
Time: O(nlogm + nlogn)  Space: O(n)   Medium
.Python/sort-the-jumbled-numbers.py


```python
# Time:  O(nlogm + nlogn), m is the max of nums
# Space: O(n)

# sort
class Solution(object):
    def sortJumbled(self, mapping, nums):
        """
        :type mapping: List[int]
        :type nums: List[int]
        :rtype: List[int]
        """
        def transform(mapping, x):
            if not x:
                return mapping[x]
            result, base = 0, 1
            while x:
                result += mapping[x%10]*base
                x //= 10
                base *= 10
            return result

        return [nums[i] for _, i in sorted((transform(mapping, nums[i]), i) for i in xrange(len(nums)))]

```



----------------------------------------------------------------------------------------

### Sort - 2231 - https://leetcode.com/problems/largest-number-after-digit-swaps-by-parity/
Time: O(logn)  Space: O(1)   Easy
.Python/largest-number-after-digit-swaps-by-parity.py


```python
# Time:  O(logn)
# Space: O(1)

# counting sort
class Solution(object):
    def largestInteger(self, num):
        """
        :type num: int
        :rtype: int
        """
        def count(num):
            cnt = [0]*10
            while num:
                num, d = divmod(num, 10)
                cnt[d] += 1
            return cnt

        cnt = count(num)
        result = 0
        digit = [0, 1]
        base = 1
        while num:
            num, d = divmod(num, 10)
            while not cnt[digit[d%2]]:
                digit[d%2] += 2
            cnt[digit[d%2]] -= 1
            result += digit[d%2]*base
            base *= 10
        return result

```



----------------------------------------------------------------------------------------

### Sort - 2233 - https://leetcode.com/problems/maximum-product-after-k-increments/
Time: O(n + k)  Space: O(n)   Medium
.Python/maximum-product-after-k-increments.py


```python
# Time:  O(nlogn)
# Space: O(1)

# math, sort
class Solution(object):
    def maximumProduct(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        MOD = 10**9+7
        nums.sort()
        total = sum(nums)
        for i in reversed(xrange(len(nums))):
            if nums[i]*(i+1)-total &lt;= k:
                break
            total -= nums[i]
        q, r = divmod(k+total, i+1)
        return (pow(q, (i+1)-r, MOD)*pow(q+1, r, MOD)*
                reduce(lambda x, y: x*y%MOD, (nums[j] for j in xrange(i+1, len(nums))), 1)) % MOD


# Time:  O(n + k)
# Space: O(n)
import collections


# freq table
class Solution2(object):
    def maximumProduct(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        MOD = 10**9+7
        cnt = collections.Counter(nums)
        min_num = min(cnt.iterkeys())
        while k:
            c = min(cnt[min_num], k)
            cnt[min_num] -= c
            cnt[min_num+1] += c 
            if not cnt[min_num]:
                del cnt[min_num]
                min_num += 1
            k -= c
        return reduce(lambda total, x: total*pow(x[0], x[1], MOD)%MOD, cnt.iteritems(), 1)


# Time:  O(n + klogn)
# Space: O(1)
import heapq


# heap
class Solution3(object):
    def maximumProduct(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        MOD = 10**9+7
        min_heap = nums
        heapq.heapify(min_heap)
        while k:
            heapq.heappush(min_heap, heapq.heappop(min_heap)+1)
            k -= 1
        return reduce(lambda x, y: x*y%MOD, min_heap)

```



----------------------------------------------------------------------------------------

### Sort - 2248 - https://leetcode.com/problems/intersection-of-multiple-arrays/
Time: O(n * l + r)  Space: O(l)   Easy
.Python/intersection-of-multiple-arrays.py


```python
# Time:  O(n * l + r), n = len(nums), l = len(nums[0])
# Space: O(r), r = max(nums)-min(nums)

# freq table, counting sort
class Solution(object):
    def intersection(self, nums):
        """
        :type nums: List[List[int]]
        :rtype: List[int]
        """
        MAX_NUM = 1000
        cnt = [0]*(MAX_NUM+1)
        for num in nums:
            for x in num:
                cnt[x] += 1
        return [i for i in xrange(1, MAX_NUM+1) if cnt[i] == len(nums)]


# Time:  O(n * l + r), n = len(nums), l = len(nums[0]), r = max(nums)-min(nums)
# Space: O(l)
# hash table, counting sort
class Solution2(object):
    def intersection(self, nums):
        """
        :type nums: List[List[int]]
        :rtype: List[int]
        """
        result = set(nums[0])
        for i in xrange(1, len(nums)):
            result = set(x for x in nums[i] if x in result)
        return [i for i in xrange(min(result), max(result)+1) if i in result] if result else []


# Time:  O(n * l + llogl), n = len(nums), l = len(nums[0])
# Space: O(l)
# hash table, sort
class Solution3(object):
    def intersection(self, nums):
        """
        :type nums: List[List[int]]
        :rtype: List[int]
        """
        result = set(nums[0])
        for i in xrange(1, len(nums)):
            result = set(x for x in nums[i] if x in result)
        return sorted(result)

```



----------------------------------------------------------------------------------------

### Sort - 2251 - https://leetcode.com/problems/number-of-flowers-in-full-bloom/
Time: O(nlogn + mlogn)  Space: O(n)   Hard
.Python/number-of-flowers-in-full-bloom.py


```python
# Time:  O(nlogn + mlogn)
# Space: O(n)

import bisect


# line sweep, binary search
class Solution(object):
    def fullBloomFlowers(self, flowers, persons):
        """
        :type flowers: List[List[int]]
        :type persons: List[int]
        :rtype: List[int]
        """
        cnt = collections.Counter()
        for s, e in flowers:
            cnt[s] += 1
            cnt[e+1] -= 1
        events = sorted(cnt.iterkeys())
        prefix = [0]
        for x in events:
            prefix.append(prefix[-1]+cnt[x])
        return [prefix[bisect.bisect_right(events, t)] for t in persons]


# Time:  O(nlogn + mlogn)
# Space: O(n)
import bisect


# binary search
class Solution(object):
    def fullBloomFlowers(self, flowers, persons):
        """
        :type flowers: List[List[int]]
        :type persons: List[int]
        :rtype: List[int]
        """
        starts, ends = [], []
        for s, e in flowers:
            starts.append(s)
            ends.append(e+1)
        starts.sort()
        ends.sort()
        return [bisect.bisect_right(starts, t)-bisect.bisect_right(ends, t) for t in persons]

```



----------------------------------------------------------------------------------------

### Sort - 2343 - https://leetcode.com/problems/query-kth-smallest-trimmed-number/
Time: O(q + n * t)  Space: O(t + n + q)   Medium
.Python/query-kth-smallest-trimmed-number.py


```python
# Time:  O(q + n * t)
# Space: O(t + n + q)

# radix sort
class Solution(object):
    def smallestTrimmedNumbers(self, nums, queries):
        """
        :type nums: List[str]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        max_t = max(t for _, t in queries)
        lookup = [[] for _ in xrange(max_t+1)]
        for i, (k, t) in enumerate(queries):
            lookup[t].append((k, i))
        result = [0]*len(queries)
        idxs = range(len(nums))
        for l in xrange(1, max_t+1):
            cnt = [0]*10
            for i in idxs:
                d = int(nums[i][-l])
                cnt[d] += 1
            for d in xrange(9):
                cnt[d+1] += cnt[d]
            new_idxs = [0]*len(nums)
            for i in reversed(idxs):
                d = int(nums[i][-l])
                cnt[d] -= 1
                new_idxs[cnt[d]] = i
            idxs = new_idxs
            for k, i in lookup[l]:
                result[i] = idxs[k-1]
        return result

            
# Time:  O(q * n * t) on average
# Space: O(n + q)
import random


# quick select
class Solution2(object):
    def smallestTrimmedNumbers(self, nums, queries):
        """
        :type nums: List[str]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        def nth_element(nums, n, compare=lambda a, b: a &lt; b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid &lt;= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left &lt;= n &lt;= pivot_right:
                    return
                elif pivot_left &gt; n:
                    right = pivot_left-1
                else:  # pivot_right &lt; n.
                    left = pivot_right+1

        def compare(a, b):
            for i in xrange(len(nums[a])-t, len(nums[a])):
                if nums[a][i] &lt; nums[b][i]:
                    return True
                if nums[a][i] &gt; nums[b][i]:
                    return False
            return cmp(a, b) &lt; 0

        result = []
        idxs = range(len(nums))
        for k, t in queries:
            nth_element(idxs, k-1, compare=compare)
            result.append(idxs[k-1])
        return result


# Time:  O(q + nlogn * t)
# Space: O(t + n + q)
# sort
class Solution3(object):
    def smallestTrimmedNumbers(self, nums, queries):
        """
        :type nums: List[str]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        def compare(a, b):
            for i in xrange(len(nums[a])-t, len(nums[a])):
                if nums[a][i] &lt; nums[b][i]:
                    return -1
                if nums[a][i] &gt; nums[b][i]:
                    return 1
            return cmp(a, b)

        max_t = max(t for _, t in queries)
        lookup = [[] for _ in xrange(max_t+1)]
        for i, (k, t) in enumerate(queries):
            lookup[t].append((k, i))
        result = [0]*len(queries)
        idxs = range(len(nums))
        for t in xrange(1, max_t+1):
            if not lookup[t]:
                continue
            idxs.sort(cmp=compare)
            for k, i in lookup[t]:
                result[i] = idxs[k-1]
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1004 - https://leetcode.com/problems/max-consecutive-ones-iii/
Time: O(n)  Space: O(1)   Medium
.Python/max-consecutive-ones-iii.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def longestOnes(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: int
        """
        result, i = 0, 0
        for j in xrange(len(A)):
            K -= int(A[j] == 0)
            while K &lt; 0:
                K += int(A[i] == 0)
                i += 1
            result = max(result, j-i+1)
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1033 - https://leetcode.com/problems/moving-stones-until-consecutive/
Time: O(1)  Space: O(1)   Easy
.Python/moving-stones-until-consecutive.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def numMovesStones(self, a, b, c):
        """
        :type a: int
        :type b: int
        :type c: int
        :rtype: List[int]
        """
        s = [a, b, c]
        s.sort()
        if s[0]+1 == s[1] and s[1]+1 == s[2]:
            return [0, 0]
        return [1 if s[0]+2 &gt;= s[1] or s[1]+2 &gt;= s[2] else 2, s[2]-s[0]-2]


# Time:  O(1)
# Space: O(1)
class Solution2(object):
    def numMovesStones(self, a, b, c):
        """
        :type a: int
        :type b: int
        :type c: int
        :rtype: List[int]
        """
        stones = [a, b, c]
        stones.sort()
        left, min_moves = 0, float("inf")
        max_moves = (stones[-1]-stones[0]) - (len(stones)-1)
        for right in xrange(len(stones)):
            while stones[right]-stones[left]+1 &gt; len(stones): # find window size &lt;= len(stones)
                left += 1
            min_moves = min(min_moves, len(stones)-(right-left+1))  # move stones not in this window
        return [min_moves, max_moves]

```



----------------------------------------------------------------------------------------

### Two Pointers - 1040 - https://leetcode.com/problems/moving-stones-until-consecutive-ii/
Time: O(nlogn)  Space: O(1)   Medium
.Python/moving-stones-until-consecutive-ii.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def numMovesStonesII(self, stones):
        """
        :type stones: List[int]
        :rtype: List[int]
        """
        stones.sort()
        left, min_moves = 0, float("inf")
        max_moves = max(stones[-1]-stones[1], stones[-2]-stones[0]) - (len(stones)-2)
        for right in xrange(len(stones)):
            while stones[right]-stones[left]+1 &gt; len(stones): # find window size &lt;= len(stones)
                left += 1
            if len(stones)-(right-left+1) == 1 and stones[right]-stones[left]+1 == len(stones)-1:
                min_moves = min(min_moves, 2)  # case (1, 2, 3, 4), 7
            else:
                min_moves = min(min_moves, len(stones)-(right-left+1))  # move stones not in this window
        return [min_moves, max_moves]

```



----------------------------------------------------------------------------------------

### Two Pointers - 1151 - https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-swaps-to-group-all-1s-together.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minSwaps(self, data):
        """
        :type data: List[int]
        :rtype: int
        """
        total_count = sum(data)
        result, count, left = 0, 0, 0
        for i in xrange(len(data)):
            count += data[i]
            if i-left+1 &gt; total_count: 
                count -= data[left]
                left += 1
            result = max(result, count)
        return total_count-result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1156 - https://leetcode.com/problems/swap-for-longest-repeated-character-substring/
Time: O(n)  Space: O(1)   Medium
.Python/swap-for-longest-repeated-character-substring.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def maxRepOpt1(self, text):
        """
        :type text: str
        :rtype: int
        """
        K = 1
        result = 0
        total_count, count = collections.Counter(), collections.Counter()
        left, max_count = 0, 0
        for i in xrange(len(text)):
            total_count[text[i]] += 1
            count[text[i]] += 1
            max_count = max(max_count, count[text[i]])
            if i-left+1 - max_count &gt; K:
                count[text[left]] -= 1
                left += 1
            result = max(result, min(i-left+1, total_count[text[i]]))
        return result


    
# Time:  O(n)
# Space: O(n)
import itertools


class Solution2(object):
    def maxRepOpt1(self, text):
        """
        :type text: str
        :rtype: int
        """
        A = [[c, len(list(group))] for c, group in itertools.groupby(text)]
        total_count = collections.Counter(text)
        result = max(min(l+1, total_count[c]) for c, l in A)
        for i in xrange(1, len(A)-1):
            if A[i-1][0] == A[i+1][0] and A[i][1] == 1:
                result = max(result, min(A[i-1][1] + 1 + A[i+1][1], total_count[A[i+1][0]]))
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1176 - https://leetcode.com/problems/diet-plan-performance/
Time: O(n)  Space: O(1)   Easy
.Python/diet-plan-performance.py


```python
# Time:  O(n)
# Space: O(1)

import itertools


class Solution(object):
    def dietPlanPerformance(self, calories, k, lower, upper):
        """
        :type calories: List[int]
        :type k: int
        :type lower: int
        :type upper: int
        :rtype: int
        """
        total = sum(itertools.islice(calories, 0, k))
        result = int(total &gt; upper)-int(total &lt; lower)
        for i in xrange(k, len(calories)):
            total += calories[i]-calories[i-k]
            result += int(total &gt; upper)-int(total &lt; lower)
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1208 - https://leetcode.com/problems/get-equal-substrings-within-budget/
Time: O(n)  Space: O(1)   Medium
.Python/get-equal-substrings-within-budget.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def equalSubstring(self, s, t, maxCost):
        """
        :type s: str
        :type t: str
        :type maxCost: int
        :rtype: int
        """
        left = 0
        for right in xrange(len(s)):
            maxCost -= abs(ord(s[right])-ord(t[right]))
            if maxCost &lt; 0:
                maxCost += abs(ord(s[left])-ord(t[left]))
                left += 1
        return (right+1)-left

```



----------------------------------------------------------------------------------------

### Two Pointers - 1213 - https://leetcode.com/problems/intersection-of-three-sorted-arrays/
Time: O(n)  Space: O(1)   Easy
.Python/intersection-of-three-sorted-arrays.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :type arr3: List[int]
        :rtype: List[int]
        """
        result = []
        i, j, k = 0, 0, 0
        while i != len(arr1) and j != len(arr2) and k != len(arr3):
            if arr1[i] == arr2[j] == arr3[k]:
                result.append(arr1[i])
                i += 1
                j += 1
                k += 1
            else:
                curr = max(arr1[i], arr2[j], arr3[k])
                while i != len(arr1) and arr1[i] &lt; curr:
                    i += 1
                while j != len(arr2) and arr2[j] &lt; curr:
                    j += 1
                while k != len(arr3) and arr3[k] &lt; curr:
                    k += 1
        return result


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def arraysIntersection(self, arr1, arr2, arr3):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :type arr3: List[int]
        :rtype: List[int]
        """
        intersect = reduce(set.intersection, map(set, [arr2, arr3]))
        return [x for x in arr1 if x in intersect]

```



----------------------------------------------------------------------------------------

### Two Pointers - 1169 - https://leetcode.com/problems/invalid-transactions/
Time: O(nlogn)  Space: O(n)   Medium
.Python/invalid-transactions.py


```python
# Time:  O(nlogn)
# Space: O(n)


import collections


class Solution:
    def invalidTransactions(self, transactions):
        AMOUNT, MINUTES = 1000, 60
        trans = map(lambda x: (x[0], int(x[1]), int(x[2]), x[3]),
                    (transaction.split(',') for transaction in transactions))
        trans.sort(key=lambda t: t[1])
        trans_indexes = collections.defaultdict(list)
        for i, t in enumerate(trans):
            trans_indexes[t[0]].append(i)
        result = []
        for name, indexes in trans_indexes.iteritems():
            left, right = 0, 0
            for i, t_index in enumerate(indexes):
                t = trans[t_index]
                if (t[2] &gt; AMOUNT):
                    result.append("{},{},{},{}".format(*t))
                    continue
                while left+1 &lt; len(indexes) and trans[indexes[left]][1] &lt; t[1]-MINUTES:
                    left += 1
                while right+1 &lt; len(indexes) and trans[indexes[right+1]][1] &lt;= t[1]+MINUTES:
                    right += 1
                for i in xrange(left, right+1):
                    if trans[indexes[i]][3] != t[3]:
                        result.append("{},{},{},{}".format(*t))
                        break
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1214 - https://leetcode.com/problems/two-sum-bsts/
Time: O(n)  Space: O(n)   Medium
.Python/two-sum-bsts.py


```python
# Time:  O(n)
# Space: O(n)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def twoSumBSTs(self, root1, root2, target):
        """
        :type root1: TreeNode
        :type root2: TreeNode
        :type target: int
        :rtype: bool
        """
        def inorder_gen(root, asc=True):
            result, stack = [], [(root, False)]
            while stack:
                root, is_visited = stack.pop()
                if root is None:
                    continue
                if is_visited:
                    yield root.val
                else:
                    if asc:
                        stack.append((root.right, False))
                        stack.append((root, True))
                        stack.append((root.left, False))
                    else:
                        stack.append((root.left, False))
                        stack.append((root, True))
                        stack.append((root.right, False))
        
        left_gen, right_gen = inorder_gen(root1, True), inorder_gen(root2, False)
        left, right = next(left_gen), next(right_gen)
        while left is not None and right is not None:
            if left + right &lt; target:
                left = next(left_gen)
            elif left + right &gt; target:
                right = next(right_gen)
            else:
                return True
        return False

```



----------------------------------------------------------------------------------------

### Two Pointers - 1234 - https://leetcode.com/problems/replace-the-substring-for-balanced-string/
Time: O(n)  Space: O(t)   Medium
.Python/replace-the-substring-for-balanced-string.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def balancedString(self, s):
        """
        :type s: str
        :rtype: int
        """
        count = collections.Counter(s)
        result = len(s) 
        left = 0
        for right in xrange(len(s)):
            count[s[right]] -= 1
            while left &lt; len(s) and \
                  all(v &lt;= len(s)//4 for v in count.itervalues()):
                result = min(result, right-left+1)
                count[s[left]] += 1
                left += 1
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1248 - https://leetcode.com/problems/count-number-of-nice-subarrays/
Time: O(n)  Space: O(k)   Medium
.Python/count-number-of-nice-subarrays.py


```python
# Time:  O(n)
# Space: O(k)

class Solution(object):
    def numberOfSubarrays(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def atMost(nums, k):
            result, left, count = 0, 0, 0
            for right, x in enumerate(nums):
                count += x%2
                while count &gt; k:
                    count -= nums[left]%2
                    left += 1
                result += right-left+1
            return result

        return atMost(nums, k) - atMost(nums, k-1)


# Time:  O(n)
# Space: O(k)
import collections


class Solution2(object):
    def numberOfSubarrays(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        result = 0
        dq = collections.deque([-1])
        for i in xrange(len(nums)):
            if nums[i]%2:
                dq.append(i)
            if len(dq) &gt; k+1:
                dq.popleft()
            if len(dq) == k+1:
                result += dq[1]-dq[0]
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1297 - https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/
Time: O(n)  Space: O(n)   Medium
.Python/maximum-number-of-occurrences-of-a-substring.py


```python
# Time:  O(n)
# Space: O(n)

import collections


# rolling hash (Rabin-Karp Algorithm)
class Solution(object):
    def maxFreq(self, s, maxLetters, minSize, maxSize):
        """
        :type s: str
        :type maxLetters: int
        :type minSize: int
        :type maxSize: int
        :rtype: int
        """
        M, p = 10**9+7, 113
        power, rolling_hash = pow(p, minSize-1, M), 0

        left = 0
        lookup, count = collections.defaultdict(int), collections.defaultdict(int)
        for right in xrange(len(s)):
            count[s[right]] += 1
            if right-left+1 &gt; minSize:
                count[s[left]] -= 1
                rolling_hash = (rolling_hash - ord(s[left])*power) % M
                if count[s[left]] == 0:
                    count.pop(s[left])
                left += 1
            rolling_hash = (rolling_hash*p + ord(s[right])) % M
            if right-left+1 == minSize and len(count) &lt;= maxLetters:
                lookup[rolling_hash] += 1
        return max(lookup.values() or [0])


# Time:  O(m * n), m = 26
# Space: O(m * n)
class Solution2(object):
    def maxFreq(self, s, maxLetters, minSize, maxSize):
        """
        :type s: str
        :type maxLetters: int
        :type minSize: int
        :type maxSize: int
        :rtype: int
        """
        lookup = {}
        for right in xrange(minSize-1, len(s)):
            word = s[right-minSize+1:right+1]
            if word in lookup:
                lookup[word] += 1
            elif len(collections.Counter(word)) &lt;= maxLetters:
                lookup[word] = 1
        return max(lookup.values() or [0])

```



----------------------------------------------------------------------------------------

### Two Pointers - 1305 - https://leetcode.com/problems/all-elements-in-two-binary-search-trees/
Time: O(n)  Space: O(h)   Medium
.Python/all-elements-in-two-binary-search-trees.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def getAllElements(self, root1, root2):
        """
        :type root1: TreeNode
        :type root2: TreeNode
        :rtype: List[int]
        """
        def inorder_gen(root):
            result, stack = [], [(root, False)]
            while stack:
                root, is_visited = stack.pop()
                if root is None:
                    continue
                if is_visited:
                    yield root.val
                else:
                    stack.append((root.right, False))
                    stack.append((root, True))
                    stack.append((root.left, False))
            yield None
        
        result = []
        left_gen, right_gen = inorder_gen(root1), inorder_gen(root2)
        left, right = next(left_gen), next(right_gen)
        while left is not None or right is not None:
            if right is None or (left is not None and left &lt; right):
                result.append(left)
                left = next(left_gen)
            else:
                result.append(right)
                right = next(right_gen)
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1316 - https://leetcode.com/problems/distinct-echo-substrings/
Time: O(n^2 + d)  Space: O(r)   Hard
.Python/distinct-echo-substrings.py


```python
# Time:  O(n^2 + d), d is the duplicated of result substrings size
# Space: O(r), r is the size of result substrings set

class Solution(object):
    def distinctEchoSubstrings(self, text):
        """
        :type text: str
        :rtype: int
        """
        def KMP(text, l, result):
            prefix = [-1]*(len(text)-l)
            j = -1
            for i in xrange(1, len(prefix)):
                while j &gt; -1 and text[l+j+1] != text[l+i]:
                    j = prefix[j]
                if text[l+j+1] == text[l+i]:
                    j += 1
                prefix[i] = j
                if (j+1) and (i+1) % ((i+1) - (j+1)) == 0 and \
                   (i+1) // ((i+1) - (j+1)) % 2 == 0:
                    result.add(text[l:l+i+1])
            return len(prefix)-(prefix[-1]+1) \
                   if prefix[-1]+1 and len(prefix) % (len(prefix)-(prefix[-1]+1)) == 0 \
                   else float("inf")

        result = set()
        i, l = 0, len(text)-1
        while i &lt; l:  # aaaaaaaaaaaaaaaaaaaaaaaaaaaaaabcdefabcdefabcdef
            l = min(l, i + KMP(text, i, result));
            i += 1
        return len(result)


# Time:  O(n^2 + d), d is the duplicated of result substrings size
# Space: O(r), r is the size of result substrings set
class Solution2(object):
    def distinctEchoSubstrings(self, text):
        """
        :type text: str
        :rtype: int
        """
        result = set()
        for l in xrange(1, len(text)//2+1):
            count = sum(text[i] == text[i+l] for i in xrange(l))
            for i in xrange(len(text)-2*l):
                if count == l:
                    result.add(text[i:i+l])
                count += (text[i+l] == text[i+l+l]) - (text[i] == text[i+l])
            if count == l:
                result.add(text[len(text)-2*l:len(text)-2*l+l])
        return len(result)


# Time:  O(n^2 + d), d is the duplicated of result substrings size
# Space: O(r), r is the size of result substrings set
class Solution3(object):
    def distinctEchoSubstrings(self, text):
        """
        :type text: str
        :rtype: int
        """
        MOD = 10**9+7
        D = 27  # a-z and ''
        result = set()
        for i in xrange(len(text)-1):
            left, right, pow_D = 0, 0, 1
            for l in xrange(1, min(i+2, len(text)-i)):
                left = (D*left + (ord(text[i-l+1])-ord('a')+1)) % MOD
                right = (pow_D*(ord(text[i+l])-ord('a')+1) + right) % MOD
                if left == right:  # assumed no collision
                    result.add(left)
                pow_D = (pow_D*D) % MOD 
        return len(result)


# Time:  O(n^3 + d), d is the duplicated of result substrings size
# Space: O(r), r is the size of result substrings set
class Solution_TLE(object):
    def distinctEchoSubstrings(self, text):
        """
        :type text: str
        :rtype: int
        """
        def compare(text, l, s1, s2):
            for i in xrange(l):
                if text[s1+i] != text[s2+i]:
                    return False
            return True

        MOD = 10**9+7
        D = 27  # a-z and ''
        result = set()
        for i in xrange(len(text)):
            left, right, pow_D = 0, 0, 1
            for l in xrange(1, min(i+2, len(text)-i)):
                left = (D*left + (ord(text[i-l+1])-ord('a')+1)) % MOD
                right = (pow_D*(ord(text[i+l])-ord('a')+1) + right) % MOD
                if left == right and compare(text, l, i-l+1, i+1):
                    result.add(text[i+1:i+1+l])
                pow_D = (pow_D*D) % MOD 
        return len(result)

```



----------------------------------------------------------------------------------------

### Two Pointers - 1358 - https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-substrings-containing-all-three-characters.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def numberOfSubstrings(self, s):
        """
        :type s: str
        :rtype: int
        """
        result, left = 0, [-1]*3
        for right, c in enumerate(s):
            left[ord(c)-ord('a')] = right
            result += min(left)+1
        return result


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def numberOfSubstrings(self, s):
        """
        :type s: str
        :rtype: int
        """
        result, left, count = 0, 0, [0]*3
        for right, c in enumerate(s):
            count[ord(s[right])-ord('a')] += 1
            while all(count):
                count[ord(s[left])-ord('a')] -= 1
                left += 1
            result += left
        return result


# Time:  O(n)
# Space: O(1)
class Solution3(object):
    def numberOfSubstrings(self, s):
        """
        :type s: str
        :rtype: int
        """
        result, right, count = 0, 0, [0]*3
        for left, c in enumerate(s):
            while right &lt; len(s) and not all(count):
                count[ord(s[right])-ord('a')] += 1
                right += 1
            if all(count):
                result += (len(s)-1) - (right-1) + 1
            count[ord(c)-ord('a')] -= 1
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1423 - https://leetcode.com/problems/maximum-points-you-can-obtain-from-cards/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-points-you-can-obtain-from-cards.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxScore(self, cardPoints, k):
        """
        :type cardPoints: List[int]
        :type k: int
        :rtype: int
        """
        result, total, curr, left = float("inf"), 0, 0, 0
        for right, point in enumerate(cardPoints):
            total += point
            curr += point
            if right-left+1 &gt; len(cardPoints)-k:
                curr -= cardPoints[left]
                left += 1
            if right-left+1 == len(cardPoints)-k:
                result = min(result, curr)
        return total-result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1425 - https://leetcode.com/problems/constrained-subset-sum/
Time: O(n)  Space: O(k)   Hard
.Python/constrained-subset-sum.py


```python
# Time:  O(n)
# Space: O(k)

import collections


class Solution(object):
    def constrainedSubsetSum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        result, dq = float("-inf"), collections.deque()
        for i in xrange(len(nums)):
            if dq and i-dq[0][0] == k+1:
                dq.popleft()
            curr = nums[i] + (dq[0][1] if dq else 0)
            while dq and dq[-1][1] &lt;= curr:
                dq.pop()
            if curr &gt; 0:
                dq.append((i, curr))
            result = max(result, curr)
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1456 - https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-number-of-vowels-in-a-substring-of-given-length.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxVowels(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: int
        """
        VOWELS = set("aeiou")
        result = curr = 0
        for i, c in enumerate(s):
            curr += c in VOWELS
            if i &gt;= k:
                curr -= s[i-k] in VOWELS
            result = max(result, curr)
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1493 - https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/
Time: O(n)  Space: O(1)   Medium
.Python/longest-subarray-of-1s-after-deleting-one-element.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def longestSubarray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        count, left = 0, 0
        for right in xrange(len(nums)):
            count += (nums[right] == 0)
            if count &gt;= 2:
                count -= (nums[left] == 0)
                left += 1
        return (right-left+1)-1


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def longestSubarray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result, count, left = 0, 0, 0
        for right in xrange(len(nums)):
            count += (nums[right] == 0)
            while count &gt;= 2:
                count -= (nums[left] == 0)
                left += 1
            result = max(result, right-left+1)
        return result-1

```



----------------------------------------------------------------------------------------

### Two Pointers - 1498 - https://leetcode.com/problems//number-of-subsequences-that-satisfy-the-given-sum-condition/
Time: O(nlogn)  Space: O(n)   Medium
.Python/number-of-subsequences-that-satisfy-the-given-sum-condition.py


```python
# Time:  O(nlogn)
# Space: O(n)

class Solution(object):
    def numSubseq(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        MOD = 10**9 + 7
        nums.sort()
        result = 0
        left, right = 0, len(nums)-1
        while left &lt;= right:
            if nums[left]+nums[right] &gt; target:
                right -= 1
            else:
                result = (result+pow(2, right-left, MOD))%MOD
                left += 1
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1508 - https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/
Time: O(nlog(sum(nums)))  Space: O(n)   Medium
.Python/range-sum-of-sorted-subarray-sums.py


```python
# Time:  O(nlog(sum(nums)))
# Space: O(n)

# binary search + sliding window solution
class Solution(object):
    def rangeSum(self, nums, n, left, right):
        """
        :type nums: List[int]
        :type n: int
        :type left: int
        :type right: int
        :rtype: int
        """
        def countUntil(nums, target):
            result, curr, left = 0, 0, 0
            for right in xrange(len(nums)):
                curr += nums[right]
                while curr &gt; target:
                    curr -= nums[left]
                    left += 1
                result += right-left+1
            return result
        
        def sumUntil(nums, prefix, target):
            result, curr, total, left = 0, 0, 0, 0
            for right in xrange(len(nums)):
                curr += nums[right]
                total += nums[right]*(right-left+1)
                while curr &gt; target:
                    curr -= nums[left]
                    total -= prefix[right+1]-prefix[(left-1)+1]
                    left += 1
                result += total
            return result
            
        def sumLessOrEqualTo(prefix, nums, left, right, count):
            while left &lt;= right:
                mid = left + (right-left)//2
                if countUntil(nums, mid)-count &gt;= 0:
                    right = mid-1
                else:
                    left = mid+1
            return sumUntil(nums, prefix, left)-left*(countUntil(nums, left)-count)
    
        MOD = 10**9+7
        prefix = [0]*(len(nums)+1)
        for i in xrange(len(nums)):
            prefix[i+1] = prefix[i]+nums[i]
        m, M = min(nums), sum(nums)
        return (sumLessOrEqualTo(prefix, nums, m, M, right) -
                sumLessOrEqualTo(prefix, nums, m, M, left-1))%MOD
    

    
# Time:  O(rlogr), worst: O(n^2 * logn)
# Space: O(n)
import heapq


# heap solution
class Solution2(object):
    def rangeSum(self, nums, n, left, right):
        """
        :type nums: List[int]
        :type n: int
        :type left: int
        :type right: int
        :rtype: int
        """
        MOD = 10**9+7
        min_heap = [];
        for i, num in enumerate(nums, 1):
            heapq.heappush(min_heap, (num, i))
        result = 0
        for i in xrange(1, right+1):
            total, j = heapq.heappop(min_heap)
            if i &gt;= left:
                result = (result+total)%MOD
            if j+1 &lt;= n:
                heapq.heappush(min_heap, (total+nums[j], j+1))
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1521 - https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/
Time: O(nlogm)  Space: O(logm)   Hard
.Python/find-a-value-of-a-mysterious-function-closest-to-target.py


```python
# Time:  O(nlogm), m is the max value of arr
# Space: O(logm)

class BitCount(object):
    def __init__(self, n):
        self.__l = 0
        self.__n = n
        self.__count = [0]*n
    
    def __iadd__(self, num):
        self.__l += 1
        base = 1
        for i in xrange(self.__n):
            if num&amp;base:
                self.__count[i] += 1
            base &lt;&lt;= 1
        return self

    def __isub__(self, num):
        self.__l -= 1
        base = 1
        for i in xrange(self.__n):
            if num&amp;base:
                self.__count[i] -= 1
            base &lt;&lt;= 1
        return self
            
    def bit_and(self):
        num, base = 0, 1
        for i in xrange(self.__n):
            if self.__count[i] == self.__l:
                num |= base
            base &lt;&lt;= 1
        return num


class Solution(object):
    def closestToTarget(self, arr, target):
        """
        :type arr: List[int]
        :type target: int
        :rtype: int
        """
        count = BitCount(max(arr).bit_length())
        result, left = float("inf"), 0
        for right in xrange(len(arr)):
            count += arr[right]
            while left &lt;= right:
                f = count.bit_and()
                result = min(result, abs(f-target))
                if f &gt;= target:
                    break
                count -= arr[left]
                left += 1
        return result
                    
  
# Time:  O(nlogm), m is the max value of arr
# Space: O(logm)
class Solution2(object):
    def closestToTarget(self, arr, target):
        """
        :type arr: List[int]
        :type target: int
        :rtype: int
        """
        result, dp = float("inf"), set()  # at most O(logm) dp states
        for x in arr:
            dp = {x}|{f&amp;x for f in dp}
            for f in dp:
                result = min(result, abs(f-target))
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1604 - https://leetcode.com/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period/
Time: O(nlogn)  Space: O(n)   Medium
.Python/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections
import itertools


class Solution(object):
    def alertNames(self, keyName, keyTime):
        """
        :type keyName: List[str]
        :type keyTime: List[str]
        :rtype: List[str]
        """
        THRESHOLD = 3
        name_to_times = collections.defaultdict(list)
        for name, hour_minute in itertools.izip(keyName, keyTime):
            hour, minute = map(int, hour_minute.split(':'))
            name_to_times[name].append(hour*60 + minute)
        names = []    
        for name, times in name_to_times.iteritems():
            times.sort()
            left = 0
            for right, time in enumerate(times):
                while time-times[left] &gt; 60:
                    left += 1
                if right-left+1 &gt;= THRESHOLD:
                    names.append(name)
                    break
        names.sort()
        return names

```



----------------------------------------------------------------------------------------

### Two Pointers - 1658 - https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-operations-to-reduce-x-to-zero.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minOperations(self, nums, x):
        """
        :type nums: List[int]
        :type x: int
        :rtype: int
        """
        target = sum(nums)-x
        result = -1
        curr = left = 0
        for right in xrange(len(nums)):
            curr += nums[right]
            while left &lt; len(nums) and curr &gt; target:
                curr -= nums[left]
                left += 1
            if curr == target:
                result = max(result, right-left+1)
        return len(nums)-result if result != -1 else -1

```



----------------------------------------------------------------------------------------

### Two Pointers - 1687 - https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/
Time: O(nlogn)  Space: O(n)   Hard
.Python/delivering-boxes-from-storage-to-ports.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def boxDelivering(self, boxes, portsCount, maxBoxes, maxWeight):
        """
        :type boxes: List[List[int]]
        :type portsCount: int
        :type maxBoxes: int
        :type maxWeight: int
        :rtype: int
        """
        dp = [0]*(len(boxes)+1)
        left, cost, curr = 0, 1, 0
        for right in xrange(len(boxes)):
            if right == 0 or boxes[right][0] != boxes[right-1][0]:
                cost += 1
            curr += boxes[right][1]
            while right-left+1 &gt; maxBoxes or \
                  curr &gt; maxWeight or \
                  (left+1 &lt; right+1 and dp[left+1] == dp[left]):  # greedily drop box to make cost as smaller as possible
                curr -= boxes[left][1]
                if boxes[left+1][0] != boxes[left][0]:
                    cost -= 1
                left += 1
            dp[right+1] = dp[(left-1)+1] + cost
        return dp[len(boxes)]

```



----------------------------------------------------------------------------------------

### Two Pointers - 1695 - https://leetcode.com/problems/maximum-erasure-value/
Time: O(n)  Space: O(n)   Medium
.Python/maximum-erasure-value.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def maximumUniqueSubarray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        lookup = {}
        prefix = [0]*(len(nums)+1)
        result, left = 0, 0
        for right, num in enumerate(nums):
            prefix[right+1] = prefix[right]+num
            if num in lookup:
                left = max(left, lookup[num]+1)
            lookup[num] = right
            result = max(result, prefix[right+1]-prefix[left])
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1712 - https://leetcode.com/problems/ways-to-split-array-into-three-subarrays/
Time: O(n)  Space: O(n)   Medium
.Python/ways-to-split-array-into-three-subarrays.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def waysToSplit(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        MOD = 10**9+7

        prefix = [0]
        for x in nums:
            prefix.append(prefix[-1]+x)

        result = left = right = 0 
        for i in xrange(len(nums)): 
            left = max(left, i+1)
            while left+1 &lt; len(nums) and prefix[i+1] &gt; prefix[left+1]-prefix[i+1]:
                left += 1
            right = max(right, left)
            while right+1 &lt; len(nums) and prefix[right+1]-prefix[i+1] &lt;= prefix[-1]-prefix[right+1]:
                right += 1
            result = (result + (right-left))%MOD
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1750 - https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-length-of-string-after-deleting-similar-ends.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minimumLength(self, s):
        """
        :type s: str
        :rtype: int
        """
        left, right = 0, len(s)-1
        while left &lt; right:
            if s[left] != s[right]:
                break
            c = s[left]
            while left &lt;= right:
                if s[left] != c:
                    break
                left += 1
            while left &lt;= right:
                if s[right] != c:
                    break
                right -= 1
        return right-left+1

```



----------------------------------------------------------------------------------------

### Two Pointers - 1838 - https://leetcode.com/problems/frequency-of-the-most-frequent-element/
Time: O(nlogn)  Space: O(n)   Medium
.Python/frequency-of-the-most-frequent-element.py


```python
# Time:  O(nlogn)
# Space: O(n)

class Solution(object):
    def maxFrequency(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        left = 0
        nums.sort()
        for right in xrange(len(nums)):
            k += nums[right]
            if k &lt; nums[right]*(right-left+1):
                k -= nums[left]
                left += 1
        return right-left+1

```



----------------------------------------------------------------------------------------

### Two Pointers - 1852 - https://leetcode.com/problems/distinct-numbers-in-each-subarray/
Time: O(n)  Space: O(k)   Medium
.Python/distinct-numbers-in-each-subarray.py


```python
# Time:  O(n)
# Space: O(k)

import collections


class Solution(object):
    def distinctNumbers(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        result = []
        count = collections.Counter()
        for i, num in enumerate(nums):
            count[num] += 1
            if i &gt;= k:
                count[nums[i-k]] -= 1
                if not count[nums[i-k]]:
                    del count[nums[i-k]]
            if i+1 &gt;= k:
                result.append(len(count))
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1855 - https://leetcode.com/problems/maximum-distance-between-a-pair-of-values/
Time: O(n + m)  Space: O(1)   Medium
.Python/maximum-distance-between-a-pair-of-values.py


```python
# Time:  O(n + m)
# Space: O(1)

class Solution(object):
    def maxDistance(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        result = i = j = 0
        while i &lt; len(nums1) and j &lt; len(nums2):
            if nums1[i] &gt; nums2[j]:
                i += 1
            else:
                result = max(result, j-i)
                j += 1
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1868 - https://leetcode.com/problems/product-of-two-run-length-encoded-arrays/
Time: O(m + n)  Space: O(1)   Medium
.Python/product-of-two-run-length-encoded-arrays.py


```python
# Time:  O(m + n)
# Space: O(1)

class Solution(object):
    def findRLEArray(self, encoded1, encoded2):
        """
        :type encoded1: List[List[int]]
        :type encoded2: List[List[int]]
        :rtype: List[List[int]]
        """
        result = []
        i = j = remain1 = remain2 = 0
        while (remain1 or i &lt; len(encoded1)) and (remain2 or j &lt; len(encoded2)):
            if not remain1:
                remain1 = encoded1[i][1]
                i += 1
            if not remain2:
                remain2 = encoded2[j][1]
                j += 1
            cnt = min(remain1, remain2)
            remain1 -= cnt
            remain2 -= cnt
            if result and result[-1][0] == encoded1[i-1][0]*encoded2[j-1][0]:
                result[-1][1] += cnt
            else:
                result.append([encoded1[i-1][0]*encoded2[j-1][0], cnt])
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1885 - https://leetcode.com/problems/count-pairs-in-two-arrays/
Time: O(nlogn)  Space: O(1)   Medium
.Python/count-pairs-in-two-arrays.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def countPairs(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        for i in xrange(len(nums1)):
            nums1[i] -= nums2[i]
        nums1.sort()
        result = 0
        left, right = 0, len(nums1)-1
        while left &lt; right:
            if nums1[left] &gt; 0 or -nums1[left] &lt; nums1[right]:
                result += right-left
                right -= 1
            else:
                left += 1
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1888 - https://leetcode.com/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-number-of-flips-to-make-the-binary-string-alternating.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minFlips(self, s):
        """
        :type s: str
        :rtype: int
        """
        result = float("inf")
        cnt1 = cnt2 = 0
        for i in xrange(2*len(s)-1 if len(s)%2 else len(s)):
            if i &gt;= len(s):
                cnt1 -= int(s[i%len(s)])^((i-len(s))%2)^0
                cnt2 -= int(s[i%len(s)])^((i-len(s))%2)^1
            cnt1 += int(s[i%len(s)])^(i%2)^0
            cnt2 += int(s[i%len(s)])^(i%2)^1
            if i &gt;= len(s)-1:
                result = min(result, cnt1, cnt2)
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 1984 - https://leetcode.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/
Time: O(nlogn)  Space: O(1)   Easy
.Python/minimum-difference-between-highest-and-lowest-of-k-scores.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def minimumDifference(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        nums.sort()
        return min(nums[i]-nums[i-k+1] for i in xrange(k-1, len(nums)))

```



----------------------------------------------------------------------------------------

### Two Pointers - 1989 - https://leetcode.com/problems/maximum-number-of-people-that-can-be-caught-in-tag/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-number-of-people-that-can-be-caught-in-tag.py


```python
# Time:  O(n)
# Space: O(1)

# greedy with two pointers solution
class Solution(object):
    def catchMaximumAmountofPeople(self, team, dist):
        """
        :type team: List[int]
        :type dist: int
        :rtype: int
        """
        result = i = j = 0
        while i &lt; len(team) and j &lt; len(team):
            if i+dist &lt; j or team[i] != 1:
                i += 1
            elif j+dist &lt; i or team[j] != 0:
                j += 1
            else:
                result += 1
                i += 1
                j += 1
        return result


# Time:  O(n)
# Space: O(1)
# greedy with sliding window solution
class Solution2(object):
    def catchMaximumAmountofPeople(self, team, dist):
        """
        :type team: List[int]
        :type dist: int
        :rtype: int
        """
        result = j = 0
        for i in xrange(len(team)):
            if not team[i]:
                continue
            while j &lt; i-dist:
                j += 1
            while j &lt;= min(i+dist, len(team)-1):
                if team[j] == 0:
                    break
                j += 1
            if j &lt;= min(i+dist, len(team)-1):
                result += 1
                j += 1
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2009 - https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/
Time: O(nlogn)  Space: O(1)   Hard
.Python/minimum-number-of-operations-to-make-array-continuous.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def minOperations(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def unique(nums):
            left = 0
            for right in xrange(1, len(nums)):
                if nums[left] != nums[right]:
                    left += 1
                    nums[left] = nums[right]
            return left

        def erase(nums, i):
            while len(nums) &gt; i+1:
                nums.pop()

        n = len(nums)
        nums.sort()
        erase(nums, unique(nums))
        result = l = 0
        for i in xrange(len(nums)):
            if nums[i] &lt;= nums[i-l]+n-1:
                l += 1
        return n-l


# Time:  O(nlogn)
# Space: O(n)
class Solution2(object):
    def minOperations(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        n = len(nums)
        nums = sorted(set(nums))
        result = right = 0
        for left in xrange(len(nums)):
            while right &lt; len(nums) and nums[right] &lt;= nums[left]+n-1:
                right += 1
            result = max(result, right-left)
        return n-result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2024 - https://leetcode.com/problems/maximize-the-confusion-of-an-exam/
Time: O(n)  Space: O(1)   Medium
.Python/maximize-the-confusion-of-an-exam.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def maxConsecutiveAnswers(self, answerKey, k):
        """
        :type answerKey: str
        :type k: int
        :rtype: int
        """
        result = max_count = 0
        count = collections.Counter()
        for i in xrange(len(answerKey)):
            count[answerKey[i]] += 1
            max_count = max(max_count, count[answerKey[i]])
            if result-max_count &gt;= k:
                count[answerKey[i-result]] -= 1
            else:
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2040 - https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/
Time: O((m + n) * logr)  Space: O(1)   Hard
.Python/kth-smallest-product-of-two-sorted-arrays.py


```python
# Time:  O((m + n) * logr), r is the range size of [min(products), max(products)]
# Space: O(1)

class Solution(object):
    def kthSmallestProduct(self, nums1, nums2, k):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :type k: int
        :rtype: int
        """
        def check(nums1, nums2, k, neg_cnt, target):
            cnt = 0
            left, right = 0, len(nums2)-1
            direction = reversed if target &gt;= 0 else lambda x: x
            for i in direction(xrange(neg_cnt)):
                while left &lt; len(nums2) and nums1[i]*nums2[left] &gt; target:
                    left += 1
                cnt += (len(nums2)-1)-left+1
            direction = (lambda x: x) if target &gt;= 0 else reversed
            for i in direction(xrange(neg_cnt, len(nums1))): 
                if nums1[i] == 0: 
                    if target &gt;= 0:
                        cnt += len(nums2)
                    continue
                while right &gt;= 0 and nums1[i]*nums2[right] &gt; target:
                    right -= 1
                cnt += right-0+1
            return cnt &gt;= k

        neg_cnt = sum(x &lt; 0 for x in nums1)
        left = min(nums1[i]*nums2[j] for i in (0, -1) for j in (0, -1))
        right = max(nums1[i]*nums2[j] for i in (0, -1) for j in (0, -1))
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(nums1, nums2, k, neg_cnt, mid):
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Two Pointers - 2046 - https://leetcode.com/problems/sort-linked-list-already-sorted-using-absolute-values/
Time: O(n)  Space: O(1)   Medium
.Python/sort-linked-list-already-sorted-using-absolute-values.py


```python
# Time:  O(n)
# Space: O(1)

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class Solution(object):
    def sortLinkedList(self, head):
        """
        :type head: Optional[ListNode]
        :rtype: Optional[ListNode]
        """
        tail, curr, head.next = head, head.next, None
        while curr:
            if curr.val &gt; 0:
                curr.next, tail.next, tail, curr = None, curr, curr, curr.next
            else:
                curr.next, head, curr = head, curr, curr.next
        return head

```



----------------------------------------------------------------------------------------

### Two Pointers - 2062 - https://leetcode.com/problems/count-vowel-substrings-of-a-string/
Time: O(n)  Space: O(1)   Easy
.Python/count-vowel-substrings-of-a-string.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def countVowelSubstrings(self, word):
        """
        :type word: str
        :rtype: int
        """
        VOWELS = set("aeiou")
        k = 5
        def atLeastK(word, k):
            cnt = collections.Counter()
            result = left = right = 0
            for i, c in enumerate(word):
                if c not in VOWELS:
                    cnt = collections.Counter()
                    left = right = i+1
                    continue
                cnt[c] += 1
                while len(cnt) &gt; k-1:
                    cnt[word[right]] -= 1
                    if not cnt[word[right]]:
                        del cnt[word[right]]
                    right += 1
                result += right-left
            return result

        return atLeastK(word, k)


# Time:  O(n)
# Space: O(1)
import collections


class Solution2(object):
    def countVowelSubstrings(self, word):
        """
        :type word: str
        :rtype: int
        """
        VOWELS = set("aeiou")
        k = 5
        def atMostK(word, k):
            cnt = collections.Counter()
            result = left = 0
            for right, c in enumerate(word):
                if c not in VOWELS:
                    cnt = collections.Counter()
                    left = right+1
                    continue
                cnt[c] += 1
                while len(cnt) &gt; k:
                    cnt[word[left]] -=1
                    if not cnt[word[left]]:
                        del cnt[word[left]]
                    left += 1
                result += right-left+1
            return result

        return atMostK(word, k) - atMostK(word, k-1)

```



----------------------------------------------------------------------------------------

### Two Pointers - 2067 - https://leetcode.com/problems/number-of-equal-count-substrings/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-equal-count-substrings.py


```python
# Time:  O(26 * n) = O(n)
# Space: O(26) = O(1)

class Solution(object):
    def equalCountSubstrings(self, s, count):
        """
        :type s: str
        :type count: int
        :rtype: int
        """
        result = 0
        for l in xrange(1, min(len(set(s)), len(s)//count)+1):
            cnt, equal_cnt = collections.Counter(), 0
            for i, c in enumerate(s):
                cnt[c] += 1
                equal_cnt += (cnt[c] == count)
                if i &gt;= count*l:
                    equal_cnt -= (cnt[s[i-count*l]] == count)
                    cnt[s[i-count*l]] -= 1
                result += (equal_cnt == l)
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2090 - https://leetcode.com/problems/k-radius-subarray-averages/
Time: O(n)  Space: O(1)   Medium
.Python/k-radius-subarray-averages.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def getAverages(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        total, l = 0, 2*k+1
        result = [-1]*len(nums)
        for i in xrange(len(nums)):
            total += nums[i]
            if i-l &gt;= 0:
                total -= nums[i-l]
            if i &gt;= l-1:
                result[i-k] = total//l
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2105 - https://leetcode.com/problems/watering-plants-ii/
Time: O(n)  Space: O(1)   Medium
.Python/watering-plants-ii.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minimumRefill(self, plants, capacityA, capacityB):
        """
        :type plants: List[int]
        :type capacityA: int
        :type capacityB: int
        :rtype: int
        """
        result = 0 
        left, right = 0, len(plants)-1
        canA, canB = capacityA, capacityB
        while left &lt; right: 
            if canA &lt; plants[left]:
                result += 1
                canA = capacityA
            canA -= plants[left]
            if canB &lt; plants[right]:
                result += 1
                canB = capacityB
            canB -= plants[right]
            left, right = left+1, right-1
        if left == right:
            if max(canA, canB) &lt; plants[left]:
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2107 - https://leetcode.com/problems/number-of-unique-flavors-after-sharing-k-candies/
Time: O(n)  Space: O(n)   Medium
.Python/number-of-unique-flavors-after-sharing-k-candies.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def shareCandies(self, candies, k):
        """
        :type candies: List[int]
        :type k: int
        :rtype: int
        """
        cnt = collections.Counter(candies[i] for i in xrange(k, len(candies)))
        result = curr = len(cnt)
        for i in xrange(k, len(candies)):
            cnt[candies[i]] -= 1
            curr += (cnt[candies[i-k]] == 0) - (cnt[candies[i]] == 0)
            cnt[candies[i-k]] += 1
            result = max(result, curr)
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2134 - https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-swaps-to-group-all-1s-together-ii.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minSwaps(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = cnt = w = nums.count(1)
        for i in xrange(len(nums)+(w-1)):
            if i &gt;= w:
                cnt += nums[(i-w)%len(nums)]
            cnt -= nums[i%len(nums)]
            result = min(result, cnt)
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2149 - https://leetcode.com/problems/rearrange-array-elements-by-sign/
Time: O(n)  Space: O(1)   Medium
.Python/rearrange-array-elements-by-sign.py


```python
# Time:  O(n)
# Space: O(1)

# two pointers
class Solution(object):
    def rearrangeArray(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        pos, neg = 0, 1
        result = [0]*len(nums)
        for x in nums:
            if x &gt; 0:
                result[pos] = x
                pos += 2
            else:
                result[neg] = x
                neg += 2
        return result


# Time:  O(n)
# Space: O(1)
# generator
class Solution2(object):
    def rearrangeArray(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        def pos():
            for x in nums:
                if x &gt; 0:
                    yield x
        
        def neg():
            for x in nums:
                if x &lt; 0:
                    yield x
        
        gen_pos = pos()
        gen_neg = neg()
        return [next(gen_pos) if i%2 == 0 else next(gen_neg)  for i in xrange(len(nums))]


# Time:  O(n)
# Space: O(n)
# array, implementation
class Solution3(object):
    def rearrangeArray(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        pos, neg = [], []
        for i in reversed(xrange(len(nums))):
            if nums[i] &gt; 0:
                pos.append(nums[i])
            else:
                neg.append(nums[i])
        result = []
        for i in xrange(len(nums)):
            if i%2 == 0:
                result.append(pos.pop())
            else:
                result.append(neg.pop())
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2161 - https://leetcode.com/problems/partition-array-according-to-given-pivot/
Time: O(n)  Space: O(n)   Medium
.Python/partition-array-according-to-given-pivot.py


```python
# Time:  O(n)
# Space: O(n)

# two pointers
class Solution(object):
    def pivotArray(self, nums, pivot):
        """
        :type nums: List[int]
        :type pivot: int
        :rtype: List[int]
        """
        result = [pivot]*len(nums)
        left, right = 0, len(nums)-sum(x &gt; pivot for x in nums)
        for x in nums:
            if x &lt; pivot:
                result[left] = x
                left += 1
            elif x &gt; pivot:
                result[right] = x
                right += 1
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2200 - https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/
Time: O(n)  Space: O(1)   Easy
.Python/find-all-k-distant-indices-in-an-array.py


```python
# Time:  O(n)
# Space: O(1)

# two pointers
class Solution(object):
    def findKDistantIndices(self, nums, key, k):
        """
        :type nums: List[int]
        :type key: int
        :type k: int
        :rtype: List[int]
        """
        result = []
        prev = -1
        for i, x in enumerate(nums):
            if x != key:
                continue
            for j in xrange(max(i-k, prev+1), min(i+k+1, len(nums))):
                result.append(j)
            prev = min(i+k, len(nums)-1)
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2234 - https://leetcode.com/problems/maximum-total-beauty-of-the-gardens/
Time: O(nlogn)  Space: O(1)   Hard
.Python/maximum-total-beauty-of-the-gardens.py


```python
# Time:  O(nlogn)
# Space: O(1)

import bisect


# sort, prefix sum, greedy, two pointers, improved from solution3
class Solution(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        """
        :type flowers: List[int]
        :type newFlowers: int
        :type target: int
        :type full: int
        :type partial: int
        :rtype: int
        """
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix, suffix = 0, sum(flowers[i] for i in xrange(n))
        result = left = 0
        for right in xrange(n+1):
            if right:
                suffix -= flowers[right-1]
            total = newFlowers-((n-right)*target-suffix)
            if total &lt; 0:
                continue
            while not (left == right or (left and (total+prefix)//left &lt;= flowers[left])):
                prefix += flowers[left]
                left += 1
            mn = min((total+prefix)//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result


# Time:  O(nlogn)
# Space: O(1)
import bisect


# sort, prefix sum, greedy, two pointers, improved from solution4
class Solution2(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        """
        :type flowers: List[int]
        :type newFlowers: int
        :type target: int
        :type full: int
        :type partial: int
        :rtype: int
        """
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in xrange(n):
            prefix[i+1] = prefix[i]+flowers[i]
        result = suffix = 0
        left = n
        for right in reversed(xrange(n+1)):
            if right != n:
                suffix += flowers[right]
            total = newFlowers-((n-right)*target-suffix)
            if total &lt; 0:
                continue
            left = min(left, right)
            while not (left == 0 or (prefix[left]-prefix[left-1])*left-prefix[left] &lt;= total):
                left -= 1
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result


# Time:  O(nlogn)
# Space: O(n)
import bisect


# sort, prefix sum, greedy, binary search
class Solution3(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        """
        :type flowers: List[int]
        :type newFlowers: int
        :type target: int
        :type full: int
        :type partial: int
        :rtype: int
        """
        def check(prefix, total, x):
            return x and (total+prefix[x])//x &lt;= prefix[x+1]-prefix[x]

        def binary_search(prefix, total, left, right):
            while left &lt;= right:
                mid = left+(right-left)//2
                if check(prefix, total, mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
    
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in xrange(n):
            prefix[i+1] = prefix[i]+flowers[i]
        suffix = sum(flowers[i] for i in xrange(n))
        result = left = 0
        for right in xrange(n+1):
            if right:
                suffix -= flowers[right-1]
            total = newFlowers-((n-right)*target-suffix)
            if total &lt; 0:
                continue
            left = binary_search(prefix, total, 0, right-1)
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result


# Time:  O(nlogn)
# Space: O(n)
import bisect


# sort, prefix sum, greedy, binary search
class Solution4(object):
    def maximumBeauty(self, flowers, newFlowers, target, full, partial):
        """
        :type flowers: List[int]
        :type newFlowers: int
        :type target: int
        :type full: int
        :type partial: int
        :rtype: int
        """
        def check(prefix, total, x):
            return (prefix[x]-prefix[x-1])*x-prefix[x] &lt;= total

        def binary_search_right(prefix, total, left, right):
            while left &lt;= right:
                mid = left+(right-left)//2
                if not check(prefix, total, mid):
                    right = mid-1
                else:
                    left = mid+1
            return right
    
        flowers.sort()
        n = bisect.bisect_left(flowers, target)
        prefix = [0]*(n+1)
        for i in xrange(n):
            prefix[i+1] = prefix[i]+flowers[i]
        result = suffix = 0
        left = n
        for right in reversed(xrange(n+1)):
            if right != n:
                suffix += flowers[right]
            total = newFlowers-((n-right)*target-suffix)
            if total &lt; 0:
                break
            left = binary_search_right(prefix, total, 1, right)
            mn = min((total+prefix[left])//left if left else 0, target-1)
            result = max(result, mn*partial+(len(flowers)-right)*full)
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2302 - https://leetcode.com/problems/count-subarrays-with-score-less-than-k/
Time: O(n)  Space: O(1)   Hard
.Python/count-subarrays-with-score-less-than-k.py


```python
# Time:  O(n)
# Space: O(1)

# sliding window, two pointers
class Solution(object):
    def countSubarrays(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        result = total = left = 0
        for right in xrange(len(nums)):
            total += nums[right]
            while total*(right-left+1) &gt;= k:
                total -= nums[left]
                left += 1
            result += right-left+1
        return result

```



----------------------------------------------------------------------------------------

### Two Pointers - 2330 - https://leetcode.com/problems/valid-palindrome-iv/
Time: O(n)  Space: O(1)   Medium
.Python/valid-palindrome-iv.py


```python
# Time:  O(n)
# Space: O(1)

# string, two pointers
class Solution(object):
    def makePalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        return sum(s[i] != s[~i] for i in xrange(len(s)//2)) &lt;= 2


# Time:  O(n)
# Space: O(1)
# string, two pointers
class Solution2(object):
    def makePalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        cnt = 0
        left, right = 0, len(s)-1
        while left &lt; right:
            if s[left] != s[right]:
                cnt += 1
                if cnt &gt; 2:
                    return False
            left += 1
            right -= 1
        return True

```



----------------------------------------------------------------------------------------

### Two Pointers - 2332 - https://leetcode.com/problems/the-latest-time-to-catch-a-bus/
Time: O(nlogn + mlogm)  Space: O(1)   Medium
.Python/the-latest-time-to-catch-a-bus.py


```python
# Time:  O(nlogn + mlogm)
# Space: O(1)

# sort, two pointers
class Solution(object):
    def latestTimeCatchTheBus(self, buses, passengers, capacity):
        """
        :type buses: List[int]
        :type passengers: List[int]
        :type capacity: int
        :rtype: int
        """
        buses.sort()
        passengers.sort()
        cnt = j = 0
        for i in xrange(len(buses)-1):
            while j &lt; len(passengers) and passengers[j] &lt;= buses[i]:
                cnt += 1
                j += 1
            cnt = max(cnt-capacity, 0)
        j -= max(cnt-capacity, 0)
        cnt = min(cnt, capacity)
        while j &lt; len(passengers) and passengers[j] &lt;= buses[-1] and cnt+1 &lt;= capacity:
            cnt += 1
            j += 1
        return buses[-1] if cnt &lt; capacity and (j-1 &lt; 0 or passengers[j-1] != buses[-1]) else next(passengers[i]-1 for i in reversed(xrange(j)) if i-1 &lt; 0 or passengers[i]-1 != passengers[i-1])

```



----------------------------------------------------------------------------------------

### Two Pointers - 2337 - https://leetcode.com/problems/move-pieces-to-obtain-a-string/
Time: O(n + m)  Space: O(1)   Medium
.Python/move-pieces-to-obtain-a-string.py


```python
# Time:  O(n)
# Space: O(1)

# two pointers
class Solution(object):
    def canChange(self, start, target):
        """
        :type start: str
        :type target: str
        :rtype: bool
        """
        i = j = 0
        while True:
            while i &lt; len(start) and start[i] == '_':
                i += 1
            while j &lt; len(target) and target[j] == '_':
                j += 1
            if i == len(start) and j == len(target):
                break
            if i == len(start) or j == len(target) or start[i] != target[j] or \
               (start[i] == 'L' and i &lt; j) or (start[i] == 'R' and i &gt; j):
                    return False
            i += 1
            j += 1
        return True

```



----------------------------------------------------------------------------------------

### Two Pointers - 2348 - https://leetcode.com/problems/number-of-zero-filled-subarrays/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-zero-filled-subarrays.py


```python
# Time:  O(n)
# Space: O(1)

# two pointers, combinatorics
class Solution(object):
    def zeroFilledSubarray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = 0
        prev = -1
        for i in xrange(len(nums)):
            if nums[i]:
                prev = i
                continue
            result += i-prev
        return result

```



----------------------------------------------------------------------------------------

### Recursion - 1106 - https://leetcode.com/problems/parsing-a-boolean-expression/
Time: O(n)  Space: O(n)   Hard
.Python/parsing-a-boolean-expression.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def parseBoolExpr(self, expression):
        """
        :type expression: str
        :rtype: bool
        """
        def parse(expression, i):
            if expression[i[0]] not in "&amp;|!":
                result = expression[i[0]] == 't'
                i[0] += 1
                return result
            op = expression[i[0]]
            i[0] += 2
            stk = []
            while expression[i[0]] != ')':
                if expression[i[0]] == ',': 
                    i[0] += 1
                    continue
                stk.append(parse(expression, i))
            i[0] += 1
            if op == '&amp;':
                return all(stk)
            if op == '|':
                return any(stk)
            return not stk[0]

        return parse(expression, [0])

```



----------------------------------------------------------------------------------------

### Binary Search - 1011 - https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/
Time: O(nlogr)  Space: O(1)   Medium
.Python/capacity-to-ship-packages-within-d-days.py


```python
# Time:  O(nlogr)
# Space: O(1)

class Solution(object):
    def shipWithinDays(self, weights, D):
        """
        :type weights: List[int]
        :type D: int
        :rtype: int
        """
        def possible(weights, D, mid):
            result, curr = 1, 0
            for w in weights:
                if curr+w &gt; mid:
                    result += 1
                    curr = 0
                curr += w
            return result &lt;= D
    
        left, right = max(weights), sum(weights)
        while left &lt;= right:
            mid = left + (right-left)//2
            if possible(weights, D, mid):
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Binary Search - 1044 - https://leetcode.com/problems/longest-duplicate-substring/
Time: O(nlogn)  Space: O(n)   Hard
.Python/longest-duplicate-substring.py


```python
# Time:  O(nlogn)
# Space: O(n)

# 1. other solution is to apply kasai's algorithm, refer to the link below:
# - https://leetcode.com/problems/longest-duplicate-substring/discuss/290852/Suffix-array-clear-solution
# 2. the best solution is to apply ukkonen's algorithm, refer to the link below:
# - https://leetcode.com/problems/longest-duplicate-substring/discuss/312999/best-java-on-complexity-and-on-space-solution-suffix-tree-67ms

import collections


class Solution(object):
    def longestDupSubstring(self, S):
        """
        :type S: str
        :rtype: str
        """
        M = 10**9+7
        D = 26

        def check(S, L):
            p = pow(D, L, M)
            curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0)
            lookup = collections.defaultdict(list)
            lookup[curr].append(L-1)
            for i in xrange(L, len(S)):
                curr = ((D*curr) % M + ord(S[i])-ord('a') -
                        ((ord(S[i-L])-ord('a'))*p) % M) % M
                if curr in lookup:
                    for j in lookup[curr]:  # check if string is the same when hash is the same
                        if S[j-L+1:j+1] == S[i-L+1:i+1]:
                            return i-L+1
                lookup[curr].append(i)
            return 0

        left, right = 1, len(S)-1
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(S, mid):
                right = mid-1
            else:
                left = mid+1
        result = check(S, right)
        return S[result:result + right]

```



----------------------------------------------------------------------------------------

### Binary Search - 1060 - https://leetcode.com/problems/missing-element-in-sorted-array/
Time: O(logn)  Space: O(1)   Medium
.Python/missing-element-in-sorted-array.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def missingElement(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def missing_count(nums, x):
            return (nums[x]-nums[0]+1)-(x-0+1)

        def check(nums, k, x):
            return k &gt; missing_count(nums, x)

        left, right = 0, len(nums)-1
        while left &lt;= right:  # find the largest right s.t. k &gt; missingCount(nums, x)
            mid = left + (right-left)//2
            if not check(nums, k, mid):
                right = mid-1
            else:
                left = mid+1
        assert(check(nums, k, right))
        return nums[right] + (k-missing_count(nums, right))

```



----------------------------------------------------------------------------------------

### Binary Search - 1062 - https://leetcode.com/problems/longest-repeating-substring/
Time: O(nlogn)  Space: O(n)   Medium
.Python/longest-repeating-substring.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class Solution(object):
    def longestRepeatingSubstring(self, S):
        """
        :type S: str
        :rtype: int
        """
        M = 10**9+7
        D = 26

        def check(S, L):
            p = pow(D, L, M)
            curr = reduce(lambda x, y: (D*x+ord(y)-ord('a')) % M, S[:L], 0)
            lookup = collections.defaultdict(list)
            lookup[curr].append(L-1)
            result = 0
            for i in xrange(L, len(S)):
                curr = ((D*curr) % M + ord(S[i])-ord('a') -
                        ((ord(S[i-L])-ord('a'))*p) % M) % M
                if curr in lookup:
                    for j in lookup[curr]:
                        if S[j-L+1:j+1] == S[i-L+1:i+1]:
                            if result == 0:
                                result = i
                            return result-L+1
                lookup[curr].append(i)
            return result

        left, right = 0, len(S)-1
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(S, mid):
                right = mid-1
            else:
                left = mid+1
        return right

```



----------------------------------------------------------------------------------------

### Binary Search - 1064 - https://leetcode.com/problems/fixed-point/
Time: O(logn)  Space: O(1)   Easy
.Python/fixed-point.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def fixedPoint(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        left, right = 0, len(A)-1
        while left &lt;= right:
            mid = left + (right-left)//2
            if A[mid] &gt;= mid:
                right = mid-1
            else:
                left = mid+1
        return left if A[left] == left else -1

```



----------------------------------------------------------------------------------------

### Binary Search - 1095 - https://leetcode.com/problems/find-in-mountain-array/
Time: O(logn)  Space: O(1)   Hard
.Python/find-in-mountain-array.py


```python
# Time:  O(logn)
# Space: O(1)

# """
# This is MountainArray's API interface.
# You should not implement it, or speculate about its implementation
# """
class MountainArray(object):
   def get(self, index):
       """
       :type index: int
       :rtype int
       """
       pass

   def length(self):
       """
       :rtype int
       """
       pass


class Solution(object):
    def findInMountainArray(self, target, mountain_arr):
        """
        :type target: integer
        :type mountain_arr: MountainArray
        :rtype: integer
        """
        def binarySearch(A, left, right, check):
            while left &lt;= right:
                mid = left + (right-left)//2
                if check(mid):
                    right = mid-1
                else:
                    left = mid+1
            return left
        
        peak = binarySearch(mountain_arr, 0, mountain_arr.length()-1,
                            lambda x: mountain_arr.get(x) &gt;= mountain_arr.get(x+1))
        left = binarySearch(mountain_arr, 0, peak,
                            lambda x: mountain_arr.get(x) &gt;= target)
        if left &lt;= peak and mountain_arr.get(left) == target:
            return left
        right = binarySearch(mountain_arr, peak, mountain_arr.length()-1,
                             lambda x: mountain_arr.get(x) &lt;= target)
        if right &lt;= mountain_arr.length()-1 and mountain_arr.get(right) == target:
            return right
        return -1

```



----------------------------------------------------------------------------------------

### Binary Search - 1110 - https://leetcode.com/problems/delete-nodes-and-return-forest/
Time: O(n)  Space: O(h + d)   Medium
.Python/delete-nodes-and-return-forest.py


```python
# Time:  O(n)
# Space: O(h + d), d is the number of to_delete

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

        
class Solution(object):
    def delNodes(self, root, to_delete):
        """
        :type root: TreeNode
        :type to_delete: List[int]
        :rtype: List[TreeNode]
        """
        def delNodesHelper(to_delete_set, root, is_root, result):
            if not root:
                return None
            is_deleted = root.val in to_delete_set
            if is_root and not is_deleted:
                result.append(root)
            root.left = delNodesHelper(to_delete_set, root.left, is_deleted, result)
            root.right = delNodesHelper(to_delete_set, root.right, is_deleted, result)
            return None if is_deleted else root
        
        result = []
        to_delete_set = set(to_delete)
        delNodesHelper(to_delete_set, root, True, result)
        return result

```



----------------------------------------------------------------------------------------

### Binary Search - 1170 - https://leetcode.com/problems/compare-strings-by-frequency-of-the-smallest-character/
Time: O((m + n)logn)  Space: O(n)   Easy
.Python/compare-strings-by-frequency-of-the-smallest-character.py


```python
# Time:  O((m + n)logn), m is the number of queries, n is the number of words
# Space: O(n)

import bisect


class Solution(object):
    def numSmallerByFrequency(self, queries, words):
        """
        :type queries: List[str]
        :type words: List[str]
        :rtype: List[int]
        """
        words_freq = sorted(word.count(min(word)) for word in words)
        return [len(words)-bisect.bisect_right(words_freq, query.count(min(query))) \
                for query in queries]

```



----------------------------------------------------------------------------------------

### Binary Search - 1201 - https://leetcode.com/problems/ugly-number-iii/
Time: O(logn)  Space: O(1)   Medium
.Python/ugly-number-iii.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def nthUglyNumber(self, n, a, b, c):
        """
        :type n: int
        :type a: int
        :type b: int
        :type c: int
        :rtype: int
        """
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a

        def lcm(x, y):
            return x//gcd(x, y)*y

        def count(x, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c):
            return x//a + x//b + x//c - (x//lcm_a_b + x//lcm_b_c + x//lcm_c_a) + x//lcm_a_b_c

        lcm_a_b, lcm_b_c, lcm_c_a = lcm(a, b), lcm(b, c), lcm(c, a)
        lcm_a_b_c = lcm(lcm_a_b, lcm_b_c)

        left, right = 1, 2*10**9
        while left &lt;= right:
            mid = left + (right-left)//2
            if count(mid, a, b, c, lcm_a_b, lcm_b_c, lcm_c_a, lcm_a_b_c) &gt;= n:
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Binary Search - 1228 - https://leetcode.com/problems/missing-number-in-arithmetic-progression/
Time: O(logn)  Space: O(1)   Easy
.Python/missing-number-in-arithmetic-progression.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def missingNumber(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        def check(arr, d, x):
            return arr[x] != arr[0] + d*x

        d = (arr[-1]-arr[0])//len(arr)
        left, right = 0, len(arr)-1
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(arr, d, mid):
                right = mid-1
            else:
                left = mid+1
        return arr[0] + d*left


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def missingNumber(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        return (min(arr)+max(arr))*(len(arr)+1)//2 - sum(arr)

```



----------------------------------------------------------------------------------------

### Binary Search - 1231 - https://leetcode.com/problems/divide-chocolate/
Time: O(nlogn)  Space: O(1)   Hard
.Python/divide-chocolate.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def maximizeSweetness(self, sweetness, K):
        """
        :type sweetness: List[int]
        :type K: int
        :rtype: int
        """
        def check(sweetness, K, x):
            curr, cuts = 0, 0
            for s in sweetness:
                curr += s
                if curr &gt;= x:
                    cuts += 1
                    curr = 0
            return cuts &gt;= K+1

        left, right = min(sweetness), sum(sweetness)//(K+1)
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(sweetness, K, mid):
                right = mid-1
            else:
                left = mid+1
        return right

```



----------------------------------------------------------------------------------------

### Binary Search - 1274 - https://leetcode.com/problems/number-of-ships-in-a-rectangle/
Time: O(log(m * n))  Space: O(log(m * n))   Hard
.Python/number-of-ships-in-a-rectangle.py


```python
# Time:  O(s * log(m * n)), s is the max number of ships, which is 10 in this problem
# Space: O(log(m * n))

# """
# This is Sea's API interface.
# You should not implement it, or speculate about its implementation
# """
class Sea(object):
   def hasShips(self, topRight, bottomLeft):
       """
       :type topRight: Point
		 :type bottomLeft: Point
       :rtype bool
       """
       pass

class Point(object):
	def __init__(self, x, y):
		self.x = x
		self.y = y

class Solution(object):
    def countShips(self, sea, topRight, bottomLeft):
        """
        :type sea: Sea
        :type topRight: Point
        :type bottomLeft: Point
        :rtype: integer
        """
        result = 0
        if topRight.x &gt;= bottomLeft.x and \
           topRight.y &gt;= bottomLeft.y and \
           sea.hasShips(topRight, bottomLeft):
            if (topRight.x, topRight.y) == (bottomLeft.x, bottomLeft.y):
                return 1
            mid_x, mid_y = (topRight.x+bottomLeft.x)//2, (topRight.y+bottomLeft.y)//2
            result += self.countShips(sea, topRight, Point(mid_x+1, mid_y+1))
            result += self.countShips(sea, Point(mid_x, topRight.y), Point(bottomLeft.x, mid_y+1))
            result += self.countShips(sea, Point(topRight.x, mid_y), Point(mid_x+1, bottomLeft.y))
            result += self.countShips(sea, Point(mid_x, mid_y), bottomLeft)
        return result

```



----------------------------------------------------------------------------------------

### Binary Search - 1283 - https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/
Time: O(logn)  Space: O(1)   Medium
.Python/find-the-smallest-divisor-given-a-threshold.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def smallestDivisor(self, nums, threshold):
        """
        :type nums: List[int]
        :type threshold: int
        :rtype: int
        """
        def check(A, d, threshold):
            return sum((i-1)//d+1 for i in nums) &lt;= threshold

        left, right = 1, max(nums)
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(nums, mid, threshold):
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Binary Search - 1287 - https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/
Time: O(logn)  Space: O(1)   Easy
.Python/element-appearing-more-than-25-in-sorted-array.py


```python
# Time:  O(logn)
# Space: O(1)

import bisect


class Solution(object):
    def findSpecialInteger(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        for x in [arr[len(arr)//4], arr[len(arr)//2], arr[len(arr)*3//4]]:
            if (bisect.bisect_right(arr, x) - bisect.bisect_left(arr, x)) * 4 &gt; len(arr):
                return x
        return -1

```



----------------------------------------------------------------------------------------

### Binary Search - 1385 - https://leetcode.com/problems/find-the-distance-value-between-two-arrays/
Time: O((n + m) * logm)  Space: O(1)   Easy
.Python/find-the-distance-value-between-two-arrays.py


```python
# Time:  O((n + m) * logm)
# Space: O(1)

import bisect


class Solution(object):
    def findTheDistanceValue(self, arr1, arr2, d):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :type d: int
        :rtype: int
        """
        arr2.sort()
        result, i, j = 0, 0, 0
        for x in arr1:
            j = bisect.bisect_left(arr2, x)
            left = arr2[j-1] if j-1 &gt;= 0 else float("-inf")
            right = arr2[j] if j &lt; len(arr2) else float("inf")
            result += left+d &lt; x &lt; right-d
        return result


# Time:  O(nlogn + mlogm)
# Space: O(1)
class Solution2(object):
    def findTheDistanceValue(self, arr1, arr2, d):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :type d: int
        :rtype: int
        """
        arr1.sort(), arr2.sort()
        result, i, j = 0, 0, 0
        while i &lt; len(arr1) and j &lt; len(arr2):
            if arr1[i]-arr2[j] &gt; d:
                j += 1
                continue
            result += arr2[j]-arr1[i] &gt; d
            i += 1
        return result+len(arr1)-i

```



----------------------------------------------------------------------------------------

### Binary Search - 1482 - https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/
Time: O(nlogd)  Space: O(1)   Medium
.Python/minimum-number-of-days-to-make-m-bouquets.py


```python
# Time:  O(nlogd), d is the max day of bloomDay
# Space: O(1)

class Solution(object):
    def minDays(self, bloomDay, m, k):
        """
        :type bloomDay: List[int]
        :type m: int
        :type k: int
        :rtype: int
        """
        def check(bloomDay, m, k, x):
            result = count = 0
            for d in bloomDay:
                count = count+1 if d &lt;= x else 0
                if count == k:
                    count = 0
                    result += 1
                    if result == m:
                        break
            return result &gt;= m

        if m*k &gt; len(bloomDay):
            return -1
        left, right = 1, max(bloomDay)
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(bloomDay, m, k, mid):
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Binary Search - 1533 - https://leetcode.com/problems/find-the-index-of-the-large-integer/
Time: O(logn)  Space: O(1)   Medium
.Python/find-the-index-of-the-large-integer.py


```python
# Time:  O(logn)
# Space: O(1)

class ArrayReader(object):
   def compareSub(self, l, r, x, y):
       pass

   def length(self):
       pass

class Solution(object):
    def getIndex(self, reader):
        """
        :type reader: ArrayReader
        :rtype: integer
        """
        left, right = 0, reader.length()-1
        while left &lt; right:
            mid = left + (right-left)//2
            if reader.compareSub(left, mid, mid if (right-left+1)%2 else mid+1, right) &gt;= 0:
                right = mid
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Binary Search - 1539 - https://leetcode.com/problems/kth-missing-positive-number/
Time: O(logn)  Space: O(1)   Easy
.Python/kth-missing-positive-number.py


```python
# Time:  O(logn)
# Space: O(1)

class Solution(object):
    def findKthPositive(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: int
        """
        def check(arr, k, x):
            return arr[x]-(x+1) &lt; k

        left, right = 0, len(arr)-1
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(arr, k, mid):
                right = mid-1
            else:
                left = mid+1
        return right+1+k  # arr[right] + (k-(arr[right]-(right+1))) if right &gt;= 0 else k

```



----------------------------------------------------------------------------------------

### Binary Search - 1552 - https://leetcode.com/problems/magnetic-force-between-two-balls/
Time: O(nlogn + nlogr)  Space: O(1)   Medium
.Python/magnetic-force-between-two-balls.py


```python
# Time:  O(nlogn + nlogr), r is the range of positions
# Space: O(1)

class Solution(object):
    def maxDistance(self, position, m):
        """
        :type position: List[int]
        :type m: int
        :rtype: int
        """
        def check(position, m, x):
            count, prev = 1, position[0]
            for i in xrange(1, len(position)):
                if position[i]-prev &gt;= x:
                    count += 1
                    prev = position[i]
            return count &gt;= m
        
        position.sort()
        left, right = 1, position[-1]-position[0]
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(position, m, mid):
                right = mid-1
            else:
                left = mid+1
        return right

```



----------------------------------------------------------------------------------------

### Binary Search - 1618 - https://leetcode.com/problems/maximum-font-to-fit-a-sentence-in-a-screen/
Time: O(n + logm)  Space: O(1)   Medium
.Python/maximum-font-to-fit-a-sentence-in-a-screen.py


```python
# Time:  O(n + logm), n is the length of text, m is the number of fonts
# Space: O(1)

import collections


class FontInfo(object):
    def getWidth(self, fontSize, ch):
        """
        :type fontSize: int
        :type ch: char
        :rtype int
        """
        pass
    
    def getHeight(self, fontSize):
        """
        :type fontSize: int
        :rtype int
        """
        pass


class Solution(object):
    def maxFont(self, text, w, h, fonts, fontInfo):
        """
        :type text: str
        :type w: int
        :type h: int
        :type fonts: List[int]
        :type fontInfo: FontInfo
        :rtype: int
        """
        def check(count, w, h, fonts, fontInfo, x):  # Time: O(1)
            return (fontInfo.getHeight(fonts[x]) &lt;= h and
                    sum(cnt * fontInfo.getWidth(fonts[x], c) for c, cnt in count.iteritems()) &lt;= w)

        count = collections.Counter(text)
        left, right = 0, len(fonts)-1
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(count, w, h, fonts, fontInfo, mid):
                right = mid-1
            else:
                left = mid+1
        return fonts[right] if right &gt;= 0 else -1

```



----------------------------------------------------------------------------------------

### Binary Search - 1648 - https://leetcode.com/problems/sell-diminishing-valued-colored-balls/
Time: O(nlogm)  Space: O(1)   Medium
.Python/sell-diminishing-valued-colored-balls.py


```python
# Time:  O(nlogm), m is the max of inventory, n is the size of inventory
# Space: O(1)

class Solution(object):
    def maxProfit(self, inventory, orders):
        """
        :type inventory: List[int]
        :type orders: int
        :rtype: int
        """
        MOD = 10**9+7
        def check(inventory, orders, x):
            return count(inventory, x) &gt; orders
        
        def count(inventory, x):
            return sum(count-x+1 for count in inventory if count &gt;= x)

        left, right = 1, max(inventory)
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(inventory, orders, mid):
                right = mid-1
            else:
                left = mid+1
        # assert(orders-count(inventory, left) &gt;= 0)
        return (sum((left+cnt)*(cnt-left+1)//2 for cnt in inventory if cnt &gt;= left) +
                (left-1)*(orders-count(inventory, left)))% MOD

```



----------------------------------------------------------------------------------------

### Binary Search - 1671 - https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/
Time: O(nlogn)  Space: O(n)   Medium
.Python/minimum-number-of-removals-to-make-mountain-array.py


```python
# Time:  O(nlogn)
# Space: O(n)

import bisect


class Solution(object):
    def minimumMountainRemovals(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        left_lis_len = [0]*len(nums)
        lis = []
        for i in xrange(len(nums)-1):
            j = bisect.bisect_left(lis, nums[i])
            if j == len(lis):
                lis.append(nums[i])
            else:
                lis[j] = nums[i]
            left_lis_len[i] = j
        max_len = 0
        lis = []
        for i in reversed(xrange(1, len(nums))):
            j = bisect.bisect_left(lis, nums[i])
            if j == len(lis):
                lis.append(nums[i])
            else:
                lis[j] = nums[i]
            if i &lt; len(nums)-1:
                max_len = max(max_len, left_lis_len[i]+j)
        return len(nums) - (1+max_len)

```



----------------------------------------------------------------------------------------

### Binary Search - 1713 - https://leetcode.com/problems/minimum-operations-to-make-a-subsequence/
Time: O(nlogn)  Space: O(n)   Hard
.Python/minimum-operations-to-make-a-subsequence.py


```python
# Time:  O(nlogn)
# Space: O(n)

import bisect


class Solution(object):
    def minOperations(self, target, arr):
        """
        :type target: List[int]
        :type arr: List[int]
        :rtype: int
        """
        lookup = {x:i for i, x in enumerate(target)}
        lis = []
        for x in arr:
            if x not in lookup:
                continue
            i = bisect.bisect_left(lis, lookup[x])
            if i == len(lis):
                lis.append(lookup[x])
            else:
                lis[i] = lookup[x]
        return len(target)-len(lis)
    
    
# Range Maximum Query
class SegmentTree(object):  # 0-based index
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y),  # (lambda x, y: y if x is None else min(x, y))
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x &lt; self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h):  # Time: O(logN), Space: O(N)
        def pull(x):
            while x &gt; 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L &lt;= R:
            if L &amp; 1:  # is right child
                self.__apply(L, h) 
                L += 1
            if R &amp; 1 == 0:  # is left child
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):  # Time: O(logN), Space: O(N)
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L &gt; R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L &lt;= R:
            if L &amp; 1:  # is right child
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R &amp; 1 == 0:  # is left child
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in xrange(self.N):
            showList.append(self.query(i, i))
        return ",".join(map(str, showList))


# Time:  O(nlogn)
# Space: O(n)
# segment tree solution
class Solution2(object):
    def minOperations(self, target, arr):
        """
        :type target: List[int]
        :type arr: List[int]
        :rtype: int
        """
        lookup = {x:i for i, x in enumerate(target)}
        st = SegmentTree(len(lookup))
        for x in arr:
            if x not in lookup:
                continue
            st.update(lookup[x], lookup[x], st.query(0, lookup[x]-1)+1 if lookup[x] &gt;= 1 else 1)
        return len(target)-(st.query(0, len(lookup)-1) if len(lookup) &gt;= 1 else 0)

```



----------------------------------------------------------------------------------------

### Binary Search - 1760 - https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/
Time: O(nlogm)  Space: O(1)   Medium
.Python/minimum-limit-of-balls-in-a-bag.py


```python
# Time:  O(nlogm), m is the max of nums
# Space: O(1)

class Solution(object):
    def minimumSize(self, nums, maxOperations):
        """
        :type nums: List[int]
        :type maxOperations: int
        :rtype: int
        """
        def check(nums, maxOperations, x):
            return sum((num+x-1)//x-1 for num in nums) &lt;= maxOperations
    
        left, right = 1, max(nums)
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(nums, maxOperations, mid):
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Binary Search - 1802 - https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/
Time: O(logm)  Space: O(1)   Medium
.Python/maximum-value-at-a-given-index-in-a-bounded-array.py


```python
# Time:  O(logm)
# Space: O(1)

class Solution(object):
    def maxValue(self, n, index, maxSum):
        """
        :type n: int
        :type index: int
        :type maxSum: int
        :rtype: int
        """
        def check(n, index, maxSum, x):
            y = max(x-index, 0)
            total = (x+y)*(x-y+1)//2
            y = max(x-((n-1)-index), 0)
            total += (x+y)*(x-y+1)//2
            return total-x &lt;= maxSum

        maxSum -= n
        left, right = 0, maxSum
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(n, index, maxSum, mid):
                right = mid-1
            else:
                left = mid+1
        return 1+right

```



----------------------------------------------------------------------------------------

### Binary Search - 1818 - https://leetcode.com/problems/minimum-absolute-sum-difference/
Time: O(nlogn)  Space: O(n)   Medium
.Python/minimum-absolute-sum-difference.py


```python
# Time:  O(nlogn)
# Space: O(n)

import bisect


class Solution(object):
    def minAbsoluteSumDiff(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        MOD = 10**9+7

        sorted_nums1 = sorted(nums1)
        result = max_change = 0
        for i in xrange(len(nums2)):
            diff = abs(nums1[i]-nums2[i])
            result = (result+diff)%MOD
            if diff &lt; max_change:
                continue
            j = bisect.bisect_left(sorted_nums1, nums2[i])
            if j != len(sorted_nums1):
                max_change = max(max_change, diff-abs(sorted_nums1[j]-nums2[i]))
            if j != 0:
                max_change = max(max_change, diff-abs(sorted_nums1[j-1]-nums2[i]))
        return (result-max_change)%MOD

```



----------------------------------------------------------------------------------------

### Binary Search - 1870 - https://leetcode.com/problems/minimum-speed-to-arrive-on-time/
Time: O(nlogr)  Space: O(1)   Medium
.Python/minimum-speed-to-arrive-on-time.py


```python
# Time:  O(nlogr), r is the range of speed
# Space: O(1)

class Solution(object):
    def minSpeedOnTime(self, dist, hour):
        """
        :type dist: List[int]
        :type hour: float
        :rtype: int
        """
        def ceil(a, b):
            return (a+b-1)//b

        def total_time(dist, x):
            return sum(ceil(dist[i], x) for i in xrange(len(dist)-1)) + float(dist[-1])/x

        def check(dist, hour, x):
            return total_time(dist, x) &lt;= hour

        MAX_SPEED = 10**7
        if not check(dist, hour, MAX_SPEED):
            return -1
        left, right = 1, MAX_SPEED
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(dist, hour, mid):
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Binary Search - 1889 - https://leetcode.com/problems/minimum-space-wasted-from-packaging/
Time: O(mlogm + nlogn + mlogn)  Space: O(1)   Hard
.Python/minimum-space-wasted-from-packaging.py


```python
# Time:  O(mlogm + nlogn + mlogn)
# Space: O(1)

import bisect


class Solution(object):
    def minWastedSpace(self, packages, boxes):
        """
        :type packages: List[int]
        :type boxes: List[List[int]]
        :rtype: int
        """
        MOD = 10**9+7
        INF = float("inf")

        packages.sort()
        result = INF
        for box in boxes:
            box.sort()
            if box[-1] &lt; packages[-1]:
                continue
            curr = left = 0
            for b in box:
                right = bisect.bisect_right(packages, b, left)
                curr += b * (right-left)
                left = right
            result = min(result, curr)
        return (result-sum(packages))%MOD if result != INF else -1

```



----------------------------------------------------------------------------------------

### Binary Search - 1891 - https://leetcode.com/problems/cutting-ribbons/
Time: O(nlogr)  Space: O(1)   Medium
.Python/cutting-ribbons.py


```python
# Time:  O(nlogr), r is sum(ribbons)/k
# Space: O(1)

class Solution(object):
    def maxLength(self, ribbons, k):
        """
        :type ribbons: List[int]
        :type k: int
        :rtype: int
        """
        def check(ribbons, k, s):
            return reduce(lambda total,x: total+x//s, ribbons, 0) &gt;= k

        left, right = 1, sum(ribbons)//k
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(ribbons, k, mid):
                right = mid-1
            else:
                left = mid+1
        return right

```



----------------------------------------------------------------------------------------

### Binary Search - 1898 - https://leetcode.com/problems/maximum-number-of-removable-characters/
Time: O(rlogn)  Space: O(r)   Medium
.Python/maximum-number-of-removable-characters.py


```python
# Time:  O(rlogn)
# Space: O(r)

# if r = O(1), this is better
class Solution(object):
    def maximumRemovals(self, s, p, removable):
        """
        :type s: str
        :type p: str
        :type removable: List[int]
        :rtype: int
        """
        def check(s, p, removable, x):
            lookup = set(removable[i] for i in xrange(x))
            j = 0
            for i in xrange(len(s)):
                if i in lookup or s[i] != p[j]:
                    continue
                j += 1
                if j == len(p):
                    return True
            return False

        left, right = 0, len(removable)
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(s, p, removable, mid):
                right = mid-1
            else:
                left = mid+1
        return right


# Time:  O(rlogn)
# Space: O(n)
# if r = O(n), this is better
class Solution2(object):
    def maximumRemovals(self, s, p, removable):
        """
        :type s: str
        :type p: str
        :type removable: List[int]
        :rtype: int
        """
        def check(s, p, lookup, x):
            j = 0
            for i in xrange(len(s)):
                if lookup[i] &lt;= x or s[i] != p[j]:
                    continue
                j += 1
                if j == len(p):
                    return True
            return False

        lookup = [float("inf")]*len(s)
        for i, r in enumerate(removable):
            lookup[r] = i+1
        left, right = 0, len(removable)
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(s, p, lookup, mid):
                right = mid-1
            else:
                left = mid+1
        return right

```



----------------------------------------------------------------------------------------

### Binary Search - 1901 - https://leetcode.com/problems/find-a-peak-element-ii/
Time: O(min(n, m) * log(max(n, m)))  Space: O(1)   Medium
.Python/find-a-peak-element-ii.py


```python
# Time:  O(min(n, m) * log(max(n, m)))
# Space: O(1)

class Solution(object):
    def findPeakGrid(self, mat):
        """
        :type mat: List[List[int]]
        :rtype: List[int]
        """
        def get_vec(mat, i):
            return mat[i] if len(mat) &gt; len(mat[0]) else (mat[j][i] for j in xrange(len(mat)))

        def check(mat, x):
            return max(get_vec(mat, x)) &gt; max(get_vec(mat, x+1))

        left, right = 0, (max(len(mat), len(mat[0]))-1)-1
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(mat, mid):
                right = mid-1
            else:
                left = mid+1
        mav_val = max(get_vec(mat, left))
        result = [left, next(i for i, x in enumerate(get_vec(mat, left)) if x == mav_val)]
        return result if len(mat) &gt; len(mat[0]) else result[::-1]

```



----------------------------------------------------------------------------------------

### Binary Search - 1918 - https://leetcode.com/problems/kth-smallest-subarray-sum/
Time: O(nlogr)  Space: O(1)   Medium
.Python/kth-smallest-subarray-sum.py


```python
# Time:  O(nlogr)
# Space: O(1)

class Solution(object):
    def kthSmallestSubarraySum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def check(nums, k, x):
            cnt = curr = left = 0
            for right in xrange(len(nums)):
                curr += nums[right]
                while curr &gt; x:
                    curr -= nums[left]
                    left += 1
                cnt += right-left+1
            return cnt &gt;= k

        left, right = min(nums), sum(nums)
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(nums, k, mid):
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Binary Search - 1964 - https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/
Time: O(nlogn)  Space: O(n)   Hard
.Python/find-the-longest-valid-obstacle-course-at-each-position.py


```python
# Time:  O(nlogn)
# Space: O(n)

import bisect


# binary search solution
class Solution(object):
    def longestObstacleCourseAtEachPosition(self, obstacles):
        """
        :type obstacles: List[int]
        :rtype: List[int]
        """
        result, stk = [], []
        for x in obstacles:
            i = bisect.bisect_right(stk, x)
            result.append(i+1)
            if i == len(stk):
                stk.append(0)
            stk[i] = x
        return result
    

# Range Maximum Query
class SegmentTree(object):  # 0-based index
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y),  # (lambda x, y: y if x is None else min(x, y))
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x &lt; self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h):  # Time: O(logN), Space: O(N)
        def pull(x):
            while x &gt; 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L &lt;= R:
            if L &amp; 1:  # is right child
                self.__apply(L, h) 
                L += 1
            if R &amp; 1 == 0:  # is left child
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):  # Time: O(logN), Space: O(N)
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L &gt; R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L &lt;= R:
            if L &amp; 1:  # is right child
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R &amp; 1 == 0:  # is left child
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in xrange(self.N):
            showList.append(self.query(i, i))
        return ",".join(map(str, showList))


# Time:  O(nlogn)
# Space: O(n)
# segment tree solution
class Solution2_TLE(object):
    def longestObstacleCourseAtEachPosition(self, obstacles):
        """
        :type obstacles: List[int]
        :rtype: List[int]
        """
        sorted_obstacles = sorted(set(obstacles))
        lookup = {x:i for i, x in enumerate(sorted_obstacles)}
        segment_tree = SegmentTree(len(lookup))
        result = []
        for x in obstacles:
            cnt = segment_tree.query(0, lookup[x])+1
            result.append(cnt)
            segment_tree.update(lookup[x], lookup[x], cnt)
        return result

```



----------------------------------------------------------------------------------------

### Binary Search - 2064 - https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/
Time: O(nlogm)  Space: O(1)   Medium
.Python/minimized-maximum-of-products-distributed-to-any-store.py


```python
# Time:  O(nlogm), m is the max of quantities
# Space: O(1)

class Solution(object):
    def minimizedMaximum(self, n, quantities):
        """
        :type n: int
        :type quantities: List[int]
        :rtype: int
        """
        def ceil_divide(a, b):
            return (a+(b-1))//b

        def check(n, quantities, x):
            return sum(ceil_divide(q, x) for q in quantities) &lt;= n
         
        left, right = 1, max(quantities)
        while left &lt;= right:
            mid = left+(right-left)//2
            if check(n, quantities, mid):
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Binary Search - 2111 - https://leetcode.com/problems/minimum-operations-to-make-the-array-k-increasing/
Time: O(nlog(n/k))  Space: O(n/k)   Hard
.Python/minimum-operations-to-make-the-array-k-increasing.py


```python
# Time:  O(k * (n/k)log(n/k)) = O(nlog(n/k))
# Space: O(n/k)

import bisect


class Solution(object):
    def kIncreasing(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: int
        """
        def longest_non_decreasing_subsequence(arr):
            result = []
            for x in arr:
                right = bisect.bisect_right(result, x)
                if right == len(result):
                    result.append(x)
                else:
                    result[right] = x
            return len(result)

        return len(arr) - sum(longest_non_decreasing_subsequence((arr[j] for j in xrange(i, len(arr), k))) for i in xrange(k))

```



----------------------------------------------------------------------------------------

### Binary Search - 2137 - https://leetcode.com/problems/pour-water-between-buckets-to-make-water-levels-equal/
Time: O(nlogr)  Space: O(1)   Medium
.Python/pour-water-between-buckets-to-make-water-levels-equal.py


```python
# Time:  O(nlogr)
# Space: O(1)

# binary search
class Solution(object):
    def equalizeWater(self, buckets, loss):
        """
        :type buckets: List[int]
        :type loss: int
        :rtype: float
        """
        def check(buckets, rate, x):
            return sum(b-x for b in buckets if b-x &gt; 0)*rate &gt;= sum(x-b for b in buckets if x-b &gt; 0)

        EPS = 1e-5
        rate = (100-loss)/100.0
        left, right = float(min(buckets)), float(sum(buckets))/len(buckets)
        while right-left &gt; EPS:
            mid = left + (right-left)/2
            if not check(buckets, rate, mid):
                right = mid
            else:
                left = mid
        return left

```



----------------------------------------------------------------------------------------

### Binary Search - 2187 - https://leetcode.com/problems/minimum-time-to-complete-trips/
Time: O(nlogr)  Space: O(1)   Medium
.Python/minimum-time-to-complete-trips.py


```python
# Time:  O(nlogr)
# Space: O(1)

# binary search
class Solution(object):
    def minimumTime(self, time, totalTrips):
        """
        :type time: List[int]
        :type totalTrips: int
        :rtype: int
        """
        def check(time, totalTrips, x):
            return sum(x//t for t in time) &gt;= totalTrips

        left, right = 1, max(time)*totalTrips
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(time, totalTrips, mid):
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Binary Search - 2226 - https://leetcode.com/problems/maximum-candies-allocated-to-k-children/
Time: O(nlogr)  Space: O(1)   Medium
.Python/maximum-candies-allocated-to-k-children.py


```python
# Time:  O(nlogr), r is max(candies)
# Space: O(1)

# binary search
class Solution(object):
    def maximumCandies(self, candies, k):
        """
        :type candies: List[int]
        :type k: int
        :rtype: int
        """
        def check(x):
            return sum(c//x for c in candies) &gt;= k

        left, right = 1, max(candies)
        while left &lt;= right:
            mid = left+(right-left)//2
            if not check(mid):
                right = mid-1
            else:
                left = mid+1
        return right

```



----------------------------------------------------------------------------------------

### Binary Search - 2250 - https://leetcode.com/problems/count-number-of-rectangles-containing-each-point/
Time: O(nlogn + m * max_y * logn)  Space: O(n)   Medium
.Python/count-number-of-rectangles-containing-each-point.py


```python
# Time:  O(nlogn + m * max_y * logn), n = len(rectangles), m = len(points)
# Space: O(n)

import bisect


# bucket sort, binary search
class Solution(object):
    def countRectangles(self, rectangles, points):
        """
        :type rectangles: List[List[int]]
        :type points: List[List[int]]
        :rtype: List[int]
        """
        max_y = max(y for _, y in rectangles)
        buckets = [[] for _ in xrange(max_y+1)]
        for x, y in rectangles:
            buckets[y].append(x)
        for bucket in buckets:
            bucket.sort()
        return [sum(len(buckets[y])-bisect.bisect_left(buckets[y], x) for y in xrange(y, max_y+1))
                for x, y in points]

```



----------------------------------------------------------------------------------------

### Binary Search - 2300 - https://leetcode.com/problems/successful-pairs-of-spells-and-potions/
Time: O(mlogm + nlogm)  Space: O(1)   Medium
.Python/successful-pairs-of-spells-and-potions.py


```python
# Time:  O(mlogm + nlogm)
# Space: O(1)

# binary search
class Solution(object):
    def successfulPairs(self, spells, potions, success):
        """
        :type spells: List[int]
        :type potions: List[int]
        :type success: int
        :rtype: List[int]
        """
        def ceil_divide(a, b):
            return (a+(b-1))//b
            
        potions.sort()
        return [len(potions)-bisect.bisect_left(potions, ceil_divide(success, s)) for s in spells]

```



----------------------------------------------------------------------------------------

### Binary Search - 2333 - https://leetcode.com/problems/minimum-sum-of-squared-difference/
Time: O(nlogn + nlogr)  Space: O(1)   Medium
.Python/minimum-sum-of-squared-difference.py


```python
# Time:  O(nlogn + nlogr), r is max((abs(i-j) for i, j in itertools.izip(nums1, nums2))
# Space: O(n)

import itertools


# binary search
class Solution(object):
    def minSumSquareDiff(self, nums1, nums2, k1, k2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :type k1: int
        :type k2: int
        :rtype: int
        """
        def check(diffs, k, x):
            return sum(max(d-x, 0) for d in diffs) &lt;= k

        diffs = sorted((abs(i-j) for i, j in itertools.izip(nums1, nums2)), reverse=True)
        k = min(k1+k2, sum(diffs))
        left, right = 0, diffs[0]
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(diffs, k, mid):
                right = mid-1
            else:
                left = mid+1
        k -= sum(max(d-left, 0) for d in diffs)
        for i in xrange(len(diffs)):
            diffs[i] = min(diffs[i], left)-int(i &lt; k)
        return sum(d**2 for d in diffs)

```



----------------------------------------------------------------------------------------

### Binary Search Tree - 1373 - https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/
Time: O(n)  Space: O(h)   Hard
.Python/maximum-sum-bst-in-binary-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


# dfs solution with stack
class Solution(object):
    def maxSumBST(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        result = 0
        stk = [[root, None, []]]
        while stk:
            node, tmp, ret = stk.pop()
            if tmp:
                lvalid, lsum, lmin, lmax = tmp[0]
                rvalid, rsum, rmin, rmax = tmp[1]
                if lvalid and rvalid and lmax &lt; node.val &lt; rmin:
                    total = lsum + node.val + rsum
                    result = max(result, total)
                    ret[:] = [True, total, min(lmin, node.val), max(node.val, rmax)]
                    continue
                ret[:] = [False, 0, 0, 0]
                continue
            if not node:
                ret[:] = [True, 0, float("inf"), float("-inf")]
                continue
            new_tmp = [[], []]
            stk.append([node, new_tmp, ret])
            stk.append([node.right, None, new_tmp[1]])
            stk.append([node.left, None, new_tmp[0]])
        return result


# Time:  O(n)
# Space: O(h)
# dfs solution with recursion
class Solution2(object):
    def maxSumBST(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(node, result):
            if not node:
                return True, 0, float("inf"), float("-inf")
            lvalid, lsum, lmin, lmax = dfs(node.left, result)
            rvalid, rsum, rmin, rmax = dfs(node.right, result)
            if lvalid and rvalid and lmax &lt; node.val &lt; rmin:
                total = lsum + node.val + rsum
                result[0] = max(result[0], total)
                return True, total, min(lmin, node.val), max(node.val, rmax)
            return False, 0, 0, 0

        result = [0]
        dfs(root, result)
        return result[0]

```



----------------------------------------------------------------------------------------

### Binary Search Tree - 1382 - https://leetcode.com/problems/balance-a-binary-search-tree/
Time: O(n)  Space: O(h)   Medium
.Python/balance-a-binary-search-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


# dfs solution with stack
class Solution(object):
    def balanceBST(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        def inorderTraversal(root):
            result, stk = [], [(root, False)]
            while stk:
                node, is_visited = stk.pop()
                if node is None:
                    continue
                if is_visited:
                    result.append(node.val)
                else:
                    stk.append((node.right, False))
                    stk.append((node, True))
                    stk.append((node.left, False))
            return result
    
        def sortedArrayToBst(arr):
            ROOT, LEFT, RIGHT = range(3)
            result = [None]
            stk = [(0, len(arr), ROOT, result)]
            while stk:
                i, j, update, ret = stk.pop()
                if i &gt;= j:
                    continue
                mid = i + (j-i)//2
                node = TreeNode(arr[mid])
                if update == ROOT:
                    ret[0] = node
                elif update == LEFT:
                    ret[0].left = node
                else:
                    ret[0].right = node
                stk.append((mid+1, j, RIGHT, [node]))
                stk.append((i, mid, LEFT, [node]))
            return result[0]
        
        return sortedArrayToBst(inorderTraversal(root))


# Time:  O(n)
# Space: O(h)
# dfs solution with recursion
class Solution2(object):
    def balanceBST(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        def inorderTraversalHelper(node, arr):
            if not node:
                return
            inorderTraversalHelper(node.left, arr)
            arr.append(node.val)
            inorderTraversalHelper(node.right, arr)
        
        def sortedArrayToBstHelper(arr, i, j):
            if i &gt;= j:
                return None
            mid = i + (j-i)//2
            node = TreeNode(arr[mid])
            node.left = sortedArrayToBstHelper(arr, i, mid)
            node.right = sortedArrayToBstHelper(arr, mid+1, j)
            return node
        
        arr = []
        inorderTraversalHelper(root, arr)
        return sortedArrayToBstHelper(arr, 0, len(arr))

```



----------------------------------------------------------------------------------------

### Binary Search Tree - 1902 - https://depth-of-bst-given-insertion-order/
Time: O(nlogn)  Space: O(n)   Medium
.Python/depth-of-bst-given-insertion-order.py


```python
# Time:  O(nlogn)
# Space: O(n)

import sortedcontainers


class Solution(object):
    def maxDepthBST(self, order):
        """
        :type order: List[int]
        :rtype: int
        """
        depths = sortedcontainers.SortedDict({float("-inf"):0, float("inf"):0})
        values_view = depths.values()
        result = 0
        for x in order:
            i = depths.bisect_right(x)
            depths[x] = max(values_view[i-1:i+1])+1
            result = max(result, depths[x])
        return result

```



----------------------------------------------------------------------------------------

### Binary Search Tree - 1932 - https://leetcode.com/problems/merge-bsts-to-create-single-bst/
Time: O(n)  Space: O(n)   Hard
.Python/merge-bsts-to-create-single-bst.py


```python
# Time:  O(n)
# Space: O(n)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def canMerge(self, trees):
        """
        :type trees: List[TreeNode]
        :rtype: TreeNode
        """
        def find_leaves_and_roots(trees, leaf_vals_set, val_to_root):
            for root in trees:
                val_to_root[root.val] = root
                q = [root]
                while q:
                    new_q = []
                    for node in q:
                        if node.left is None and node.right is None:
                            if node is not root:
                                leaf_vals_set.add(node.val)
                            continue
                        if node.left:
                            new_q.append(node.left)
                        if node.right:
                            new_q.append(node.right)
                    q = new_q

        def find_root(trees, left_vals_set, val_to_root):
            root = None
            for node in trees:
                if node.val in leaf_vals_set:
                    continue
                if root:  # multiple roots
                    return None
                root = node
            return root

        def merge_bsts(root, left_vals_set, val_to_root):
            if not root:
                return None
            del val_to_root[root.val]
            q = [(root, float("-inf"), float("inf"))]
            while q:
                new_q = []
                for node, left, right in q:
                    if not (left &lt; node.val &lt; right):
                        return None
                    if node.left:
                        if node.left.val in leaf_vals_set and node.left.val in val_to_root:
                            node.left = val_to_root[node.left.val]
                            del val_to_root[node.left.val]
                        new_q.append((node.left, left, node.val))
                    if node.right:
                        if node.right.val in leaf_vals_set and node.right.val in val_to_root:
                            node.right = val_to_root[node.right.val]
                            del val_to_root[node.right.val]
                        new_q.append((node.right, node.val, right))
                q = new_q
            return root if not val_to_root else None

        leaf_vals_set, val_to_root = set(), {}
        find_leaves_and_roots(trees, leaf_vals_set, val_to_root)    
        root = find_root(trees, leaf_vals_set, val_to_root)
        return merge_bsts(root, leaf_vals_set, val_to_root)

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1034 - https://leetcode.com/problems/coloring-a-border/
Time: O(m * n)  Space: O(m + n)   Medium
.Python/coloring-a-border.py


```python
# Time:  O(m * n)
# Space: O(m + n)

import collections


class Solution(object):
    def colorBorder(self, grid, r0, c0, color):
        """
        :type grid: List[List[int]]
        :type r0: int
        :type c0: int
        :type color: int
        :rtype: List[List[int]]
        """
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        lookup, q, borders = set([(r0, c0)]), collections.deque([(r0, c0)]), []
        while q:
            r, c = q.popleft()
            is_border = False

            for direction in directions:
                nr, nc = r+direction[0], c+direction[1]
                if not ((0 &lt;= nr &lt; len(grid)) and \
                        (0 &lt;= nc &lt; len(grid[0])) and \
                        grid[nr][nc] == grid[r][c]):
                    is_border = True
                    continue
                if (nr, nc) in lookup:
                    continue
                lookup.add((nr, nc))
                q.append((nr, nc))

            if is_border:
                borders.append((r, c))

        for r, c in borders:
            grid[r][c] = color
        return grid

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1036 - https://leetcode.com/problems/escape-a-large-maze/
Time: O(n^2)  Space: O(n)   Hard
.Python/escape-a-large-maze.py


```python
# Time:  O(n^2), n is the number of blocked
# Space: O(n)

import collections


class Solution(object):
    def isEscapePossible(self, blocked, source, target):
        """
        :type blocked: List[List[int]]
        :type source: List[int]
        :type target: List[int]
        :rtype: bool
        """
        R, C = 10**6, 10**6
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

        def bfs(blocks, source, target):
            max_area_surrounded_by_blocks = len(blocks)*(len(blocks)-1)//2
            lookup = set([source])
            if len(lookup) &gt; max_area_surrounded_by_blocks:
                return True
            q = collections.deque([source])
            while q:
                source = q.popleft()
                if source == target:
                    return True
                for direction in directions:
                    nr, nc = source[0]+direction[0], source[1]+direction[1]
                    if not ((0 &lt;= nr &lt; R) and
                            (0 &lt;= nc &lt; C) and 
                            (nr, nc) not in lookup and
                            (nr, nc) not in blocks):
                        continue
                    lookup.add((nr, nc))
                    if len(lookup) &gt; max_area_surrounded_by_blocks:
                        return True
                    q.append((nr, nc))
            return False
        
        return bfs(set(map(tuple, blocked)), tuple(source), tuple(target)) and \
               bfs(set(map(tuple, blocked)), tuple(target), tuple(source))

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1091 - https://leetcode.com/problems/shortest-path-in-binary-matrix/
Time: O(n^2)  Space: O(n)   Medium
.Python/shortest-path-in-binary-matrix.py


```python
# Time:  O(n^2)
# Space: O(n)

import collections


class Solution(object):
    def shortestPathBinaryMatrix(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        directions = [(-1, -1), (-1, 0), (-1, 1), \
                      ( 0, -1), ( 0, 1), \
                      ( 1, -1), ( 1, 0), ( 1, 1)]
        result = 0
        q = collections.deque([(0, 0)])
        while q:
            result += 1
            next_depth = collections.deque()
            while q:
                i, j = q.popleft()
                if 0 &lt;= i &lt; len(grid) and \
                   0 &lt;= j &lt; len(grid[0]) and \
                    not grid[i][j]:
                    grid[i][j] = 1
                    if i == len(grid)-1 and j == len(grid)-1:
                        return result
                    for d in directions:
                        next_depth.append((i+d[0], j+d[1]))
            q = next_depth
        return -1

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1102 - https://leetcode.com/problems/path-with-maximum-minimum-value/
Time: O((m * n) * log(m * n))  Space: O(m * n)   Medium
.Python/path-with-maximum-minimum-value.py


```python
# Time:  O(m * n * log(m * n))
# Space: O(m * n)

# binary search + dfs solution
class Solution(object):
    def maximumMinimumPath(self, A):
        """
        :type A: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        def check(A, val, r, c, lookup):
            if r == len(A)-1 and c == len(A[0])-1:
                return True
            lookup.add((r, c))
            for d in directions:
                nr, nc = r + d[0], c + d[1]
                if 0 &lt;= nr &lt; len(A) and \
                   0 &lt;= nc &lt; len(A[0]) and \
                   (nr, nc) not in lookup and \
                   A[nr][nc] &gt;= val and \
                   check(A, val, nr, nc, lookup):
                    return True
            return False
        
        vals, ceil = [], min(A[0][0], A[-1][-1])
        for i in xrange(len(A)):
            for j in xrange(len(A[0])):
                if A[i][j] &lt;= ceil:
                    vals.append(A[i][j])
        vals = list(set(vals))
        vals.sort()
        left, right = 0, len(vals)-1
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(A, vals[mid], 0, 0, set()):
                right = mid-1
            else:
                left = mid+1
        return vals[right]


# Time:  O(m * n * log(m * n))
# Space: O(m * n)
import heapq


# Dijkstra algorithm solution
class Solution2(object):
    def maximumMinimumPath(self, A):
        """
        :type A: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        max_heap = [(-A[0][0], 0, 0)]
        lookup = set([(0, 0)])
        while max_heap:
            i, r, c = heapq.heappop(max_heap)
            if r == len(A)-1 and c == len(A[0])-1:
                return -i
            for d in directions:
                nr, nc = r+d[0], c+d[1]
                if 0 &lt;= nr &lt; len(A) and \
                   0 &lt;= nc &lt; len(A[0]) and \
                   (nr, nc) not in lookup:
                    heapq.heappush(max_heap, (-min(-i, A[nr][nc]), nr, nc))
                    lookup.add((nr, nc))    
        return -1

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1129 - https://leetcode.com/problems/shortest-path-with-alternating-colors/
Time: O(n + e)  Space: O(n + e)   Medium
.Python/shortest-path-with-alternating-colors.py


```python
# Time:  O(n + e), e is the number of red and blue edges
# Space: O(n + e)

import collections


class Solution(object):
    def shortestAlternatingPaths(self, n, red_edges, blue_edges):
        """
        :type n: int
        :type red_edges: List[List[int]]
        :type blue_edges: List[List[int]]
        :rtype: List[int]
        """
        neighbors = [[set() for _ in xrange(2)] for _ in xrange(n)]
        for i, j in red_edges:
            neighbors[i][0].add(j)
        for i, j in blue_edges:
            neighbors[i][1].add(j)
        INF = max(2*n-3, 0)+1
        dist = [[INF, INF] for i in xrange(n)]
        dist[0] = [0, 0]
        q = collections.deque([(0, 0), (0, 1)])
        while q:
            i, c = q.popleft()
            for j in neighbors[i][c]:
                if dist[j][c] != INF:
                    continue
                dist[j][c] = dist[i][1^c]+1
                q.append((j, 1^c))
        return [x if x != INF else -1 for x in map(min, dist)]

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1136 - https://leetcode.com/problems/parallel-courses/
Time: O(|V| + |E|)  Space: O(|E|)   Hard
.Python/parallel-courses.py


```python
# Time:  O(|V| + |E|)
# Space: O(|E|)

import collections


class Solution(object):
    def minimumSemesters(self, N, relations):
        """
        :type N: int
        :type relations: List[List[int]]
        :rtype: int
        """
        g = collections.defaultdict(list)
        in_degree = [0]*N
        for x, y in relations:
            g[x-1].append(y-1)
            in_degree[y-1] += 1
        q = collections.deque([(1, i) for i in xrange(N) if not in_degree[i]])

        result = 0
        count = N
        while q:
            level, u = q.popleft()
            count -= 1
            result = level
            for v in g[u]:
                in_degree[v] -= 1
                if not in_degree[v]:
                    q.append((level+1, v))
        return result if count == 0 else -1

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1161 - https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/
Time: O(n)  Space: O(w)   Medium
.Python/maximum-level-sum-of-a-binary-tree.py


```python
# Time:  O(n)
# Space: O(h)

import collections


# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


# dfs solution
class Solution(object):
    def maxLevelSum(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(node, i, level_sums):
            if not node:
                return
            if i == len(level_sums):
                level_sums.append(0)
            level_sums[i] += node.val
            dfs(node.left, i+1, level_sums)
            dfs(node.right, i+1, level_sums)

        level_sums = []
        dfs(root, 0, level_sums)
        return level_sums.index(max(level_sums))+1

    
# Time:  O(n)
# Space: O(w)
# bfs solution
class Solution2(object):
    def maxLevelSum(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        result, level, max_total = 0, 1, float("-inf")
        q = collections.deque([root])
        while q:
            total = 0
            for _ in xrange(len(q)):
                node = q.popleft()
                total += node.val
                if node.left:
                    q.append(node.left)
                if node.right:
                    q.append(node.right)
            if total &gt; max_total:
                result, max_total = level, total
            level += 1
        return result

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1162 - https://leetcode.com/problems/as-far-from-land-as-possible/
Time: O(m * n)  Space: O(m * n)   Medium
.Python/as-far-from-land-as-possible.py


```python
# Time:  O(m * n)
# Space: O(m * n)

import collections


class Solution(object):
    def maxDistance(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        q = collections.deque([(i, j) for i in xrange(len(grid))
                                      for j in xrange(len(grid[0])) if grid[i][j] == 1])    
        if len(q) == len(grid)*len(grid[0]):
            return -1
        level = -1
        while q:
            next_q = collections.deque()
            while q:
                x, y = q.popleft()
                for dx, dy in directions:
                    nx, ny = x+dx, y+dy
                    if not (0 &lt;= nx &lt; len(grid) and 
                            0 &lt;= ny &lt; len(grid[0]) and 
                            grid[nx][ny] == 0):
                        continue
                    next_q.append((nx, ny))
                    grid[nx][ny] = 1
            q = next_q
            level += 1
        return level

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1203 - https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/
Time: O(n + e)  Space: O(n + e)   Hard
.Python/sort-items-by-groups-respecting-dependencies.py


```python
# Time:  O(n + e)
# Space: O(n + e)

import collections


class Topo(object):
    def __init__(self):
        self.__nodes = set()
        self.__in_degree = collections.defaultdict(set)
        self.__out_degree = collections.defaultdict(set)
        
    def add_node(self, node):
        self.__nodes.add(node)
    
    def add_edge(self, src, dst):
        self.add_node(src), self.add_node(dst)
        self.__in_degree[dst].add(src)
        self.__out_degree[src].add(dst)
    
    def sort(self):
        q = collections.deque()
        result = []
        for node in self.__nodes:
            if node not in self.__in_degree:
                q.append(node)
        while q:
            node = q.popleft()
            result.append(node)
            for nei in self.__out_degree[node]:
                self.__in_degree[nei].remove(node)
                if not self.__in_degree[nei]:
                    self.__in_degree.pop(nei)
                    q.append(nei)
        if len(result) &lt; len(self.__nodes):
            return
        return result


class Solution(object):
    def sortItems(self, n, m, group, beforeItems):
        """
        :type n: int
        :type m: int
        :type group: List[int]
        :type beforeItems: List[List[int]]
        :rtype: List[int]
        """
        for i in xrange(n):
            if group[i] == -1:
                group[i] = m
                m += 1    
        global_group = Topo()
        for i in xrange(m):
            global_group.add_node(i)
        local_groups = collections.defaultdict(Topo)
        for i in xrange(n):
            local_groups[group[i]].add_node(i)
        for i in xrange(n):
            for j in beforeItems[i]:
                if group[i] == group[j]:
                    local_groups[group[i]].add_edge(j, i)
                else:
                    global_group.add_edge(group[j], group[i]);
        result = []
        global_order = global_group.sort()
        if global_order is None:
            return []
        for i in global_order:
            local_order = local_groups[i].sort();
            if local_order is None:
                return []
            for x in local_order:
                result.append(x)
        return result

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1210 - https://leetcode.com/problems/minimum-moves-to-reach-target-with-rotations/
Time: O(n)  Space: O(n)   Hard
.Python/minimum-moves-to-reach-target-with-rotations.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def minimumMoves(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        level, q, lookup = 0, [(0, 0, False)], set()
        while q:
            next_q = []
            for r, c, is_vertical in q:
                if (r, c, is_vertical) in lookup:
                    continue
                if (r, c, is_vertical) == (len(grid)-1, len(grid)-2, False):
                    return level
                lookup.add((r, c, is_vertical))
                if not is_vertical:
                    if c+2 != len(grid[0]) and grid[r][c+2] == 0:
                        next_q.append((r, c+1, is_vertical))
                    if r+1 != len(grid) and grid[r+1][c] == 0 and grid[r+1][c+1] == 0:
                        next_q.append((r+1, c, is_vertical))
                        next_q.append((r, c, not is_vertical))
                else:
                    if r+2 != len(grid) and grid[r+2][c] == 0:
                        next_q.append((r+1, c, is_vertical))
                    if c+1 != len(grid) and grid[r][c+1] == 0 and grid[r+1][c+1] == 0:
                        next_q.append((r, c+1, is_vertical))
                        next_q.append((r, c, not is_vertical))
            q = next_q
            level += 1
        return -1

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1215 - https://leetcode.com/problems/stepping-numbers/
Time: O(logk + r)  Space: O(k)   Medium
.Python/stepping-numbers.py


```python
# Time:  O(logk + r), r is the size of result
# Space: O(k), k is the size of stepping numbers in [0, high]

import bisect


MAX_HIGH = int(2e9)
result = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for i in xrange(1, MAX_HIGH):
    if result[-1] &gt;= MAX_HIGH:
        break
    d1 = result[i]%10 - 1
    if d1 &gt;= 0:
        result.append(result[i]*10 + d1)
    d2 = result[i]%10 + 1
    if d2 &lt;= 9:
        result.append(result[i]*10 + d2)
result.append(float("inf"))


class Solution(object):
    def countSteppingNumbers(self, low, high):
        """
        :type low: int
        :type high: int
        :rtype: List[int]
        """
        lit = bisect.bisect_left(result, low);
        rit = bisect.bisect_right(result, high);
        return result[lit:rit]


# Time:  O(k + r), r is the size of result
# Space: O(k), k is the size of stepping numbers in [0, high]
class Solution2(object):
    def countSteppingNumbers(self, low, high):
        """
        :type low: int
        :type high: int
        :rtype: List[int]
        """
        result = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        for i in xrange(1, high):
            if result[-1] &gt;= high:
                break
            d1 = result[i]%10 - 1
            if d1 &gt;= 0:
                result.append(result[i]*10 + d1)
            d2 = result[i]%10 + 1
            if d2 &lt;= 9:
                result.append(result[i]*10 + d2)
        result.append(float("inf"))
        lit = bisect.bisect_left(result, low);
        rit = bisect.bisect_right(result, high);
        return result[lit:rit]

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1245 - https://leetcode.com/problems/tree-diameter/
Time: O(|V| + |E|)  Space: O(|E|)   Medium
.Python/tree-diameter.py


```python
# Time:  O(|V| + |E|)
# Space: O(|E|)

import collections


class Solution(object):
    def treeDiameter(self, edges):
        """
        :type edges: List[List[int]]
        :rtype: int
        """
        graph, length = collections.defaultdict(set), 0
        for u, v in edges:
            graph[u].add(v)
            graph[v].add(u)
        curr_level = {(None, u) for u, neighbors in graph.iteritems() if len(neighbors) == 1}
        while curr_level:
            curr_level = {(u, v) for prev, u in curr_level
                          for v in graph[u] if v != prev}
            length += 1
        return max(length-1, 0)

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1263 - https://leetcode.com/problems/minimum-moves-to-move-a-box-to-their-target-location/
Time: O(m^2 * n^2)  Space: O(m^2 * n^2)   Hard
.Python/minimum-moves-to-move-a-box-to-their-target-location.py


```python
# Time:  O(m^2 * n^2)
# Space: O(m^2 * n^2)

# A* Search Algorithm without heap
class Solution(object):
    def minPushBox(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def dot(a, b):
            return a[0]*b[0]+a[1]*b[1]

        def can_reach(grid, b, p, t):
            closer, detour = [p], []
            lookup = set([b])
            while closer or detour:
                if not closer:
                    closer, detour = detour, closer
                p = closer.pop()
                if p == t:
                    return True
                if p in lookup:
                    continue
                lookup.add(p)
                for dx, dy in directions:
                    np = (p[0]+dx, p[1]+dy)
                    if not (0 &lt;= np[0] &lt; len(grid) and 0 &lt;= np[1] &lt; len(grid[0]) and
                       grid[np[0]][np[1]] != '#' and np not in lookup):
                        continue
                    (closer if dot((dx, dy), (t[0]-p[0], t[1]-p[1])) &gt; 0 else detour).append(np)
            return False

        def g(a, b):
            return abs(a[0]-b[0])+abs(a[1]-b[1])
        
        def a_star(grid, b, p, t):
            f, dh = g(b, t), 2
            closer, detour = [(b, p)], []
            lookup = set()
            while closer or detour:
                if not closer:
                    f += dh
                    closer, detour = detour, closer
                b, p = closer.pop()
                if b == t:
                    return f
                if (b, p) in lookup:
                    continue
                lookup.add((b, p))
                for dx, dy in directions:
                    nb, np = (b[0]+dx, b[1]+dy), (b[0]-dx, b[1]-dy)
                    if not (0 &lt;= nb[0] &lt; len(grid) and 0 &lt;= nb[1] &lt; len(grid[0]) and
                            0 &lt;= np[0] &lt; len(grid) and 0 &lt;= np[1] &lt; len(grid[0]) and
                            grid[nb[0]][nb[1]] != '#' and grid[np[0]][np[1]] != '#' and
                            (nb, b) not in lookup and can_reach(grid, b, p, np)):
                        continue
                    (closer if dot((dx, dy), (t[0]-b[0], t[1]-b[1])) &gt; 0 else detour).append((nb, b))
            return -1
        
        b, p, t = None, None, None
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if grid[i][j] == 'B':
                    b = (i, j)
                elif grid[i][j] == 'S':
                    p = (i, j)
                elif grid[i][j] == 'T':
                    t = (i, j)
        return a_star(grid, b, p, t)

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1284 - https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/
Time: O((m * n) * 2^(m * n))  Space: O((m * n) * 2^(m * n))   Hard
.Python/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix.py


```python
# Time:  O((m * n) * 2^(m * n))
# Space: O((m * n) * 2^(m * n))

import collections


class Solution(object):
    def minFlips(self, mat):
        """
        :type mat: List[List[int]]
        :rtype: int
        """
        directions = [(0, 0), (0, 1), (1, 0), (0, -1), (-1, 0)]
        start = sum(val &lt;&lt; r*len(mat[0])+c for r, row in enumerate(mat) for c, val in enumerate(row))
        q = collections.deque([(start, 0)])
        lookup = {start}
        while q:
            state, step = q.popleft()
            if not state:
                return step
            for r in xrange(len(mat)):
                for c in xrange(len(mat[0])):
                    new_state = state
                    for dr, dc in directions:
                        nr, nc = r+dr, c+dc
                        if 0 &lt;= nr &lt; len(mat) and 0 &lt;= nc &lt; len(mat[0]):
                            new_state ^= 1 &lt;&lt; nr*len(mat[0])+nc
                    if new_state in lookup:
                        continue
                    lookup.add(new_state)
                    q.append((new_state, step+1))
        return -1

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1291 - https://leetcode.com/problems/sequential-digits/
Time: O(1)  Space: O(1)   Medium
.Python/sequential-digits.py


```python
# Time:  O((8 + 1) * 8 / 2) = O(1)
# Space: O(8) = O(1)

import collections


class Solution(object):
    def sequentialDigits(self, low, high):
        """
        :type low: int
        :type high: int
        :rtype: List[int]
        """
        result = []
        q = collections.deque(range(1, 9))
        while q:
            num = q.popleft()
            if num &gt; high:
                continue
            if low &lt;= num:
                result.append(num)
            if num%10+1 &lt; 10:
                q.append(num*10+num%10+1)
        return result

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1293 - https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/
Time: O(m * n * k)  Space: O(m * n)   Hard
.Python/shortest-path-in-a-grid-with-obstacles-elimination.py


```python
# Time:  O(m * n * k)
# Space: O(m * n)

# A* Search Algorithm without heap
class Solution(object):
    def shortestPath(self, grid, k):
        """
        :type grid: List[List[int]]
        :type k: int
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def dot(a, b):
            return a[0]*b[0]+a[1]*b[1]

        def g(a, b):
            return abs(a[0]-b[0])+abs(a[1]-b[1])
        
        def a_star(grid, b, t, k):
            f, dh = g(b, t), 2
            closer, detour = [(b, k)], []
            lookup = {}
            while closer or detour:
                if not closer:
                    f += dh
                    closer, detour = detour, closer
                b, k = closer.pop()
                if b == t:
                    return f
                if b in lookup and lookup[b] &gt;= k:
                    continue
                lookup[b] = k
                for dx, dy in directions:
                    nb = (b[0]+dx, b[1]+dy)
                    if not (0 &lt;= nb[0] &lt; len(grid) and 0 &lt;= nb[1] &lt; len(grid[0]) and
                            (grid[nb[0]][nb[1]] == 0 or k &gt; 0) and
                            (nb not in lookup or lookup[nb] &lt; k)):
                        continue
                    (closer if dot((dx, dy), (t[0]-b[0], t[1]-b[1])) &gt; 0 else detour).append((nb, k-int(grid[nb[0]][nb[1]] == 1)))
            return -1

        return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1), k)

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1298 - https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes/
Time: O(n^2)  Space: O(n)   Hard
.Python/maximum-candies-you-can-get-from-boxes.py


```python
# Time:  O(n^2)
# Space: O(n)

import collections


class Solution(object):
    def maxCandies(self, status, candies, keys, containedBoxes, initialBoxes):
        """
        :type status: List[int]
        :type candies: List[int]
        :type keys: List[List[int]]
        :type containedBoxes: List[List[int]]
        :type initialBoxes: List[int]
        :rtype: int
        """
        result = 0
        q = collections.deque(initialBoxes)
        while q:
            changed = False
            for _ in xrange(len(q)):
                box = q.popleft()
                if not status[box]:
                    q.append(box)
                    continue
                changed = True
                result += candies[box]
                for contained_key in keys[box]:
                    status[contained_key] = 1
                for contained_box in containedBoxes[box]:
                    q.append(contained_box)
            if not changed:
                break
        return result

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1302 - https://leetcode.com/problems/deepest-leaves-sum/
Time: O(n)  Space: O(w)   Medium
.Python/deepest-leaves-sum.py


```python
# Time:  O(n)
# Space: O(w)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def deepestLeavesSum(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        curr = [root]
        while curr:
            prev, curr = curr, [child for p in curr for child in [p.left, p.right] if child]
        return sum(node.val for node in prev)

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1306 - https://leetcode.com/problems/jump-game-iii/
Time: O(n)  Space: O(n)   Medium
.Python/jump-game-iii.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def canReach(self, arr, start):
        """
        :type arr: List[int]
        :type start: int
        :rtype: bool
        """
        q, lookup = collections.deque([start]), set([start])
        while q:
            i = q.popleft()
            if not arr[i]:
                return True
            for j in [i-arr[i], i+arr[i]]:
                if 0 &lt;= j &lt; len(arr) and j not in lookup:
                    lookup.add(j)
                    q.append(j) 
        return False

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1311 - https://leetcode.com/problems/get-watched-videos-by-your-friends/
Time: O(n + vlogv)  Space: O(w)   Medium
.Python/get-watched-videos-by-your-friends.py


```python
# Time:  O(n + vlogv), v is the number of the level videos
# Space: O(w)

import collections


class Solution(object):
    def watchedVideosByFriends(self, watchedVideos, friends, id, level):
        """
        :type watchedVideos: List[List[str]]
        :type friends: List[List[int]]
        :type id: int
        :type level: int
        :rtype: List[str]
        """
        curr_level, lookup = set([id]), set([id])
        for _ in xrange(level):
            curr_level = set(j for i in curr_level for j in friends[i] if j not in lookup)
            lookup |= curr_level
        count = collections.Counter([v for i in curr_level for v in watchedVideos[i]])
        return sorted(count.keys(), key=lambda x: (count[x], x))

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1345 - https://leetcode.com/problems/jump-game-iv/
Time: O(n)  Space: O(n)   Hard
.Python/jump-game-iv.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def minJumps(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        groups = collections.defaultdict(list)
        for i, x in enumerate(arr):
            groups[x].append(i)
        q = collections.deque([(0, 0)])
        lookup = set([0])
        while q:
            pos, step = q.popleft()
            if pos == len(arr)-1:
                break
            neighbors = set(groups[arr[pos]] + [pos-1, pos+1])
            groups[arr[pos]] = []
            for p in neighbors:
                if p in lookup or not 0 &lt;= p &lt; len(arr):
                    continue
                lookup.add(p)
                q.append((p, step+1)) 
        return step

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1368 - https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/
Time: O(m * n)  Space: O(m * n)   Hard
.Python/minimum-cost-to-make-at-least-one-valid-path-in-a-grid.py


```python
# Time:  O(m * n)
# Space: O(m * n)

# A* Search Algorithm without heap
class Solution(object):
    def minCost(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        def a_star(grid, b, t):
            f, dh = 0, 1
            closer, detour = [b], []
            lookup = [[False]*len(grid[0]) for _ in xrange(len(grid))]
            while closer or detour:
                if not closer:
                    f += dh
                    closer, detour = detour, closer
                b = closer.pop()
                if b == t:
                    return f
                if lookup[b[0]][b[1]]:
                    continue
                lookup[b[0]][b[1]] = True
                for nd, (dr, dc) in enumerate(directions, 1):
                    nb = (b[0]+dr, b[1]+dc)
                    if not (0 &lt;= nb[0] &lt; len(grid) and 0 &lt;= nb[1] &lt; len(grid[0]) and not lookup[nb[0]][nb[1]]):
                        continue
                    (closer if nd == grid[b[0]][b[1]] else detour).append(nb)
            return -1

        return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1))


# Time:  O(m * n)
# Space: O(m * n)
import collections


#  0-1 bfs solution
class Solution2(object):
    def minCost(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        b, t = (0, 0), (len(grid)-1, len(grid[0])-1)
        dq = collections.deque([(b, 0)])
        lookup = [[False]*len(grid[0]) for _ in xrange(len(grid))]
        while dq:
            b, d = dq.popleft()
            if b == t:
                return d
            if lookup[b[0]][b[1]]:
                    continue
            lookup[b[0]][b[1]] = True
            for nd, (dr, dc) in enumerate(directions, 1):
                nb = (b[0]+dr, b[1]+dc)
                if not (0 &lt;= nb[0] &lt; len(grid) and 0 &lt;= nb[1] &lt; len(grid[0]) and not lookup[nb[0]][nb[1]]):
                    continue
                if nd == grid[b[0]][b[1]]:
                    dq.appendleft((nb, d))
                else:
                    dq.append((nb, d+1))
        return -1  # never reach here

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1514 - https://leetcode.com/problems/path-with-maximum-probability/
Time: O(|E| * log|V|)  Space: O(|E|)   Medium
.Python/path-with-maximum-probability.py


```python
# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)
# Space: O(|E| + |V|) = O(|E|)

import collections
import itertools
import heapq


class Solution(object):
    def maxProbability(self, n, edges, succProb, start, end):
        """
        :type n: int
        :type edges: List[List[int]]
        :type succProb: List[float]
        :type start: int
        :type end: int
        :rtype: float
        """
        adj = collections.defaultdict(list)
        for (u, v), p in itertools.izip(edges, succProb):
            adj[u].append((v, p))
            adj[v].append((u, p))
        max_heap = [(-1.0, start)]
        result, lookup = collections.defaultdict(float), set()
        result[start] = 1.0
        while max_heap and len(lookup) != len(adj):
            curr, u = heapq.heappop(max_heap)
            if u in lookup:
                continue
            lookup.add(u)
            for v, w in adj[u]:
                if v in lookup:
                    continue
                if v in result and result[v] &gt;= -curr*w:
                    continue
                result[v] = -curr*w
                heapq.heappush(max_heap, (-result[v], v))
        return result[end]

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1602 - https://leetcode.com/problems/find-nearest-right-node-in-binary-tree/
Time: O(n)  Space: O(w)   Medium
.Python/find-nearest-right-node-in-binary-tree.py


```python
# Time:  O(n)
# Space: O(w)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def findNeartestRightNode(self, root, u):
        """
        :type root: TreeNode
        :type u: TreeNode
        :rtype: TreeNode
        """
        q = [root]
        while q:
            new_q = []
            for i, node in enumerate(q):
                if node == u:
                    return q[i+1] if i+1 &lt; len(q) else None
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
            q = new_q
        return None

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1609 - https://leetcode.com/problems/even-odd-tree/
Time: O(n)  Space: O(w)   Medium
.Python/even-odd-tree.py


```python
# Time:  O(n)
# Space: O(w)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution(object):
    def isEvenOddTree(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        q = [root]
        is_odd = False
        while q:
            new_q = []
            prev = None
            for node in q:
                if is_odd:
                    if node.val%2 or (prev and prev.val &lt;= node.val):
                        return False
                else:
                    if not node.val%2 or (prev and prev.val &gt;= node.val):
                        return False
                if node.left:
                    new_q.append(node.left)
                if node.right:
                    new_q.append(node.right)
                prev = node
            q = new_q
            is_odd = not is_odd
        return True

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1625 - https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/
Time: O(n^2)  Space: O(1)   Medium
.Python/lexicographically-smallest-string-after-applying-operations.py


```python
# Time:  O(100 * n^2) = O(n^2)
# Space: O(1)

class Solution(object):
    def findLexSmallestString(self, s, a, b):
        """
        :type s: str
        :type a: int
        :type b: int
        :rtype: str
        """
        def less(s, i, j):
            for k in xrange(len(s)):
                if s[(k+i)%len(s)] != s[(k+j)%len(s)]:
                    return s[(k+i)%len(s)] &lt; s[(k+j)%len(s)]
            return False

        s = list(s)
        result = s[:]
        even = [False]*10
        while not even[int(s[0])]:  # at most O(10) times
            even[int(s[0])] = True
            odd = [False]*10
            while not odd[int(s[1])]:  # at most O(10) times
                odd[int(s[1])] = True
                best_rotate = 0
                lookup = [False]*len(s)
                i = b
                while not lookup[i]:  # find best rotation, at most O(n) times
                    lookup[i] = True
                    if less(s, i, best_rotate):  # O(n) time
                        best_rotate = i
                    i = (i+b)%len(s)
                result = min(result, s[best_rotate:] + s[:best_rotate])
                for k in xrange(1, len(s), 2):  # flip odd index
                    s[k] = str((int(s[k])+a) % 10)
            if b%2:  # if rotate length is odd, even index could be also flipped
                for k in xrange(0, len(s), 2):  # flip even index
                    s[k] = str((int(s[k])+a) % 10)
        return "".join(result)


# Time:  O(100 * n^2), at most O(100n) strings and each compare costs O(n)
# Space: O(n^2)
import collections


class Solution2(object):
    def findLexSmallestString(self, s, a, b):
        """
        :type s: str
        :type a: int
        :type b: int
        :rtype: str
        """
        q, lookup, result = collections.deque([s]), {s}, s
        while q:
            curr = q.popleft()
            if curr &lt; result:
                result = curr
            add_a = list(curr)    
            for i, c in enumerate(add_a):
                if i%2:
                    add_a[i] = str((int(c)+a) % 10)
            add_a = "".join(add_a)        
            if add_a not in lookup:
                lookup.add(add_a);
                q.append(add_a)
            rotate_b = curr[b:] + curr[:b]
            if rotate_b not in lookup:
                lookup.add(rotate_b)
                q.append(rotate_b)
        return result

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1654 - https://leetcode.com/problems/minimum-jumps-to-reach-home/
Time: O(max(x, max(forbidden)) + a + b)  Space: O(max(x, max(forbidden)) + a + b)   Medium
.Python/minimum-jumps-to-reach-home.py


```python
# Time:  O(max(x, max(forbidden)) + a + (b+a))
# Space: O(max(x, max(forbidden)) + a + (b+a))

class Solution(object):
    def minimumJumps(self, forbidden, a, b, x):
        """
        :type forbidden: List[int]
        :type a: int
        :type b: int
        :type x: int
        :rtype: int
        """
        max_f = max(forbidden)
        max_val = x+b if a &gt;= b else max(x, max_f)+a+(b+a)  # a may be a non-periodic area, (a+b) is a periodic area which is divided by gcd(a, b) and all points are reachable
        lookup = set()      
        for pos in forbidden:
            lookup.add((pos, True))
            lookup.add((pos, False))
        result = 0
        q = [(0, True)]
        lookup.add((0, True))
        while q:
            new_q = []
            for pos, can_back in q:
                if pos == x:
                    return result
                if pos+a &lt;= max_val and (pos+a, True) not in lookup:
                    lookup.add((pos+a, True))
                    new_q.append((pos+a, True))
                if not can_back:
                    continue
                if pos-b &gt;= 0 and (pos-b, False) not in lookup:
                    lookup.add((pos-b, False))
                    new_q.append((pos-b, False))
            q = new_q
            result += 1
        return -1

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1660 - https://leetcode.com/problems/correct-a-binary-tree/
Time: O(n)  Space: O(w)   Medium
.Python/correct-a-binary-tree.py


```python
# Time:  O(n)
# Space: O(w)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def correctBinaryTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        q = {root:None}
        while q:
            new_q = {}
            for node, parent in q.iteritems():
                if node.right in q:
                    if parent.left == node:
                        parent.left = None
                    else:
                        parent.right = None
                    return root
                if node.left:
                    new_q[node.left] = node
                if node.right:
                    new_q[node.right] = node
            q = new_q

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1728 - https://leetcode.com/problems/cat-and-mouse-ii/
Time: O((m * n)^2 * (m + n))  Space: O((m * n)^2)   Hard
.Python/cat-and-mouse-ii.py


```python
# Time:  O((m * n)^2 * (m + n))
# Space: O((m * n)^2)

import collections


class Solution(object):
    def canMouseWin(self, grid, catJump, mouseJump):
        """
        :type grid: List[str]
        :type catJump: int
        :type mouseJump: int
        :rtype: bool
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        DRAW, MOUSE, CAT = range(3)
        def parents(m, c, t):
            if t == CAT:
                for nm in graph[m, MOUSE^CAT^t]:
                    yield nm, c, MOUSE^CAT^t
            else:
                for nc in graph[c, MOUSE^CAT^t]:
                    yield m, nc, MOUSE^CAT^t

        R, C = len(grid), len(grid[0])
        N = R*C
        WALLS = set()
        FOOD, MOUSE_START, CAT_START = [-1]*3
        for r in xrange(R):
            for c in xrange(C):
                if grid[r][c] == 'M':
                    MOUSE_START = r*C + c
                elif grid[r][c] == 'C':
                    CAT_START = r*C + c
                elif grid[r][c] == 'F':
                    FOOD = r*C + c
                elif grid[r][c] == '#':
                    WALLS.add(r*C + c)

        graph = collections.defaultdict(set)
        jump = {MOUSE:mouseJump, CAT:catJump}
        for r in xrange(R):
            for c in xrange(C):
                if grid[r][c] == '#':
                    continue
                pos = r*C + c
                for t in [MOUSE, CAT]:
                    for dr, dc in directions:
                        for d in xrange(jump[t]+1):
                            nr, nc = r+dr*d, c+dc*d
                            if not (0 &lt;= nr &lt; R and 0 &lt;= nc &lt; C and grid[nr][nc] != '#'):
                                break
                            graph[pos, t].add(nr*C + nc)

        degree = {}
        for m in xrange(N):
            for c in xrange(N):
                degree[m, c, MOUSE] = len(graph[m, MOUSE])
                degree[m, c, CAT] = len(graph[c, CAT])
        color = collections.defaultdict(int)
        q = collections.deque()
        for i in xrange(N):
            if i in WALLS or i == FOOD:
                continue
            color[FOOD, i, CAT] = MOUSE
            q.append((FOOD, i, CAT, MOUSE))
            color[i, FOOD, MOUSE] = CAT
            q.append((i, FOOD, MOUSE, CAT))
            for t in [MOUSE, CAT]:
                color[i, i, t] = CAT
                q.append((i, i, t, CAT))
        while q:
            i, j, t, c = q.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if nt == c:
                    color[ni, nj, nt] = c
                    q.append((ni, nj, nt, c))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = c
                    q.append((ni, nj, nt, c))
        return color[MOUSE_START, CAT_START, MOUSE] == MOUSE


# Time:  O((m * n)^2 * (m + n))
# Space: O((m * n)^2)
import collections


class Solution2(object):
    def canMouseWin(self, grid, catJump, mouseJump):
        """
        :type grid: List[str]
        :type catJump: int
        :type mouseJump: int
        :rtype: bool
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        DRAW, MOUSE, CAT = range(3)
        def parents(m, c, t):
            if t == CAT:
                for nm in graph[m, MOUSE^CAT^t]:
                    yield nm, c, MOUSE^CAT^t
            else:
                for nc in graph[c, MOUSE^CAT^t]:
                    yield m, nc, MOUSE^CAT^t

        R, C = len(grid), len(grid[0])
        N = R*C
        WALLS = set()
        FOOD, MOUSE_START, CAT_START = [-1]*3
        for r in xrange(R):
            for c in xrange(C):
                if grid[r][c] == 'M':
                    MOUSE_START = r*C + c
                elif grid[r][c] == 'C':
                    CAT_START = r*C + c
                elif grid[r][c] == 'F':
                    FOOD = r*C + c
                elif grid[r][c] == '#':
                    WALLS.add(r*C + c)
        graph = collections.defaultdict(set)
        jump = {MOUSE:mouseJump, CAT:catJump}
        for r in xrange(R):
            for c in xrange(C):
                if grid[r][c] == '#':
                    continue
                pos = r*C + c
                for t in [MOUSE, CAT]:
                    for dr, dc in directions:
                        for d in xrange(jump[t]+1):
                            nr, nc = r+dr*d, c+dc*d
                            if not (0 &lt;= nr &lt; R and 0 &lt;= nc &lt; C and grid[nr][nc] != '#'):
                                break
                            graph[pos, t].add(nr*C + nc)

        degree = {}
        for m in xrange(N):
            for c in xrange(N):
                # degree[m, c, MOUSE] = len(graph[m, MOUSE])
                degree[m, c, CAT] = len(graph[c, CAT])
        color = collections.defaultdict(int)
        q1 = collections.deque()
        # q2 = collections.deque()
        for i in xrange(N):
            if i in WALLS or i == FOOD:
                continue
            color[FOOD, i, CAT] = MOUSE
            q1.append((FOOD, i, CAT))
            color[i, FOOD, MOUSE] = CAT
            # q2.append((i, FOOD, MOUSE))
            for t in [MOUSE, CAT]:
                color[i, i, t] = CAT
                # q2.append((i, i, t))
        while q1:
            i, j, t = q1.popleft()
            for ni, nj, nt in parents(i, j, t):
                if color[ni, nj, nt] != DRAW:
                    continue
                if t == CAT:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
                    continue
                degree[ni, nj, nt] -= 1
                if not degree[ni, nj, nt]:
                    color[ni, nj, nt] = MOUSE
                    q1.append((ni, nj, nt))
        # while q2:
        #     i, j, t = q2.popleft()
        #     for ni, nj, nt in parents(i, j, t):
        #         if color[ni, nj, nt] != DRAW:
        #             continue
        #         if t == MOUSE:
        #             color[ni, nj, nt] = CAT
        #             q2.append((ni, nj, nt))
        #             continue
        #         degree[ni, nj, nt] -= 1
        #         if not degree[ni, nj, nt]:
        #             color[ni, nj, nt] = CAT
        #             q2.append((ni, nj, nt))
        return color[MOUSE_START, CAT_START, MOUSE] == MOUSE

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1730 - https://leetcode.com/problems/shortest-path-to-get-food/
Time: O(m * n)  Space: O(m + n)   Medium
.Python/shortest-path-to-get-food.py


```python
# Time:  O(m * n)
# Space: O(m + n)

class Solution(object):
    def getFood(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]

        q = []
        for r in xrange(len(grid)):
            for c in xrange(len(grid[0])):
                if grid[r][c] == '*':
                    q.append((r, c))
                    break
        
        result = 0
        while q:
            result += 1
            new_q = []
            for r, c in q:
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 &lt;= nr &lt; len(grid) and
                            0 &lt;= nc &lt; len(grid[0]) and
                            grid[nr][nc] != 'X'):
                        continue
                    if grid[nr][nc] == '#':
                        return result
                    grid[nr][nc] = 'X'
                    new_q.append((nr, nc))
            q = new_q 
        return -1

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1765 - https://leetcode.com/problems/map-of-highest-peak/
Time: O(m * n)  Space: O(m * n)   Medium
.Python/map-of-highest-peak.py


```python
# Time:  O(m * n)
# Space: O(m * n)

class Solution(object):
    def highestPeak(self, isWater):
        """
        :type isWater: List[List[int]]
        :rtype: List[List[int]]
        """
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        q = []
        for r, row in enumerate(isWater):
            for c, cell in enumerate(row):
                row[c] -= 1
                if not cell:
                    continue
                q.append((r, c))
        while q:
            new_q = []
            for r, c in q:
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc 
                    if not (0 &lt;= nr &lt; len(isWater) and
                            0 &lt;= nc &lt; len(isWater[0]) and
                            isWater[nr][nc] == -1):
                        continue
                    isWater[nr][nc] = isWater[r][c]+1
                    q.append((nr, nc))
            q = new_q
        return isWater


# Time:  O(m * n)
# Space: O(m * n)
class Solution2(object):
    def highestPeak(self, isWater):
        """
        :type isWater: List[List[int]]
        :rtype: List[List[int]]
        """
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]

        q, heights = [], [[-1]*len(isWater[0]) for _ in xrange(len(isWater))]
        for r, row in enumerate(isWater):
            for c, cell in enumerate(row):
                if not cell:
                    continue
                heights[r][c] = 0
                q.append((r, c))
        while q:
            new_q = []
            for r, c in q:
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc 
                    if not (0 &lt;= nr &lt; len(isWater) and
                            0 &lt;= nc &lt; len(isWater[0]) and
                            heights[nr][nc] == -1):
                        continue
                    heights[nr][nc] = heights[r][c]+1
                    q.append((nr, nc))
            q = new_q
        return heights

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1926 - https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/
Time: O(m * n)  Space: O(m + n)   Medium
.Python/nearest-exit-from-entrance-in-maze.py


```python
# Time:  O(m * n)
# Space: O(m + n)

# bi-bfs solution
class Solution(object):
    def nearestExit(self, maze, entrance):
        """
        :type maze: List[List[str]]
        :type entrance: List[int]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        visited = ' '
        entrance = tuple(entrance)
        left = set([entrance])
        right = set([(r, 0) for r in xrange(len(maze)-1) if maze[r][0] == '.' and (r, 0) != entrance] +
                    [(len(maze)-1, c) for c in xrange(len(maze[0])-1) if maze[len(maze)-1][c] == '.' and (len(maze)-1, c) != entrance] +
                    [(r, len(maze[0])-1) for r in reversed(xrange(1, len(maze))) if maze[r][len(maze[0])-1] == '.' and (r, len(maze[0])-1) != entrance] +
                    [(0, c) for c in reversed(xrange(1, len(maze[0]))) if maze[0][c] == '.' and (0, c) != entrance])
        steps = 0
        while left:
            for (r, c) in left:
                maze[r][c] = visited
            new_left = set()
            for (r, c) in left:
                if (r, c) in right: 
                    return steps
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 &lt;= nr &lt; len(maze) and
                            0 &lt;= nc &lt; len(maze[0]) and
                            maze[nr][nc] == '.'):
                        continue
                    new_left.add((nr, nc))
            left = new_left
            steps += 1
            if len(left) &gt; len(right): 
                left, right = right, left
        return -1


# Time:  O(m * n)
# Space: O(m + n)
# bfs solution
class Solution2(object):
    def nearestExit(self, maze, entrance):
        """
        :type maze: List[List[str]]
        :type entrance: List[int]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        visited = ' '
        entrance = tuple(entrance)
        maze[entrance[0]][entrance[1]] = visited
        q = [(entrance, 0)]
        while q:
            new_q = []
            for (r, c), step in q:
                if (r, c) != entrance and \
                   (r in (0, len(maze)-1) or c in (0, len(maze[0])-1)):
                    return step
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 &lt;= nr &lt; len(maze) and
                            0 &lt;= nc &lt; len(maze[0]) and
                            maze[nr][nc] == '.'):
                        continue
                    maze[nr][nc] = visited
                    q.append(((nr, nc), step+1))
            q = new_q
        return -1

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 1928 - https://leetcode.com/problems/minimum-cost-to-reach-destination-in-time/
Time: O(|E| * log|V|)  Space: O(|E|)   Hard
.Python/minimum-cost-to-reach-destination-in-time.py


```python
# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)
# Space: O(|E| + |V|) = O(|E|)

import collections
import heapq


# Dijkstra's algorithm
class Solution(object):
    def minCost(self, maxTime, edges, passingFees):
        """
        :type maxTime: int
        :type edges: List[List[int]]
        :type passingFees: List[int]
        :rtype: int
        """        
        adj = [[] for i in xrange(len(passingFees))]
        for u, v, w in edges:
            adj[u].append((v, w))
            adj[v].append((u, w))
        best = collections.defaultdict(lambda:float("inf"))
        best[0] = 0
        min_heap = [(passingFees[0], 0, 0)]
        while min_heap:
            result, u, w = heapq.heappop(min_heap)
            if w &gt; maxTime:  # state with best[u] &lt; w can't be filtered, which may have less cost
                continue
            if u == len(passingFees)-1:
                return result
            for v, nw in adj[u]:
                if w+nw &lt; best[v]:  # from less cost to more cost, only need to check state with less time
                    best[v] = w+nw
                    heapq.heappush(min_heap, (result+passingFees[v], v, w+nw))
        return -1

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 2039 - https://leetcode.com/problems/the-time-when-the-network-becomes-idle/
Time: O(|E|)  Space: O(|E|)   Medium
.Python/the-time-when-the-network-becomes-idle.py


```python
# Time:  O(|V| + |E|) = O(|E|) since graph is connected, O(|E|) &gt;= O(|V|) 
# Space: O(|V| + |E|) = O(|E|)

class Solution(object):
    def networkBecomesIdle(self, edges, patience):
        """
        :type edges: List[List[int]]
        :type patience: List[int]
        :rtype: int
        """
        adj = [[] for _ in xrange(len(patience))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        q = [0]
        lookup = [False]*len(patience)
        lookup[0] = True
        step = 1
        result = 0
        while q:
            new_q = []
            for u in q:
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    lookup[v] = True
                    new_q.append(v)
                    result = max(result, ((step*2)-1)//patience[v]*patience[v] + (step*2))
            q = new_q
            step += 1
        return 1+result

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 2045 - https://leetcode.com/problems/second-minimum-time-to-reach-destination/
Time: O(|E|)  Space: O(|E|)   Hard
.Python/second-minimum-time-to-reach-destination.py


```python
# Time:  O(|V| + |E|) = O(|E|) since graph is connected, O(|E|) &gt;= O(|V|) 
# Space: O(|V| + |E|) = O(|E|)

class Solution(object):
    def secondMinimum(self, n, edges, time, change):
        """
        :type n: int
        :type edges: List[List[int]]
        :type time: int
        :type change: int
        :rtype: int
        """
        # Template:
        # https://github.com/kamyu104/LeetCode-Solutions/blob/master/Python/find-if-path-exists-in-graph.py
        def bi_bfs(adj, start, target):
            left, right = {start}, {target}
            lookup = set()
            result = steps = 0
            while left and (not result or result+2 &gt; steps):  # modified
                for u in left:
                    lookup.add(u)
                new_left = set()
                for u in left: 
                    if u in right:
                        if not result:  # modified
                            result = steps
                        elif result &lt; steps:  # modifeid
                            return result+1
                    for v in adj[u]:
                        if v in lookup:
                            continue
                        new_left.add(v)
                left = new_left
                steps += 1
                if len(left) &gt; len(right): 
                    left, right = right, left
            return result+2  # modified

        def calc_time(time, change, dist):
            result = 0
            for _ in xrange(dist):
                if result//change%2:
                    result = (result//change+1)*change
                result += time
            return result

        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        return calc_time(time, change, bi_bfs(adj, 0, n-1))


# Time:  O(|V| + |E|) = O(|E|) since graph is connected, O(|E|) &gt;= O(|V|) 
# Space: O(|V| + |E|) = O(|E|)
class Solution2(object):
    def secondMinimum(self, n, edges, time, change):
        """
        :type n: int
        :type edges: List[List[int]]
        :type time: int
        :type change: int
        :rtype: int
        """
        INF = float("inf")
        def bfs(adj, start):
            q = [start]
            dist = [INF]*len(adj)
            dist[start] = 0
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if dist[v] != INF:
                            continue
                        dist[v] = dist[u]+1
                        new_q.append(v)
                q = new_q
            return dist

        def calc_time(time, change, dist):
            result = 0
            for _ in xrange(dist):
                if result//change%2:
                    result = (result//change+1)*change
                result += time
            return result

        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u-1].append(v-1)
            adj[v-1].append(u-1)
        dist_to_end, dist_to_start = bfs(adj, 0), bfs(adj, n-1)

        dist = dist_to_end[n-1]+2  # always exists
        for i in xrange(n):  # case of detour
            if dist_to_end[i]+dist_to_start[i] == dist_to_end[n-1]:
                continue
            dist = min(dist, dist_to_end[i]+dist_to_start[i])  # find second min
            if dist == dist_to_end[n-1]+1:
                break
        return calc_time(time, change, dist)

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 2050 - https://leetcode.com/problems/parallel-courses-iii/
Time: O(|V| + |E|)  Space: O(|E|)   Hard
.Python/parallel-courses-iii.py


```python
# Time:  O(|V| + |E|)
# Space: O(|E|)

class Solution(object):
    def minimumTime(self, n, relations, time):
        """
        :type n: int
        :type relations: List[List[int]]
        :type time: List[int]
        :rtype: int
        """
        adj = [[] for _ in xrange(n)]
        in_degree = [0]*n
        for prev, nxt in relations:
            adj[prev-1].append(nxt-1)
            in_degree[nxt-1] += 1
        q = [u for u in xrange(n) if not in_degree[u]]
        dist = [time[u] if not in_degree[u] else 0 for u in xrange(n)] 
        while q:
            new_q = []
            for u in q:
                for v in adj[u]:
                    dist[v] = max(dist[v], dist[u]+time[v])
                    in_degree[v] -= 1
                    if not in_degree[v]:
                        new_q.append(v)
            q = new_q
        return max(dist)

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 2059 - https://leetcode.com/problems/minimum-operations-to-convert-number/
Time: O(m * n)  Space: O(m)   Medium
.Python/minimum-operations-to-convert-number.py


```python
# Time:  O(n * m), m is max x
# Space: O(m)

class Solution(object):
    def minimumOperations(self, nums, start, goal):
        """
        :type nums: List[int]
        :type start: int
        :type goal: int
        :rtype: int
        """
        MAX_X = 1000
        nums = [y for y in nums if y and any(0 &lt;= nx &lt;= MAX_X for nx in (y, goal-y, goal+y, goal^y))]
        q = [(start, 0)]
        lookup = {start}
        while q:
            new_q = []
            for x, steps in q:
                for y in nums:
                    for nx in (x+y, x-y, x^y):
                        if nx == goal:
                            return steps+1
                        if not (0 &lt;= nx &lt;= MAX_X) or nx in lookup:
                            continue
                        lookup.add(nx)
                        q.append((nx, steps+1))
            q = new_q
        return -1

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 2115 - https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/
Time: O(|E|)  Space: O(|E|)   Medium
.Python/find-all-possible-recipes-from-given-supplies.py


```python
# Time:  O(|E|)
# Space: O(|E|)

import collections
import itertools

class Solution(object):
    def findAllRecipes(self, recipes, ingredients, supplies):
        """
        :type recipes: List[str]
        :type ingredients: List[List[str]]
        :type supplies: List[str]
        :rtype: List[str]
        """
        indegree = collections.defaultdict(int)
        adj = collections.defaultdict(list)
        for r, ingredient in itertools.izip(recipes, ingredients): 
            indegree[r] = len(ingredient)
            for ing in ingredient:
                adj[ing].append(r)
        result = []
        recipes = set(recipes)
        q = supplies
        while q: 
            new_q = []
            for u in q:
                if u in recipes:
                    result.append(u)
                for v in adj[u]:
                    indegree[v] -= 1
                    if not indegree[v]:
                        new_q.append(v)
            q = new_q
        return result

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 2146 - https://leetcode.com/problems/k-highest-ranked-items-within-a-price-range/
Time: O(m * n + klogk)  Space: O(m * n)   Medium
.Python/k-highest-ranked-items-within-a-price-range.py


```python
# Time:  O(m * n + klogk)
# Space: O(m * n)

import random


# bfs, quick select
class Solution(object):
    def highestRankedKItems(self, grid, pricing, start, k):
        """
        :type grid: List[List[int]]
        :type pricing: List[int]
        :type start: List[int]
        :type k: int
        :rtype: List[List[int]]
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def nth_element(nums, n, left=0, compare=lambda a, b: a &lt; b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid &lt;= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            right = len(nums)-1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left &lt;= n &lt;= pivot_right:
                    return
                elif pivot_left &gt; n:
                    right = pivot_left-1
                else:  # pivot_right &lt; n.
                    left = pivot_right+1

        def get_val(x):
            return (lookup[x[0]][x[1]], grid[x[0]][x[1]], x[0], x[1])
    
        result = []
        q = [start]
        lookup = [[-1]*len(grid[0]) for _ in xrange(len(grid))]
        d = lookup[start[0]][start[1]] = 0
        while q:
            if len(result) &gt;= k:
                if len(result) &gt; k:
                    nth_element(result, k-1, compare=lambda a, b: get_val(a) &lt; get_val(b))
                    result = result[:k]
                break
            new_q = []
            for r, c in q:
                if pricing[0] &lt;= grid[r][c] &lt;= pricing[1]:
                    result.append([r, c])
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 &lt;= nr &lt; len(grid) and 0 &lt;= nc &lt; len(grid[0]) and grid[nr][nc] and lookup[nr][nc] == -1):
                        continue
                    lookup[nr][nc] = d+1
                    new_q.append((nr, nc))
            q = new_q
            d += 1
        result.sort(key=lambda x: get_val(x))
        return result

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 2258 - https://leetcode.com/problems/escape-the-spreading-fire/
Time: O(m * n)  Space: O(m * n)   Hard
.Python/escape-the-spreading-fire.py


```python
# Time:  O(m * n)
# Space: O(m * n)

import collections


# bfs
class Solution(object):
    def maximumMinutes(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        GRASS, FIRE, WALL, PERSON = range(4)
        INF = 10**9
        def bfs(grid):
            time = collections.defaultdict(int)
            d = 0
            q = [(r, c, FIRE) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c] == FIRE]
            q.append((0, 0, PERSON))
            while q:
                new_q = []
                for r, c, t in q:
                    for dr, dc in DIRECTIONS:
                        nr, nc = r+dr, c+dc
                        if not (0 &lt;= nr &lt; len(grid) and 0 &lt;= nc &lt; len(grid[0]) and
                                grid[nr][nc] != WALL and
                                ((t == FIRE and grid[nr][nc] != FIRE) or
                                 (t == PERSON and (grid[nr][nc] == GRASS or (grid[nr][nc] == FIRE and (nr, nc) == (len(grid)-1, len(grid[0])-1) and d+1 == time[FIRE, nr, nc]))))):
                            continue
                        if grid[nr][nc] != FIRE:
                            grid[nr][nc] = t
                        if (nr, nc) in ((len(grid)-1, len(grid[0])-1), (len(grid)-1, len(grid[0])-2), (len(grid)-2, len(grid[0])-1)):
                            time[t, nr, nc] = d+1
                        new_q.append((nr, nc, t))
                q = new_q
                d += 1
            return time

        time = bfs(grid)
        if not time[PERSON, len(grid)-1, len(grid[0])-1]:
            return -1
        if not time[FIRE, len(grid)-1, len(grid[0])-1]:
            return INF
        diff = time[FIRE, len(grid)-1, len(grid[0])-1]-time[PERSON, len(grid)-1, len(grid[0])-1]
        return diff if diff+2 in (time[FIRE, len(grid)-1, len(grid[0])-2]-time[PERSON, len(grid)-1, len(grid[0])-2],
                                  time[FIRE, len(grid)-2, len(grid[0])-1]-time[PERSON, len(grid)-2, len(grid[0])-1]) else diff-1


# Time:  O(m * n)
# Space: O(m * n)
# bfs
class Solution2(object):
    def maximumMinutes(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        FIRE, WALL, PERSON = range(1, 4)
        INF = 10**9
        def bfs(grid):
            time = {FIRE:[[INF]*len(grid[0]) for _ in xrange(len(grid))],
                    PERSON:[[INF]*len(grid[0]) for _ in xrange(len(grid))]}
            d = 0
            q = [(r, c, FIRE) for r in xrange(len(grid)) for c in xrange(len(grid[0])) if grid[r][c] == FIRE]
            q.append((0, 0, PERSON))
            for r, c, t in q:
                time[t][r][c] = d
            while q:
                new_q = []
                for r, c, t in q:
                    for dr, dc in DIRECTIONS:
                        nr, nc = r+dr, c+dc
                        if not (0 &lt;= nr &lt; len(grid) and 0 &lt;= nc &lt; len(grid[0]) and
                                grid[nr][nc] != WALL and time[t][nr][nc] == INF and
                                (t == FIRE or
                                 d+1 &lt; time[FIRE][nr][nc] or (d+1 == time[FIRE][nr][nc] and (nr, nc) == (len(grid)-1, len(grid[0])-1)))):
                            continue
                        time[t][nr][nc] = d+1
                        new_q.append((nr, nc, t))
                q = new_q
                d += 1
            return time

        time = bfs(grid)
        if time[PERSON][-1][-1] == INF:
            return -1
        if time[FIRE][-1][-1] == INF:
            return INF
        diff = time[FIRE][-1][-1]-time[PERSON][-1][-1]
        return diff if diff+2 in (time[FIRE][-1][-2]-time[PERSON][-1][-2], time[FIRE][-2][-1]-time[PERSON][-2][-1]) else diff-1

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 2290 - https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/
Time: O(m * n)  Space: O(m * n)   Hard
.Python/minimum-obstacle-removal-to-reach-corner.py


```python
# Time:  O(m * n)
# Space: O(m * n)

# A* Search Algorithm without heap
class Solution(object):
    def minimumObstacles(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        def a_star(grid, b, t):
            f, dh = 0, 1
            closer, detour = [b], []
            lookup = [[False]*len(grid[0]) for _ in xrange(len(grid))]
            while closer or detour:
                if not closer:
                    f += dh
                    closer, detour = detour, closer
                b = closer.pop()
                if b == t:
                    return f
                if lookup[b[0]][b[1]]:
                    continue
                lookup[b[0]][b[1]] = True
                for dr, dc in directions:
                    nb = (b[0]+dr, b[1]+dc)
                    if not (0 &lt;= nb[0] &lt; len(grid) and 0 &lt;= nb[1] &lt; len(grid[0]) and not lookup[nb[0]][nb[1]]):
                        continue
                    (closer if not grid[b[0]][b[1]] else detour).append(nb)
            return -1

        return a_star(grid, (0, 0), (len(grid)-1, len(grid[0])-1))


# Time:  O(m * n)
# Space: O(m * n)
import collections


# 0-1 bfs solution
class Solution2(object):
    def minimumObstacles(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
        b, t = (0, 0), (len(grid)-1, len(grid[0])-1)
        dq = collections.deque([(b, 0)])
        lookup = [[False]*len(grid[0]) for _ in xrange(len(grid))]
        while dq:
            b, d = dq.popleft()
            if b == t:
                return d
            if lookup[b[0]][b[1]]:
                continue
            lookup[b[0]][b[1]] = True
            for dr, dc in directions:
                nb = (b[0]+dr, b[1]+dc)
                if not (0 &lt;= nb[0] &lt; len(grid) and 0 &lt;= nb[1] &lt; len(grid[0]) and not lookup[nb[0]][nb[1]]):
                    continue
                if not grid[b[0]][b[1]]:
                    dq.appendleft((nb, d))
                else:
                    dq.append((nb, d+1))
        return -1  # never reach here

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 2316 - https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/
Time: O(n)  Space: O(n)   Medium
.Python/count-unreachable-pairs-of-nodes-in-an-undirected-graph.py


```python
# Time:  O(n)
# Space: O(n)

# flood fill, bfs, math
class Solution(object):
    def countPairs(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        def bfs(adj, u, lookup):
            q = [u]
            lookup[u] = 1
            result = 1
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = 1
                        result += 1
                        new_q.append(v)
                q = new_q
            return result
        
        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        lookup = [0]*n
        result = 0
        for u in xrange(n):
            if lookup[u]:
                continue
            cnt = bfs(adj, u, lookup)
            result += cnt*(n-cnt)
            n -= cnt
        return result

```



----------------------------------------------------------------------------------------

### Breadth-First Search - 2368 - https://leetcode.com/problems/reachable-nodes-with-restrictions/
Time: O(n)  Space: O(n)   Medium
.Python/reachable-nodes-with-restrictions.py


```python
# Time:  O(n)
# Space: O(n)

# bfs
class Solution(object):
    def reachableNodes(self, n, edges, restricted):
        """
        :type n: int
        :type edges: List[List[int]]
        :type restricted: List[int]
        :rtype: int
        """
        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = 0
        lookup = [False]*n
        for x in restricted:
            lookup[x] = True
        q = [0]
        lookup[0] = True
        while q:
            new_q = []
            for u in q:
                result += 1
                for v in adj[u]:
                    if lookup[v]:
                        continue
                    lookup[v] = True
                    new_q.append(v)
            q = new_q
        return result

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1020 - https://leetcode.com/problems/number-of-enclaves/
Time: O(m * n)  Space: O(m * n)   Medium
.Python/number-of-enclaves.py


```python
# Time:  O(m * n)
# Space: O(m * n)

class Solution(object):
    def numEnclaves(self, A):
        """
        :type A: List[List[int]]
        :rtype: int
        """
        directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]
        def dfs(A, i, j):
            if not (0 &lt;= i &lt; len(A) and 0 &lt;= j &lt; len(A[0]) and A[i][j]):
                return
            A[i][j] = 0
            for d in directions:
                dfs(A, i+d[0], j+d[1])
        
        for i in xrange(len(A)):
            dfs(A, i, 0)
            dfs(A, i, len(A[0])-1)
        for j in xrange(1, len(A[0])-1):
            dfs(A, 0, j)
            dfs(A, len(A)-1, j)
        return sum(sum(row) for row in A)

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1059 - https://leetcode.com/problems/all-paths-from-source-lead-to-destination/
Time: O(n + e)  Space: O(n + e)   Medium
.Python/all-paths-from-source-lead-to-destination.py


```python
# Time:  O(n + e)
# Space: O(n + e)

import collections


class Solution(object):
    def leadsToDestination(self, n, edges, source, destination):
        """
        :type n: int
        :type edges: List[List[int]]
        :type source: int
        :type destination: int
        :rtype: bool
        """
        UNVISITED, VISITING, DONE = range(3)
        def dfs(children, node, destination, status):
            if status[node] == DONE:
                return True
            if status[node] == VISITING:
                return False
            status[node] = VISITING
            if node not in children and node != destination:
                return False
            if node in children:
                for child in children[node]:
                    if not dfs(children, child, destination, status):
                        return False
            status[node] = DONE
            return True
        
        children = collections.defaultdict(list)
        for parent, child in edges:
            children[parent].append(child)
        return dfs(children, source, destination, [0]*n)

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1192 - https://leetcode.com/problems/critical-connections-in-a-network/
Time: O(|V| + |E|)  Space: O(|V| + |E|)   Hard
.Python/critical-connections-in-a-network.py


```python
# Time:  O(|V| + |E|)
# Space: O(|V| + |E|)

# variant of Tarjan's algorithm (https://www.geeksforgeeks.org/bridge-in-a-graph/)
class Solution(object):
    def criticalConnections(self, n, connections):
        """
        :type n: int
        :type connections: List[List[int]]
        :rtype: List[List[int]]
        """
        def dfs(edges, parent, u, idx, lowlinks, lookup, result):
            if lookup[u]:
                return  
            lookup[u] = True
            curr_idx = lowlinks[u] = idx[0]
            idx[0] += 1
            for v in edges[u]:
                if v == parent:
                    continue
                dfs(edges, u, v, idx, lowlinks, lookup, result)
                lowlinks[u] = min(lowlinks[u], lowlinks[v])
                if lowlinks[v] &gt; curr_idx:
                    # if any lowlink of neighbors is larger than curr_idx
                    result.append([u, v])
        
        edges = [[] for _ in xrange(n)]
        idx, lowlinks, lookup = [0], [0]*n, [False]*n
        result = []
        for u, v in connections:
            edges[u].append(v)
            edges[v].append(u)
        dfs(edges, -1, 0, idx, lowlinks, lookup, result)
        return result

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1202 - https://leetcode.com/problems/smallest-string-with-swaps/
Time: O(nlogn)  Space: O(n)   Medium
.Python/smallest-string-with-swaps.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class UnionFind(object):
    def __init__(self, n):
        self.set = range(n)

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        return True


class Solution(object):
    def smallestStringWithSwaps(self, s, pairs):
        """
        :type s: str
        :type pairs: List[List[int]]
        :rtype: str
        """
        union_find = UnionFind(len(s))
        for x,y in pairs: 
            union_find.union_set(x, y)
        components = collections.defaultdict(list)
        for i in xrange(len(s)): 
            components[union_find.find_set(i)].append(s[i])
        for i in components.iterkeys(): 
            components[i].sort(reverse=True)
        result = []
        for i in xrange(len(s)): 
            result.append(components[union_find.find_set(i)].pop())
        return "".join(result)


# Time:  O(nlogn)
# Space: O(n)
import itertools
class Solution2(object):
    def smallestStringWithSwaps(self, s, pairs):
        """
        :type s: str
        :type pairs: List[List[int]]
        :rtype: str
        """
        def dfs(i, adj, lookup, component):
            lookup.add(i)
            component.append(i)
            for j in adj[i]:
                if j in lookup:
                    continue
                dfs(j, adj, lookup, component)
            
        adj = collections.defaultdict(list)
        for i, j in pairs:
            adj[i].append(j)
            adj[j].append(i)
        lookup = set()
        result = list(s)
        for i in xrange(len(s)):
            if i in lookup:
                continue
            component = []
            dfs(i, adj, lookup, component)
            component.sort()
            chars = sorted(result[k] for k in component)
            for comp, char in itertools.izip(component, chars):
                result[comp] = char
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1254 - https://leetcode.com/problems/number-of-closed-islands/
Time: O(m * n)  Space: O(1)   Medium
.Python/number-of-closed-islands.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def closedIsland(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def fill(grid, i, j):
            if not (0 &lt;= i &lt; len(grid) and 
                    0 &lt;= j &lt; len(grid[0]) and 
                    grid[i][j] == 0):
                return False
            grid[i][j] = 1
            for dx, dy in directions:
                fill(grid, i+dx, j+dy)
            return True

        for j in xrange(len(grid[0])):
            fill(grid, 0, j)
            fill(grid, len(grid)-1, j)
        for i in xrange(1, len(grid)):
            fill(grid, i, 0)
            fill(grid, i, len(grid[0])-1)
        result = 0
        for i in xrange(1, len(grid)-1):
            for j in xrange(1, len(grid[0])-1):
                if fill(grid, i, j):
                    result += 1
        return result

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1273 - https://leetcode.com/problems/delete-tree-nodes/
Time: O(n)  Space: O(n)   Medium
.Python/delete-tree-nodes.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def deleteTreeNodes(self, nodes, parent, value):
        """
        :type nodes: int
        :type parent: List[int]
        :type value: List[int]
        :rtype: int
        """
        def dfs(value, children, x):
            total, count = value[x], 1
            for y in children[x]:
                t, c = dfs(value, children, y)
                total += t
                count += c if t else 0
            return total, count if total else 0

        children = collections.defaultdict(list)
        for i, p in enumerate(parent):
            if i:
                children[p].append(i)
        return dfs(value, children, 0)[1]


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def deleteTreeNodes(self, nodes, parent, value):
        """
        :type nodes: int
        :type parent: List[int]
        :type value: List[int]
        :rtype: int
        """
        # assuming parent[i] &lt; i for all i &gt; 0
        result = [1]*nodes
        for i in reversed(xrange(1, nodes)):
            value[parent[i]] += value[i]
            result[parent[i]] += result[i] if value[i] else 0
        return result[0]

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1315 - https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/
Time: O(n)  Space: O(h)   Medium
.Python/sum-of-nodes-with-even-valued-grandparent.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def sumEvenGrandparent(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def sumEvenGrandparentHelper(root, p, gp):
            return sumEvenGrandparentHelper(root.left, root.val, p) + \
                   sumEvenGrandparentHelper(root.right, root.val, p) + \
                   (root.val if gp is not None and gp % 2 == 0 else 0) if root else 0

        return sumEvenGrandparentHelper(root, None, None)

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1319 - https://leetcode.com/problems/number-of-operations-to-make-network-connected/
Time: O(|E| + |V|)  Space: O(|V|)   Medium
.Python/number-of-operations-to-make-network-connected.py


```python
# Time:  O(|E| + |V|)
# Space: O(|V|)

class UnionFind(object):
    def __init__(self, n):
        self.set = range(n)
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def makeConnected(self, n, connections):
        """
        :type n: int
        :type connections: List[List[int]]
        :rtype: int
        """
        if len(connections) &lt; n-1:
            return -1
        union_find = UnionFind(n)
        for i, j in connections:
            union_find.union_set(i, j)
        return union_find.count - 1


# Time:  O(|E| + |V|)
# Space: O(|V|)
import collections


class Solution2(object):
    def makeConnected(self, n, connections):
        """
        :type n: int
        :type connections: List[List[int]]
        :rtype: int
        """
        def dfs(i, lookup):
            if i in lookup:
                return 0
            lookup.add(i)
            if i in G:
                for j in G[i]:
                    dfs(j, lookup)
            return 1

        if len(connections) &lt; n-1:
            return -1
        G = collections.defaultdict(list)
        for i, j in connections:
            G[i].append(j)
            G[j].append(i)
        lookup = set()
        return sum(dfs(i, lookup) for i in xrange(n)) - 1

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1367 - https://leetcode.com/problems/linked-list-in-binary-tree/
Time: O(n + l)  Space: O(h + l)   Medium
.Python/linked-list-in-binary-tree.py


```python
# Time:  O(n + l)
# Space: O(h + l)

# Definition for singly-linked list.
class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None


# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


# kmp solution
class Solution(object):
    def isSubPath(self, head, root):
        """
        :type head: ListNode
        :type root: TreeNode
        :rtype: bool
        """
        def getPrefix(head):
            pattern, prefix = [head.val], [-1]
            j = -1
            node = head.next
            while node:
                while j+1 and pattern[j+1] != node.val:
                    j = prefix[j]
                if pattern[j+1] == node.val:
                    j += 1
                pattern.append(node.val)
                prefix.append(j)
                node = node.next
            return pattern, prefix
            
        def dfs(pattern, prefix, root, j):
            if not root:
                return False
            while j+1 and pattern[j+1] != root.val:
                j = prefix[j]
            if pattern[j+1] == root.val:
                j += 1
            if j+1 == len(pattern):
                return True
            return dfs(pattern, prefix, root.left, j) or \
                   dfs(pattern, prefix, root.right, j)
        
        if not head:
            return True
        pattern, prefix = getPrefix(head)
        return dfs(pattern, prefix, root, -1)
    

# Time:  O(n * min(h, l))
# Space: O(h)
# dfs solution
class Solution2(object):
    def isSubPath(self, head, root):
        """
        :type head: ListNode
        :type root: TreeNode
        :rtype: bool
        """
        def dfs(head, root):
            if not head:
                return True
            if not root:
                return False
            return root.val == head.val and \
                   (dfs(head.next, root.left) or 
                    dfs(head.next, root.right))
    
        if not head:
            return True
        if not root:
            return False
        return dfs(head, root) or \
               self.isSubPath(head, root.left) or \
               self.isSubPath(head, root.right)

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1372 - https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/
Time: O(n)  Space: O(h)   Medium
.Python/longest-zigzag-path-in-a-binary-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def longestZigZag(self, root):
        """
        :type root: TreeNode
        :rtype: int
        """
        def dfs(node, result):
            if not node:
                return [-1, -1]
            left, right = dfs(node.left, result), dfs(node.right, result)
            result[0] = max(result[0], left[1]+1, right[0]+1)
            return [left[1]+1, right[0]+1]

        result = [0]
        dfs(root, result)
        return result[0]

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1376 - https://leetcode.com/problems/time-needed-to-inform-all-employees/
Time: O(n)  Space: O(n)   Medium
.Python/time-needed-to-inform-all-employees.py


```python
# Time:  O(n)
# Space: O(n)

import collections


# dfs solution with stack
class Solution(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        """
        :type n: int
        :type headID: int
        :type manager: List[int]
        :type informTime: List[int]
        :rtype: int
        """
        children = collections.defaultdict(list)
        for child, parent in enumerate(manager):
            if parent != -1:
                children[parent].append(child)

        result = 0
        stk = [(headID, 0)]
        while stk:
            node, curr = stk.pop()
            curr += informTime[node]
            result = max(result, curr)
            if node not in children:
                continue
            for c in children[node]:
                stk.append((c, curr))
        return result

    
# Time:  O(n)
# Space: O(n)
# dfs solution with recursion
class Solution2(object):
    def numOfMinutes(self, n, headID, manager, informTime):
        """
        :type n: int
        :type headID: int
        :type manager: List[int]
        :type informTime: List[int]
        :rtype: int
        """
        def dfs(informTime, children, node):
            return (max(dfs(informTime, children, c)
                        for c in children[node])
                    if node in children
                    else 0) + informTime[node]

        children = collections.defaultdict(list)
        for child, parent in enumerate(manager):
            if parent != -1:
                children[parent].append(child)
        return dfs(informTime, children, headID)

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1377 - https://leetcode.com/problems/frog-position-after-t-seconds/
Time: O(n)  Space: O(n)   Hard
.Python/frog-position-after-t-seconds.py


```python
# Time:  O(n)
# Space: O(n)

import collections


# bfs solution with better precision
class Solution(object):
    def frogPosition(self, n, edges, t, target):
        """
        :type n: int
        :type edges: List[List[int]]
        :type t: int
        :type target: int
        :rtype: float
        """                
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)

        stk = [(t, 1, 0, 1)]
        while stk:
            new_stk = []
            while stk:
                t, node, parent, choices = stk.pop()
                if not t or not (len(G[node])-(parent != 0)):
                    if node == target:
                        return 1.0/choices
                    continue
                for child in G[node]:
                    if child == parent:
                        continue
                    new_stk.append((t-1, child, node,
                                    choices*(len(G[node])-(parent != 0))))
            stk = new_stk
        return 0.0


# Time:  O(n)
# Space: O(n)
# dfs solution with stack with better precision
class Solution2(object):
    def frogPosition(self, n, edges, t, target):
        """
        :type n: int
        :type edges: List[List[int]]
        :type t: int
        :type target: int
        :rtype: float
        """                
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)

        stk = [(t, 1, 0, 1)]
        while stk:
            t, node, parent, choices = stk.pop()
            if not t or not (len(G[node])-(parent != 0)):
                if node == target:
                    return 1.0/choices
                continue
            for child in G[node]:
                if child == parent:
                    continue
                stk.append((t-1, child, node,
                            choices*(len(G[node])-(parent != 0))))
        return 0.0


# Time:  O(n)
# Space: O(n)
# dfs solution with recursion with better precision
class Solution3(object):
    def frogPosition(self, n, edges, t, target):
        """
        :type n: int
        :type edges: List[List[int]]
        :type t: int
        :type target: int
        :rtype: float
        """        
        def dfs(G, target, t, node, parent):
            if not t or not (len(G[node])-(parent != 0)):
                return int(node == target)
            result = 0
            for child in G[node]:
                if child == parent:
                    continue
                result = dfs(G, target, t-1, child, node)
                if result:
                    break
            return result*(len(G[node])-(parent != 0))
        
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)
        choices = dfs(G, target, t, 1, 0)
        return 1.0/choices if choices else 0.0


# Time:  O(n)
# Space: O(n)
# dfs solution with recursion
class Solution4(object):
    def frogPosition(self, n, edges, t, target):
        """
        :type n: int
        :type edges: List[List[int]]
        :type t: int
        :type target: int
        :rtype: float
        """        
        def dfs(G, target, t, node, parent):
            if not t or not (len(G[node])-(parent != 0)):
                return float(node == target)
            for child in G[node]:
                if child == parent:
                    continue
                result = dfs(G, target, t-1, child, node)
                if result:
                    break
            return result/(len(G[node])-(parent != 0))
        
        G = collections.defaultdict(list)
        for u, v in edges:
            G[u].append(v)
            G[v].append(u)
        return dfs(G, target, t, 1, 0)

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1391 - https://leetcode.com/problems/check-if-there-is-a-valid-path-in-a-grid/
Time: O(m * n)  Space: O(1)   Medium
.Python/check-if-there-is-a-valid-path-in-a-grid.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def hasValidPath(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: bool
        """
        E, S, W, N = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        directions = [
            [W, E], [N, S],
            [W, S], [S, E],
            [W, N], [N, E]
        ]

        for r, c in directions[grid[0][0]-1]:
            if not (0 &lt;= r &lt; len(grid) and 0 &lt;= c &lt; len(grid[0])):
                continue
            pr, pc = 0, 0
            while r != len(grid)-1 or c != len(grid[0])-1:
                for dx, dy in directions[grid[r][c]-1]:
                    nr, nc = r+dx, c+dy
                    if (nr == pr and nc == pc) or \
                       not(0 &lt;= nr &lt; len(grid) and 0 &lt;= nc &lt; len(grid[0])) or \
                       (-dx, -dy) not in directions[grid[nr][nc]-1]:
                        continue
                    pr, pc, r, c = r, c, nr, nc
                    break
                else:
                    return False
            return True
        return len(grid) == len(grid[0]) == 1

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1466 - https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/
Time: O(n)  Space: O(n)   Medium
.Python/reorder-routes-to-make-all-paths-lead-to-the-city-zero.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def minReorder(self, n, connections):
        """
        :type n: int
        :type connections: List[List[int]]
        :rtype: int
        """
        lookup, graph = set(), collections.defaultdict(list)
        for u, v in connections:
            lookup.add(u*n+v)
            graph[v].append(u)
            graph[u].append(v) 
        result = 0
        stk = [(-1, 0)]
        while stk:
            parent, u = stk.pop()
            result += (parent*n+u in lookup)
            for v in reversed(graph[u]):
                if v == parent:
                    continue
                stk.append((u, v))
        return result


# Time:  O(n)
# Space: O(n)
import collections


class Solution2(object):
    def minReorder(self, n, connections):
        """
        :type n: int
        :type connections: List[List[int]]
        :rtype: int
        """
        def dfs(n, lookup, graph, parent, u):
            result = (parent*n+u in lookup)
            for v in graph[u]:
                if v == parent:
                    continue
                result += dfs(n, lookup, graph, u, v)  
            return result

        lookup, graph = set(), collections.defaultdict(list)
        for u, v in connections:
            lookup.add(u*n+v)
            graph[v].append(u)
            graph[u].append(v) 
        return dfs(n, lookup, graph, -1, 0)

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1485 - https://leetcode.com/problems/clone-binary-tree-with-random-pointer/
Time: O(n)  Space: O(h)   Medium
.Python/clone-binary-tree-with-random-pointer.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for Node.
class Node(object):
    def __init__(self, val=0, left=None, right=None, random=None):
        self.val = val
        self.left = left
        self.right = right
        self.random = random


# Definition for NodeCopy.
class NodeCopy(object):
    def __init__(self, val=0, left=None, right=None, random=None):
        pass


class Solution(object):
    def copyRandomBinaryTree(self, root):
        """
        :type root: Node
        :rtype: NodeCopy
        """
        def iter_dfs(node, callback):
            result = None
            stk = [node]
            while stk:
                node = stk.pop()
                if not node:
                    continue
                left_node, copy = callback(node)
                if not result:
                    result = copy
                stk.append(node.right)
                stk.append(left_node)
            return result
    
        def merge(node):
            copy = NodeCopy(node.val)
            node.left, copy.left = copy, node.left
            return copy.left, copy
        
        def clone(node):
            copy = node.left
            node.left.random = node.random.left if node.random else None
            node.left.right = node.right.left if node.right else None
            return copy.left, copy
        
        def split(node):
            copy = node.left
            node.left, copy.left = copy.left, copy.left.left if copy.left else None
            return node.left, copy
    
        iter_dfs(root, merge)
        iter_dfs(root, clone)
        return iter_dfs(root, split)


# Time:  O(n)
# Space: O(h)
class Solution_Recu(object):
    def copyRandomBinaryTree(self, root):
        """
        :type root: Node
        :rtype: NodeCopy
        """
        def dfs(node, callback):
            if not node:
                return None
            left_node, copy = callback(node)
            dfs(left_node, callback)
            dfs(node.right, callback) 
            return copy
    
        def merge(node):
            copy = NodeCopy(node.val)
            node.left, copy.left = copy, node.left
            return copy.left, copy
        
        def clone(node):
            copy = node.left
            node.left.random = node.random.left if node.random else None
            node.left.right = node.right.left if node.right else None
            return copy.left, copy
        
        def split(node):
            copy = node.left
            node.left, copy.left = copy.left, copy.left.left if copy.left else None
            return node.left, copy
    
        dfs(root, merge)
        dfs(root, clone)
        return dfs(root, split)


# Time:  O(n)
# Space: O(n)
import collections


class Solution2(object):
    def copyRandomBinaryTree(self, root):
        """
        :type root: Node
        :rtype: NodeCopy
        """ 
        lookup = collections.defaultdict(lambda: NodeCopy())
        lookup[None] = None
        stk = [root]
        while stk:
            node = stk.pop()
            if not node:
                continue
            lookup[node].val = node.val
            lookup[node].left = lookup[node.left]
            lookup[node].right = lookup[node.right]
            lookup[node].random = lookup[node.random]
            stk.append(node.right)
            stk.append(node.left)
        return lookup[root]


# Time:  O(n)
# Space: O(n)
import collections


class Solution2_Recu(object):
    def copyRandomBinaryTree(self, root):
        """
        :type root: Node
        :rtype: NodeCopy
        """ 
        def dfs(node, lookup):
            if not node:
                return
            lookup[node].val = node.val
            lookup[node].left = lookup[node.left]
            lookup[node].right = lookup[node.right]
            lookup[node].random = lookup[node.random]
            dfs(node.left, lookup)
            dfs(node.right, lookup)
    
        lookup = collections.defaultdict(lambda: NodeCopy())
        lookup[None] = None
        dfs(root, lookup)
        return lookup[root]

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1644 - https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-ii/
Time: O(n)  Space: O(h)   Medium
.Python/lowest-common-ancestor-of-a-binary-tree-ii.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        pass


class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        def iter_dfs(node, p, q):
            result = None
            stk = [(1, (node, [0]))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    curr = int(node == p or node == q)
                    if curr+ret1[0]+ret2[0] == 2 and not result:
                        result = node
                    ret[0] = curr+ret1[0]+ret2[0]
            return result

        return iter_dfs(root, p, q)


# Time:  O(n)
# Space: O(h)
class Solution2(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """        
        def dfs(node, p, q, result):
            if not node:
                return 0
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            curr = int(node == p or node == q)
            if curr+left+right == 2 and not result[0]:
                result[0] = node
            return curr+left+right

        result = [0]
        dfs(root, p, q, result)
        return result[0]

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1676 - https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree-iv/
Time: O(n)  Space: O(h)   Medium
.Python/lowest-common-ancestor-of-a-binary-tree-iv.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        pass


class Solution(object):
    def lowestCommonAncestor(self, root, nodes):
        """
        :type root: TreeNode
        :type nodes: List[TreeNode]
        """
        def iter_dfs(root, lookup):
            result = [0]
            stk = [(1, (root, result))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node or node in lookup:
                        ret[0] = node
                        continue
                    ret1, ret2 = [None], [None]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    if ret1[0] and ret2[0]:
                        ret[0] = node
                    else:
                        ret[0] = ret1[0] or ret2[0]
            return result[0]
        
        return iter_dfs(root, set(nodes))


# Time:  O(n)
# Space: O(h)
class Solution2(object):
    def lowestCommonAncestor(self, root, nodes):
        """
        :type root: TreeNode
        :type nodes: List[TreeNode]
        """
        def dfs(node, lookup):
            if not node or node in lookup:
                return node
            left, right = dfs(node.left, lookup), dfs(node.right, lookup)
            if left and right:
                return node
            return left or right
        
        return dfs(root, set(nodes))

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1722 - https://leetcode.com/problems/minimize-hamming-distance-after-swap-operations/
Time: O(n)  Space: O(n)   Medium
.Python/minimize-hamming-distance-after-swap-operations.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def minimumHammingDistance(self, source, target, allowedSwaps):
        """
        :type source: List[int]
        :type target: List[int]
        :type allowedSwaps: List[List[int]]
        :rtype: int
        """
        def iter_flood_fill(adj, node, lookup, idxs):
            stk = [node]
            while stk:
                node = stk.pop()
                if node in lookup:
                    continue
                lookup.add(node)
                idxs.append(node)
                for child in adj[node]:
                    stk.append(child)

        adj = [set() for i in xrange(len(source))]
        for i, j in allowedSwaps:
            adj[i].add(j)
            adj[j].add(i)
        result = 0
        lookup = set()
        for i in xrange(len(source)):
            if i in lookup:
                continue
            idxs = []
            iter_flood_fill(adj, i, lookup, idxs)
            source_cnt = collections.Counter([source[i] for i in idxs])
            target_cnt = collections.Counter([target[i] for i in idxs])
            diff = source_cnt-target_cnt
            result += sum(diff.itervalues())
        return result


# Time:  O(n * (n)) ~= O(n)
# Space: O(n)
import collections


class UnionFind(object):  # Time: O(n * (n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        if self.rank[x_root] &lt; self.rank[y_root]:  # union by rank
            self.set[x_root] = y_root
        elif self.rank[x_root] &gt; self.rank[y_root]:
            self.set[y_root] = x_root
        else:
            self.set[y_root] = x_root
            self.rank[x_root] += 1
        return True


class Solution2(object):
    def minimumHammingDistance(self, source, target, allowedSwaps):
        """
        :type source: List[int]
        :type target: List[int]
        :type allowedSwaps: List[List[int]]
        :rtype: int
        """
        uf = UnionFind(len(source))
        for x, y in allowedSwaps: 
            uf.union_set(x, y)
        groups = collections.defaultdict(set)
        for i in xrange(len(source)):
            groups[uf.find_set(i)].add(i)
        result = 0
        for idxs in groups.itervalues():
            source_cnt = collections.Counter([source[i] for i in idxs])
            target_cnt = collections.Counter([target[i] for i in idxs])
            diff = source_cnt-target_cnt
            result += sum(diff.itervalues())
        return result

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1740 - https://leetcode.com/problems/find-distance-in-a-binary-tree/
Time: O(n)  Space: O(h)   Medium
.Python/find-distance-in-a-binary-tree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def findDistance(self, root, p, q):
        """
        :type root: TreeNode
        :type p: int
        :type q: int
        :rtype: int
        """
        def iter_dfs(root, p, q):
            result = 0
            dist = [-1]
            stk = [(1, [root, dist])]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    node, ret = params
                    if not node:
                        continue
                    ret1, ret2 = [-1], [-1]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = params
                    if node.val in (p, q):
                        if ret1[0] == ret2[0] == -1:
                            ret[0] = 0
                        else:
                            result = ret1[0]+1 if ret1[0] != -1 else ret2[0]+1
                    elif ret1[0] != -1 and ret2[0] != -1:
                        result = ret1[0]+ret2[0]+2
                    elif ret1[0] != -1:
                        ret[0] = ret1[0]+1
                    elif ret2[0] != -1:
                        ret[0] = ret2[0]+1
            return result
        
        return iter_dfs(root, p, q)
                    

# Time:  O(n)
# Space: O(h)
class Solution2(object):
    def findDistance(self, root, p, q):
        """
        :type root: TreeNode
        :type p: int
        :type q: int
        :rtype: int
        """
        def dfs(node, p, q, result):
            if not node:
                return -1
            left = dfs(node.left, p, q, result)
            right = dfs(node.right, p, q, result)
            if node.val in (p, q):
                if left == right == -1:
                    return 0
                result[0] = left+1 if left != -1 else right+1
            if left != -1 and right != -1:
                result[0] = left+right+2
            elif left != -1:
                return left+1
            elif right != -1:
                return right+1
            return -1
        
        result = [0]
        dfs(root, p, q, result)
        return result[0]

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1766 - https://leetcode.com/problems/tree-of-coprimes/
Time: O(n)  Space: O(n)   Hard
.Python/tree-of-coprimes.py


```python
# Time:  O(50 * n) = O(n)
# Space: O(n)

import collections
import fractions


class Solution(object):
    def getCoprimes(self, nums, edges):
        """
        :type nums: List[int]
        :type edges: List[List[int]]
        :rtype: List[int]
        """        
        def iter_dfs(nums, adj):
            result = [-1]*len(nums)
            path = collections.defaultdict(list)
            stk = [(1, (-1, 0, 0))]
            while stk:
                step, params = stk.pop()
                if step == 1:
                    prev, node, depth = params
                    stk.append((4, (node,)))
                    stk.append((3, (prev, node, depth)))
                    stk.append((2, (node,)))
                elif step == 2:
                    node = params[0]
                    max_d = -1
                    for x in path.iterkeys():
                        if fractions.gcd(nums[node], x) != 1:
                            continue
                        if path[x][-1][1] &gt; max_d:
                            max_d = path[x][-1][1]
                            result[node] = path[x][-1][0]
                elif step == 3:
                    prev, node, depth = params
                    path[nums[node]].append((node, depth))
                    for nei in adj[node]:
                        if nei == prev:
                            continue
                        stk.append((1, (node, nei, depth+1)))
                elif step == 4:
                    node = params[0]
                    path[nums[node]].pop()
                    if not path[nums[node]]:
                        path.pop(nums[node])
            return result

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return iter_dfs(nums, adj)


# Time:  O(50 * n) = O(n)
# Space: O(n)
import collections
import fractions


class Solution2(object):
    def getCoprimes(self, nums, edges):
        """
        :type nums: List[int]
        :type edges: List[List[int]]
        :rtype: List[int]
        """        
        def dfs(nums, adj, prev, node, depth, path, result):
            max_d = -1
            for x in path.iterkeys():
                if fractions.gcd(nums[node], x) != 1:
                    continue
                if path[x][-1][1] &gt; max_d:
                    max_d = path[x][-1][1]
                    result[node] = path[x][-1][0]
            path[nums[node]].append((node, depth))
            for nei in adj[node]:
                if nei == prev:
                    continue
                dfs(nums, adj, node, nei, depth+1, path, result)
            path[nums[node]].pop()
            if not path[nums[node]]:
                path.pop(nums[node])

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        result = [-1]*len(nums)
        path = collections.defaultdict(list)
        dfs(nums, adj, -1, 0, 0, path, result)
        return result

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1905 - https://leetcode.com/problems/count-sub-islands/
Time: O(m * n)  Space: O(1)   Medium
.Python/count-sub-islands.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def countSubIslands(self, grid1, grid2):
        """
        :type grid1: List[List[int]]
        :type grid2: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def dfs(grid1, grid2, i, j):
            if not (0 &lt;= i &lt; len(grid2) and
                    0 &lt;= j &lt; len(grid2[0]) and
                    grid2[i][j] == 1):
                return 1
            grid2[i][j] = 0
            result = grid1[i][j]
            for di, dj in directions:
                result &amp;= dfs(grid1, grid2, i+di, j+dj)
            return result
            
        return sum(dfs(grid1, grid2, i, j) for i in xrange(len(grid2)) for j in xrange(len(grid2[0])) if grid2[i][j])

```



----------------------------------------------------------------------------------------

### Depth-First Search - 1973 - https://leetcode.com/problems/count-nodes-equal-to-sum-of-descendants/
Time: O(n)  Space: O(h)   Medium
.Python/count-nodes-equal-to-sum-of-descendants.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


class Solution(object):
    def equalToDescendants(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        def iter_dfs(node):
            result = 0
            stk = [(1, [node, [0]])]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, [node, ret1, ret2, ret]))
                    stk.append((1, [node.right, ret2]))
                    stk.append((1, [node.left, ret1]))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    if node.val == ret1[0]+ret2[0]:
                        result += 1
                    ret[0] = ret1[0]+ret2[0]+node.val
            return result

        return iter_dfs(root)


# Time:  O(n)
# Space: O(h)
class Solution2(object):
    def equalToDescendants(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        def dfs(node, result):
            if not node:
                return 0
            total = dfs(node.left, result) + dfs(node.right, result)
            if node.val == total:
                result[0] += 1
            return total+node.val

        result = [0]
        dfs(root, result)
        return result[0]

```



----------------------------------------------------------------------------------------

### Depth-First Search - 2049 - https://leetcode.com/problems/count-nodes-with-the-highest-score/
Time: O(n)  Space: O(n)   Medium
.Python/count-nodes-with-the-highest-score.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def countHighestScoreNodes(self, parents):
        """
        :type parents: List[int]
        :rtype: int
        """
        def iter_dfs(adj):
            result = [0]*2
            stk = [(1, (0, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    i, ret = args
                    cnts = [[0] for _ in xrange(len(adj[i]))]
                    stk.append((2, (cnts, ret)))
                    for j, child in enumerate(adj[i]):
                        stk.append((1, (child, cnts[j])))
                elif step == 2:
                    cnts, ret = args
                    ret[0] = sum(cnt[0] for cnt in cnts)+1
                    score = max((len(adj)-ret[0]), 1)*reduce(lambda x, y: x*y[0], cnts, 1)
                    if score &gt; result[0]:
                        result[:] = [score, 1]
                    elif score == result[0]:
                        result[1] += 1
            return result[1]

        adj = [[] for _ in xrange(len(parents))]  # Space: O(n)
        for i in xrange(1, len(parents)):
            adj[parents[i]].append(i)
        return iter_dfs(adj)


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def countHighestScoreNodes(self, parents):
        """
        :type parents: List[int]
        :rtype: int
        """
        def dfs(adj, i, result):
            cnts = [dfs(adj, child, result) for child in adj[i]]
            total = sum(cnts)+1
            score = max((len(adj)-total), 1)*reduce(lambda x, y: x*y, cnts, 1)
            if score &gt; result[0]:
                result[:] = [score, 1]
            elif score == result[0]:
                result[1] += 1
            return total

        adj = [[] for _ in xrange(len(parents))]  # Space: O(n)
        for i in xrange(1, len(parents)):
            adj[parents[i]].append(i)
        result = [0]*2
        dfs(adj, 0, result)
        return result[1]

```



----------------------------------------------------------------------------------------

### Depth-First Search - 2065 - https://leetcode.com/problems/maximum-path-quality-of-a-graph/
Time: O(|V| + |E| + 4^10)  Space: O(|V| + |E| )   Hard
.Python/maximum-path-quality-of-a-graph.py


```python
# Time: O(|V| + |E| + 4^(maxTime/min(times))) = O(|V| + |E| + 4^10)
# Time: O(|V| + |E|)

class Solution(object):
    def maximalPathQuality(self, values, edges, maxTime):
        """
        :type values: List[int]
        :type edges: List[List[int]]
        :type maxTime: int
        :rtype: int
        """
        def iter_dfs(values, adj, maxTime):
            lookup, lookup2 = [0]*len(adj), set()
            result = 0
            stk = [(1, (0, maxTime, 0))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, time, total = args
                    lookup[u] += 1
                    if lookup[u] == 1:
                        total += values[u]
                    if not u:
                        result = max(result, total)
                    stk.append((4, (u,)))
                    for v, t in reversed(adj[u]):
                        if (u, v) in lookup2 or time &lt; t:  # same directed edge won't be visited twice
                            continue
                        stk.append((3, (u, v)))
                        stk.append((1, (v, time-t, total)))
                        stk.append((2, (u, v)))
                elif step == 2:
                    u, v = args
                    lookup2.add((u, v))
                elif step == 3:
                    u, v = args
                    lookup2.remove((u, v))
                elif step == 4:
                    u = args[0]
                    lookup[u] -= 1
            return result

        adj = [[] for _ in xrange(len(values))]
        for u, v, t in edges:
            adj[u].append((v, t))
            adj[v].append((u, t))
        return iter_dfs(values, adj, maxTime)


# Time: O(|V| + |E| + 4^(maxTime/min(times))) = O(|V| + |E| + 4^10)
# Time: O(|V| + |E|)
class Solution2(object):
    def maximalPathQuality(self, values, edges, maxTime):
        """
        :type values: List[int]
        :type edges: List[List[int]]
        :type maxTime: int
        :rtype: int
        """
        def dfs(values, adj, u, time, total, lookup, lookup2, result):
            lookup[u] += 1
            if lookup[u] == 1:
                total += values[u]
            if not u:
                result[0] = max(result[0], total)
            for v, t in adj[u]:
                if (u, v) in lookup2 or time &lt; t:  # same directed edge won't be visited twice
                    continue
                lookup2.add((u, v))
                dfs(values, adj, v, time-t, total, lookup, lookup2, result)
                lookup2.remove((u, v))
            lookup[u] -= 1

        adj = [[] for _ in xrange(len(values))]
        for u, v, t in edges:
            adj[u].append((v, t))
            adj[v].append((u, t))
        result = [0]
        dfs(values, adj, 0, maxTime, 0, [0]*len(adj), set(), result)
        return result[0]


# Time: O(|V| + |E| + 4^(maxTime/min(times))) = O(|V| + |E| + 4^10)
# Time: O(|V| + |E|)
class Solution3(object):
    def maximalPathQuality(self, values, edges, maxTime):
        """
        :type values: List[int]
        :type edges: List[List[int]]
        :type maxTime: int
        :rtype: int
        """
        def dfs(values, adj, u, time, total, lookup, lookup2):
            lookup[u] += 1
            if lookup[u] == 1:
                total += values[u]
            result = total if not u else 0
            for v, t in adj[u]:
                if (u, v) in lookup2 or time &lt; t:  # same directed edge won't be visited twice
                    continue
                lookup2.add((u, v))
                result = max(result, dfs(values, adj, v, time-t, total, lookup, lookup2))
                lookup2.remove((u, v))
            lookup[u] -= 1
            return result

        adj = [[] for _ in xrange(len(values))]
        for u, v, t in edges:
            adj[u].append((v, t))
            adj[v].append((u, t))
        return dfs(values, adj, 0, maxTime, 0, [0]*len(adj), set())

```



----------------------------------------------------------------------------------------

### Depth-First Search - 2192 - https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/
Time: O(|V| * |E|)  Space: O(|V| + |E|)   Medium
.Python/all-ancestors-of-a-node-in-a-directed-acyclic-graph.py


```python
# Time:  O(|V| * |E|)
# Space: O(|V| + |E|)

# dfs
class Solution(object):
    def getAncestors(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[List[int]]
        """
        def iter_dfs(adj, i, result):
            lookup = [False]*len(adj)
            stk = [i]
            while stk:
                u = stk.pop()
                for v in reversed(adj[u]):
                    if lookup[v]:
                        continue
                    lookup[v] = True
                    stk.append(v)
                    result[v].append(i)
                    
        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v)
        result = [[] for _ in xrange(n)]
        for u in xrange(n):
            iter_dfs(adj, u, result)
        return result


# Time:  O(|V| * |E| * log(|V| * |E|))
# Space: O(|V| + |E|)
# bfs
class Solution2(object):
    def getAncestors(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[List[int]]
        """
        def bfs(adj, i, result):
            lookup = [False]*len(adj)
            q = [i]
            lookup[i] = True
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if lookup[v]:
                            continue
                        lookup[v] = True
                        new_q.append(v)
                        result[i].append(v)
                q = new_q
            result[i].sort()

        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[v].append(u)
        result = [[] for _ in xrange(n)]
        for u in xrange(n):
            bfs(adj, u, result) 
        return result


# Time:  O(|V| * |E| * log(|V| * |E|))
# Space: O(|V| + |E|)
# topological sort
class Solution3(object):
    def getAncestors(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[List[int]]
        """
        result = [set() for _ in xrange(n)]
        in_degree = [0]*n
        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v)
            in_degree[v] += 1
            result[v].add(u)
        q = [u for u, d in enumerate(in_degree) if not d]
        while q:
            new_q = []
            for u in q:
                for v in adj[u]:
                    result[v].update(result[u])
                    in_degree[v] -= 1
                    if not in_degree[v]:
                        new_q.append(v)
            q = new_q
        return [sorted(s) for s in result]

```



----------------------------------------------------------------------------------------

### Depth-First Search - 2246 - https://leetcode.com/problems/longest-path-with-different-adjacent-characters/
Time: O(n)  Space: O(h)   Hard
.Python/longest-path-with-different-adjacent-characters.py


```python
# Time:  O(n)
# Space: O(w)

import collections


# tree, bfs, topological sort
class Solution(object):
    def longestPath(self, parent, s):
        """
        :type parent: List[int]
        :type s: str
        :rtype: int
        """
        def topological_sort(s, adj, in_degree):
            result = 1
            top2 = collections.defaultdict(lambda:[0]*2)
            q =  [(i, 1) for i, d in enumerate(in_degree) if not d]
            while q:
                new_q = []
                for (u, l) in q:
                    for v in adj[u]:
                        if s[v] != s[u]:
                            if l &gt; top2[v][0]:
                                top2[v][0], top2[v][1] = l, top2[v][0]
                            elif l &gt; top2[v][1]:
                                top2[v][1] = l
                        in_degree[v] -= 1
                        if in_degree[v]:
                            continue
                        new_q.append((v, top2[v][0]+1))
                        result = max(result, top2[v][0]+top2[v][1]+1)
                        del top2[v]
                q = new_q
            return result

        adj = [[] for _ in xrange(len(s))]
        in_degree = [0]*len(s)
        for i in xrange(1, len(parent)):
            adj[i].append(parent[i])
            in_degree[parent[i]] += 1
        return topological_sort(s, adj, in_degree)


# Time:  O(n)
# Space: O(h)
# tree, dfs
class Solution2(object):
    def longestPath(self, parent, s):
        """
        :type parent: List[int]
        :type s: str
        :rtype: int
        """
        def iter_dfs(s, adj):
            result = 0
            stk = [(1, (0, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, ret = args
                    top2 = [0]*2
                    stk.append((4, (top2, ret)))
                    stk.append((2, (u, 0, top2, ret)))
                elif step == 2:
                    u, i, top2, ret = args
                    if i == len(adj[u]):
                        continue
                    ret2 = [0]
                    stk.append((3, (u, i, top2, ret2)))
                    stk.append((1, (adj[u][i], ret2))) 
                elif step == 3:
                    u, i, top2, ret2 = args
                    if s[adj[u][i]] != s[u]:
                        if ret2[0] &gt; top2[0]:
                            top2[0], top2[1] = ret2[0], top2[0]
                        elif ret2[0] &gt; top2[1]:
                            top2[1] = ret2[0]
                    stk.append((2, (u, i+1, top2, ret)))
                elif step == 4:
                    top2, ret = args
                    result = max(result, top2[0]+top2[1]+1)
                    ret[0] = top2[0]+1
            return result
    
        
        adj = [[] for _ in xrange(len(s))]
        for i in xrange(1, len(parent)):
            adj[parent[i]].append(i)
        return iter_dfs(s, adj)
    

# Time:  O(n)
# Space: O(h)
# tree, dfs
class Solution3(object):
    def longestPath(self, parent, s):
        """
        :type parent: List[int]
        :type s: str
        :rtype: int
        """
        def dfs(s, adj, u, result):
            top2 = [0]*2
            for v in adj[u]:
                l = dfs(s, adj, v, result)
                if s[v] == s[u]:
                    continue
                if l &gt; top2[0]:
                    top2[0], top2[1] = l, top2[0]
                elif l &gt; top2[1]:
                    top2[1] = l
            result[0] = max(result[0], top2[0]+top2[1]+1)
            return top2[0]+1
    
        
        adj = [[] for _ in xrange(len(s))]
        for i in xrange(1, len(parent)):
            adj[parent[i]].append(i)
        result = [0]
        dfs(s, adj, 0, result)
        return result[0]

```



----------------------------------------------------------------------------------------

### Depth-First Search - 2265 - https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/
Time: O(n)  Space: O(h)   Medium
.Python/count-nodes-equal-to-average-of-subtree.py


```python
# Time:  O(n)
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


# dfs
class Solution(object):
    def averageOfSubtree(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        def iter_dfs(root):
            result = 0
            stk = [(1, (root, [0]*2))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        continue
                    ret1, ret2 = [0]*2, [0]*2
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    ret[0] = ret1[0]+ret2[0]+node.val
                    ret[1] = ret1[1]+ret2[1]+1
                    result += int(ret[0]//ret[1] == node.val)
            return result
        
        return iter_dfs(root)


# Time:  O(n)
# Space: O(h)
# dfs
class Solution2(object):
    def averageOfSubtree(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: int
        """
        def dfs(node):
            if not node:
                return [0]*3
            left = dfs(node.left)
            right = dfs(node.right)
            return [left[0]+right[0]+node.val,
                    left[1]+right[1]+1,
                    left[2]+right[2]+int((left[0]+right[0]+node.val)//(left[1]+right[1]+1) == node.val)]
        
        return dfs(root)[2]

```



----------------------------------------------------------------------------------------

### Depth-First Search - 2322 - https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/
Time: O(n^2)  Space: O(n)   Hard
.Python/minimum-score-after-removals-on-a-tree.py


```python
# Time:  O(n^2)
# Space: O(n)

# dfs with stack
class Solution(object):
    def minimumScore(self, nums, edges):
        """
        :type nums: List[int]
        :type edges: List[List[int]]
        :rtype: int
        """
        def is_ancestor(a, b):
            return left[a] &lt;= left[b] and right[b] &lt;= right[a]

        def iter_dfs():
            cnt = 0
            left = [0]*len(nums)
            right = [0]*len(nums)
            stk = [(1, (0, -1))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p = args
                    left[u] = cnt
                    cnt += 1
                    stk.append((2, (u, p)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        stk.append((1, (v, u)))
                elif step == 2:
                    u, p = args
                    for v in adj[u]:
                        if v == p:
                            continue
                        nums[u] ^= nums[v]
                    right[u] = cnt
            return left, right
                
        adj = [[] for _ in xrange(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        left, right = iter_dfs()
        result = float("inf")
        for i in xrange(1, len(nums)):
            for j in xrange(i+1, len(nums)):
                if is_ancestor(i, j):
                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]
                elif is_ancestor(j, i):
                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]
                else:
                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]
                result = min(result, max(a, b, c)-min(a, b, c))
        return result


# Time:  O(n^2)
# Space: O(n)
# dfs with recursion
class Solution2(object):
    def minimumScore(self, nums, edges):
        """
        :type nums: List[int]
        :type edges: List[List[int]]
        :rtype: int
        """
        def is_ancestor(a, b):
            return left[a] &lt;= left[b] and right[b] &lt;= right[a]

        def dfs(u, p):
            left[u] = cnt[0]
            cnt[0] += 1
            for v in adj[u]:
                if v == p:
                    continue
                dfs(v, u)
                nums[u] ^= nums[v]
            right[u] = cnt[0]
                
        adj = [[] for _ in xrange(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        cnt = [0]
        left = [0]*len(nums)
        right = [0]*len(nums)
        dfs(0, -1)
        result = float("inf")
        for i in xrange(1, len(nums)):
            for j in xrange(i+1, len(nums)):
                if is_ancestor(i, j):
                    a, b, c = nums[0]^nums[i], nums[i]^nums[j], nums[j]
                elif is_ancestor(j, i):
                    a, b, c = nums[0]^nums[j], nums[j]^nums[i], nums[i]
                else:
                    a, b, c = nums[0]^nums[i]^nums[j], nums[i], nums[j]
                result = min(result, max(a, b, c)-min(a, b, c))
        return result
            

# Time:  O(n^2)
# Space: O(n)
# dfs with recursion
class Solution3(object):
    def minimumScore(self, nums, edges):
        """
        :type nums: List[int]
        :type edges: List[List[int]]
        :rtype: int
        """
        def dfs(u, p, result):
            total = nums[u]
            for v in adj[u]:
                if v == p:
                    continue
                total ^= dfs(v, u, result)
            result.append(total)
            return total
                
        adj = [[] for _ in xrange(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = reduce(lambda x, y: x^y, nums)
        result = float("inf")
        for u, v in edges: 
            left = []
            dfs(u, v, left)
            right = []
            dfs(v, u, right)
            for candidates in (left, right):
                total2 = candidates.pop()
                for x in candidates:
                    a, b, c = total^total2, x, total2^x
                    result = min(result, max(a, b, c)-min(a, b, c))
        return result
            

# Time:  O(n^2)
# Space: O(n)
# dfs with stk (slower, sometimes TLE)
class Solution4(object):
    def minimumScore(self, nums, edges):
        """
        :type nums: List[int]
        :type edges: List[List[int]]
        :rtype: int
        """
        def iter_dfs(nums, adj, u, p):
            result = []
            stk = [(1, (u, p, [0]))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    u, p, ret = args
                    new_rets = []
                    stk.append((2, (u, new_rets, ret)))
                    for v in adj[u]:
                        if v == p:
                            continue
                        new_rets.append([0])
                        stk.append((1, (v, u, new_rets[-1])))
                elif step == 2:
                    u, new_rets, ret = args
                    ret[0] = nums[u]
                    for x in new_rets:
                        ret[0] ^= x[0]
                    result.append(ret[0])
            return result
                
        adj = [[] for _ in xrange(len(nums))]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        total = reduce(lambda x, y: x^y, nums)
        result = float("inf")
        for u, v in edges: 
            for candidates in (iter_dfs(nums, adj, u, v), iter_dfs(nums, adj, v, u)):
                total2 = candidates.pop()
                for x in candidates:
                    a, b, c = total^total2, x, total2^x
                    result = min(result, max(a, b, c)-min(a, b, c))
        return result

```



----------------------------------------------------------------------------------------

### Depth-First Search - 2331 - https://leetcode.com/problems/evaluate-boolean-binary-tree/
Time: O(n)  Space: O(h)   Easy
.Python/evaluate-boolean-binary-tree.py


```python
# Time:  O(n)
# Space: O(h)

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


# dfs with stack
class Solution(object):
    def evaluateTree(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        INF = float("inf")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y
        }
        
        def iter_dfs(root):
            ret = [0]
            stk = [(1, (root, ret))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if node.left == node.right:
                        ret[0] = node.val
                        continue
                    ret1, ret2 = [0], [0]
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    ret[0] = OP[node.val](ret1[0], ret2[0])
            return ret[0]

        return iter_dfs(root)


# Time:  O(n)
# Space: O(h)
# dfs with recursion
class Solution2(object):
    def evaluateTree(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        INF = float("inf")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
        }
        
        def dfs(node):
            if node.left == node.right:
                return node.val
            return OP[node.val](dfs(node.left), dfs(node.right))

        return dfs(root)

```



----------------------------------------------------------------------------------------

### Backtracking - 1087 - https://leetcode.com/problems/brace-expansion/
Time: O(p * l * log(p * l))  Space: O(p * l)   Medium
.Python/brace-expansion.py


```python
# Time:  O(p*l * log(p*l)), p is the production of all number of options
#                         , l is the length of a word
# Space: O(p*l)

import itertools


class Solution(object):
    def expand(self, S):  # nested is fine
        """
        :type S: str
        :rtype: List[str]
        """
        def form_words(options):
            words = map("".join, itertools.product(*options))
            words.sort()
            return words

        def generate_option(expr, i):
            option_set = set()
            while i[0] != len(expr) and expr[i[0]] != "}":
                i[0] += 1  # { or ,
                for option in generate_words(expr, i):
                    option_set.add(option)
            i[0] += 1  # }
            option = list(option_set)
            option.sort()
            return option

        def generate_words(expr, i):
            options = []
            while i[0] != len(expr) and expr[i[0]] not in ",}":
                tmp = []
                if expr[i[0]] not in "{,}":
                    tmp.append(expr[i[0]])
                    i[0] += 1  # a-z
                elif expr[i[0]] == "{":
                    tmp = generate_option(expr, i)
                options.append(tmp)
            return form_words(options)

        return generate_words(S, [0])


class Solution2(object):
    def expand(self, S):  # nested is fine
        """
        :type S: str
        :rtype: List[str]
        """
        def form_words(options):
            words = []
            total = 1
            for opt in options:
                total *= len(opt)
            for i in xrange(total):
                tmp = []
                for opt in reversed(options):
                    i, c = divmod(i, len(opt))
                    tmp.append(opt[c])
                tmp.reverse()
                words.append("".join(tmp))
            words.sort()
            return words

        def generate_option(expr, i):
            option_set = set()
            while i[0] != len(expr) and expr[i[0]] != "}":
                i[0] += 1  # { or ,
                for option in generate_words(expr, i):
                    option_set.add(option)
            i[0] += 1  # }
            option = list(option_set)
            option.sort()
            return option

        def generate_words(expr, i):
            options = []
            while i[0] != len(expr) and expr[i[0]] not in ",}":
                tmp = []
                if expr[i[0]] not in "{,}":
                    tmp.append(expr[i[0]])
                    i[0] += 1  # a-z
                elif expr[i[0]] == "{":
                    tmp = generate_option(expr, i)
                options.append(tmp)
            return form_words(options)

        return generate_words(S, [0])

```



----------------------------------------------------------------------------------------

### Backtracking - 1096 - https://leetcode.com/problems/brace-expansion-ii/
Time: O(p * l * log(p * l))  Space: O(p * l)   Hard
.Python/brace-expansion-ii.py


```python
# Time:  O(p*l * log(p*l)), p is the production of all number of options
#                         , l is the length of a word
# Space: O(p*l)

import itertools


class Solution(object):
    def braceExpansionII(self, expression):
        """
        :type expression: str
        :rtype: List[str]
        """
        def form_words(options):
            words = map("".join, itertools.product(*options))
            words.sort()
            return words

        def generate_option(expr, i):
            option_set = set()
            while i[0] != len(expr) and expr[i[0]] != "}":
                i[0] += 1  # { or ,
                for option in generate_words(expr, i):
                    option_set.add(option)
            i[0] += 1  # }
            option = list(option_set)
            option.sort()
            return option

        def generate_words(expr, i):
            options = []
            while i[0] != len(expr) and expr[i[0]] not in ",}":
                tmp = []
                if expr[i[0]] not in "{,}":
                    tmp.append(expr[i[0]])
                    i[0] += 1  # a-z
                elif expr[i[0]] == "{":
                    tmp = generate_option(expr, i)
                options.append(tmp)
            return form_words(options)

        return generate_words(expression, [0])


class Solution2(object):
    def braceExpansionII(self, expression):
        """
        :type expression: str
        :rtype: List[str]
        """
        def form_words(options):
            words = []
            total = 1
            for opt in options:
                total *= len(opt)
            for i in xrange(total):
                tmp = []
                for opt in reversed(options):
                    i, c = divmod(i, len(opt))
                    tmp.append(opt[c])
                tmp.reverse()
                words.append("".join(tmp))
            words.sort()
            return words

        def generate_option(expr, i):
            option_set = set()
            while i[0] != len(expr) and expr[i[0]] != "}":
                i[0] += 1  # { or ,
                for option in generate_words(expr, i):
                    option_set.add(option)
            i[0] += 1  # }
            option = list(option_set)
            option.sort()
            return option

        def generate_words(expr, i):
            options = []
            while i[0] != len(expr) and expr[i[0]] not in ",}":
                tmp = []
                if expr[i[0]] not in "{,}":
                    tmp.append(expr[i[0]])
                    i[0] += 1  # a-z
                elif expr[i[0]] == "{":
                    tmp = generate_option(expr, i)
                options.append(tmp)
            return form_words(options)

        return generate_words(expression, [0])

```



----------------------------------------------------------------------------------------

### Backtracking - 1219 - https://leetcode.com/problems/path-with-maximum-gold/
Time: O(m^2 * n^2)  Space: O(m * n)   Medium
.Python/path-with-maximum-gold.py


```python
# Time:  O(m^2 * n^2)
# Space: O(m * n)

class Solution(object):
    def getMaximumGold(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def backtracking(grid, i, j):
            result = 0
            grid[i][j] *= -1
            for dx, dy in directions:
                ni, nj = i+dx, j+dy
                if not (0 &lt;= ni &lt; len(grid) and
                        0 &lt;= nj &lt; len(grid[0]) and
                        grid[ni][nj] &gt; 0):
                    continue
                result = max(result, backtracking(grid, ni, nj))
            grid[i][j] *= -1
            return grid[i][j] + result

        result = 0
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if grid[i][j]:
                    result = max(result, backtracking(grid, i, j))
        return result

```



----------------------------------------------------------------------------------------

### Backtracking - 1240 - https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/
Time: O(n^2 * m^2 * m^(n * m))  Space: O(n * m)   Hard
.Python/tiling-a-rectangle-with-the-fewest-squares.py


```python
# Time:  O(n^2 * m^2 * m^(n * m)), given m &lt; n
# Space: O(n * m)

class Solution(object):
    def tilingRectangle(self, n, m):
        """
        :type n: int
        :type m: int
        :rtype: int
        """
        def find_next(board):
            for i in xrange(len(board)):
                for j in xrange(len(board[0])):
                    if not board[i][j]:
                        return i, j
            return -1, -1

        def find_max_length(board, i, j):
            max_length = 1
            while i+max_length-1 &lt; len(board) and \
                  j+max_length-1 &lt; len(board[0]):
                for r in xrange(i, i+max_length-1):
                    if board[r][j+max_length-1]:
                        return max_length-1
                for c in xrange(j, j+max_length):
                    if board[i+max_length-1][c]:
                        return max_length-1
                max_length += 1
            return max_length-1

        def fill(board, i, j, length, val):
            for r in xrange(i, i+length):
                for c in xrange(j, j+length):
                    board[r][c] = val

        def backtracking(board, count, result):
            if count &gt;= result[0]:  # pruning
                return
            i, j = find_next(board)
            if (i, j) == (-1, -1):  # finished
                result[0] = min(result[0], count)
                return
            max_length = find_max_length(board, i, j)
            for k in reversed(xrange(1, max_length+1)):
                fill(board, i, j, k, 1)
                backtracking(board, count+1, result)
                fill(board, i, j, k, 0)

        if m &gt; n:
            return self.tilingRectangle(m, n)
        board = [[0]*m for _ in xrange(n)]
        result = [float("inf")]
        backtracking(board, 0, result)
        return result[0]

```



----------------------------------------------------------------------------------------

### Backtracking - 1255 - https://leetcode.com/problems/maximum-score-words-formed-by-letters/
Time: O(n * 2^n)  Space: O(n)   Hard
.Python/maximum-score-words-formed-by-letters.py


```python
# Time:  O(n * 2^n)
# Space: O(n)

import collections


class Solution(object):
    def maxScoreWords(self, words, letters, score):
        """
        :type words: List[str]
        :type letters: List[str]
        :type score: List[int]
        :rtype: int
        """
        def backtracking(words, word_scores, word_counts, curr, curr_score, letter_count, result):
            result[0] = max(result[0], curr_score) 
            for i in xrange(curr, len(words)):
                if any(letter_count[c] &lt; word_counts[i][c] for c in word_counts[i]):
                    continue
                backtracking(words, word_scores, word_counts, i+1,
                             curr_score+word_scores[i], letter_count-word_counts[i],
                             result)

        letter_count = collections.Counter(letters)    
        word_counts = map(collections.Counter, words)
        word_scores = [sum(score[ord(c)-ord('a')] for c in words[i])
                       for i in xrange(len(words))]
        result = [0]
        backtracking(words, word_scores, word_counts, 0, 0, letter_count, result)
        return result[0]

```



----------------------------------------------------------------------------------------

### Backtracking - 1258 - https://leetcode.com/problems/synonymous-sentences/
Time: O(p * l * log(p * l))  Space: O(p * l)   Medium
.Python/synonymous-sentences.py


```python
# Time:  O(p*l * log(p*l)), p is the production of all number of synonyms
#                         , l is the length of a word
# Space: O(p*l)

import collections
import itertools


class UnionFind(object):
    def __init__(self, n):
        self.set = range(n)
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        return True


class Solution(object):
    def generateSentences(self, synonyms, text):
        """
        :type synonyms: List[List[str]]
        :type text: str
        :rtype: List[str]
        """
        def assign_id(x, lookup, inv_lookup):
            if x in lookup:
                return
            lookup[x] = len(lookup)
            inv_lookup[lookup[x]] = x
        
        lookup, inv_lookup = {}, {}
        for u, v in synonyms:
            assign_id(u, lookup, inv_lookup), assign_id(v, lookup, inv_lookup)
        union_find = UnionFind(len(lookup))
        for u, v in synonyms:
            union_find.union_set(lookup[u], lookup[v])
        groups = collections.defaultdict(list)
        for i in xrange(len(union_find.set)):
            groups[union_find.find_set(i)].append(i)
        result = []
        for w in text.split(' '):
            if w not in lookup:
                result.append([w])
                continue
            result.append(sorted(map(lambda x: inv_lookup[x], 
                                 groups[union_find.find_set(lookup[w])])))
        return [" ".join(sentense) for sentense in itertools.product(*result)]

```



----------------------------------------------------------------------------------------

### Backtracking - 1307 - https://leetcode.com/problems/verbal-arithmetic-puzzle/
Time: O(10! * n * l)  Space: O(n * l)   Hard
.Python/verbal-arithmetic-puzzle.py


```python
# Time:  O(10! * n * l)
# Space: O(n * l)

import collections


class Solution(object):
    def isSolvable(self, words, result):
        """
        :type words: List[str]
        :type result: str
        :rtype: bool
        """
        def backtracking(words, result, i, j, carry, lookup, used):
            if j == len(result):
                return carry == 0

            if i != len(words):
                if j &gt;= len(words[i]) or words[i][j] in lookup:
                    return backtracking(words, result, i+1, j, carry, lookup, used)     
                for val in xrange(10):
                    if val in used or (val == 0 and j == len(words[i])-1):
                        continue
                    lookup[words[i][j]] = val
                    used.add(val)
                    if backtracking(words, result, i+1, j, carry, lookup, used):
                        return True
                    used.remove(val)
                    del lookup[words[i][j]]
                return False

            carry, val = divmod(carry + sum(lookup[w[j]] for w in words if j &lt; len(w)), 10)
            if result[j] in lookup:
                return val == lookup[result[j]] and \
                       backtracking(words, result, 0, j+1, carry, lookup, used)
            if val in used or (val == 0 and j == len(result)-1):
                return False
            lookup[result[j]] = val
            used.add(val)
            if backtracking(words, result, 0, j+1, carry, lookup, used):
                return True
            used.remove(val)
            del lookup[result[j]]
            return False
        
        return backtracking([w[::-1] for w in words], result[::-1], 0, 0, 0, {}, set())

```



----------------------------------------------------------------------------------------

### Backtracking - 1379 - https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/
Time: O(n)  Space: O(h)   Medium
.Python/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree.py


```python
# Time:  O(n)
# Space: O(h)

import itertools


# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None


class Solution(object):
    def getTargetCopy(self, original, cloned, target):
        """
        :type original: TreeNode
        :type cloned: TreeNode
        :type target: TreeNode
        :rtype: TreeNode
        """
        def preorder_gen(node):
            stk = [node]
            while stk:
                node = stk.pop()
                if not node:
                    continue
                yield node
                stk.append(node.right)
                stk.append(node.left)
            
        for node1, node2 in itertools.izip(preorder_gen(original),
                                           preorder_gen(cloned)):
            if node1 == target:
                return node2

```



----------------------------------------------------------------------------------------

### Backtracking - 1593 - https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/
Time: O(n * 2^(n - 1))  Space: O(n)   Medium
.Python/split-a-string-into-the-max-number-of-unique-substrings.py


```python
# Time:  O(n * 2^(n - 1))
# Space: O(n)

class Solution(object):
    def maxUniqueSplit(self, s):
        """
        :type s: str
        :rtype: int
        """
        def popcount(n):
            count = 0
            while n:
                n &amp;= n-1
                count += 1
            return count
    
        result = 1
        total = 2**(len(s)-1)
        mask = 0
        while mask &lt; total:
            if popcount(mask) &lt; result:
                mask += 1
                continue
            lookup, curr, base = set(), [], total//2
            for i in xrange(len(s)):
                curr.append(s[i])
                if (mask&amp;base) or base == 0:
                    if "".join(curr) in lookup:
                        mask = (mask | (base-1)) + 1 if base else mask+1  # pruning, try next mask without base
                        break
                    lookup.add("".join(curr))
                    curr = []
                base &gt;&gt;= 1
            else:
                result = max(result, len(lookup))
                mask += 1
        return result

```



----------------------------------------------------------------------------------------

### Backtracking - 1659 - https://leetcode.com/problems/maximize-grid-happiness/
Time: O(C(m * n, i) * C(m * n - i, e))  Space: O(min(m * n, i + e))   Hard
.Python/maximize-grid-happiness.py


```python
# Time:  O(C(m * n, i) * C(m * n - i, e))
# Space: O(min(m * n, i + e))

class Solution(object):
    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):
        """
        :type m: int
        :type n: int
        :type introvertsCount: int
        :type extrovertsCount: int
        :rtype: int
        """
        def left(curr):
            return curr[-1] if len(curr)%n else 0

        def up(curr):
            return curr[-n] if len(curr) &gt;= n else 0 

        def count_total(curr, t, total):
            return (total
                    - 30*((left(curr) == 1)+(up(curr) == 1))
                    + 20*((left(curr) == 2)+(up(curr) == 2))
                    + (120 - 30*((left(curr) != 0)+(up(curr) != 0)))*(t == 1)
                    + ( 40 + 20*((left(curr) != 0)+(up(curr) != 0)))*(t == 2))
        
        def iter_backtracking(i, e):
            result = 0
            curr = []
            stk = [(2, (i, e, 0))]
            while stk:
                step, params = stk.pop()
                if step == 2:
                    i, e, total = params             
                    if len(curr) == m*n or (i == 0 and e == 0):
                        result = max(result, total)                
                        continue
                    if total + (i+e)*120 &lt; result:  # pruning
                        continue
                    if e &gt; 0:
                        stk.append((3, tuple()))
                        stk.append((2, (i, e-1, count_total(curr, 2, total))))
                        stk.append((1, (2,)))
                    if i &gt; 0:
                        stk.append((3, tuple()))
                        stk.append((2, (i-1, e, count_total(curr, 1, total))))
                        stk.append((1, (1,)))
                    if left(curr) or up(curr):  # leave unoccupied iff left or up is occupied
                        stk.append((3, tuple()))
                        stk.append((2, (i, e, total)))
                        stk.append((1, (0,)))
                elif step == 1:
                    x = params[0]
                    curr.append(x)
                elif step == 3:
                    curr.pop()
            return result
          
        return iter_backtracking(introvertsCount, extrovertsCount)


# Time:  O(C(m * n, i) * C(m * n - i, e))
# Space: O(min(m * n, i + e))
class Solution2(object):
    def getMaxGridHappiness(self, m, n, introvertsCount, extrovertsCount):
        """
        :type m: int
        :type n: int
        :type introvertsCount: int
        :type extrovertsCount: int
        :rtype: int
        """
        def left(curr):
            return curr[-1] if len(curr)%n else 0

        def up(curr):
            return curr[-n] if len(curr) &gt;= n else 0 

        def count_total(curr, t, total):
            return (total
                    - 30*((left(curr) == 1)+(up(curr) == 1))
                    + 20*((left(curr) == 2)+(up(curr) == 2))
                    + (120 - 30*((left(curr) != 0)+(up(curr) != 0)))*(t == 1)
                    + ( 40 + 20*((left(curr) != 0)+(up(curr) != 0)))*(t == 2))
        
        def backtracking(i, e, total, curr, result):              
            if len(curr) == m*n or (i == 0 and e == 0):
                result[0] = max(result[0], total)                
                return
            if total + (i+e)*120 &lt; result[0]:  # pruning
                return
            if left(curr) or up(curr):  # leave unoccupied iff left or up is occupied
                curr.append(0)
                backtracking(i, e, total, curr, result)
                curr.pop()
            if i &gt; 0:
                new_total = count_total(curr, 1, total)
                curr.append(1)
                backtracking(i-1, e, new_total, curr, result)
                curr.pop()
            if e &gt; 0:
                new_total = count_total(curr, 2, total)
                curr.append(2)
                backtracking(i, e-1, new_total, curr, result)
                curr.pop()

        result = [0]
        backtracking(introvertsCount, extrovertsCount, 0, [], result)
        return result[0]

```



----------------------------------------------------------------------------------------

### Backtracking - 1718 - https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/
Time: O(n!)  Space: O(b)   Medium
.Python/construct-the-lexicographically-largest-valid-sequence.py


```python
# Time:  O(n!)
# Space: O(n)

class Solution(object):
    def constructDistancedSequence(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        def backtracking(n, i, result, lookup):
            if i == len(result):
                return True
            if result[i]:
                return backtracking(n, i+1, result, lookup)
            for x in reversed(xrange(1, n+1)):
                j = i if x == 1 else i+x
                if lookup[x] or j &gt;= len(result) or result[j]:
                    continue
                result[i], result[j], lookup[x] = x, x, True
                if backtracking(n, i+1, result, lookup):
                    return True
                result[i], result[j], lookup[x] = 0, 0, False
            return False

        result, lookup = [0]*(2*n-1), [False]*(n+1)
        backtracking(n, 0, result, lookup)
        return result

```



----------------------------------------------------------------------------------------

### Backtracking - 1723 - https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs/
Time: O(k^n * logr)  Space: O(n + k)   Hard
.Python/find-minimum-time-to-finish-all-jobs.py


```python
# Time:  O(k^n * logr), the real complexity shoud be much less, but hard to analyze
# Space: O(n + k)

class Solution(object):
    def minimumTimeRequired(self, jobs, k):
        """
        :type jobs: List[int]
        :type k: int
        :rtype: int
        """
        def backtracking(jobs, i, cap, counts):
            if i == len(jobs):
                return True
            for j in xrange(len(counts)):
                if counts[j]+jobs[i] &lt;= cap:
                    counts[j] += jobs[i]
                    if backtracking(jobs, i+1, cap, counts):
                        return True
                    counts[j] -= jobs[i]
                if counts[j] == 0:
                    break
            return False

        jobs.sort(reverse=True)
        left, right = max(jobs), sum(jobs)
        while left &lt;= right:
            mid = left + (right-left)//2
            if backtracking(jobs, 0, mid, [0]*k):
                right = mid-1
            else:
                left = mid+1
        return left


# Time:  O(k * k^n), the real complexity shoud be less, but hard to analyze
# Space: O(n + k)
class Solution2(object):
    def minimumTimeRequired(self, jobs, k):
        """
        :type jobs: List[int]
        :type k: int
        :rtype: int
        """
        def backtracking(jobs, i, counts, result):
            if i == len(jobs):
                result[0] = min(result[0], max(counts))
                return
            for j in xrange(len(counts)):
                if counts[j]+jobs[i] &lt;= result[0]:
                    counts[j] += jobs[i]
                    backtracking(jobs, i+1, counts, result)
                    counts[j] -= jobs[i]
                if counts[j] == 0:
                    break

        jobs.sort(reverse=False)
        result = [sum(jobs)]
        backtracking(jobs, 0, [0]*k, result)
        return result[0]

```



----------------------------------------------------------------------------------------

### Backtracking - 1849 - https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/
Time: O(n^2)  Space: O(n)   Medium
.Python/splitting-a-string-into-descending-consecutive-values.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def splitString(self, s):
        """
        :type s: str
        :rtype: bool
        """
        def backtracking(s, i, num, cnt):
            if i == len(s):
                return cnt &gt;= 2
            new_num = 0
            for j in xrange(i, len(s)):
                new_num = new_num*10 + int(s[j])
                if new_num &gt;= num &gt;= 0:
                    break
                if (num == -1 or num-1 == new_num) and backtracking(s, j+1, new_num, cnt+1):
                    return True
            return False
            
        return backtracking(s, 0, -1, 0)

```



----------------------------------------------------------------------------------------

### Backtracking - 1999 - https://leetcode.com/problems/smallest-greater-multiple-made-of-two-digits/
Time: O(1)  Space: O(1)   Medium
.Python/smallest-greater-multiple-made-of-two-digits.py


```python
# Time:  sum(O(l * 2^l) for l in range(1, 11)) = O(20 * 2^10) = O(1)
# Space: O(1)

class Solution(object):
    def findInteger(self, k, digit1, digit2):
        """
        :type k: int
        :type digit1: int
        :type digit2: int
        :rtype: int
        """
        MAX_NUM_OF_DIGITS = 10
        INT_MAX = 2**31-1

        if digit1 &lt; digit2:
            digit1, digit2 = digit2, digit1
        total = 2
        for l in xrange(1, MAX_NUM_OF_DIGITS+1):
            for mask in xrange(total):
                curr, bit = 0, total&gt;&gt;1
                while bit:
                    curr = curr*10 + (digit1 if mask&amp;bit else digit2)
                    bit &gt;&gt;= 1
                if k &lt; curr &lt;= INT_MAX and curr%k == 0:
                    return curr
            total &lt;&lt;= 1
        return -1

```



----------------------------------------------------------------------------------------

### Backtracking - 2014 - https://leetcode.com/problems/longest-subsequence-repeated-k-times/
Time: O(n * (n/k)!)  Space: O(n/k)   Hard
.Python/longest-subsequence-repeated-k-times.py


```python
# Time:  O(n * (n/k)!)
# Space: O(n)

import collections


class Solution(object):
    def longestSubsequenceRepeatedK(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: str
        """
        def check(s, k, curr):
            if not curr:
                return True
            i = 0
            for c in s:
                if c != curr[i]:
                    continue
                i += 1
                if i != len(curr):
                    continue
                i = 0
                k -= 1
                if not k:
                    return True
            return False

        def backtracking(s, k, curr, cnts, result):
            if not check(s, k, curr):
                return
            if len(curr) &gt; len(result):
                result[:] = curr
            for c in reversed(string.ascii_lowercase):
                if cnts[c] &lt; k:
                    continue
                cnts[c] -= k
                curr.append(c)
                backtracking(s, k, curr, cnts, result)
                curr.pop()
                cnts[c] += k
                    
        cnts = collections.Counter(s)
        new_s = []
        for c in s:
            if cnts[c] &lt; k:
                continue
            new_s.append(c)
        result =[]
        backtracking(new_s, k, [], cnts, result)
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Backtracking - 2056 - https://leetcode.com/problems/number-of-valid-move-combinations-on-chessboard/
Time: O(1)  Space: O(1)   Hard
.Python/number-of-valid-move-combinations-on-chessboard.py


```python
# Time:  O(n^p) = O(1), n is the max number of possible moves for each piece, and n is at most 29
#                     , p is the number of pieces, and p is at most 4
# Space: O(1)

class Solution(object):
    def countCombinations(self, pieces, positions):
        """
        :type pieces: List[str]
        :type positions: List[List[int]]
        :rtype: int
        """
        directions = {"rook": [(0, 1), (1, 0), (0, -1), (-1, 0)],
                      "bishop": [(1, 1), (1, -1), (-1, 1), (-1, -1)],
                      "queen" : [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]}
        all_mask = 2**7-1  # at most 7 seconds in 8x8 board
        def backtracking(pieces, positions, i, lookup):
            if i == len(pieces):
                return 1
            result = 0
            r, c = positions[i]
            r, c = r-1, c-1
            mask = all_mask
            if not (lookup[r][c]&amp;mask):
                lookup[r][c] += mask  # stopped at (r, c)
                result += backtracking(pieces, positions, i+1, lookup)
                lookup[r][c] -= mask          
            for dr, dc in directions[pieces[i]]:
                bit, nr, nc = 1, r+dr, c+dc
                mask = all_mask  # (mask&amp;bit == 1): (log2(bit)+1)th second is occupied
                while 0 &lt;= nr &lt; 8 and 0 &lt;= nc &lt; 8 and not (lookup[nr][nc]&amp;bit):
                    lookup[nr][nc] += bit
                    mask -= bit
                    if not (lookup[nr][nc]&amp;mask):  # stopped at (nr, nc)
                        lookup[nr][nc] += mask
                        result += backtracking(pieces, positions, i+1, lookup)
                        lookup[nr][nc] -= mask
                    bit, nr, nc = bit&lt;&lt;1, nr+dr, nc+dc
                while bit&gt;&gt;1:
                    bit, nr, nc = bit&gt;&gt;1, nr-dr, nc-dc
                    lookup[nr][nc] -= bit
            return result

        return backtracking(pieces, positions, 0, [[0]*8 for _ in range(8)])

```



----------------------------------------------------------------------------------------

### Backtracking - 2094 - https://leetcode.com/problems/finding-3-digit-even-numbers/
Time: O(n)  Space: O(1)   Easy
.Python/finding-3-digit-even-numbers.py


```python
# Time:  O(1) ~ O(n), n is 10^3
# Space: O(1)

class Solution(object):
    def findEvenNumbers(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        k = 3
        def backtracking(curr, cnt, result):
            if len(curr) == k:
                result.append(reduce(lambda x, y: x*10+y, curr))
                return
            for i, c in enumerate(cnt):
                if c == 0 or (not curr and i == 0) or (len(curr) == k-1 and i%2 != 0):
                    continue
                cnt[i] -= 1
                curr.append(i)
                backtracking(curr, cnt, result)
                curr.pop()
                cnt[i] += 1

        cnt = [0]*10
        for d in digits:
            cnt[d] += 1
        result = []
        backtracking([], cnt, result)
        return result


# Time:  O(n), n is 10^3
# Space: O(1)
import collections


class Solution2(object):
    def findEvenNumbers(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        result, cnt = [], collections.Counter(digits)
        for i in xrange(1, 10):
            for j in xrange(10):
                for k in xrange(0, 10, 2):
                    if cnt[i] &gt; 0 and cnt[j] &gt; (j == i) and cnt[k] &gt; (k == i) + (k == j):
                        result.append(i*100 + j*10 + k)
        return result


# Time:  O(1) ~ O(n), n is 10^3
# Space: O(1)
import collections


class Node(object):
    def __init__(self, val=None, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution3(object):
    def findEvenNumbers(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        k = 3
        def backtracking(curr, dummy, result):
            if len(curr) == k:
                result.append(reduce(lambda x, y: x*10+y, curr))
                return
            node = dummy.right
            while node:
                if (not curr and node.val[0] == 0) or (len(curr) == k-1 and node.val[0]%2 != 0):
                    node = node.right
                    continue
                node.val[1] -= 1
                if node.val[1] == 0:
                    if node.left:
                        node.left.right = node.right
                    if node.right:
                        node.right.left = node.left
                curr.append(node.val[0])
                backtracking(curr, dummy, result)
                curr.pop()
                if node.val[1] == 0:
                    if node.left:
                        node.left.right = node
                    if node.right:
                        node.right.left = node
                node.val[1] += 1
                node = node.right

        prev = dummy = Node()
        for digit, cnt in sorted(map(list, collections.Counter(digits).iteritems())):
            prev.right = Node(val=[digit, cnt], left=prev)
            prev = prev.right
        result = []
        backtracking([], dummy, result)
        return result


# Time:  O(1) ~ O(nlogn), n is 10^3
# Space: O(1)
import collections


class Solution4(object):
    def findEvenNumbers(self, digits):
        """
        :type digits: List[int]
        :rtype: List[int]
        """
        k = 3
        def backtracking(curr, digit_cnt, result):
            if len(curr) == k:
                result.append(reduce(lambda x, y: x*10+y, curr))
                return
            for i, (digit, cnt) in enumerate(digit_cnt):
                if (not curr and digit == 0) or (len(curr) == k-1 and digit%2 != 0):
                    continue
                digit_cnt[i][1] -= 1
                digit_cnt[i], digit_cnt[-1] = digit_cnt[-1], digit_cnt[i]
                removed = []
                if digit_cnt[-1][1] == 0:
                    removed = digit_cnt.pop()
                curr.append(digit)
                backtracking(curr, digit_cnt, result)
                curr.pop()
                if removed:
                    digit_cnt.append(removed)
                digit_cnt[i], digit_cnt[-1] = digit_cnt[-1], digit_cnt[i]
                digit_cnt[i][1] += 1

        cnt = collections.Counter(digits)
        digit_cnt = map(list, cnt.iteritems())
        result = []
        backtracking([], digit_cnt, result)
        result.sort()
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1027 - https://leetcode.com/problems/longest-arithmetic-sequence/
Time: O(n^2)  Space: O(n^2)   Medium
.Python/longest-arithmetic-sequence.py


```python
# Time:  O(n^2)
# Space: O(n^2)

import collections

class Solution(object):
    def longestArithSeqLength(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        dp = collections.defaultdict(int)
        for i in xrange(len(A)-1):
            for j in xrange(i+1, len(A)):
                v =  A[j]-A[i]
                dp[v, j] = max(dp[v, j], dp[v, i]+1)
        return max(dp.values())+1

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1035 - https://leetcode.com/problems/uncrossed-lines/
Time: O(m * n)  Space: O(min(m, n))   Medium
.Python/uncrossed-lines.py


```python
# Time:  O(m * n)
# Space: O(min(m, n))

class Solution(object):
    def maxUncrossedLines(self, A, B):
        """
        :type A: List[int]
        :type B: List[int]
        :rtype: int
        """
        if len(A) &lt; len(B):
            return self.maxUncrossedLines(B, A)

        dp = [[0 for _ in xrange(len(B)+1)] for _ in xrange(2)]
        for i in xrange(len(A)):
            for j in xrange(len(B)):
                dp[(i+1)%2][j+1] = max(dp[i%2][j] + int(A[i] == B[j]),
                                       dp[i%2][j+1],
                                       dp[(i+1)%2][j])
        return dp[len(A)%2][len(B)]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1039 - https://leetcode.com/problems/minimum-score-triangulation-of-polygon/
Time: O(n^3)  Space: O(n^2)   Medium
.Python/minimum-score-triangulation-of-polygon.py


```python
# Time:  O(n^3)
# Space: O(n^2)

class Solution(object):
    def minScoreTriangulation(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        dp = [[0 for _ in xrange(len(A))] for _ in xrange(len(A))]
        for p in xrange(3, len(A)+1):
            for i in xrange(len(A)-p+1):
                j = i+p-1;
                dp[i][j] = float("inf")
                for k in xrange(i+1, j):
                    dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j] + A[i]*A[j]*A[k])
        return dp[0][-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1043 - https://leetcode.com/problems/partition-array-for-maximum-sum/
Time: O(n * k)  Space: O(k)   Medium
.Python/partition-array-for-maximum-sum.py


```python
# Time:  O(n * k)
# Space: O(k)

class Solution(object):
    def maxSumAfterPartitioning(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: int
        """
        W = K+1
        dp = [0]*W
        for i in xrange(len(A)):
            curr_max = 0
            # dp[i % W] = 0;  # no need in this problem
            for k in xrange(1, min(K, i+1) + 1):
                curr_max = max(curr_max, A[i-k+1])
                dp[i % W] = max(dp[i % W], (dp[(i-k) % W] if i &gt;= k else 0) + curr_max*k)
        return dp[(len(A)-1) % W]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1048 - https://leetcode.com/problems/longest-string-chain/
Time: O(n * l^2)  Space: O(n * l)   Medium
.Python/longest-string-chain.py


```python
# Time:  O(n * l^2)
# Space: O(n * l)

import collections


class Solution(object):
    def longestStrChain(self, words):
        """
        :type words: List[str]
        :rtype: int
        """
        words.sort(key=len)
        dp = collections.defaultdict(int)
        for w in words:
            for i in xrange(len(w)):
                dp[w] = max(dp[w], dp[w[:i]+w[i+1:]]+1)
        return max(dp.itervalues())

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1049 - https://leetcode.com/problems/last-stone-weight-ii/
Time: O(2^n)  Space: O(2^n)   Medium
.Python/last-stone-weight-ii.py


```python
# Time:  O(2^n)
# Space: O(2^n)

class Solution(object):
    def lastStoneWeightII(self, stones):
        """
        :type stones: List[int]
        :rtype: int
        """
        dp = {0}
        for stone in stones:
            dp |= {stone+i for i in dp}
        S = sum(stones)
        return min(abs(i-(S-i)) for i in dp)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1066 - https://leetcode.com/problems/campus-bikes-ii/
Time: O(w * b * 2^b)  Space: O(w * b * 2^b)   Medium
.Python/campus-bikes-ii.py


```python
# Time:  O(w * b * 2^b)
# Space: O(b * 2^b)

# if w = b, we can even apply Hungarian algorithm (see https://en.wikipedia.org/wiki/Hungarian_algorithm),
# it can be improved to O(w^3), see https://github.com/t3nsor/codebook/blob/master/bipartite-mincost.cpp
class Solution(object):  # this is slower than Solution2 in python
    def assignBikes(self, workers, bikes):
        """
        :type workers: List[List[int]]
        :type bikes: List[List[int]]
        :rtype: int
        """
        def manhattan(p1, p2):
            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
        
        dp = [[float("inf")]*((1&lt;&lt;len(bikes))) for _ in xrange(2)]
        dp[0][0] = 0
        for i in xrange(len(workers)):
            dp[(i+1)%2] = [float("inf")] * ((1&lt;&lt;len(bikes)))
            for j in xrange(len(bikes)):
                for taken in xrange((1&lt;&lt;len(bikes))):
                    if taken &amp; (1&lt;&lt;j):
                        continue
                    dp[(i+1)%2][taken|(1&lt;&lt;j)] = \
                        min(dp[(i+1)%2][taken|(1&lt;&lt;j)],
                            dp[i%2][taken] +
                            manhattan(workers[i], bikes[j]))
        return min(dp[len(workers)%2])


# Time:  O((w * b * 2^b) * log(w * b * 2^b))
# Space: O(w * b * 2^b)
import heapq


class Solution2(object):
    def assignBikes(self, workers, bikes):
        """
        :type workers: List[List[int]]
        :type bikes: List[List[int]]
        :rtype: int
        """
        def manhattan(p1, p2):
            return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])
        
        min_heap = [(0, 0, 0)]
        lookup = set()
        while min_heap:
            cost, i, taken = heapq.heappop(min_heap)
            if (i, taken) in lookup:
                continue
            lookup.add((i, taken))
            if i == len(workers):
                return cost
            for j in xrange(len(bikes)):
                if taken &amp; (1&lt;&lt;j):
                    continue
                heapq.heappush(min_heap, (cost+manhattan(workers[i], bikes[j]),  # O(b)
                                          i+1,            # O(w)
                                          taken|(1&lt;&lt;j)))  # O(2^b)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1092 - https://leetcode.com/problems/shortest-common-supersequence/
Time: O(m * n)  Space: O(m * n)   Hard
.Python/shortest-common-supersequence.py


```python
# Time:  O(m * n)
# Space: O(m * n)

class Solution(object):
    def shortestCommonSupersequence(self, str1, str2):
        """
        :type str1: str
        :type str2: str
        :rtype: str
        """
        dp = [[0 for _ in xrange(len(str2)+1)] for _ in xrange(2)]
        bt = [[None for _ in xrange(len(str2)+1)] for _ in xrange(len(str1)+1)]
        for i, c in enumerate(str1):
            bt[i+1][0] = (i, 0, c)
        for j, c in enumerate(str2):
            bt[0][j+1] = (0, j, c)
        for i in xrange(len(str1)):
            for j in xrange(len(str2)):
                if dp[i % 2][j+1] &gt; dp[(i+1) % 2][j]:
                    dp[(i+1) % 2][j+1] = dp[i % 2][j+1]
                    bt[i+1][j+1] = (i, j+1, str1[i])
                else:
                    dp[(i+1) % 2][j+1] = dp[(i+1) % 2][j]
                    bt[i+1][j+1] = (i+1, j, str2[j])
                if str1[i] != str2[j]:
                    continue
                if dp[i % 2][j]+1 &gt; dp[(i+1) % 2][j+1]:
                    dp[(i+1) % 2][j+1] = dp[i % 2][j]+1
                    bt[i+1][j+1] = (i, j, str1[i])
        
        i, j = len(str1), len(str2)
        result = []
        while i != 0 or j != 0:
            i, j, c = bt[i][j]
            result.append(c)
        result.reverse()
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1105 - https://leetcode.com/problems/filling-bookcase-shelves/
Time: O(n^2)  Space: O(n)   Medium
.Python/filling-bookcase-shelves.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def minHeightShelves(self, books, shelf_width):
        """
        :type books: List[List[int]]
        :type shelf_width: int
        :rtype: int
        """
        dp = [float("inf") for _ in xrange(len(books)+1)]
        dp[0] = 0
        for i in xrange(1, len(books)+1):
            max_width = shelf_width
            max_height = 0
            for j in reversed(xrange(i)):
                if max_width-books[j][0] &lt; 0:
                    break
                max_width -= books[j][0]
                max_height = max(max_height, books[j][1])
                dp[i] = min(dp[i], dp[j]+max_height)
        return dp[len(books)]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1125 - https://leetcode.com/problems/smallest-sufficient-team/
Time: O(m * 2^n)  Space: O(2^n)   Hard
.Python/smallest-sufficient-team.py


```python
# Time:  O(m * 2^n), n is the number of skills
#                    m is the number of people
# Space: O(2^n)

class Solution(object):
    def smallestSufficientTeam(self, req_skills, people):
        """
        :type req_skills: List[str]
        :type people: List[List[str]]
        :rtype: List[int]
        """
        lookup = {v: i for i, v in enumerate(req_skills)}
        dp = {0: []}
        for i, p in enumerate(people):
            his_skill_set = 0
            for skill in p:
                if skill in lookup:
                    his_skill_set |= 1 &lt;&lt; lookup[skill]
            for skill_set, people in dp.items():
                with_him = skill_set | his_skill_set
                if with_him == skill_set: continue
                if with_him not in dp or \
                   len(dp[with_him]) &gt; len(people)+1:
                    dp[with_him] = people + [i]
        return dp[(1&lt;&lt;len(req_skills))-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1137 - https://leetcode.com/problems/n-th-tribonacci-number/
Time: O(logn)  Space: O(1)   Easy
.Python/n-th-tribonacci-number.py


```python
# Time:  O(logn)
# Space: O(1)

import itertools


class Solution(object):
    def tribonacci(self, n):
        """
        :type n: int
        :rtype: int
        """
        def matrix_expo(A, K):
            result = [[int(i==j) for j in xrange(len(A))] \
                      for i in xrange(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = zip(*B)
            return [[sum(a*b for a, b in itertools.izip(row, col)) \
                     for col in ZB] for row in A]

        T = [[1, 1, 0],
             [1, 0, 1],
             [1, 0, 0]]
        return matrix_mult([[1, 0, 0]], matrix_expo(T, n))[0][1]  # [a1, a0, a(-1)] * T^n
    
    
# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def tribonacci(self, n):
        """
        :type n: int
        :rtype: int
        """
        a, b, c = 0, 1, 1
        for _ in xrange(n):
            a, b, c = b, c, a+b+c
        return a

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1139 - https://leetcode.com/problems/largest-1-bordered-square/
Time: O(n^3)  Space: O(n^2)   Medium
.Python/largest-1-bordered-square.py


```python
# Time:  O(n^3)
# Space: O(n^2)

class Solution(object):
    def largest1BorderedSquare(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        top, left = [a[:] for a in grid], [a[:] for a in grid]
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if not grid[i][j]:
                    continue
                if i:
                    top[i][j] = top[i-1][j] + 1
                if j:
                    left[i][j] = left[i][j-1] + 1
        for l in reversed(xrange(1, min(len(grid), len(grid[0]))+1)):
            for i in xrange(len(grid)-l+1):
                for j in xrange(len(grid[0])-l+1):
                    if min(top[i+l-1][j],
                           top[i+l-1][j+l-1],
                           left[i][j+l-1],
                           left[i+l-1][j+l-1]) &gt;= l:
                        return l*l
        return 0

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1140 - https://leetcode.com/problems/stone-game-ii/
Time: O(n*(logn)^2)  Space: O(nlogn)   Medium
.Python/stone-game-ii.py


```python
# Time:  O(n*(logn)^2)
# Space: O(nlogn)

class Solution(object):
    def stoneGameII(self, piles):
        """
        :type piles: List[int]
        :rtype: int
        """
        def dp(piles, lookup, i, m):
            if i+2*m &gt;= len(piles):
                return piles[i]
            if (i, m) not in lookup:
                lookup[i, m] = piles[i] - \
                               min(dp(piles, lookup, i+x, max(m, x))
                                   for x in xrange(1, 2*m+1))
            return lookup[i, m]

        for i in reversed(xrange(len(piles)-1)):
            piles[i] += piles[i+1]
        return dp(piles, {}, 0, 1)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1143 - https://leetcode.com/problems/longest-common-subsequence/
Time: O(m * n)  Space: O(min(m, n))   Medium
.Python/longest-common-subsequence.py


```python
# Time:  O(m * n)
# Space: O(min(m, n))

class Solution(object):
    def longestCommonSubsequence(self, text1, text2):
        """
        :type text1: str
        :type text2: str
        :rtype: int
        """
        if len(text1) &lt; len(text2):
            return self.longestCommonSubsequence(text2, text1)

        dp = [[0 for _ in xrange(len(text2)+1)] for _ in xrange(2)]
        for i in xrange(1, len(text1)+1):
            for j in xrange(1, len(text2)+1):
                dp[i%2][j] = dp[(i-1)%2][j-1]+1 if text1[i-1] == text2[j-1] \
                             else max(dp[(i-1)%2][j], dp[i%2][j-1])
        return dp[len(text1)%2][len(text2)]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1155 - https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/
Time: O(d * f * t)  Space: O(t)   Medium
.Python/number-of-dice-rolls-with-target-sum.py


```python
# Time:  O(d * f * t)
# Space: O(t)

class Solution(object):
    def numRollsToTarget(self, d, f, target):
        """
        :type d: int
        :type f: int
        :type target: int
        :rtype: int
        """
        MOD = 10**9+7
        dp = [[0 for _ in xrange(target+1)] for _ in xrange(2)]
        dp[0][0] = 1
        for i in xrange(1, d+1):
            dp[i%2] = [0 for _ in xrange(target+1)]
            for k in xrange(1, f+1):
                for j in xrange(k, target+1):
                    dp[i%2][j] = (dp[i%2][j] + dp[(i-1)%2][j-k]) % MOD
        return dp[d%2][target] % MOD

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1182 - https://leetcode.com/problems/shortest-distance-to-target-color/
Time: O(n)  Space: O(n)   Medium
.Python/shortest-distance-to-target-color.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def shortestDistanceColor(self, colors, queries):
        """
        :type colors: List[int]
        :type queries: List[List[int]]
        :rtype: List[int]
        """
        dp = [[-1 for _ in xrange(len(colors))] for _ in xrange(3)]
        dp[colors[0]-1][0] = 0
        for i in xrange(1, len(colors)):
            for color in xrange(3):
                dp[color][i] = dp[color][i-1]
            dp[colors[i]-1][i] = i

        dp[colors[len(colors)-1]-1][len(colors)-1] = len(colors)-1
        for i in reversed(xrange(len(colors)-1)):
            for color in xrange(3):
                if dp[color][i+1] == -1:
                    continue
                if dp[color][i] == -1 or \
                   abs(dp[color][i+1]-i) &lt; abs(dp[color][i]-i):
                    dp[color][i] = dp[color][i+1]
            dp[colors[i]-1][i] = i
         
        return [abs(dp[color-1][i]-i) if dp[color-1][i] != -1 else -1 \
                    for i, color in queries]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1186 - https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-subarray-sum-with-one-deletion.py


```python
class Solution(object):
    def maximumSum(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        result, prev, curr = float("-inf"), float("-inf"), float("-inf")
        for x in arr:
            curr = max(prev, curr+x, x)
            result = max(result, curr)
            prev = max(prev+x, x)
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1187 - https://leetcode.com/problems/make-array-strictly-increasing/
Time: O(n^2 * logn)  Space: O(n)   Hard
.Python/make-array-strictly-increasing.py


```python
# Time:  O(n^2 * logn)
# Space: O(n)

import collections
import bisect


class Solution(object):
    def makeArrayIncreasing(self, arr1, arr2):
        """
        :type arr1: List[int]
        :type arr2: List[int]
        :rtype: int
        """
        arr2 = sorted(set(arr2))
        dp = {0: -1}  # dp[min_cost] = end_with_val
        for val1 in arr1:
            next_dp = collections.defaultdict(lambda: float("inf"))
            for cost, val in dp.iteritems():
                if val &lt; val1:
                    next_dp[cost] = min(next_dp[cost], val1)
                k = bisect.bisect_right(arr2, val)
                if k == len(arr2):
                    continue
                next_dp[cost+1] = min(next_dp[cost+1], arr2[k])
            dp = next_dp
            if not dp:
                return -1
        return min(dp.iterkeys())

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1191 - https://leetcode.com/problems/k-concatenation-maximum-sum/
Time: O(n)  Space: O(1)   Medium
.Python/k-concatenation-maximum-sum.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def kConcatenationMaxSum(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: int
        """
        def max_sub_k_array(arr, k):
            result, curr = float("-inf"), float("-inf")
            for _ in xrange(k):
                for x in arr:
                    curr = max(curr+x, x)
                    result = max(result, curr)
            return result
        
        MOD = 10**9+7
        if k == 1:
            return max(max_sub_k_array(arr, 1), 0) % MOD
        return (max(max_sub_k_array(arr, 2), 0) + (k-2)*max(sum(arr), 0)) % MOD

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1216 - https://leetcode.com/problems/valid-palindrome-iii/
Time: O(n^2)  Space: O(n)   Hard
.Python/valid-palindrome-iii.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def isValidPalindrome(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: bool
        """
        if s == s[::-1]:  # optional, to optimize special case
            return True

        dp = [[1] * len(s) for _ in xrange(2)]
        for i in reversed(xrange(len(s))):
            for j in xrange(i+1, len(s)):
                if s[i] == s[j]:
                    dp[i%2][j] = 2 + dp[(i+1)%2][j-1] if i+1 &lt;= j-1 else 2
                else:
                    dp[i%2][j] = max(dp[(i+1)%2][j], dp[i%2][j-1])
        return len(s) &lt;= k + dp[0][-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1218 - https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/
Time: O(n)  Space: O(n)   Medium
.Python/longest-arithmetic-subsequence-of-given-difference.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def longestSubsequence(self, arr, difference):
        """
        :type arr: List[int]
        :type difference: int
        :rtype: int
        """
        result = 1
        lookup = collections.defaultdict(int)
        for i in xrange(len(arr)):
            lookup[arr[i]] = lookup[arr[i]-difference] + 1
            result = max(result, lookup[arr[i]])
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1220 - https://leetcode.com/problems/count-vowels-permutation/
Time: O(logn)  Space: O(1)   Hard
.Python/count-vowels-permutation.py


```python
# Time:  O(logn)
# Space: O(1)

import itertools


class Solution(object):
    def countVowelPermutation(self, n):
        """
        :type n: int
        :rtype: int
        """
        def matrix_expo(A, K):
            result = [[int(i==j) for j in xrange(len(A))] \
                      for i in xrange(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = zip(*B)
            return [[sum(a*b for a, b in itertools.izip(row, col)) % MOD \
                     for col in ZB] for row in A]
        
        MOD = 10**9 + 7
        T = [[0, 1, 1, 0, 1],
             [1, 0, 1, 0, 0],
             [0, 1, 0, 1, 0],
             [0, 0, 1, 0, 0],
             [0, 0, 1, 1, 0]]
        return sum(map(sum, matrix_expo(T, n-1))) % MOD


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def countVowelPermutation(self, n):
        """
        :type n: int
        :rtype: int
        """
        MOD = 10**9 + 7
        a, e, i, o, u = 1, 1, 1, 1, 1
        for _ in xrange(1, n):
            a, e, i, o, u = (e+i+u) % MOD, (a+i) % MOD, (e+o) % MOD, i, (i+o) % MOD
        return (a+e+i+o+u) % MOD

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1223 - https://leetcode.com/problems/dice-roll-simulation/
Time: O(m * n)  Space: O(m)   Medium
.Python/dice-roll-simulation.py


```python
# Time:  O(m * n), m is the max of rollMax
# Space: O(m)

class Solution(object):
    def dieSimulator(self, n, rollMax):
        """
        :type n: int
        :type rollMax: List[int]
        :rtype: int
        """
        MOD = 10**9+7
        def sum_mod(array):
            return reduce(lambda x, y: (x+y)%MOD, array)

        dp = [[1] + [0]*(rollMax[i]-1) for i in xrange(6)]  # 0-indexed
        for _ in xrange(n-1):
            new_dp = [[0]*rollMax[i] for i in xrange(6)]
            for i in xrange(6):
                for k in xrange(rollMax[i]):
                    for j in xrange(6):
                        if i == j:
                            if k &lt; rollMax[i]-1:  # 0-indexed
                                new_dp[j][k+1] = (new_dp[j][k+1]+dp[i][k])%MOD
                        else:
                            new_dp[j][0] = (new_dp[j][0]+dp[i][k])%MOD
            dp = new_dp
        return sum_mod(sum_mod(row) for row in dp)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1230 - https://leetcode.com/problems/toss-strange-coins/
Time: O(n^2)  Space: O(n)   Medium
.Python/toss-strange-coins.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def probabilityOfHeads(self, prob, target):
        """
        :type prob: List[float]
        :type target: int
        :rtype: float
        """
        dp = [0.0]*(target+1)
        dp[0] = 1.0
        for p in prob:
            for i in reversed(xrange(target+1)):
                dp[i] = (dp[i-1] if i &gt;= 1 else 0.0)*p + dp[i]*(1-p)
        return dp[target]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1235 - https://leetcode.com/problems/maximum-profit-in-job-scheduling/
Time: O(nlogn)  Space: O(n)   Hard
.Python/maximum-profit-in-job-scheduling.py


```python
# Time:  O(nlogn)
# Space: O(n)

import itertools
import bisect


class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        """
        :type startTime: List[int]
        :type endTime: List[int]
        :type profit: List[int]
        :rtype: int
        """
        jobs = sorted(itertools.izip(endTime, startTime, profit))
        dp = [(0, 0)]
        for e, s, p in jobs:
            i = bisect.bisect_right(dp, (s+1, 0))-1
            if dp[i][1]+p &gt; dp[-1][1]:
                dp.append((e, dp[i][1]+p))
        return dp[-1][1]


# Time:  O(nlogn)
# Space: O(n)
import heapq
class Solution(object):
    def jobScheduling(self, startTime, endTime, profit):
        """
        :type startTime: List[int]
        :type endTime: List[int]
        :type profit: List[int]
        :rtype: int
        """
        min_heap = zip(startTime, endTime, profit)
        heapq.heapify(min_heap)
        result = 0
        while min_heap:
            s, e, p = heapq.heappop(min_heap)
            if s &lt; e:
                heapq.heappush(min_heap, (e, s, result+p))
            else:
                result = max(result, p)
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1239 - https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/
Time: O(n) ~ O(2^n)  Space: O(1) ~ O(2^n)   Medium
.Python/maximum-length-of-a-concatenated-string-with-unique-characters.py


```python
# Time:  O(n) ~ O(2^n)
# Space: O(1) ~ O(2^n)

power = [1]
log2 = {1:0}
for i in xrange(1, 26):
    power.append(power[-1]&lt;&lt;1)
    log2[power[i]] = i


class Solution(object):
    def maxLength(self, arr):
        """
        :type arr: List[str]
        :rtype: int
        """
        def bitset(s):
            result = 0
            for c in s:
                if result &amp; power[ord(c)-ord('a')]:
                    return 0
                result |= power[ord(c)-ord('a')]
            return result
        
        def number_of_one(n):
            result = 0
            while n:
                n &amp;= n-1
                result += 1
            return result

        dp = [0]
        for x in arr:
            x_set = bitset(x)
            if not x_set:
                continue
            curr_len = len(dp)
            for i in xrange(curr_len):
                if dp[i] &amp; x_set:
                    continue
                dp.append(dp[i] | x_set)
        return max(number_of_one(s_set) for s_set in dp)


# Time:  O(2^n)
# Space: O(1)
class Solution2(object):
    def maxLength(self, arr):
        """
        :type arr: List[str]
        :rtype: int
        """ 
        def bitset(s):
            result = 0
            for c in s:
                if result &amp; power[ord(c)-ord('a')]:
                    return 0
                result |= power[ord(c)-ord('a')]
            return result
    
        bitsets = [bitset(x) for x in arr]
        result = 0
        for i in xrange(power[len(arr)]):
            curr_bitset, curr_len = 0, 0
            while i:
                j = i &amp; -i  # rightmost bit
                i ^= j
                j = log2[j]  # log2(j)
                if not bitsets[j] or (curr_bitset &amp; bitsets[j]):
                    break
                curr_bitset |= bitsets[j]
                curr_len += len(arr[j])
            else:
                result = max(result, curr_len)
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1246 - https://leetcode.com/problems/palindrome-removal/
Time: O(n^3)  Space: O(n^2)   Hard
.Python/palindrome-removal.py


```python
# Time:  O(n^3)
# Space: O(n^2)

class Solution(object):
    def minimumMoves(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        dp = [[0 for _ in xrange(len(arr)+1)] for _ in xrange(len(arr)+1)]
        for l in xrange(1, len(arr)+1):
            for i in xrange(len(arr)-l+1):
                j = i+l-1
                if l == 1:
                    dp[i][j] = 1
                else:
                    dp[i][j] = 1+dp[i+1][j]
                    if arr[i] == arr[i+1]:
                        dp[i][j] = min(dp[i][j], 1+dp[i+2][j])
                    for k in xrange(i+2, j+1):
                        if arr[i] == arr[k]:
                            dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k+1][j])
        return dp[0][len(arr)-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1262 - https://leetcode.com/problems/greatest-sum-divisible-by-three/
Time: O(n)  Space: O(1)   Medium
.Python/greatest-sum-divisible-by-three.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxSumDivThree(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dp = [0, 0, 0]
        for num in nums:
            for i in [num+x for x in dp]:
                dp[i%3] = max(dp[i%3], i)
        return dp[0]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1269 - https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/
Time: O(n^2)  Space: O(n)   Hard
.Python/number-of-ways-to-stay-in-the-same-place-after-some-steps.py


```python
# Time:  O(n^2), n is the number of steps
# Space: O(n)
    
class Solution(object):
    def numWays(self, steps, arrLen):
        """
        :type steps: int
        :type arrLen: int
        :rtype: int
        """
        MOD = int(1e9+7)
        l = min(1+steps//2, arrLen)
        dp = [0]*(l+2)
        dp[1] = 1
        while steps &gt; 0:
            steps -= 1
            new_dp = [0]*(l+2)
            for i in xrange(1, l+1):
                new_dp[i] = (dp[i] + dp[i-1] + dp[i+1]) % MOD
            dp = new_dp
        return dp[1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1277 - https://leetcode.com/problems/count-square-submatrices-with-all-ones/
Time: O(m * n)  Space: O(1)   Medium
.Python/count-square-submatrices-with-all-ones.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def countSquares(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: int
        """
        for i in xrange(1, len(matrix)):
            for j in xrange(1, len(matrix[0])):
                if not matrix[i][j]:
                    continue
                l = min(matrix[i-1][j], matrix[i][j-1])
                matrix[i][j] = l+1 if matrix[i-l][j-l] else l
        return sum(x for row in matrix for x in row)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1278 - https://leetcode.com/problems/palindrome-partitioning-iii/
Time: O(k * n^2)  Space: O(n^2)   Hard
.Python/palindrome-partitioning-iii.py


```python
# Time:  O(k * n^2)
# Space: O(n^2)

class Solution(object):
    def palindromePartition(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: int
        """
        # dp1[i][j]: minimum number of changes to make s[i, j] palindrome
        dp1 = [[0]*len(s) for _ in xrange(len(s))]
        for l in xrange(1, len(s)+1):
            for i in xrange(len(s)-l+1):
                j = i+l-1
                if i == j-1:
                    dp1[i][j] = 0 if s[i] == s[j] else 1
                elif i != j:
                    dp1[i][j] = dp1[i+1][j-1] if s[i] == s[j] else dp1[i+1][j-1]+1

        # dp2[d][i]: minimum number of changes to divide s[0, i] into d palindromes
        dp2 = [[float("inf")]*len(s) for _ in xrange(2)]
        dp2[1] = dp1[0][:]
        for d in xrange(2, k+1):
            dp2[d%2] = [float("inf")]*len(s)
            for i in xrange(d-1, len(s)):  
                for j in xrange(d-2, i):
                    dp2[d%2][i] = min(dp2[d%2][i], dp2[(d-1)%2][j]+dp1[j+1][i])
        return dp2[k%2][len(s)-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1289 - https://leetcode.com/problems/minimum-falling-path-sum-ii/
Time: O(m * n)  Space: O(1)   Hard
.Python/minimum-falling-path-sum-ii.py


```python
# Time:  O(m * n)
# Space: O(1)

import heapq


class Solution(object):
    def minFallingPathSum(self, arr):
        """
        :type arr: List[List[int]]
        :rtype: int
        """
        for i in xrange(1, len(arr)):
            smallest_two = heapq.nsmallest(2, arr[i-1])
            for j in xrange(len(arr[0])):
                arr[i][j] += smallest_two[1] if arr[i-1][j] == smallest_two[0] else smallest_two[0]
        return min(arr[-1])

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1292 - https://leetcode.com/problems/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold/
Time: O(m * n * log(min(m, n)))  Space: O(m * n)   Medium
.Python/maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold.py


```python
# Time:  O(m * n * log(min(m, n)))
# Space: O(m * n)

class Solution(object):
    def maxSideLength(self, mat, threshold):
        """
        :type mat: List[List[int]]
        :type threshold: int
        :rtype: int
        """
        def check(dp, mid, threshold):
            for i in xrange(mid, len(dp)):
                for j in xrange(mid, len(dp[0])):
                    if dp[i][j] - dp[i-mid][j] - dp[i][j-mid] + dp[i-mid][j-mid] &lt;= threshold:
                        return True
            return False
        
        dp = [[0 for _ in xrange(len(mat[0])+1)] for _ in xrange(len(mat)+1)]
        for i in xrange(1, len(mat)+1):
            for j in xrange(1, len(mat[0])+1):
                dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + mat[i-1][j-1]

        left, right = 0, min(len(mat), len(mat[0])+1)
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(dp, mid, threshold):
                right = mid-1
            else:
                left = mid+1
        return right

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1301 - https://leetcode.com/problems/number-of-paths-with-max-score/
Time: O(n^2)  Space: O(n)   Hard
.Python/number-of-paths-with-max-score.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def pathsWithMaxScore(self, board):
        """
        :type board: List[str]
        :rtype: List[int]
        """
        MOD = 10**9+7
        directions = [[1, 0], [0, 1], [1, 1]]
        dp = [[[0, 0] for r in xrange(len(board[0])+1)]
              for r in xrange(2)]
        dp[(len(board)-1)%2][len(board[0])-1] = [0, 1]
        for r in reversed(xrange(len(board))):
            for c in reversed(xrange(len(board[0]))):
                if board[r][c] in "XS":
                    continue
                dp[r%2][c] = [0, 0]
                for dr, dc in directions:
                    if dp[r%2][c][0] &lt; dp[(r+dr)%2][c+dc][0]:
                        dp[r%2][c] = dp[(r+dr)%2][c+dc][:]
                    elif dp[r%2][c][0] == dp[(r+dr)%2][c+dc][0]:
                        dp[r%2][c][1] = (dp[r%2][c][1]+dp[(r+dr)%2][c+dc][1]) % MOD
                if dp[r%2][c][1] and board[r][c] != 'E':
                    dp[r%2][c][0] += int(board[r][c])
        return dp[0][0]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1312 - https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/
Time: O(n^2)  Space: O(n)   Hard
.Python/minimum-insertion-steps-to-make-a-string-palindrome.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def minInsertions(self, s):
        """
        :type s: str
        :rtype: int
        """
        def longestCommonSubsequence(text1, text2):
            if len(text1) &lt; len(text2):
                return self.longestCommonSubsequence(text2, text1)
            dp = [[0 for _ in xrange(len(text2)+1)] for _ in xrange(2)]
            for i in xrange(1, len(text1)+1):
                for j in xrange(1, len(text2)+1):
                    dp[i%2][j] = dp[(i-1)%2][j-1]+1 if text1[i-1] == text2[j-1] \
                                 else max(dp[(i-1)%2][j], dp[i%2][j-1])
            return dp[len(text1)%2][len(text2)]

        return len(s)-longestCommonSubsequence(s, s[::-1])

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1314 - https://leetcode.com/problems/matrix-block-sum/
Time: O(m * n)  Space: O(m * n)   Medium
.Python/matrix-block-sum.py


```python
# Time:  O(m * n)
# Space: O(m * n)

class Solution(object):
    def matrixBlockSum(self, mat, K):
        """
        :type mat: List[List[int]]
        :type K: int
        :rtype: List[List[int]]
        """
        m, n = len(mat), len(mat[0])
        accu = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]
        for i in xrange(m):
            for j in xrange(n):
                accu[i+1][j+1] = accu[i+1][j]+accu[i][j+1]-accu[i][j]+mat[i][j]
        result = [[0 for _ in xrange(n)] for _ in xrange(m)]        
        for i in xrange(m):
            for j in xrange(n):
                r1, c1, r2, c2 = max(i-K, 0), max(j-K, 0), min(i+K+1, m), min(j+K+1, n)
                result[i][j] = accu[r2][c2]-accu[r1][c2]-accu[r2][c1]+accu[r1][c1]
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1320 - https://leetcode.com/problems/minimum-distance-to-type-a-word-using-two-fingers/
Time: O(n)  Space: O(1)   Hard
.Python/minimum-distance-to-type-a-word-using-two-fingers.py


```python
# Time:  O(26n)
# Space: O(26)

class Solution(object):
    def minimumDistance(self, word):
        """
        :type word: str
        :rtype: int
        """
        def distance(a, b):
            return abs(a//6 - b//6) + abs(a%6 - b%6)

        dp = [0]*26
        for i in xrange(len(word)-1):
            b, c = ord(word[i])-ord('A'), ord(word[i+1])-ord('A')
            dp[b] = max(dp[a] - distance(a, c) + distance(b, c) for a in xrange(26))
        return sum(distance(ord(word[i])-ord('A'), ord(word[i+1])-ord('A')) for i in xrange(len(word)-1)) - max(dp)


# Time:  O(52n)
# Space: O(52)
class Solution2(object):
    def minimumDistance(self, word):
        """
        :type word: str
        :rtype: int
        """
        def distance(a, b):
            if -1 in [a, b]:
                return 0
            return abs(a//6 - b//6) + abs(a%6 - b%6)

        dp = {(-1, -1): 0}
        for c in word:
            c = ord(c)-ord('A')
            new_dp = {}
            for a, b in dp:
                new_dp[c, b] = min(new_dp.get((c, b), float("inf")), dp[a, b] + distance(a, c))
                new_dp[a, c] = min(new_dp.get((a, c), float("inf")), dp[a, b] + distance(b, c))
            dp = new_dp
        return min(dp.itervalues())

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1335 - https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/
Time: O(d * n^2)  Space: O(d * n)   Hard
.Python/minimum-difficulty-of-a-job-schedule.py


```python
# Time:  O(d * n^2)
# Space: O(d * n)

class Solution(object):
    def minDifficulty(self, jobDifficulty, d):
        """
        :type jobDifficulty: List[int]
        :type d: int
        :rtype: int
        """
        if len(jobDifficulty) &lt; d:
            return -1;
        
        dp = [[float("inf")]*len(jobDifficulty) for _ in xrange(d)]
        dp[0][0] = jobDifficulty[0]
        for i in xrange(1, len(jobDifficulty)):
            dp[0][i] = max(dp[0][i-1], jobDifficulty[i])
        for i in xrange(1, d):
            for j in xrange(i, len(jobDifficulty)):
                curr_max = jobDifficulty[j]
                for k in reversed(xrange(i, j+1)):
                    curr_max = max(curr_max, jobDifficulty[k])
                    dp[i][j] = min(dp[i][j], dp[i-1][k-1] + curr_max)
        return dp[d-1][len(jobDifficulty)-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1340 - https://leetcode.com/problems/jump-game-v/
Time: O(n)  Space: O(n)   Hard
.Python/jump-game-v.py


```python
# Time:  O(n)
# Space: O(n)

import collections
import itertools


# sliding window + top-down dp
class Solution(object):
    def maxJumps(self, arr, d):
        """
        :type arr: List[int]
        :type d: int
        :rtype: int
        """
        def dp(arr, d, i, left, right, lookup):
            if lookup[i]:
                return lookup[i]
            lookup[i] = 1
            for j in itertools.chain(left[i], right[i]):
                # each dp[j] will be visited at most twice 
                lookup[i] = max(lookup[i], dp(arr, d, j, left, right, lookup)+1)
            return lookup[i]

        left, decreasing_dq = [[] for _ in xrange(len(arr))], collections.deque()
        for i in xrange(len(arr)):
            if decreasing_dq and i - decreasing_dq[0] == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] &lt; arr[i]:
                if left[i] and arr[left[i][-1]] != arr[decreasing_dq[-1]]:
                    left[i] = []
                left[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)
        right, decreasing_dq = [[] for _ in xrange(len(arr))], collections.deque()
        for i in reversed(xrange(len(arr))):
            if decreasing_dq and decreasing_dq[0] - i == d+1:
                decreasing_dq.popleft()
            while decreasing_dq and arr[decreasing_dq[-1]] &lt; arr[i]:
                if right[i] and arr[right[i][-1]] != arr[decreasing_dq[-1]]:
                    right[i] = []
                right[i].append(decreasing_dq.pop())
            decreasing_dq.append(i)

        lookup = [0]*len(arr)
        return max(itertools.imap(lambda x: dp(arr, d, x, left, right, lookup), xrange(len(arr))))


# Time:  O(nlogn)
# Space: O(n)
# mono stack + bottom-up dp
class Solution2(object):
    def maxJumps(self, arr, d):
        """
        :type arr: List[int]
        :type d: int
        :rtype: int
        """
        left, decreasing_stk = [[] for _ in xrange(len(arr))], []
        for i in xrange(len(arr)):
            while decreasing_stk and arr[decreasing_stk[-1]] &lt; arr[i]:
                if i - decreasing_stk[-1] &lt;= d:
                    if left[i] and arr[left[i][-1]] != arr[decreasing_stk[-1]]:
                        left[i] = []
                    left[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)
        right, decreasing_stk = [[] for _ in xrange(len(arr))], []
        for i in reversed(xrange(len(arr))):
            while decreasing_stk and arr[decreasing_stk[-1]] &lt; arr[i]:
                if decreasing_stk[-1] - i &lt;= d:
                    if right[i] and arr[right[i][-1]] != arr[decreasing_stk[-1]]:
                        right[i] = []
                    right[i].append(decreasing_stk[-1])
                decreasing_stk.pop()
            decreasing_stk.append(i)

        dp = [0]*len(arr)
        for a, i in sorted([a, i] for i, a in enumerate(arr)):
            dp[i] = 1
            for j in itertools.chain(left[i], right[i]):
                # each dp[j] will be visited at most twice 
                dp[i] = max(dp[i], dp[j]+1)
        return max(dp)


# Template:
# https://github.com/kamyu104/FacebookHackerCup-2018/blob/master/Final%20Round/the_claw.py
class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=max,
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x &lt; self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h):  # Time: O(logN), Space: O(N)
        def pull(x):
            while x &gt; 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])
        L += self.N
        R += self.N
        L0, R0 = L, R
        while L &lt;= R:
            if L &amp; 1:  # is right child
                self.__apply(L, h)
                L += 1
            if R &amp; 1 == 0:  # is left child
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):  # Time: O(logN), Space: O(N)
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = self.default_val
        if L &gt; R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L &lt;= R:
            if L &amp; 1:  # is right child
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R &amp; 1 == 0:  # is left child
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in xrange(self.N):
            showList.append(self.query(i, i))
        return ",".join(map(str, showList))


# Time:  O(nlogn)
# Space: O(n)
# mono stack + bottom-up dp + segment tree
class Solution3(object):
    def maxJumps(self, arr, d):
        """
        :type arr: List[int]
        :type d: int
        :rtype: int
        """
        left, decreasing_stk = range(len(arr)), []
        for i in xrange(len(arr)):
            while decreasing_stk and arr[decreasing_stk[-1]] &lt; arr[i]:
                if i - decreasing_stk[-1] &lt;= d:
                    left[i] = decreasing_stk[-1]
                decreasing_stk.pop()
            decreasing_stk.append(i)
        right, decreasing_stk = range(len(arr)), []
        for i in reversed(xrange(len(arr))):
            while decreasing_stk and arr[decreasing_stk[-1]] &lt; arr[i]:
                if decreasing_stk[-1] - i &lt;= d:
                    right[i] = decreasing_stk[-1]
                decreasing_stk.pop()
            decreasing_stk.append(i)

        segment_tree = SegmentTree(len(arr))
        for _, i in sorted([x, i] for i, x in enumerate(arr)):
            segment_tree.update(i, i, segment_tree.query(left[i], right[i]) + 1)
        return segment_tree.query(0, len(arr)-1)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1387 - https://leetcode.com/problems/sort-integers-by-the-power-value/
Time: O(n) on average  Space: O(n)   Medium
.Python/sort-integers-by-the-power-value.py


```python
# Time:  O(n) on average
# Space: O(n)

import random


class Solution(object):
    dp = {}

    def getKth(self, lo, hi, k):
        """
        :type lo: int
        :type hi: int
        :type k: int
        :rtype: int
        """
        def nth_element(nums, n, compare=lambda a, b: a &lt; b):
            def partition_around_pivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in xrange(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = partition_around_pivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == n:
                    return
                elif new_pivot_idx &gt; n:
                    right = new_pivot_idx - 1
                else:  # new_pivot_idx &lt; n
                    left = new_pivot_idx + 1
                    
        def power_value(x):
            y, result = x, 0
            while x &gt; 1 and x not in Solution.dp:
                result += 1
                if x%2:
                    x = 3*x + 1
                else:
                    x //= 2
            Solution.dp[y] = result + (Solution.dp[x] if x &gt; 1 else 0)
            return Solution.dp[y], y
        
        arr = map(power_value, range(lo, hi+1))
        nth_element(arr, k-1)
        return arr[k-1][1]


# Time:  O(nlogn)
# Space: O(n)
class Solution2(object):
    dp = {}

    def getKth(self, lo, hi, k):
        """
        :type lo: int
        :type hi: int
        :type k: int
        :rtype: int
        """
        def power_value(x):
            y, result = x, 0
            while x &gt; 1 and x not in Solution2.dp:
                result += 1
                if x%2:
                    x = 3*x + 1
                else:
                    x //= 2
            Solution2.dp[y] = result + (Solution2.dp[x] if x &gt; 1 else 0)
            return Solution2.dp[y], y
        
        return sorted(range(lo, hi+1), key=power_value)[k-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1388 - https://leetcode.com/problems/pizza-with-3n-slices/
Time: O(n^2)  Space: O(n)   Hard
.Python/pizza-with-3n-slices.py


```python
# Time:  O(n^2)
# Space: O(n)

# [observation]
# 1. we can never take two adjacent slices
# 2. if we want some set of N / 3 non-adjacent slices, there is always a way to take
#
# [proof]
# - for N = 3, it is obviously true.
# - for N' = N + 3,
#   - because it's impossible to have only one unwanted slices between all wanted slices.
#     if it's true, there will be 3N'/2 unwanted slices rather than 2N' unwanted ones, -&gt;&lt;-
#   - so we can always find a sequence of two unwanted slices with one wanted slice
#     to take firstly, then we can find a way to take the remaining N ones by induction, QED

# better optimized space
class Solution(object):
    def maxSizeSlices(self, slices):
        """
        :type slices: List[int]
        :rtype: int
        """
        def maxSizeSlicesLinear(slices, start, end):
            dp = [[0]*(len(slices)//3+1) for _ in xrange(2)]
            for i in xrange(start, end):
                for j in reversed(xrange(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1)):
                    dp[i%2][j] = max(dp[(i-1)%2][j], dp[(i-2)%2][j-1] + slices[i])
            return dp[(end-1)%2][len(slices)//3]
        
        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),
                   maxSizeSlicesLinear(slices, 1, len(slices)))


# Time:  O(n^2)
# Space: O(n)
class Solution2(object):
    def maxSizeSlices(self, slices):
        """
        :type slices: List[int]
        :rtype: int
        """
        def maxSizeSlicesLinear(slices, start, end):
            dp = [[0]*(len(slices)//3+1) for _ in xrange(3)]
            for i in xrange(start, end):
                for j in xrange(1, min(((i-start+1)-1)//2+1, len(slices)//3)+1):
                    dp[i%3][j] = max(dp[(i-1)%3][j], dp[(i-2)%3][j-1] + slices[i])
            return dp[(end-1)%3][len(slices)//3]
        
        return max(maxSizeSlicesLinear(slices, 0, len(slices)-1),
                   maxSizeSlicesLinear(slices, 1, len(slices)))

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1395 - https://leetcode.com/problems/count-number-of-teams/
Time: O(n^2)  Space: O(1)   Medium
.Python/count-number-of-teams.py


```python
# Time:  O(n^2)
# Space: O(1)

class Solution(object):
    def numTeams(self, rating):
        """
        :type rating: List[int]
        :rtype: int
        """
        result = 0
        for i in xrange(1, len(rating)-1):
            less, greater = [0]*2, [0]*2
            for j in xrange(len(rating)):
                if rating[i] &gt; rating[j]:
                    less[i &lt; j] += 1
                if rating[i] &lt; rating[j]:
                    greater[i &lt; j] += 1
            result += less[0]*greater[1] + greater[0]*less[1]
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1397 - https://leetcode.com/problems/find-all-good-strings/
Time: O(m * n)  Space: O(m)   Hard
.Python/find-all-good-strings.py


```python
# Time:  O(m * n)
# Space: O(m)

class Solution(object):
    def findGoodStrings(self, n, s1, s2, evil):
        """
        :type n: int
        :type s1: str
        :type s2: str
        :type evil: str
        :rtype: int
        """
        MOD = 10**9+7
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in xrange(1, len(pattern)):
                while j != -1 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
    
        prefix = getPrefix(evil)
        dp = [[[[0]*len(evil) for _ in xrange(2)] for _ in xrange(2)] for _ in xrange(2)]
        dp[0][0][0][0] = 1
        for i in xrange(n):
            dp[(i+1)%2] = [[[0]*len(evil) for _ in xrange(2)] for _ in xrange(2)]
            for j in xrange(2):
                for k in xrange(2):
                    min_c = 'a' if j else s1[i]
                    max_c = 'z' if k else s2[i]
                    for l in xrange(len(evil)):
                        if not dp[i%2][j][k][l]:
                            continue
                        for c in xrange(ord(min_c)-ord('a'), ord(max_c)-ord('a')+1):
                            c = chr(c+ord('a'))
                            m = l-1
                            while m != -1 and evil[m+1] != c:
                                m = prefix[m]
                            if evil[m+1] == c:
                                m += 1
                            if m+1 == len(evil):
                                continue
                            dp[(i+1)%2][j or (s1[i] != c)][k or (s2[i] != c)][m+1] = \
                                (dp[(i+1)%2][j or (s1[i] != c)][k or (s2[i] != c)][m+1] + dp[i%2][j][k][l]) % MOD
        result = 0
        for j in xrange(2):
            for k in xrange(2):
                for l in xrange(len(evil)):
                    result = (result + dp[n%2][j][k][l]) % MOD
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1406 - https://leetcode.com/problems/stone-game-iii/
Time: O(n)  Space: O(1)   Hard
.Python/stone-game-iii.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def stoneGameIII(self, stoneValue):
        """
        :type stoneValue: List[int]
        :rtype: str
        """
        dp = [float("-inf")]*3
        dp[len(stoneValue)%3] = 0
        for i in reversed(xrange(len(stoneValue))):
            max_dp, curr = float("-inf"), 0
            for j in xrange(min(3, len(stoneValue)-i)):
                curr += stoneValue[i+j]
                max_dp = max(max_dp, curr-dp[(i+j+1)%3])
            dp[i%3] = max_dp
        return ["Tie", "Alice", "Bob"][cmp(dp[0], 0)]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1411 - https://leetcode.com/problems/number-of-ways-to-paint-n-3-grid/
Time: O(logn)  Space: O(1)   Hard
.Python/number-of-ways-to-paint-n-3-grid.py


```python
# Time:  O(logn)
# Space: O(1)

import itertools


class Solution(object):
    def numOfWays(self, n):
        """
        :type n: int
        :rtype: int
        """
        def matrix_expo(A, K):
            result = [[int(i==j) for j in xrange(len(A))]
                       for i in xrange(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def matrix_mult(A, B):
            ZB = zip(*B)
            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD
                     for col in ZB] for row in A]
        
        MOD = 10**9 + 7
        T = [[3, 2],
             [2, 2]]
        return sum(matrix_mult([[6, 6]], matrix_expo(T, n-1))[0]) % MOD  # [a1, a0] * T^(n-1)


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def numOfWays(self, n):
        """
        :type n: int
        :rtype: int
        """
        MOD = 10**9 + 7
        aba, abc = 6, 6
        for _ in xrange(n-1):
            aba, abc = (3*aba%MOD + 2*abc%MOD)%MOD, \
                       (2*abc%MOD + 2*aba%MOD)%MOD
        return (aba+abc)%MOD

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1416 - https://leetcode.com/problems/restore-the-array/
Time: O(nlogk)  Space: O(logk)   Hard
.Python/restore-the-array.py


```python
# Time:  O(nlogk)
# Space: O(logk)

class Solution(object):
    def numberOfArrays(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: int
        """
        MOD = 10**9 + 7
        klen = len(str(k))
        dp = [0]*(klen+1)
        dp[len(s)%len(dp)] = 1
        for i in reversed(xrange(len(s))):
            dp[i%len(dp)] = 0
            if s[i] == '0':
                continue
            curr = 0
            for j in xrange(i, min(i+klen, len(s))):
                curr = 10*curr + int(s[j])
                if curr &gt; k:
                    break
                dp[i%len(dp)] = (dp[i%len(dp)] + dp[(j+1)%len(dp)])%MOD
        return dp[0]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1420 - https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/
Time: O(n * m * k)  Space: O(m * k)   Hard
.Python/build-array-where-you-can-find-the-maximum-exactly-k-comparisons.py


```python
# Time:  O(n * m * k)
# Space: O(m * k)

class Solution(object):
    def numOfArrays(self, n, m, k):
        """
        :type n: int
        :type m: int
        :type k: int
        :rtype: int
        """
        MOD = 10**9 + 7
        # dp[l][i][j] = number of ways of constructing array length l with max element i at search cost j
        dp = [[[0]*(k+1) for _ in xrange(m+1)] for _ in xrange(2)]
        # prefix_dp[l][i][j] = sum(dp[l][i][j] for i in [1..i])
        prefix_dp = [[[0]*(k+1) for _ in xrange(m+1)] for _ in xrange(2)]
        for i in xrange(1, m+1):
            dp[1][i][1] = 1
            prefix_dp[1][i][1] = (prefix_dp[1][i-1][1] + dp[1][i][1])%MOD
        for l in xrange(2, n+1):
            for i in xrange(1, m+1):
                for j in xrange(1, k+1):
                    dp[l%2][i][j] = (i*dp[(l-1)%2][i][j]%MOD + prefix_dp[(l-1)%2][i-1][j-1])%MOD
                    prefix_dp[l%2][i][j] = (prefix_dp[l%2][i-1][j] + dp[l%2][i][j])%MOD
        return prefix_dp[n%2][m][k]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1434 - https://leetcode.com/problems/number-of-ways-to-wear-different-hats-to-each-other/
Time: O(h * 2^n)  Space: O(2^n)   Hard
.Python/number-of-ways-to-wear-different-hats-to-each-other.py


```python
# Time:  O(h * 2^n)
# Space: O(2^n)

class Solution(object):
    def numberWays(self, hats):
        """
        :type hats: List[List[int]]
        :rtype: int
        """
        MOD = 10**9 + 7
        HAT_SIZE = 40
        hat_to_people = [[] for _ in xrange(HAT_SIZE)]
        for i in xrange(len(hats)):
            for h in hats[i]:
                hat_to_people[h-1].append(i)
        dp = [0]*(1&lt;&lt;len(hats))
        dp[0] = 1
        for people in hat_to_people:
            for mask in reversed(xrange(len(dp))):
                for p in people:
                    if mask &amp; (1&lt;&lt;p):
                        continue
                    dp[mask | (1&lt;&lt;p)] += dp[mask]
                    dp[mask | (1&lt;&lt;p)] %= MOD
        return dp[-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1444 - https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/
Time: O(m * n * k * (m + n))  Space: O(m * n * k)   Hard
.Python/number-of-ways-of-cutting-a-pizza.py


```python
# Time:  O(m * n * k * (m + n))
# Space: O(m * n * k)

class Solution(object):
    def ways(self, pizza, k):
        """
        :type pizza: List[str]
        :type k: int
        :rtype: int
        """
        MOD = 10**9+7
        prefix = [[0]*len(pizza[0]) for _ in xrange(len(pizza))]
        for j in reversed(xrange(len(pizza[0]))):
            accu = 0
            for i in reversed(xrange(len(pizza))):
                accu += int(pizza[i][j] == 'A')
                prefix[i][j] = (prefix[i][j+1] if (j+1 &lt; len(pizza[0])) else 0) + accu
        dp = [[[0]*k for _ in xrange(len(pizza[0]))] for _ in xrange(len(pizza))]
        for i in reversed(xrange(len(pizza))):
            for j in reversed(xrange(len(pizza[0]))):
                dp[i][j][0] = 1
                for m in xrange(1, k):
                    for n in xrange(i+1, len(pizza)):
                        if prefix[i][j] == prefix[n][j]:
                            continue
                        if prefix[n][j] == 0:
                            break
                        dp[i][j][m] = (dp[i][j][m] + dp[n][j][m-1]) % MOD
                    for n in xrange(j+1, len(pizza[0])):
                        if prefix[i][j] == prefix[i][n]:
                            continue
                        if prefix[i][n] == 0:
                            break
                        dp[i][j][m] = (dp[i][j][m] + dp[i][n][m-1]) % MOD
        return dp[0][0][k-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1449 - https://leetcode.com/problems/form-largest-integer-with-digits-that-add-up-to-target/
Time: O(t)  Space: O(t)   Hard
.Python/form-largest-integer-with-digits-that-add-up-to-target.py


```python
# Time:  O(t)
# Space: O(t)

class Solution(object):
    def largestNumber(self, cost, target):
        """
        :type cost: List[int]
        :type target: int
        :rtype: str
        """
        dp = [0]
        for t in xrange(1, target+1):
            dp.append(-1)
            for i, c in enumerate(cost):
                if t-c &lt; 0 or dp[t-c] &lt; 0:
                    continue
                dp[t] = max(dp[t], dp[t-c]+1)
        if dp[target] &lt; 0:
            return "0"
        result = []
        for i in reversed(xrange(9)):
            while target &gt;= cost[i] and dp[target] == dp[target-cost[i]]+1:
                target -= cost[i]
                result.append(i+1)
        return "".join(map(str, result))


# Time:  O(t)
# Space: O(t)
class Solution2(object):
    def largestNumber(self, cost, target):
        """
        :type cost: List[int]
        :type target: int
        :rtype: str
        """
        def key(bag):
            return sum(bag), bag
        
        dp = [[0]*9]
        for t in xrange(1, target+1):
            dp.append([])
            for d, c in enumerate(cost):
                if t &lt; c or not dp[t-c]:
                    continue
                curr = dp[t-c][:]
                curr[~d] += 1
                if key(curr) &gt; key(dp[t]):
                    dp[-1] = curr        
        if not dp[-1]:
            return "0"
        return "".join(str(9-i)*c for i, c in enumerate(dp[-1]))


# Time:  O(t^2)
# Space: O(t^2)
class Solution3(object):
    def largestNumber(self, cost, target):
        """
        :type cost: List[int]
        :type target: int
        :rtype: str
        """
        dp = [0]
        for t in xrange(1, target+1):
            dp.append(-1)
            for i, c in enumerate(cost):
                if t-c &lt; 0:
                    continue
                dp[t] = max(dp[t], dp[t-c]*10 + i+1)
        return str(max(dp[t], 0))

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1458 - https://leetcode.com/problems/max-dot-product-of-two-subsequences/
Time: O(m * n)  Space: O(min(m, n))   Hard
.Python/max-dot-product-of-two-subsequences.py


```python
# Time:  O(m * n)
# Space: O(min(m, n))

class Solution(object):
    def maxDotProduct(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        if len(nums1) &lt; len(nums2):
            return self.maxDotProduct(nums2, nums1)
        dp = [[0]*len(nums2) for i in xrange(2)]
        for i in xrange(len(nums1)):
            for j in xrange(len(nums2)):
                dp[i%2][j] = nums1[i]*nums2[j]
                if i and j:
                    dp[i%2][j] += max(dp[(i-1)%2][j-1], 0)
                if i:
                    dp[i%2][j] = max(dp[i%2][j], dp[(i-1)%2][j])
                if j:
                    dp[i%2][j] = max(dp[i%2][j], dp[i%2][j-1])
        return dp[(len(nums1)-1)%2][-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1463 - https://leetcode.com/problems/cherry-pickup-ii/
Time: O(m * n^2)  Space: O(n^2)   Hard
.Python/cherry-pickup-ii.py


```python
# Time:  O(m * n^2)
# Space: O(n^2)

import itertools


class Solution(object):
    def cherryPickup(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        dp = [[[float("-inf")]*(len(grid[0])+2) for _ in xrange(len(grid[0])+2)] for _ in xrange(2)]
        dp[0][1][len(grid[0])] = grid[0][0] + grid[0][len(grid[0])-1]
        for i in xrange(1, len(grid)):
            for j in xrange(1, len(grid[0])+1):
                for k in xrange(1, len(grid[0])+1):
                    dp[i%2][j][k] = max(dp[(i-1)%2][j+d1][k+d2] for d1 in xrange(-1, 2) for d2 in xrange(-1, 2)) + \
                                    ((grid[i][j-1]+grid[i][k-1]) if j != k else grid[i][j-1])
        return max(itertools.imap(max, *dp[(len(grid)-1)%2]))


# Time:  O(m * n^2)
# Space: O(n^2)
import itertools


class Solution2(object):
    def cherryPickup(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        dp = [[[float("-inf")]*len(grid[0]) for _ in xrange(len(grid[0]))] for _ in xrange(2)]
        dp[0][0][len(grid[0])-1] = grid[0][0] + grid[0][len(grid[0])-1]
        for i in xrange(1, len(grid)):
            for j in xrange(len(grid[0])):
                for k in xrange(len(grid[0])):
                    dp[i%2][j][k] = max(dp[(i-1)%2][j+d1][k+d2] for d1 in xrange(-1, 2) for d2 in xrange(-1, 2)
                                        if 0 &lt;= j+d1 &lt; len(grid[0]) and 0 &lt;= k+d2 &lt; len(grid[0])) + \
                                    ((grid[i][j]+grid[i][k]) if j != k else grid[i][j])
        return max(itertools.imap(max, *dp[(len(grid)-1)%2]))

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1467 - https://leetcode.com/problems/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls/
Time: O(k^3 * n^2)  Space: O(k^2 * n)   Hard
.Python/probability-of-a-two-boxes-having-the-same-number-of-distinct-balls.py


```python
# Time:  O(k^3 * n^2)
# Space: O(k^2 * n)

import collections


class Solution(object):
    def getProbability(self, balls):
        """
        :type balls: List[int]
        :rtype: float
        """
        def nCrs(n):  # Time: O(n), Space: O(1)
            c = 1
            for k in xrange(n+1):
                yield c
                c *= n-(k+1)+1
                c //= k+1
        
        def nCr(n, r):  # Time: O(n), Space: O(1)
            if n-r &lt; r:
                return nCr(n, n-r)
            c = 1
            for k in xrange(1, r+1):
                c *= n-k+1
                c //= k
            return c
        
        dp = collections.defaultdict(int)
        dp[0, 0] = 1  # dp[i, j] is the number of ways with number difference i and color difference j
        for n in balls:  # O(k) times
            new_dp = collections.defaultdict(int)
            for (ndiff, cdiff), count in dp.iteritems():  # O(k^2 * n) times
                for k, new_count in enumerate(nCrs(n)):  # O(n) times
                    new_ndiff = ndiff+(k-(n-k))
                    new_cdiff = cdiff-1 if k == 0 else (cdiff+1 if k == n else cdiff)
                    new_dp[new_ndiff, new_cdiff] += count*new_count
            dp = new_dp
        total = sum(balls)
        return float(dp[0, 0])/nCr(total, total//2)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1473 - https://leetcode.com/problems/paint-house-iii/
Time: O(m * t * n^2)  Space: O(t * n)   Hard
.Python/paint-house-iii.py


```python
# Time:  O(m * t * n^2)
# Space: O(t * n)

class Solution(object):
    def minCost(self, houses, cost, m, n, target):
        """
        :type houses: List[int]
        :type cost: List[List[int]]
        :type m: int
        :type n: int
        :type target: int
        :rtype: int
        """
        # dp[i][j][k]: cost of covering i+1 houses with j+1 neighbor groups and the (k+1)th color
        dp = [[[float("inf") for _ in xrange(n)] for _ in xrange(target)] for _ in xrange(2)]
        for i in xrange(m):
            dp[i%2] = [[float("inf") for _ in xrange(n)] for _ in xrange(target)]
            for j in xrange(min(target, i+1)):
                for k in xrange(n):
                    if houses[i] and houses[i]-1 != k:
                        continue
                    same = dp[(i-1)%2][j][k] if i-1 &gt;= 0 else 0
                    diff = (min([dp[(i-1)%2][j-1][nk] for nk in xrange(n) if nk != k] or [float("inf")]) if j-1 &gt;= 0 else float("inf")) if i-1 &gt;= 0 else 0
                    paint = cost[i][k] if not houses[i] else 0
                    dp[i%2][j][k] = min(same, diff)+paint
        result = min(dp[(m-1)%2][-1])
        return result if result != float("inf") else -1


# Time:  O(m * t * n^2)
# Space: O(t * n)
class Solution2(object):
    def minCost(self, houses, cost, m, n, target):
        """
        :type houses: List[int]
        :type cost: List[List[int]]
        :type m: int
        :type n: int
        :type target: int
        :rtype: int
        """
        dp = {(0, 0): 0}
        for i, p in enumerate(houses):
            new_dp = {}
            for nk in (xrange(1, n+1) if not p else [p]):
                for j, k in dp:
                    nj = j + (k != nk)
                    if nj &gt; target:
                        continue
                    new_dp[nj, nk] = min(new_dp.get((nj, nk), float("inf")), dp[j, k] + (cost[i][nk-1] if nk != p else 0))
            dp = new_dp
        return min([dp[j, k] for j, k in dp if j == target] or [-1])

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1477 - https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/
Time: O(n)  Space: O(n)   Medium
.Python/find-two-non-overlapping-sub-arrays-each-with-target-sum.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def minSumOfLengths(self, arr, target):
        """
        :type arr: List[int]
        :type target: int
        :rtype: int
        """
        prefix, dp = {0: -1}, [0]*len(arr)  # dp[i], min len of target subarray until i
        result = min_len = float("inf")
        accu = 0
        for right in xrange(len(arr)):
            accu += arr[right]
            prefix[accu] = right
            if accu-target in prefix:
                left = prefix[accu-target]
                min_len = min(min_len, right-left)
                if left != -1:
                    result = min(result, dp[left] + (right-left))
            dp[right] = min_len
        return result if result != float("inf") else -1

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1478 - https://leetcode.com/problems/allocate-mailboxes/
Time: O(m * n^2)  Space: O(n)   Hard
.Python/allocate-mailboxes.py


```python
# Time:  O(m * n^2)
# Space: O(n)

class Solution(object):
    def minDistance(self, houses, k):
        """
        :type houses: List[int]
        :type k: int
        :rtype: int
        """
        def cost(prefix, i, j):
            return (prefix[j+1]-prefix[(i+j+1)//2])-(prefix[(i+j)//2+1]-prefix[i])

        houses.sort()
        prefix = [0]*(len(houses)+1)
        for i, h in enumerate(houses):
            prefix[i+1] = prefix[i]+h
        dp = [cost(prefix, 0, j) for j in xrange(len(houses))]
        for m in xrange(1, k):
            for j in reversed(xrange(m, len(houses))):
                for i in xrange(m, j+1):
                    dp[j] = min(dp[j], dp[i-1]+cost(prefix, i, j))
        return dp[-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1494 - https://leetcode.com/problems/parallel-courses-ii/
Time: O((n * C(c, min(c, k))) * 2^n)  Space: O(2^n)   Hard
.Python/parallel-courses-ii.py


```python
# Time:  O((n * C(c, min(c, k))) * 2^n)
# Space: O(2^n)

import itertools


class Solution(object):
    def minNumberOfSemesters(self, n, dependencies, k):
        """
        :type n: int
        :type dependencies: List[List[int]]
        :type k: int
        :rtype: int
        """
        reqs = [0]*n
        for u, v in dependencies:
            reqs[v-1] |= 1 &lt;&lt; (u-1)
        dp = [n]*(1&lt;&lt;n)
        dp[0] = 0
        for mask in xrange(1&lt;&lt;n):
            candidates = []
            for v in xrange(n):
                if (mask&amp;(1&lt;&lt;v)) == 0 and (mask&amp;reqs[v]) == reqs[v]:
                    candidates.append(v)
            for choice in itertools.combinations(candidates, min(len(candidates), k)):
                new_mask = mask
                for v in choice:
                    new_mask |= 1&lt;&lt;v
                dp[new_mask] = min(dp[new_mask], dp[mask]+1)
        return dp[-1]


# Time:  O(nlogn + e), e is the number of edges in graph
# Space: O(n + e)
import collections
import heapq

# wrong greedy solution
# since the priority of courses are hard to decide especially for those courses with zero indegrees are of the same outdegrees and depths
# e.x.
# 9
# [[1,4],[1,5],[3,5],[3,6],[2,6],[2,7],[8,4],[8,5],[9,6],[9,7]]
# 3
class Solution_WA(object):
    def minNumberOfSemesters(self, n, dependencies, k):
        """
        :type n: int
        :type dependencies: List[List[int]]
        :type k: int
        :rtype: int
        """
        def dfs(graph, i, depths):
            if depths[i] == -1:
                depths[i] = max(dfs(graph, child, depths) for child in graph[i])+1 if i in graph else 1
            return depths[i]
            
        degrees = [0]*n
        graph = collections.defaultdict(list)
        for u, v in dependencies:
            graph[u-1].append(v-1)
            degrees[v-1] += 1
        depths = [-1]*n
        for i in xrange(n):
            dfs(graph, i, depths)
        max_heap = []
        for i in xrange(n):
            if not degrees[i]:
                heapq.heappush(max_heap, (-depths[i], i))
        result = 0
        while max_heap:
            new_q = []
            for _ in xrange(min(len(max_heap), k)):
                _, node = heapq.heappop(max_heap)
                if node not in graph:
                    continue
                for child in graph[node]:
                    degrees[child] -= 1
                    if not degrees[child]:
                        new_q.append(child)
            result += 1
            for node in new_q:
                heapq.heappush(max_heap, (-depths[node], node))
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1504 - https://leetcode.com/problems/count-submatrices-with-all-ones/
Time: O(m * n)  Space: O(n)   Medium
.Python/count-submatrices-with-all-ones.py


```python
# Time:  O(m * n)
# Space: O(n)

class Solution(object):
    def numSubmat(self, mat):
        """
        :type mat: List[List[int]]
        :rtype: int
        """
        def count(heights):
            dp, stk = [0]*len(heights), []
            for i in xrange(len(heights)):
                while stk and heights[stk[-1]] &gt;= heights[i]:
                    stk.pop()
                dp[i] = dp[stk[-1]] + heights[i]*(i-stk[-1]) if stk else heights[i]*(i-(-1))
                stk.append(i)
            return sum(dp)

        result = 0
        heights = [0]*len(mat[0])
        for i in xrange(len(mat)):
            for j in xrange(len(mat[0])):
                heights[j] = heights[j]+1 if mat[i][j] == 1 else 0
            result += count(heights)
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1510 - https://leetcode.com/problems/stone-game-iv/
Time: O(n * sqrt(n))  Space: O(n)   Hard
.Python/stone-game-iv.py


```python
# Time:  O(n * sqrt(n))
# Space: O(n)

class Solution(object):
    def winnerSquareGame(self, n):
        """
        :type n: int
        :rtype: bool
        """
        dp = [False]*(n+1)
        for i in xrange(1, n+1):
            j = 1
            while j*j &lt;= i:
                if not dp[i-j*j]:
                    dp[i] = True
                    break
                j += 1
        return dp[-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1524 - https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-sub-arrays-with-odd-sum.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def numOfSubarrays(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        MOD = 10**9+7
        result, accu = 0, 0
        dp = [1, 0]
        for x in arr:
            accu ^= x&amp;1
            dp[accu] += 1
            result = (result + dp[accu^1]) % MOD
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1531 - https://leetcode.com/problems/string-compression-ii/
Time: O(n^2 * k)  Space: O(n * k)   Hard
.Python/string-compression-ii.py


```python
# Time:  O(n^2 * k)
# Space: O(n * k)

class Solution(object):
    def getLengthOfOptimalCompression(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: int
        """
        def length(cnt):
            l = 2 if cnt &gt;= 2 else 1
            while cnt &gt;= 10:
                l += 1
                cnt //= 10
            return l

        dp = [[len(s)]*(k+1) for _ in xrange(len(s)+1)]
        dp[0][0] = 0
        for i in xrange(1, len(s)+1):
            for j in xrange(k+1):
                if i-1 &gt;= 0 and j-1 &gt;= 0:
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1])
                keep = delete = 0
                for m in xrange(i, len(s)+1):
                    if s[i-1] == s[m-1]:
                        keep += 1
                    else:
                        delete += 1
                    if j+delete &lt;= k:
                        dp[m][j+delete] = min(dp[m][j+delete], dp[i-1][j]+length(keep));
        return dp[len(s)][k]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1547 - https://leetcode.com/problems/minimum-cost-to-cut-a-stick/
Time: O(n^3)  Space: O(n^2)   Hard
.Python/minimum-cost-to-cut-a-stick.py


```python
# Time:  O(n^3)
# Space: O(n^2)

class Solution(object):
    def minCost(self, n, cuts):
        """
        :type n: int
        :type cuts: List[int]
        :rtype: int
        """
        sorted_cuts = sorted(cuts + [0, n])
        dp = [[0]*len(sorted_cuts) for _ in xrange(len(sorted_cuts))]
        for l in xrange(2, len(sorted_cuts)):
            for i in xrange(len(sorted_cuts)-l):
                dp[i][i+l] = min(dp[i][j]+dp[j][i+l] for j in xrange(i+1, i+l)) + \
                             sorted_cuts[i+l]-sorted_cuts[i]
        return dp[0][len(sorted_cuts)-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1548 - https://leetcode.com/problems/the-most-similar-path-in-a-graph/
Time: O(n^ * m)  Space: O(n * m)   Hard
.Python/the-most-similar-path-in-a-graph.py


```python
# Time:  O(n^2 * m), m is the length of targetPath
# Space: O(n * m)

class Solution(object):
    def mostSimilar(self, n, roads, names, targetPath):
        """
        :type n: int
        :type roads: List[List[int]]
        :type names: List[str]
        :type targetPath: List[str]
        :rtype: List[int]
        """
        adj = [[] for _ in xrange(n)]
        for u, v in roads:
            adj[u].append(v)
            adj[v].append(u)

        dp = [[0]*n for _ in xrange(len(targetPath)+1)]
        for i in xrange(1, len(targetPath)+1):
            for v in xrange(n):
                dp[i][v] = (names[v] != targetPath[i-1]) + min(dp[i-1][u] for u in adj[v]) 

        path = [dp[-1].index(min(dp[-1]))]
        for i in reversed(xrange(2, len(targetPath)+1)):
            for u in adj[path[-1]]:
                if dp[i-1][u]+(names[path[-1]] != targetPath[i-1]) == dp[i][path[-1]]:
                    path.append(u)
                    break
        return path[::-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1553 - https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/
Time: O((logn)^2)  Space: O((logn)^2)   Hard
.Python/minimum-number-of-days-to-eat-n-oranges.py


```python
# Time:  O((logn)^2)
# Space: O((logn)^2)

# complexity analysis: see https://leetcode.com/problems/minimum-number-of-days-to-eat-n-oranges/discuss/794847/Polylogarithmic-solution
class Solution(object):
    def minDays(self, n):
        """
        :type n: int
        :rtype: int
        """
        def memoization(lookup, i):
            if i &lt;= 1:
                return i
            if i not in lookup:
                lookup[i] = 1+min(i%2+memoization(lookup, i//2),
                                  i%3+memoization(lookup, i//3))
            return lookup[i]

        lookup = {}
        return memoization(lookup, n)


# Time:  O((logn)^2)
# Space: O((logn)^2)
class Solution2(object):
    def minDays(self, n):
        result = 0
        q, lookup = [n], set([n])
        while q:
            new_q = []
            for i in q: 
                if not i:
                    return result
                if i-1 not in lookup:
                    lookup.add(i-1)
                    new_q.append(i-1)
                if i%2 == 0 and i//2 not in lookup:
                    lookup.add(i//2)
                    new_q.append(i//2)
                if i%3 == 0 and i//3 not in lookup:
                    lookup.add(i//3)
                    new_q.append(i//3)
            result += 1
            q = new_q
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1563 - https://leetcode.com/problems/stone-game-v/
Time: O(n^2)  Space: O(n^2)   Hard
.Python/stone-game-v.py


```python
# Time:  O(n^2)
# Space: O(n^2)

class Solution(object):
    def stoneGameV(self, stoneValue):
        """
        :type stoneValue: List[int]
        :rtype: int
        """
        n = len(stoneValue)
        prefix = [0]
        for v in stoneValue:
            prefix.append(prefix[-1] + v)

        mid = range(n)

        dp = [[0]*n for _ in xrange(n)]
        for i in xrange(n):
            dp[i][i] = stoneValue[i]

        max_score = 0
        for l in xrange(2, n+1):
            for i in xrange(n-l+1):
                j = i+l-1
                while prefix[mid[i]]-prefix[i] &lt; prefix[j+1]-prefix[mid[i]]:
                    mid[i] += 1  # Time: O(n^2) in total
                p = mid[i]
                max_score = 0
                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:
                    max_score = max(dp[i][p-1], dp[j][p])
                else:
                    if i &lt;= p-2:
                        max_score = max(max_score, dp[i][p-2])
                    if p &lt;= j:
                        max_score = max(max_score, dp[j][p])
                dp[i][j] = max(dp[i][j-1], (prefix[j+1]-prefix[i]) + max_score)
                dp[j][i] = max(dp[j][i+1], (prefix[j+1]-prefix[i]) + max_score)
        return max_score


# Time:  O(n^2)
# Space: O(n^2)
class Solution2(object):
    def stoneGameV(self, stoneValue):
        """
        :type stoneValue: List[int]
        :rtype: int
        """
        n = len(stoneValue)
        prefix = [0]
        for v in stoneValue:
            prefix.append(prefix[-1] + v)

        mid = [[0]*n for _ in xrange(n)]
        for l in xrange(1, n+1):
            for i in xrange(n-l+1):
                j = i+l-1
                p = i if l == 1 else mid[i][j-1]
                while prefix[p]-prefix[i] &lt; prefix[j+1]-prefix[p]:
                    p += 1  # Time: O(n^2) in total
                mid[i][j] = p
        
        rmq = [[0]*n for _ in xrange(n)]
        for i in xrange(n):
            rmq[i][i] = stoneValue[i]

        dp = [[0]*n for _ in xrange(n)]
        for l in xrange(2, n+1):
            for i in xrange(n-l+1):
                j = i+l-1
                p = mid[i][j]
                max_score = 0
                if prefix[p]-prefix[i] == prefix[j+1]-prefix[p]:
                    max_score = max(rmq[i][p-1], rmq[j][p])
                else:
                    if i &lt;= p-2:
                        max_score = max(max_score, rmq[i][p-2])
                    if p &lt;= j:
                        max_score = max(max_score, rmq[j][p])
                dp[i][j] = max_score
                rmq[i][j] = max(rmq[i][j-1], (prefix[j+1]-prefix[i]) + max_score)
                rmq[j][i] = max(rmq[j][i+1], (prefix[j+1]-prefix[i]) + max_score)
        return dp[0][n-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1569 - https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times/
Time: O(n^2)  Space: O(n^2)   Hard
.Python/detect-pattern-of-length-m-repeated-k-or-more-times.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def containsPattern(self, arr, m, k):
        """
        :type arr: List[int]
        :type m: int
        :type k: int
        :rtype: bool
        """
        cnt = 0
        for i in xrange(len(arr)-m):
            if arr[i] != arr[i+m]:
                cnt = 0
                continue
            cnt += 1
            if cnt == (k-1)*m:
                return True
        return False

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1575 - https://leetcode.com/problems/count-all-possible-routes/
Time: O(nlogn + n * f)  Space: O(n * f)   Hard
.Python/count-all-possible-routes.py


```python
# Time:  O(nlogn + n * f)
# Space: O(n * f)

import bisect


class Solution(object):
    def countRoutes(self, locations, start, finish, fuel):
        """
        :type locations: List[int]
        :type start: int
        :type finish: int
        :type fuel: int
        :rtype: int
        """
        MOD = 10**9+7

        s, f = locations[start], locations[finish];
        locations.sort()
        start, finish = bisect.bisect_left(locations, s), bisect.bisect_left(locations, f)

        left = [[0]*(fuel+1) for _ in xrange(len(locations))]  # left[i][f], last move is toward left to location i by f fuel
        right = [[0]*(fuel+1) for _ in xrange(len(locations))]  # right[i][f], last move is toward right to location i by f fuel
        for f in xrange(1, fuel+1):
            for j in xrange(len(locations)-1):
                d = locations[j+1]-locations[j]
                if f &gt; d:
                    # left[j][f] = right[j+1][f-d(j, j+1)] + 2*right[j+2][f-d(j, j+2)] + ... + 2^(k-1)*right[j+k][f-d(j, j+k)]
                    # =&gt; left[j+1][f] = (ight[j+2][f-d(j+1, j+2)] + 2*right[j+3][f-d(j+1, j+3)] + ... + 2^(k-2)*right[j+1+k-1][f-d(j+1, j+1+k-1)]
                    # =&gt; left[j+1][f-d(j, j+1)] = right[j+2][f-d(j, j+2)] + 2*right[j+3][f-d(j, j+3)] + ... + 2^(k-2)*right[j+k][f-d(j, j+k)]
                    # =&gt; left[j][f] = right[j+1][f-d(j, j+1)] + 2*left[j+1][f-d(j, j+1)]
                    left[j][f] = (right[j+1][f-d] + 2*left[j+1][f-d] % MOD) % MOD;
                elif f == d:
                    left[j][f] = int(j+1 == start)
            for j in xrange(1, len(locations)):
                d = locations[j]-locations[j-1]
                if f &gt; d:
                    # right[j][f] = left[j-1][f-d(j, j-1)] + 2*left[j-2][f-d(j, j-2)] + ... + 2^(k-1)*left[j-k][f-d(j, j-k)]
                    # =&gt; right[j-1][f] = left[j-2][f-d(j-1, j-2)] + 2*left[j-3][f-d(j-1, j-3)] + ... + 2^(k-2)*left[j-1-k+1][f-d(j-1, j-1-k+1)]
                    # =&gt; right[j-1][f-d(j, j-1)] = left[j-2][f-d(j, j-2)] + 2*left[j-3][f-d(j, j-3)] + ... + 2^(k-2)*left[j-k][f-d(j, j-k)]
                    # =&gt; right[j][f] = left[j-1][f-d(j, j-1)] + 2*right[j-1][f-d(j, j-1)]
                    right[j][f] = (left[j-1][f-d] + 2*right[j-1][f-d] % MOD) % MOD
                elif f == d:
                    right[j][f] = int(j-1 == start)
        result = int(start == finish)
        for f in xrange(1, fuel+1):
            result = ((result + left[finish][f]) % MOD + right[finish][f]) % MOD
        return result


# Time:  O(n^2 * f)
# Space: O(n * f)
class Solution2(object):
    def countRoutes(self, locations, start, finish, fuel):
        """
        :type locations: List[int]
        :type start: int
        :type finish: int
        :type fuel: int
        :rtype: int
        """
        MOD = 10**9+7
        dp = [[0]*(fuel+1) for _ in xrange(len(locations))]
        dp[start][0] = 1
        for f in xrange(fuel+1):
            for i in xrange(len(locations)):
                for j in xrange(len(locations)):
                    if i == j:
                        continue
                    d = abs(locations[i]-locations[j])
                    if f-d &lt; 0:
                        continue
                    dp[i][f] = (dp[i][f]+dp[j][f-d])%MOD
        return reduce(lambda x, y: (x+y)%MOD, dp[finish])

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1594 - https://leetcode.com/problems/maximum-non-negative-product-in-a-matrix/
Time: O(m * n)  Space: O(n)   Medium
.Python/maximum-non-negative-product-in-a-matrix.py


```python
# Time:  O(m * n)
# Space: O(n)

# dp with rolling window
class Solution(object):
    def maxProductPath(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        MOD = 10**9+7
        max_dp = [[0]*len(grid[0]) for _ in xrange(2)]
        min_dp = [[0]*len(grid[0]) for _ in xrange(2)]
        for i in xrange(len(grid)):
            for j in xrange(len(grid[i])):
                if i == 0 and j == 0:
                    max_dp[i%2][j] = min_dp[i%2][j] = grid[i][j]
                    continue
                curr_max = max(max_dp[(i-1)%2][j] if i &gt; 0 else max_dp[i%2][j-1],
                               max_dp[i%2][j-1] if j &gt; 0 else max_dp[(i-1)%2][j])
                curr_min = min(min_dp[(i-1)%2][j] if i &gt; 0 else min_dp[i%2][j-1],
                               min_dp[i%2][j-1] if j &gt; 0 else min_dp[(i-1)%2][j])
                if grid[i][j] &lt; 0:
                    curr_max, curr_min = curr_min, curr_max
                max_dp[i%2][j] = curr_max*grid[i][j]
                min_dp[i%2][j] = curr_min*grid[i][j]
        return max_dp[(len(grid)-1)%2][-1]%MOD if max_dp[(len(grid)-1)%2][-1] &gt;= 0 else -1

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1595 - https://leetcode.com/problems/minimum-cost-to-connect-two-groups-of-points/
Time: O(m * n * 2^n)  Space: O(2^n)   Hard
.Python/minimum-cost-to-connect-two-groups-of-points.py


```python
# Time:  O(m * n * 2^n)
# Space: O(2^n)

# dp with rolling window
class Solution(object):
    def connectTwoGroups(self, cost):
        """
        :type cost: List[List[int]]
        :rtype: int
        """
        total = 2**len(cost[0])
        dp = [[float("inf")]*total for _ in xrange(2)]
        dp[0][0] = 0
        for i in xrange(len(cost)):
            dp[(i+1)%2] = [float("inf")]*total
            for mask in xrange(total):
                base = 1
                for j in xrange(len(cost[0])):
                    dp[i%2][mask|base] = min(dp[i%2][mask|base], cost[i][j]+dp[i%2][mask])
                    dp[(i+1)%2][mask|base] = min(dp[(i+1)%2][mask|base], cost[i][j]+dp[i%2][mask])
                    base &lt;&lt;= 1
        return dp[len(cost)%2][-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1617 - https://leetcode.com/problems/count-subtrees-with-max-distance-between-cities/
Time: O(n^6)  Space: O(n^3)   Hard
.Python/count-subtrees-with-max-distance-between-cities.py


```python
# Time:  O(n^6)
# Space: O(n^3)

import collections


class Solution(object):
    def countSubgraphsForEachDiameter(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[int]
        """
        def dfs(n, adj, curr, parent, lookup, count, dp):
            for child in adj[curr]:
                if child == parent or lookup[child]:
                    continue
                dfs(n, adj, child, curr, lookup, count, dp)
            dp[curr][0][0] = 1
            for child in adj[curr]:
                if child == parent or lookup[child]:
                    continue
                new_dp_curr = [row[:] for row in dp[curr]]
                for curr_d in xrange(count[curr]):
                    for curr_max_d in xrange(curr_d, min(2*curr_d+1, count[curr])):
                        if not dp[curr][curr_d][curr_max_d]:  # pruning
                            continue
                        for child_d in xrange(count[child]):
                            for child_max_d in xrange(child_d, min(2*child_d+1, count[child])):
                                new_dp_curr[max(curr_d, child_d+1)][max(curr_max_d, child_max_d, curr_d+child_d+1)] += \
                                    dp[curr][curr_d][curr_max_d]*dp[child][child_d][child_max_d]  # count subtrees with new child
                count[curr] += count[child]  # merge new child
                dp[curr] = new_dp_curr

        adj = collections.defaultdict(list)
        for u, v in edges:
            u -= 1
            v -= 1
            adj[u].append(v)
            adj[v].append(u)
        lookup, result = [0]*n, [0]*(n-1)
        for i in xrange(n):  # Time: sum(O(k^5) for k in [1, n]) = O(n^6)
            dp = [[[0]*n for _ in xrange(n)] for _ in xrange(n)]
            count = [1]*n
            dfs(n, adj, i, -1, lookup, count, dp)  # Time: O(k^5), k is the number of the remaining cities
            lookup[i] = 1
            for d in xrange(1, n):  # for each depth from city i
                for max_d in xrange(d, min(2*d+1, n)):  # for each max distance
                    result[max_d-1] += dp[i][d][max_d]
        return result
    

# Time:  O(n * 2^n)
# Space: O(n)
import collections
import math


class Solution2(object):
    def countSubgraphsForEachDiameter(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[int]
        """
        def popcount(mask):
            count = 0
            while mask:
                mask &amp;= mask-1
                count += 1
            return count

        def bfs(adj, mask, start):
            q = collections.deque([(start, 0)])
            lookup = 1&lt;
<start (lookup&(1<<v)):="" (mask&(1<<v))="" -="1" 0="" 2)))="" 2**n):="" _="bfs(adj," adj="collections.defaultdict(list)" adj,="" adj[u].append(v)="" adj[u]:="" adj[v].append(u)="" bfs(adj,="" continue="" count="0," d="" d+1))="" def="" edges,="" edges:="" else="" farthest)[-1]="" farthest,="" for="" if="" in="" int(math.log(mask&-mask,="" is_valid="" is_valid,="" lookup="" mask="" mask)="" mask):="" mask,="" max_d="max_distance(n," max_d-1="" max_distance(n,="" none="" not="" or="" q.append((v,="" q:="" result="[0]*(n-1)" return="" u="" u,="" v="" while="" xrange(1,="" |="1&lt;&lt;v">
 = 0:
                result[max_d-1] += 1
        return result
</start>
```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1626 - https://leetcode.com/problems/best-team-with-no-conflicts/
Time: O(nloga)  Space: O(n)   Medium
.Python/best-team-with-no-conflicts.py


```python
# Time:  O(nloga)
# Space: O(n)

# Range Maximum Query
class SegmentTree(object):  # 0-based index
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y),  # (lambda x, y: y if x is None else min(x, y))
                 update_fn=lambda x, y: y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x &lt; self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h):  # Time: O(logN), Space: O(N)
        def pull(x):
            while x &gt; 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L &lt;= R:
            if L &amp; 1:  # is right child
                self.__apply(L, h) 
                L += 1
            if R &amp; 1 == 0:  # is left child
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):  # Time: O(logN), Space: O(N)
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L &gt; R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L &lt;= R:
            if L &amp; 1:  # is right child
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R &amp; 1 == 0:  # is left child
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in xrange(self.N):
            showList.append(self.query(i, i))
        return ",".join(map(str, showList))


# optimized from Solution3
class Solution(object):
    def bestTeamScore(self, scores, ages):
        """
        :type scores: List[int]
        :type ages: List[int]
        :rtype: int
        """
        players = sorted(zip(scores, ages))
        sorted_ages = sorted(set(ages))
        lookup = {age:i for i, age in enumerate(sorted_ages)}  # coordinate compression
        segment_tree = SegmentTree(len(lookup))
        result = 0
        for score, age in players:
            segment_tree.update(lookup[age], lookup[age], segment_tree.query(0, lookup[age])+score)
        return segment_tree.query(0, len(lookup)-1)


# Time:  O(nlogs)
# Space: O(n)
# optimized from Solution4
class Solution2(object):
    def bestTeamScore(self, scores, ages):
        """
        :type scores: List[int]
        :type ages: List[int]
        :rtype: int
        """
        players = sorted(zip(ages, scores))
        sorted_scores = sorted(set(scores))
        lookup = {score:i for i, score in enumerate(sorted_scores)}  # coordinate compression
        segment_tree = SegmentTree(len(lookup))
        result = 0
        for age, score in players:
            segment_tree.update(lookup[score], lookup[score], segment_tree.query(0, lookup[score])+score)
        return segment_tree.query(0, len(lookup)-1)
 

# Time:  O(n * a)
# Space: O(n)
import collections


# optimized from Solution5
class Solution3(object):
    def bestTeamScore(self, scores, ages):
        """
        :type scores: List[int]
        :type ages: List[int]
        :rtype: int
        """
        players = sorted(zip(scores, ages))
        sorted_ages = sorted(set(ages))
        dp = collections.defaultdict(int)
        result = 0
        for score, age in players:
            dp[age] = max(dp[a] for a in sorted_ages if a &lt;= age) + score
        return max(dp.itervalues())


# Time:  O(n * s)
# Space: O(n)
import collections


# optimized from Solution6
class Solution4(object):
    def bestTeamScore(self, scores, ages):
        """
        :type scores: List[int]
        :type ages: List[int]
        :rtype: int
        """
        players = sorted(zip(ages, scores))
        sorted_scores = sorted(set(scores))
        dp = collections.defaultdict(int)
        result = 0
        for age, score in players:
            dp[score] = max(dp[s] for s in sorted_scores if s &lt;= score) + score
        return max(dp.itervalues())


# Time:  O(n^2)
# Space: O(n)
# longest_increasing_subsequence like dp solution
class Solution5(object):
    def bestTeamScore(self, scores, ages):
        """
        :type scores: List[int]
        :type ages: List[int]
        :rtype: int
        """
        players = sorted(zip(scores, ages))
        dp = [0]*len(players)
        result = 0
        for i in xrange(len(players)):
            dp[i] = players[i][0]
            for j in xrange(i):
                if players[j][1] &lt;= players[i][1]:
                    dp[i] = max(dp[i], dp[j] + players[i][0])
            result = max(result, dp[i])
        return result


# Time:  O(n^2)
# Space: O(n)
# longest_increasing_subsequence like dp solution
class Solution6(object):
    def bestTeamScore(self, scores, ages):
        """
        :type scores: List[int]
        :type ages: List[int]
        :rtype: int
        """
        players = sorted(zip(ages, scores))
        dp = [0]*len(players)
        result = 0
        for i in xrange(len(players)):
            dp[i] = players[i][1]
            for j in xrange(i):
                if players[j][1] &lt;= players[i][1]:
                    dp[i] = max(dp[i], dp[j] + players[i][1])
            result = max(result, dp[i])
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1639 - https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/
Time: O(l * (w + n))  Space: O(n)   Hard
.Python/number-of-ways-to-form-a-target-string-given-a-dictionary.py


```python
# Time:  O(l * (w + n)), l is the length of a word, w is the number of words, n is the length of target
# Space: O(n)

import collections


# optimized from Solution2
class Solution(object):
    def numWays(self, words, target):
        """
        :type words: List[str]
        :type target: str
        :rtype: int
        """
        MOD = 10**9+7
        dp = [0]*(len(target)+1)
        dp[0] = 1
        for i in xrange(len(words[0])):
            count = collections.Counter(w[i] for w in words)
            for j in reversed(xrange(len(target))):
                dp[j+1] += dp[j]*count[target[j]] % MOD
        return dp[-1] % MOD


# Time:  O(l * (w + n)), l is the length of a word, w is the number of words, n is the length of target
# Space: O(n)
import collections


class Solution2(object):
    def numWays(self, words, target):
        """
        :type words: List[str]
        :type target: str
        :rtype: int
        """
        MOD = 10**9+7
        # dp[i+1][j+1]: number of ways of target[0..j] using count[0..i].
        dp = [[0]*(len(target)+1) for _ in xrange(2)]
        for i in xrange(len(dp)):
            dp[i][0] = 1
        for i in xrange(len(words[0])):
            count = collections.Counter(w[i] for w in words)
            for j in reversed(xrange(len(target))):
                dp[(i+1)%2][j+1] = dp[i%2][j+1]+dp[i%2][j]*count[target[j]] % MOD
        return dp[(len(words[0]))%2][-1] % MOD

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1655 - https://leetcode.com/problems/distribute-repeating-integers/
Time: O(n + m * 3^m)  Space: O(n + 2^m)   Hard
.Python/distribute-repeating-integers.py


```python
# Time:  O(n + m * 3^m) 
# Space: O(n + 2^m)

import collections
import random


class Solution(object):
    def canDistribute(self, nums, quantity):
        """
        :type nums: List[int]
        :type quantity: List[int]
        :rtype: bool
        """
        def nth_element(nums, n, compare=lambda a, b: a &lt; b):
            def tri_partition(nums, left, right, target, compare):
                mid = left
                while mid &lt;= right:
                    if nums[mid] == target:
                        mid += 1
                    elif compare(nums[mid], target):
                        nums[left], nums[mid] = nums[mid], nums[left]
                        left += 1
                        mid += 1
                    else:
                        nums[mid], nums[right] = nums[right], nums[mid]
                        right -= 1
                return left, right

            left, right = 0, len(nums)-1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                pivot_left, pivot_right = tri_partition(nums, left, right, nums[pivot_idx], compare)
                if pivot_left &lt;= n &lt;= pivot_right:
                    return
                elif pivot_left &gt; n:
                    right = pivot_left-1
                else:  # pivot_right &lt; n.
                    left = pivot_right+1

        count = collections.Counter(nums)
        total = (1&lt;
<len(quantity))-1 #="" +="quantity[i];" <="" <<="1" _="" a="" a,="" at="" b:="" base="" cnts="" dp="[[0]*(total+1)" dp[0][0]="1" for="" i="0" if="" in="" lambda="" len(cnts):="" len(quantity)="" len(quantity)-1,="" m="" mask="" mask&base:="" most="" nth_element(cnts,="" o(2^m)="" o(m)="" requirement="[0]*(total+1)" requirement[mask]="" time:="" top="" use="" xrange(2)]="" xrange(len(quantity)):="" xrange(len(requirement)):="">
 b)
            cnts = cnts[:len(quantity)]
        for cnt in cnts:  # Time: O(m)
            dp[(i+1)%2] = [0]*(total+1)
            # submask enumeration:
            # =&gt; sum(nCr(m, k) * 2^k for k in xrange(m+1)) = (1 + 2)^m = 3^m
            # =&gt; Time: O(3^m), see https://cp-algorithms.com/algebra/all-submasks.html
            for mask in reversed(xrange(total+1)):
                dp[(i+1)%2][mask] |= dp[i%2][mask]
                submask = mask
                while submask &gt; 0:
                    if requirement[submask] &lt;= cnt and dp[i%2][mask^submask]:
                        dp[(i+1)%2][mask] = 1
                    submask = (submask-1)&amp;mask
            i += 1
        return dp[len(cnts)%2][total]
</len(quantity))-1>
```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1664 - https://leetcode.com/problems/ways-to-make-a-fair-array/
Time: O(n)  Space: O(1)   Medium
.Python/ways-to-make-a-fair-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def waysToMakeFair(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        prefix = [0]*2
        suffix = [sum(nums[i] for i in xrange(k, len(nums), 2)) for k in xrange(2)]
        result = 0
        for i, num in enumerate(nums):
            suffix[i%2] -= num
            result += int(prefix[0]+suffix[1] == prefix[1]+suffix[0])
            prefix[i%2] += num
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1681 - https://leetcode.com/problems/minimum-incompatibility/
Time: O(max(n * 2^n, 3^n))  Space: O(2^n)   Hard
.Python/minimum-incompatibility.py


```python
# Time:  O(sum(i*d * nCr(i*d, d) * nCr(n, i*d) for i in xrange(1, k+1))) &lt; O(sum(n * 2^m * nCr(n, m) for m in xrange(n+1))) = O(n * 3^n)
# Space: O(n * k)

import itertools


class Solution(object):
    def minimumIncompatibility(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        inf = (len(nums)-1)*(len(nums)//k)+1
        def backtracking(nums, d, lookup):
            if not nums:
                return 0
            if nums not in lookup:
                ret = inf
                for new_nums in itertools.combinations(nums, d):
                    new_nums_set = set(new_nums)
                    if len(new_nums_set) &lt; d:
                        continue
                    left = []
                    for num in nums:
                        if num in new_nums_set:
                            new_nums_set.remove(num)
                            continue
                        left.append(num)
                    ret = min(ret, max(new_nums)-min(new_nums) + backtracking(tuple(left), d, lookup))
                lookup[nums] = ret
            return lookup[nums]
        
        result = backtracking(tuple(nums), len(nums)//k, {})
        return result if result != inf else -1


# Time:  O(max(n * 2^n, 3^n))
# Space: O(2^n)
class Solution_TLE(object):
    def minimumIncompatibility(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        inf = (len(nums)-1)*(len(nums)//k)+1
        POW = [1]
        for i in xrange(len(nums)):
            POW.append(POW[-1]&lt;&lt;1)
        
        def popcount(n):
            result = 0
            while n:
                n &amp;= n - 1
                result += 1
            return result
    
        def find_candidates(nums, k):
            total = POW[len(nums)]-1
            m = len(nums)//k
            result = [inf]*(total+1)
            for mask in xrange(total+1):
                if popcount(mask) != m:
                    continue
                lookup = 0
                mx, mn = 0, inf
                for i in xrange(len(nums)):
                    if mask&amp;POW[i] == 0:
                        continue
                    if lookup&amp;POW[nums[i]]:
                        break
                    lookup |= POW[nums[i]]
                    mx = max(mx, nums[i])
                    mn = min(mn, nums[i])
                else:
                    result[mask] = mx-mn
            return result
        
        candidates = find_candidates(nums, k)
        m = len(nums)//k
        total = POW[len(nums)]-1
        dp = [inf]*(total+1)
        dp[0] = 0
        for mask in xrange(total+1):
            if popcount(mask) % m != 0:
                continue
            # submask enumeration:
            # =&gt; sum(nCr(n, k) * 2^k for k in xrange(n+1)) = (1 + 2)^n = 3^n
            # =&gt; Time: O(3^n), see https://cp-algorithms.com/algebra/all-submasks.html
            submask = mask
            while submask:
                dp[mask] = min(dp[mask], dp[mask-submask] + candidates[submask])
                submask = (submask-1)&amp;mask
        return dp[-1] if dp[-1] != inf else -1


# Time:  O(nlogn)
# Space: O(n)
import collections
import sortedcontainers
# wrong with greedy solution
# nums = [15, 9, 7, 10, 15, 14, 12, 2, 10, 8, 10, 13, 4, 11, 2]
# k = 5
# greedy  =&gt; [[2, 4, 7], [2, 8, 9], [10, 11, 12], [10, 13, 15], [10, 14, 15]] =&gt; 24
# correct =&gt; [[2, 4, 7], [2, 8, 10], [9, 10, 11], [10, 12, 15], [13, 14, 15]] =&gt; 22
# optimized from Solution_Greedy, using SortedList (which is not supported in GoogleCodeJam / GoogleKickStart)
class Solution_Wrong_Greedy_SortedList(object):
    def minimumIncompatibility(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.itervalues()) &gt; k:
                return -1
            ordered_set = sortedcontainers.SortedList(count.iterkeys())
            freq_to_nodes = collections.defaultdict(collections.OrderedDict)
            for x in ordered_set:
                freq_to_nodes[count[x]][x] = count[x]
            stks = [[] for _ in xrange(k)] 
            curr = 0
            while ordered_set:  # the while loop runs O(k) times
                if len(stks)-curr in freq_to_nodes:  # fill the deterministic elements into the remaining subsets
                    for x in freq_to_nodes[len(stks)-curr].iterkeys():  # total time = O(n)
                        for i in xrange(curr, len(stks)):
                            stks[i].append(x)
                        count.pop(x)
                        ordered_set.remove(x)
                    freq_to_nodes.pop(len(stks)-curr)
                # greedily fill the contiguous ordered elements into the first vacant subset until it is full,
                # otherwise, the result sum would get larger =&gt; in fact, this is wrong
                to_remove = []
                direction = (lambda x:x) if not is_reversed else reversed
                for x in direction(ordered_set):
                    stks[curr].append(x)
                    freq_to_nodes[count[x]].pop(x)
                    if not freq_to_nodes[count[x]]:
                        freq_to_nodes.pop(count[x])
                    count[x] -= 1  # total time = O(n)
                    if not count[x]:
                        count.pop(x)
                        to_remove.append(x)
                    else:
                        freq_to_nodes[count[x]][x] = count[x]
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
                for x in to_remove:
                    ordered_set.remove(x)  # total time = O(nlogn)
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True))  # two possible minimas


# Time:  O(nlogn)
# Space: O(n)
import collections
from random import randint, seed


# Template modified from:
# https://github.com/kamyu104/LeetCode-Solutions/blob/master/Python/design-skiplist.py
class SkipNode(object):
    def __init__(self, level=0, val=None):
        self.val = val
        self.nexts = [None]*level
        self.prevs = [None]*level

class SkipList(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2  # P = 1/4 in redis implementation
    MAX_LEVEL = 32  # enough for 2^32 elements

    def __init__(self, end=float("inf"), can_duplicated=False, cmp=lambda x, y: x &lt; y):
        seed(0)
        self.__head = SkipNode()
        self.__len = 0
        self.__can_duplicated = can_duplicated
        self.__cmp = cmp
        self.add(end)
        self.__end = self.find(end)

    def begin(self):
        return self.__head.nexts[0]
    
    def end(self):
        return self.__end

    def lower_bound(self, target):
        return self.__lower_bound(target, self.__find_prev_nodes(target))

    def find(self, target):
        return self.__find(target, self.__find_prev_nodes(target))
        
    def add(self, val):
        if not self.__can_duplicated and self.find(val):
            return self.find(val), False
        node = SkipNode(self.__random_level(), val)
        if len(self.__head.nexts) &lt; len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(val)
        for i in xrange(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            if prevs[i].nexts[i]:
                prevs[i].nexts[i].prevs[i] = node
            prevs[i].nexts[i] = node
            node.prevs[i] = prevs[i]
        self.__len += 1
        return node if self.__can_duplicated else (node, True)

    def remove(self, it):
        prevs = it.prevs
        curr = self.__find(it.val, prevs)
        if not curr:
            return self.__end
        self.__len -= 1   
        for i in reversed(xrange(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if curr.nexts[i]:
                curr.nexts[i].prevs[i] = prevs[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return curr.nexts[0]
    
    def __lower_bound(self, val, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate:
                return candidate
        return None

    def __find(self, val, prevs):
        candidate = self.__lower_bound(val, prevs)
        if candidate and candidate.val == val:
            return candidate
        return None

    def __find_prev_nodes(self, val):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(xrange(len(self.__head.nexts))):
            while curr.nexts[i] and self.__cmp(curr.nexts[i].val, val):
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while randint(1, SkipList.P_DENOMINATOR) &lt;= SkipList.P_NUMERATOR and \
              level &lt; SkipList.MAX_LEVEL:
            level += 1
        return level
    
    def __iter__(self):
        it = self.begin()
        while it != self.end():
            yield it.val
            it = it.nexts[0]

    def __len__(self):
        return self.__len-1  # excluding end node

    def __str__(self):
        result = []
        for i in reversed(xrange(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.val))
                curr = curr.nexts[i]
        return "\n".join(map(lambda x: "-&gt;".join(x), result))

# wrong with greedy solution
# nums = [15, 9, 7, 10, 15, 14, 12, 2, 10, 8, 10, 13, 4, 11, 2]
# k = 5
# greedy  =&gt; [[2, 4, 7], [2, 8, 9], [10, 11, 12], [10, 13, 15], [10, 14, 15]] =&gt; 24
# correct =&gt; [[2, 4, 7], [2, 8, 10], [9, 10, 11], [10, 12, 15], [13, 14, 15]] =&gt; 22
# optimized from Solution_Wrong_Greedy, using SkipList
class Solution_Wrong_Greedy_SkipList(object):
    def minimumIncompatibility(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.itervalues()) &gt; k:
                return -1
            ordered_set = SkipList() if not is_reversed else SkipList(end=float("-inf"), cmp=lambda x, y: x &gt; y)
            freq_to_nodes = collections.defaultdict(collections.OrderedDict)
            for x in sorted(count.keys(), reverse=is_reversed):
                ordered_set.add(x)
                freq_to_nodes[count[x]][x] = count[x]
            stks = [[] for _ in xrange(k)] 
            curr = 0
            while ordered_set:  # the while loop runs O(k) times
                if len(stks)-curr in freq_to_nodes:  # fill the deterministic elements into the remaining subsets
                    for x in freq_to_nodes[len(stks)-curr].iterkeys():  # total time = O(n)
                        for i in xrange(curr, len(stks)):
                            stks[i].append(x)
                        count.pop(x)
                        ordered_set.remove(ordered_set.find(x))
                    freq_to_nodes.pop(len(stks)-curr)
                # greedily fill the contiguous ordered elements into the first vacant subset until it is full,
                # otherwise, the result sum would get larger =&gt; in fact, this is wrong
                it = ordered_set.begin()
                while it != ordered_set.end():
                    x = it.val
                    stks[curr].append(x)
                    freq_to_nodes[count[x]].pop(x)
                    if not freq_to_nodes[count[x]]:
                        freq_to_nodes.pop(count[x])
                    count[x] -= 1  # total time = O(n)
                    if not count[x]:
                        count.pop(x)
                        it = ordered_set.remove(it)  # total time = O(nlogn)
                    else:
                        freq_to_nodes[count[x]][x] = count[x]
                        it = it.nexts[0]
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True))  # two possible minimas


# Time:  O(nlogn + k * n), could be improved to O(nlogn) by skiplist or orderedlist
# Space: O(n)
import collections
# wrong with greedy solution
# nums = [15, 9, 7, 10, 15, 14, 12, 2, 10, 8, 10, 13, 4, 11, 2]
# k = 5
# greedy  =&gt; [[2, 4, 7], [2, 8, 9], [10, 11, 12], [10, 13, 15], [10, 14, 15]] =&gt; 24
# correct =&gt; [[2, 4, 7], [2, 8, 10], [9, 10, 11], [10, 12, 15], [13, 14, 15]] =&gt; 22
class Solution_Wrong_Greedy(object):
    def minimumIncompatibility(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def greedy(nums, k, is_reversed):
            count = collections.Counter(nums)
            if max(count.itervalues()) &gt; k:
                return -1
            sorted_keys = sorted(count.keys(), reverse=is_reversed)
            stks = [[] for _ in xrange(k)] 
            curr, remain = 0, len(nums)
            while remain:  # the while loop runs O(k) times, and the inner loops runs O(n) times
                for x in sorted_keys:  # fill the deterministic elements into the remaining subsets
                    if count[x] != len(stks)-curr:
                        continue
                    for i in xrange(curr, len(stks)):
                        stks[i].append(x)
                    remain -= count[x]
                    count[x] = 0
                # greedily fill the contiguous ordered elements into the first vacant subset until it is full,
                # otherwise, the result sum would get larger =&gt; in fact, this is wrong
                for x in sorted_keys:
                    if not count[x]:
                        continue
                    stks[curr].append(x)
                    remain -= 1
                    count[x] -= 1
                    if len(stks[curr]) == len(nums)//k:
                        curr += 1
                        break
            return sum([max(stk)-min(stk) for stk in stks])

        return min(greedy(nums, k, False), greedy(nums, k, True))  # two possible minimas

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1682 - https://leetcode.com/problems/longest-palindromic-subsequence-ii/
Time: O(n^2)  Space: O(n)   Medium
.Python/longest-palindromic-subsequence-ii.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def longestPalindromeSubseq(self, s):
        """
        :type s: str
        :rtype: int
        """
        dp = [[[0]*26 for _ in xrange(len(s))] for _ in xrange(2)]
        for i in reversed(xrange(len(s))):
            for j in xrange(i+1, len(s)):
                if i == j-1:
                    if s[j] == s[i]:
                        dp[i%2][j][ord(s[i])-ord('a')] = 2
                else:
                    for k in xrange(26):
                        if s[j] == s[i] and ord(s[j])-ord('a') != k:
                            dp[i%2][j][ord(s[j])-ord('a')] = max(dp[i%2][j][ord(s[j])-ord('a')], dp[(i+1)%2][j-1][k]+2);
                        dp[i%2][j][k] = max(dp[i%2][j][k], dp[i%2][j-1][k], dp[(i+1)%2][j][k], dp[(i+1)%2][j-1][k])
        return max(dp[0][-1])

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1690 - https://leetcode.com/problems/stone-game-vii/
Time: O(n^2)  Space: O(n)   Medium
.Python/stone-game-vii.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def stoneGameVII(self, stones):
        """
        :type stones: List[int]
        :rtype: int
        """
        def score(i, j):
            return prefix[j+1]-prefix[i]

        prefix = [0]
        for stone in stones:
            prefix.append(prefix[-1]+stone)
        dp = [[0 for _ in xrange(len(stones))] for _ in xrange(2)]
        for i in reversed(xrange(len(stones))):
            for j in xrange(i+1, len(stones)):
                dp[i%2][j] = max(score(i+1, j)-dp[(i+1)%2][j], score(i, j-1)-dp[i%2][j-1])
        return dp[0][-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1691 - https://leetcode.com/problems/maximum-height-by-stacking-cuboids/
Time: O(n^2)  Space: O(n)   Hard
.Python/maximum-height-by-stacking-cuboids.py


```python
# Time:  O(n^2)
# Space: O(n)
    
class Solution(object):
    def maxHeight(self, cuboids):
        """
        :type cuboids: List[List[int]]
        :rtype: int
        """
        for cuboid in cuboids:
            cuboid.sort()
        cuboids.append([0, 0, 0])
        cuboids.sort()
        dp = [0]*len(cuboids)
        for i in xrange(1, len(cuboids)):
            for j in xrange(i):
                if all(cuboids[j][k] &lt;= cuboids[i][k] for k in xrange(3)):
                    dp[i] = max(dp[i], dp[j]+cuboids[i][2])
        return max(dp)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1692 - https://leetcode.com/problems/count-ways-to-distribute-candies/
Time: O(n * k)  Space: O(k)   Hard
.Python/count-ways-to-distribute-candies.py


```python
# Time:  O(n * k)
# Space: O(k)

class Solution(object):
    def waysToDistribute(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: int
        """
        MOD = 10**9+7
        dp = [1]*k
        for i in xrange(1, n):
            for j in reversed(xrange(1, min(i, k))):
                dp[j] = ((j+1)*dp[j] + dp[j-1]) % MOD
        return dp[k-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1745 - https://leetcode.com/problems/palindrome-partitioning-iv/
Time: O(n^2)  Space: O(n)   Hard
.Python/palindrome-partitioning-iv.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def checkPartitioning(self, s):
        """
        :type s: str
        :rtype: bool
        """
        def manacher(s):
            s = '^#' + '#'.join(s) + '#$'
            P = [0]*len(s)
            C, R = 0, 0
            for i in xrange(1, len(s)-1):
                i_mirror = 2*C-i
                if R &gt; i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] &gt; R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        prefix, suffix = [], []
        for i in xrange(2, len(P)-2):
            if i-1-P[i] == 0:
                prefix.append(i)
            if i+1+P[i] == len(P)-1:
                suffix.append(i)
        for i in prefix:
            for j in suffix:
                left, right = i+1+P[i], j-1-P[j]
                if left &gt; right:
                    continue
                mid = left + (right-left)//2
                if P[mid] &gt;= mid-left:
                    return True
        return False


# Time:  O(n^2)
# Space: O(n^2)
class Solution2(object):
    def checkPartitioning(self, s):
        """
        :type s: str
        :rtype: bool
        """        
        dp = [[False]*len(s) for _ in xrange(len(s))]
        for i in reversed(xrange(len(s))):
            for j in xrange(i, len(s)):
                if s[i] == s[j] and (j-i &lt; 2 or dp[i+1][j-1]):
                    dp[i][j] = True
        for i in xrange(1, len(s)-1):
            if not dp[0][i-1]:
                continue
            for j in xrange(i+1, len(s)):
                if not dp[j][-1]:
                    continue
                if dp[i][j-1]:
                    return True
        return False

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1746 - https://leetcode.com/problems/maximum-subarray-sum-after-one-operation/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-subarray-sum-after-one-operation.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxSumAfterOperation(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        prev_with_square = prev_without_square = 0
        result = 0
        for num in nums:
            without_square = max(num, num+prev_without_square)
            with_square = max(num*num, num*num+prev_without_square, num+prev_with_square)
            result = max(result, with_square)
            prev_with_square, prev_without_square = with_square, without_square
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1751 - https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/
Time: O(nlogn + n * k)  Space: O(n * k)   Hard
.Python/maximum-number-of-events-that-can-be-attended-ii.py


```python
# Time:  O(nlogn + n * k)
# Space: O(n * k)

import bisect


class Solution(object):
    def maxValue(self, events, k):
        """
        :type events: List[List[int]]
        :type k: int
        :rtype: int
        """
        events.sort(key=lambda x: x[1])
        sorted_ends = [x[1] for x in events]
        dp = [[0]*(k+1) for _ in xrange(len(events)+1)]
        for i in xrange(1, len(events)+1):
            prev_i_m_1 = bisect.bisect_left(sorted_ends, events[i-1][0])-1
            for j in xrange(1, k+1):
                dp[i][j] = max(dp[i-1][j], dp[prev_i_m_1+1][j-1]+events[i-1][2])
        return dp[-1][-1]


# Time:  O(nlogn + n * k)
# Space: O(n * k)
import bisect


class Solution2(object):
    def maxValue(self, events, k):
        """
        :type events: List[List[int]]
        :type k: int
        :rtype: int
        """
        events.sort()
        sorted_starts = [x[0] for x in events]
        dp = [[0]*(k+1) for _ in xrange(len(events)+1)]
        for i in reversed(xrange(len(events))):
            next_i = bisect.bisect_right(sorted_starts, events[i][1])-1
            for j in xrange(1, k+1):
                dp[i][j] = max(dp[i+1][j], dp[next_i+1][j-1]+events[i][2])
        return dp[0][-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1770 - https://leetcode.com/problems/maximum-score-from-performing-multiplication-operations/
Time: O(m^2)  Space: O(m)   Medium
.Python/maximum-score-from-performing-multiplication-operations.py


```python
# Time:  O(m^2)
# Space: O(m)

class Solution(object):
    def maximumScore(self, nums, multipliers):
        """
        :type nums: List[int]
        :type multipliers: List[int]
        :rtype: int
        """
        dp = [0]*(len(multipliers)+1)
        for l, m in enumerate(reversed(multipliers), start=len(nums)-len(multipliers)):
            dp = [max(m*nums[i]+dp[i+1], m*nums[i+l]+dp[i]) for i in xrange(len(dp)-1)]
        return dp[0]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1771 - https://leetcode.com/problems/maximize-palindrome-length-from-subsequences/
Time: O((m + n)^2)  Space: O((m + n)^2)   Hard
.Python/maximize-palindrome-length-from-subsequences.py


```python
# Time:  O((m + n)^2)
# Space: O((m + n)^2)

class Solution(object):
    def longestPalindrome(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """
        s = word1+word2
        dp = [[0]*len(s) for _ in xrange(len(s))]
        result = 0
        for j in xrange(len(s)):
            dp[j][j] = 1
            for i in reversed(xrange(j)):
                if s[i] == s[j]:
                    dp[i][j] = 2 if i+1 == j else dp[i+1][j-1] + 2
                    if i &lt; len(word1) &lt;= j:
                        result = max(result, dp[i][j])
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return result


# Time:  O((m + n)^2)
# Space: O((m + n)^2)
class Solution2(object):
    def longestPalindrome(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: int
        """
        s = word1+word2
        dp = [[0]*len(s) for _ in xrange(len(s))]
        for j in xrange(len(s)):
            dp[j][j] = 1
            for i in reversed(xrange(j)):
                if s[i] == s[j]:
                    dp[i][j] = 2 if i+1 == j else dp[i+1][j-1] + 2
                else:
                    dp[i][j] = max(dp[i+1][j], dp[i][j-1])
        return max([dp[i][j] for i in xrange(len(word1)) for j in xrange(len(word1), len(s)) if s[i] == s[j]] or [0])

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1774 - https://leetcode.com/problems/closest-dessert-cost/
Time: O(m * t)  Space: O(t)   Medium
.Python/closest-dessert-cost.py


```python
# Time:  O(m * max(max_base, target + max_topping / 2)) ~= O(m * t)
# Space: O(max(max_base, target + max_topping / 2)) ~= O(t)

class Solution(object):
    def closestCost(self, baseCosts, toppingCosts, target):
        """
        :type baseCosts: List[int]
        :type toppingCosts: List[int]
        :type target: int
        :rtype: int
        """
        max_count = 2
        max_base, max_topping = max(baseCosts), max(toppingCosts)
        dp = [False]*(max(max_base, target+max_topping//2)+1)
        for b in baseCosts:
            dp[b] = True
        for t in toppingCosts:
            for _ in xrange(max_count):
                for i in reversed(xrange(len(dp)-t)):
                    if dp[i]:
                        dp[i+t] = True
        result = float("inf")
        for i in xrange(1, len(dp)):
            if not dp[i]:
                continue
            if abs(i-target) &lt; abs(result-target):
                result = i
            if i &gt;= target:
                break
        return result
            

# Time:  O(n * 3^m)
# Space: O(m * t)
class Solution2(object):
    def closestCost(self, baseCosts, toppingCosts, target):
        """
        :type baseCosts: List[int]
        :type toppingCosts: List[int]
        :type target: int
        :rtype: int
        """
        max_count = 2
        def backtracking(toppingCosts, i, cost, target, lookup, result):
            if (i, cost) in lookup:
                return
            lookup.add((i, cost))
            if cost &gt;= target or i == len(toppingCosts):
                if (abs(cost-target), cost) &lt; (abs(result[0]-target), result[0]):
                    result[0] = cost
                return
            for j in xrange(max_count+1):
                backtracking(toppingCosts, i+1, cost+j*toppingCosts[i], target, lookup, result)

        result = [float("inf")]
        lookup = set()
        for b in baseCosts:
            backtracking(toppingCosts, 0, b, target, lookup, result)
        return result[0]


# Time:  O(3^m*log(3^m)) + O(n*log(3^m)) = O(m*(3^m + n))
# Space: O(3^m)
import bisect


class Solution3(object):
    def closestCost(self, baseCosts, toppingCosts, target):
        """
        :type baseCosts: List[int]
        :type toppingCosts: List[int]
        :type target: int
        :rtype: int
        """
        max_count = 2
        combs = set([0])
        for t in toppingCosts:
            combs = set([c+i*t for c in combs for i in xrange(max_count+1)])
        result, combs = float("inf"), sorted(combs)
        for b in baseCosts:
            idx = bisect.bisect_left(combs, target-b)
            if idx &lt; len(combs):
                result = min(result, b+combs[idx], key=lambda x: (abs(x-target), x))
            if idx &gt; 0:
                result = min(result, b+combs[idx-1], key=lambda x: (abs(x-target), x))        
        return result


# Time:  O(n * 3^m)
# Space: O(3^m)
class Solution4(object):
    def closestCost(self, baseCosts, toppingCosts, target):
        """
        :type baseCosts: List[int]
        :type toppingCosts: List[int]
        :type target: int
        :rtype: int
        """
        max_count = 2
        combs = set([0])
        for t in toppingCosts:
            combs = set([c+i*t for c in combs for i in xrange(max_count+1)])
        result = float("inf")
        for b in baseCosts:
            for c in combs:
                result = min(result, b+c, key=lambda x: (abs(x-target), x))      
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1787 - https://leetcode.com/problems/make-the-xor-of-all-segments-equal-to-zero/
Time: O(n + k * m)  Space: O(min(k * m, n))   Hard
.Python/make-the-xor-of-all-segments-equal-to-zero.py


```python
# Time:  O(n + k * m), m is the max number of nums
# Space: O(min(k * m, n))

import collections


class Solution(object):
    def minChanges(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def one_are_not_from_nums(nums, cnts):
            mxs = [cnts[i].most_common(1)[0][1] for i in xrange(k)]
            return len(nums) - (sum(mxs)-min(mxs))

        def all_are_from_nums(nums, cnts):
            dp = {0:0}
            for cnt in cnts:
                new_dp = collections.defaultdict(int)
                for x in dp.iterkeys():
                    for y in cnt.iterkeys():
                        new_dp[x^y] = max(new_dp[x^y], dp[x]+cnt[y])
                dp = new_dp
            return len(nums)-dp[0]
          
        cnts = [collections.Counter(nums[j] for j in xrange(i, len(nums), k)) for i in xrange(k)]
        return min(one_are_not_from_nums(nums, cnts), all_are_from_nums(nums, cnts))

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1799 - https://leetcode.com/problems/maximize-score-after-n-operations/
Time: O(n^2 * 2^n)  Space: O(2^n)   Hard
.Python/maximize-score-after-n-operations.py


```python
# Time:  O(n^2 * 2^n)
# Space: O(2^n)

import itertools
from fractions import gcd


class Solution(object):
    def maxScore(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def popcount(n):
            count = 0
            while n:
                n &amp;= n-1
                count += 1
            return count

        def bits(mask):
            result = []
            i = 0
            while mask:
                if mask&amp;1:
                    result.append(i)
                i += 1
                mask &gt;&gt;= 1
            return result
            
        dp = [0]*(2**len(nums))
        for mask in xrange(3, len(dp)):
            cnt = popcount(mask)
            if cnt%2:
                continue
            for i, j in itertools.combinations(bits(mask), 2):  # Time: O(n^2)
                dp[mask] = max(dp[mask], cnt//2*gcd(nums[i], nums[j]) + dp[mask^(1&lt;&lt;i)^(1&lt;&lt;j)])
        return dp[-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1803 - https://leetcode.com/problems/count-pairs-with-xor-in-a-range/
Time: O(n)  Space: O(n)   Hard
.Python/count-pairs-with-xor-in-a-range.py


```python
# Time:  O(n)
# Space: O(n)

import collections


# dp solution
class Solution(object):
    def countPairs(self, nums, low, high):
        """
        :type nums: List[int]
        :type low: int
        :type high: int
        :rtype: int
        """
        def count(nums, x):
            result = 0
            dp = collections.Counter(nums)
            while x:
                if x&amp;1:
                    result += sum(dp[(x^1)^k]*dp[k] for k in dp.iterkeys())//2  # current limit is xxxxx1*****, count xor pair with xxxxx0***** pattern
                dp = collections.Counter({k&gt;&gt;1: dp[k]+dp[k^1] for k in dp.iterkeys()})
                x &gt;&gt;= 1
            return result
    
        return count(nums, high+1)-count(nums, low)


# Time:  O(n)
# Space: O(n)
# trie solution
class Trie(object):
    def __init__(self):
        self.__root = {}
        
    def insert(self, num):
        node = self.__root
        for i in reversed(xrange(32)):
            curr = (num&gt;&gt;i) &amp; 1
            if curr not in node:
                node[curr] = {"_count":0}
            node = node[curr]
            node["_count"] += 1
                
    def query(self, num, limit):
        node, result = self.__root, 0
        for i in reversed(xrange(32)):
            curr = (num&gt;&gt;i) &amp; 1
            bit = (limit&gt;&gt;i) &amp; 1
            if bit:
                if curr in node:
                    result += node[0^curr]["_count"]  # current limit is xxxxx1*****, count xor pair with xxxxx0***** pattern
            if bit^curr not in node:
                break
            node = node[bit^curr]
        return result


class Solution2(object):
    def countPairs(self, nums, low, high):
        """
        :type nums: List[int]
        :type low: int
        :type high: int
        :rtype: int
        """
        result = 0
        trie = Trie()
        for x in nums:
            result += trie.query(x, high+1)-trie.query(x, low)
            trie.insert(x)
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1857 - https://leetcode.com/problems/largest-color-value-in-a-directed-graph/
Time: O(n + m)  Space: O(n + m)   Hard
.Python/largest-color-value-in-a-directed-graph.py


```python
# Time:  O(n + m)
# Space: O(n + m)

class Solution(object):
    def largestPathValue(self, colors, edges):
        """
        :type colors: str
        :type edges: List[List[int]]
        :rtype: int
        """
        adj = [[] for _ in xrange(len(colors))]
        in_degree = [0]*len(colors)
        for u, v in edges:
            adj[u].append(v)
            in_degree[v] += 1
        q = []
        for u in xrange(len(colors)):
            if not in_degree[u]:
                q.append(u)
        dp = [[0]*26 for _ in xrange(len(colors))]
        result, cnt = -1, 0
        while q:
            new_q = []
            for u in q:
                cnt += 1
                dp[u][ord(colors[u])-ord('a')] += 1
                result = max(result, dp[u][ord(colors[u])-ord('a')])
                for v in adj[u]:
                    for c in xrange(26):
                        dp[v][c] = max(dp[v][c], dp[u][c])
                    in_degree[v] -= 1
                    if not in_degree[v]:
                        new_q.append(v)
            q = new_q
        return result if cnt == len(colors) else -1

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1866 - https://leetcode.com/problems/number-of-ways-to-rearrange-sticks-with-k-sticks-visible/
Time: O(n * k)  Space: O(k)   Hard
.Python/number-of-ways-to-rearrange-sticks-with-k-sticks-visible.py


```python
# Time:  O(n * k)
# Space: O(k)

class Solution(object):
    def rearrangeSticks(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: int
        """
        MOD = 10**9+7
        dp = [[0 for _ in xrange(k+1)] for _ in xrange(2)]
        dp[1][1] = 1
        for i in xrange(2, n+1):
            for j in xrange(1, min(i, k)+1):
                # choose the tallest as the last one which would be visible:    dp[i-1][j-1]
                # choose the non-tallest as the last one which would be hidden: (i-1)*dp[i-1][j]
                dp[i%2][j] = (dp[(i-1)%2][j-1]+(i-1)*dp[(i-1)%2][j]) % MOD 
        return dp[n%2][k]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1871 - https://leetcode.com/problems/jump-game-vii/
Time: O(n)  Space: O(n)   Medium
.Python/jump-game-vii.py


```python
# Time:  O(n)
# Space: O(n)

# dp with line sweep solution
class Solution(object):
    def canReach(self, s, minJump, maxJump):
        """
        :type s: str
        :type minJump: int
        :type maxJump: int
        :rtype: bool
        """
        dp = [False]*len(s)
        dp[0] = True
        cnt = 0
        for i in xrange(1, len(s)):
            if i &gt;= minJump:
                cnt += dp[i-minJump]
            if i &gt; maxJump:
                cnt -= dp[i-maxJump-1]
            dp[i] = cnt &gt; 0 and s[i] == '0'
        return dp[-1]


# Time:  O(n)
# Space: O(n)
import collections


# bfs solution
class Solution2(object):
    def canReach(self, s, minJump, maxJump):
        """
        :type s: str
        :type minJump: int
        :type maxJump: int
        :rtype: bool
        """
        q = collections.deque([0])
        reachable = 0
        while q:
            i = q.popleft()
            for j in xrange(max(i+minJump, reachable+1), min(i+maxJump+1, len(s))):
                if s[j] != '0':
                    continue
                q.append(j)
            reachable = i+maxJump
        return i == len(s)-1

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1872 - https://leetcode.com/problems/stone-game-viii/
Time: O(n)  Space: O(1)   Hard
.Python/stone-game-viii.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def stoneGameVIII(self, stones):
        """
        :type stones: List[int]
        :rtype: int
        """
        for i in xrange(len(stones)-1):
            stones[i+1] += stones[i]
        return reduce(lambda curr, i: max(curr, stones[i]-curr), reversed(xrange(1, len(stones)-1)), stones[-1])

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1883 - https://leetcode.com/problems/minimum-skips-to-arrive-at-meeting-on-time/
Time: O(n^2)  Space: O(n)   Hard
.Python/minimum-skips-to-arrive-at-meeting-on-time.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def minSkips(self, dist, speed, hoursBefore):
        """
        :type dist: List[int]
        :type speed: int
        :type hoursBefore: int
        :rtype: int
        """
        def ceil(a, b):
            return (a+b-1)//b

        dp = [0]*((len(dist)-1)+1)  # dp[i]: (min time by i skips) * speed
        for i, d in enumerate(dist):
            for j in reversed(xrange(len(dp))):
                dp[j] = ceil(dp[j]+d, speed)*speed if i &lt; len(dist)-1 else dp[j]+d
                if j-1 &gt;= 0:
                    dp[j] = min(dp[j], dp[j-1]+d)
        target = hoursBefore*speed
        for i in xrange(len(dist)):
            if dp[i] &lt;= target:
                return i
        return -1

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1896 - https://leetcode.com/problems/minimum-cost-to-change-the-final-value-of-expression/
Time: O(n)  Space: O(n)   Hard
.Python/minimum-cost-to-change-the-final-value-of-expression.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def minOperationsToFlip(self, expression):
        """
        :type expression: str
        :rtype: int
        """
        def compute(operands, operators):
            right, left = operands.pop(), operands.pop()
            operands.append(ops[operators.pop()](left, right))

        ops = {'&amp;':lambda x, y: [min(x[0], y[0]), min(x[1]+y[1], min(x[1], y[1])+1)],
               '|':lambda x, y: [min(x[0]+y[0], min(x[0], y[0])+1), min(x[1], y[1])]}
        precedence = {'&amp;':0, '|':0}
        operands, operators = [], []
        for c in expression:
            if c.isdigit():
                operands.append([int(c != '0'), int(c != '1')])
            elif c == '(':
                operators.append(c)
            elif c == ')':
                while operators[-1] != '(':
                    compute(operands, operators)
                operators.pop()
            elif c in precedence:
                while operators and operators[-1] in precedence and \
                      precedence[operators[-1]] &gt;= precedence[c]:
                    compute(operands, operators)
                operators.append(c)
        while operators:
            compute(operands, operators)
        return max(operands[-1])


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def minOperationsToFlip(self, expression):
        """
        :type expression: str
        :rtype: int
        """
        stk = [[None]*3]
        for c in expression:                                
            if c == '(':                                            
                stk.append([None]*3)
            elif c in {')', '0', '1'}:
                if c == ')':
                    dp0, dp1, _ = stk.pop()
                else:
                    dp0, dp1 = int(c != '0'), int(c != '1')
                if stk[-1][2] == '&amp;':
                    stk[-1] = [min(stk[-1][0], dp0),
                               min(stk[-1][1]+dp1, min(stk[-1][1], dp1)+1),
                               None]
                elif stk[-1][2] == '|':
                    stk[-1] = [min(stk[-1][0]+dp0, min(stk[-1][0], dp0)+1),
                               min(stk[-1][1], dp1),
                               None]
                else:  # operand
                    stk[-1] = [dp0, dp1, None]
            else:
                stk[-1][2] = c
        return max(stk[0][0], stk[0][1])

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1900 - https://leetcode.com/problems/the-earliest-and-latest-rounds-where-players-compete/
Time: O(n^4)  Space: O(n^2)   Hard
.Python/the-earliest-and-latest-rounds-where-players-compete.py


```python
# Time:  O(n^2) states * O(n^2) per state = O(n^4)
# Space: O(n^2 + (n/2)^2 + (n/4)^2 + ... ) = O(n^2)

class Solution(object):
    def earliestAndLatest(self, n, firstPlayer, secondPlayer):
        """
        :type n: int
        :type firstPlayer: int
        :type secondPlayer: int
        :rtype: List[int]
        """
        def memoization(t, l, r, lookup):
            # t: total number of players,
            # l: number of players left to the nearest top2 player,
            # r: number of players right to the nearest top2 player
            if (t, l, r) not in lookup:
                if l == r:
                    return (1, 1)
                if l &gt; r:  # make sure l &lt;= r
                    l, r, = r, l
                result = [float("inf"), 0]
                for i in xrange(l+1):
                    l_win_cnt, l_lose_cnt, nt, pair_cnt = i+1, l-i, (t+1)//2, t//2
                    min_j = max(l_lose_cnt, r-(pair_cnt-l_lose_cnt))  # j &gt;= l_lose_cnt and j &gt;= r-(pair_cnt-l_lose_cnt)
                    max_j = min(r-l_win_cnt, (nt-l_win_cnt)-1)  # j &lt;= r-l_win_cnt and j &lt;= (nt-l_win_cnt)-1
                    for j in xrange(min_j, max_j+1):
                        tmp = memoization(nt, i, j, lookup)
                        result = min(result[0], tmp[0]+1), max(result[1], tmp[1]+1)
                lookup[t, l, r] = result
            return lookup[t, l, r]
        
        return memoization(n, firstPlayer-1, n-secondPlayer, {})

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1908 - https://leetcode.com/problems/game-of-nim/
Time: O(n)  Space: O(1)   Medium
.Python/game-of-nim.py


```python
# Time:  O(n)
# Space: O(1)

import operator


class Solution(object):
    def nimGame(self, piles):
        """
        :type piles: List[int]
        :rtype: bool
        """
        return reduce(operator.xor, piles, 0)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1931 - https://leetcode.com/problems/painting-a-grid-with-three-different-colors/
Time: O(2^(3 * m) * logn)  Space: O(2^(2 * m))   Hard
.Python/painting-a-grid-with-three-different-colors.py


```python
# Time:  O(m * 2^m + 3^m + 2^(3 * m) * logn) = O(2^(3 * m) * logn)
# Space: O(2^(2 * m))

import collections
import itertools


# better complexity for small m, super large n
# matrix exponentiation solution
class Solution(object):
    def colorTheGrid(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        MOD = 10**9+7
        def backtracking(mask1, mask2, basis, result):  # Time: O(2^m), Space: O(2^m)
            if not basis:
                result.append(mask2)
                return
            for i in xrange(3):
                if (mask1 == -1 or mask1//basis%3 != i) and (mask2 == -1 or mask2//(basis*3)%3 != i):
                    backtracking(mask1, mask2+i*basis if mask2 != -1 else i*basis, basis//3, result)

        def matrix_mult(A, B):
            ZB = zip(*B)
            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        def normalize(basis, mask):
            norm = {}
            result = 0
            while basis:
                x = mask//basis%3
                if x not in norm:
                    norm[x] = len(norm)
                result += norm[x]*basis
                basis //= 3
            return result

        if m &gt; n:
            m, n = n, m
        basis = 3**(m-1)
        masks = []
        backtracking(-1, -1, basis, masks)  # Time: O(2^m), Space: O(2^m)
        assert(len(masks) == 3 * 2**(m-1))
        lookup = {mask:normalize(basis, mask) for mask in masks}  # Time: O(m * 2^m)
        normalized_mask_cnt = collections.Counter(lookup[mask] for mask in masks)
        assert(len(normalized_mask_cnt) == 3*2**(m-1) // 3 // (2 if m &gt;= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance
        adj = collections.defaultdict(list)
        for mask in normalized_mask_cnt.iterkeys():  # O(3^m) leaves which are all in depth m =&gt; Time: O(3^m), Space: O(3^m)
            backtracking(mask, -1, basis, adj[mask])
        normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int))
        for mask1, masks2 in adj.iteritems():
            for mask2 in masks2:
                normalized_adj[mask1][lookup[mask2]] = (normalized_adj[mask1][lookup[mask2]]+1)%MOD
        # divided by 3 * 2 is since the first two colors in upper row are normalized to speed up performance,
        # since first two colors in lower row which has at most 3 choices could be also normalized, lower bound is upper bound divided by at most 3
        assert(2*3**m // 3 // 2 // 3 &lt;= sum(len(v) for v in normalized_adj.itervalues()) &lt;= 2*3**m // 3 // 2)
        return reduce(lambda x,y: (x+y)%MOD,
                      matrix_mult([normalized_mask_cnt.values()],
                                   matrix_expo([[normalized_adj[mask1][mask2]
                                                 for mask2 in normalized_mask_cnt.iterkeys()] 
                                                 for mask1 in normalized_mask_cnt.iterkeys()], n-1))[0],
                      0)  # Time: O((2^m)^3 * logn), Space: O((2^m)^2)


# Time:  O(n * 3^m)
# Space: O(3^m)
import collections


# better complexity for small m, large n
class Solution2(object):
    def colorTheGrid(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        MOD = 10**9+7
        def find_masks(m, basis):  # Time: 3 + 3*2 + 3*2*2 + ... + 3*2^(m-1) = 3 * (2^m - 1) = O(2^m), Space: O(2^m)
            masks = [0]
            for c in xrange(m):
                new_masks = []
                for mask in masks:
                    choices = {0, 1, 2}
                    if c &gt; 0:
                        choices.discard(mask//basis)  # get left grid
                    for x in choices:
                        new_masks.append((x*basis)+(mask//3))  # encoding mask
                masks = new_masks
            return masks

        def find_adj(m, basis, dp):
            # Time:  3*2^(m-1) * (1 + 2 + 2 * (3/2) + 2 * (3/2)^2 + ... + 2 * (3/2)^(m-2)) =
            #        3*2^(m-1) * (1+2*((3/2)^(m-1)-1)/((3/2)-1)) =
            #        3*2^(m-1) * (1+4*((3/2)^(m-1)-1)) =
            #        3*2^(m-1) * (4*(3/2)^(m-1)-3) =
            #        4*3^m-9*2^(m-1) =
            #        O(3^m),
            # Space: O(3^m)
            adj = collections.defaultdict(list)
            for mask in dp.iterkeys():  # O(2^m)
                adj[mask].append(mask)
            for c in xrange(m):
                assert(sum(len(v) for v in adj.itervalues()) == (3**c * 2**(m-(c-1)) if c &gt;= 1 else 3 * 2**(m-1)) // 3 // (2 if m &gt;= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance
                new_adj = collections.defaultdict(list)
                for mask1, mask2s in adj.iteritems():
                    for mask in mask2s:
                        choices = {0, 1, 2}
                        choices.discard(mask%3)  # get up grid
                        if c &gt; 0:
                            choices.discard(mask//basis)  # get left grid
                        for x in choices:
                            new_adj[mask1].append((x*basis)+(mask//3))  # encoding mask
                adj = new_adj
            assert(sum(3**c * 2**(m-(c-1)) if c &gt;= 1 else 3 * 2**(m-1) for c in xrange(m)) == 4*3**m-9*2**(m-1))
            return adj
 
        def normalize(basis, mask):
            norm = {}
            result = 0
            while basis:
                x = mask//basis%3
                if x not in norm:
                    norm[x] = len(norm)
                result += norm[x]*basis
                basis //= 3
            return result

        if m &gt; n:
            m, n = n, m
        basis = 3**(m-1)
        masks = find_masks(m, basis)  # alternative of backtracking, Time: O(2^m), Space: O(2^m)
        assert(len(masks) == 3 * 2**(m-1))
        lookup = {mask:normalize(basis, mask) for mask in masks}  # Time: O(m * 2^m)
        dp = collections.Counter(lookup[mask] for mask in masks)  # normalize colors to speed up performance
        adj = find_adj(m, basis, dp)  # alternative of backtracking, Time: O(3^m), Space: O(3^m)
        # proof:
        #   'o' uses the same color with its bottom-left one, 
        #   'x' uses the remaining color different from its left one and bottom-left one,
        #   k is the cnt of 'o', 
        #     [3, 1(o), 1(x), 1(o), ..., 1(o), 1(x)] =&gt; nCr(m-1, k) * 3 * 2 * 2^k for k in xrange(m) = 3 * 2 * (2+1)^(m-1) = 2*3^m combinations
        #     [2,    2,    1,    2, ...,  2,      1]
        # another proof:
        #   given previous pair of colors, each pair of '?' has 3 choices of colors
        #     [3, ?, ?, ..., ?] =&gt; 3 * 2 * 3^(m-1) = 2*3^m combinations
        #         |  |       |
        #         3  3       3
        #         |  |       |
        #     [2, ?, ?, ..., ?]
        normalized_adj = collections.defaultdict(lambda:collections.defaultdict(int))
        for mask1, mask2s in adj.iteritems():
            for mask2 in mask2s:
                normalized_adj[lookup[mask1]][lookup[mask2]] = (normalized_adj[lookup[mask1]][lookup[mask2]]+1)%MOD
        # divided by 3 * 2 is since the first two colors in upper row are normalized to speed up performance,
        # since first two colors in lower row which has at most 3 choices could be also normalized, lower bound is upper bound divided by at most 3
        assert(2*3**m // 3 // 2 // 3 &lt;= sum(len(v) for v in normalized_adj.itervalues()) &lt;= 2*3**m // 3 // 2)
        for _ in xrange(n-1):  # Time: O(n * 3^m), Space: O(2^m)
            assert(len(dp) == 3*2**(m-1) // 3 // (2 if m &gt;= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance
            new_dp = collections.Counter()
            for mask, v in dp.iteritems():
                for new_mask, cnt in normalized_adj[mask].iteritems():
                    new_dp[lookup[new_mask]] = (new_dp[lookup[new_mask]] + v*cnt) % MOD
            dp = new_dp
        return reduce(lambda x,y: (x+y)%MOD, dp.itervalues(), 0)  # Time: O(2^m)


# Time:  (m * n grids) * (O(3*3*2^(m-2)) possible states per grid) = O(n * m * 2^m)
# Space: O(3*3*2^(m-2)) = O(2^m)
import collections


# better complexity for large m, large n
class Solution3(object):
    def colorTheGrid(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        MOD = 10**9+7
        def normalize(basis, mask, lookup):  # compute and cache, at most O(3*2^(m-3)) time and space
            if mask not in lookup[basis]:
                norm = {}
                result, b = 0, basis
                while b:
                    x = mask//b%3
                    if x not in norm:
                        norm[x] = len(norm)
                    result += norm[x]*b
                    b //= 3
                lookup[basis][mask] = result
            return lookup[basis][mask]

        if m &gt; n:
            m, n = n, m
        basis = b = 3**(m-1)
        lookup = collections.defaultdict(dict)
        dp = collections.Counter({0: 1})
        for idx in xrange(m*n):
            r, c = divmod(idx, m)
            # sliding window with size m doesn't cross rows:
            #   [3, 2, ..., 2] =&gt; 3*2^(m-1) combinations
            assert(r != 0 or c != 0 or len(dp) == 1)
            assert(r != 0 or c == 0 or len(dp) == 3*2**(c-1) // 3 // (2 if c &gt;= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance
            assert(r == 0 or c != 0 or len(dp) == 3*2**(m-1) // 3 // (2 if m &gt;= 2 else 1))  # divided by 3 * 2 is since the first two colors are normalized to speed up performance
            # sliding window with size m crosses rows:
            #   [*, ..., *, *, 3, 2, ..., 2] =&gt; 3*3 * 2^(m-2) combinations
            #   [2, ..., 2, 3, *, *, ..., *]
            assert(r == 0 or c == 0 or len(dp) == (1 if m == 1 else 2 if m == 2 else 3*3 * 2**(m-2) // 3 // 2))  # divided by 3 * 2 for m &gt;= 3 is since the first two colors of window are normalized to speed up performance
            new_dp = collections.Counter()
            for mask, v in dp.iteritems():
                choices = {0, 1, 2}
                if r &gt; 0:
                    choices.discard(mask%3)  # get up grid
                if c &gt; 0:
                    choices.discard(mask//basis)  # get left grid
                for x in choices:
                    new_mask = normalize(basis//b, ((x*basis)+(mask//3))//b, lookup)*b  # encoding mask
                    new_dp[new_mask] = (new_dp[new_mask]+v)%MOD
            if b &gt; 1:
                b //= 3
            dp = new_dp
        return reduce(lambda x,y: (x+y)%MOD, dp.itervalues(), 0)  # Time: O(2^m)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1937 - https://leetcode.com/problems/maximum-number-of-points-with-cost/
Time: O(m * n)  Space: O(n)   Medium
.Python/maximum-number-of-points-with-cost.py


```python
# Time:  O(m * n)
# Space: O(n)

class Solution(object):
    def maxPoints(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        dp = points[0]
        for i in xrange(1, len(points)):
            prefix = [0]*len(points[i])
            prefix[0] = dp[0]
            for j in xrange(1, len(points[i])):
                prefix[j] = max(prefix[j-1], dp[j]+j)
            suffix = [0]*len(points[i])
            suffix[-1] = dp[-1]-(len(points[i])-1)
            for j in reversed(xrange(len(points[i])-1)):
                suffix[j] = max(suffix[j+1], dp[j]-j)
            new_dp = [0]*len(points[i])
            for j in xrange(len(points[i])):
                new_dp[j] = max(prefix[j]-j, suffix[j]+j)+points[i][j]
            dp = new_dp
        return max(dp)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1955 - https://leetcode.com/problems/count-number-of-special-subsequences/
Time: O(n)  Space: O(1)   Hard
.Python/count-number-of-special-subsequences.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countSpecialSubsequences(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        MOD = 10**9+7
        dp = [0]*3
        for x in nums:
            dp[x] = ((dp[x]+dp[x])%MOD+(dp[x-1] if x-1 &gt;= 0 else 1))%MOD
        return dp[-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1959 - https://leetcode.com/problems/minimum-total-space-wasted-with-k-resizing-operations/
Time: O(k * n^2)  Space: O(k * n)   Medium
.Python/minimum-total-space-wasted-with-k-resizing-operations.py


```python
# Time:  O(k * n^2)
# Space: O(k * n)

class Solution(object):
    def minSpaceWastedKResizing(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        INF = float("inf")
        k += 1
        dp = [[INF]*(k+1) for _ in xrange(len(nums)+1)]
        dp[0][0] = 0
        for i in xrange(1, len(nums)+1):
            total = max_num = 0
            for j in reversed(xrange(1, i+1)):
                total += nums[j-1]
                max_num = max(max_num, nums[j-1])
                for m in xrange(1, k+1):
                    if dp[j-1][m-1] != INF:
                        dp[i][m] = min(dp[i][m], dp[j-1][m-1] + (max_num*(i-j+1)-total))
        return dp[-1][-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1960 - https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/
Time: O(n)  Space: O(n)   Hard
.Python/maximum-product-of-the-length-of-two-palindromic-substrings.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def maxProduct(self, s):
        """
        :type s: str
        :rtype: int
        """
        def manacher(s):
            s = '^#' + '#'.join(s) + '#$'
            P = [0]*len(s)
            C, R = 0, 0
            for i in xrange(1, len(s)-1):
                i_mirror = 2*C-i
                if R &gt; i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] &gt; R:
                    C, R = i, i+P[i]
            return P

        P = manacher(s)
        q = collections.deque()
        left = [0]
        for i in xrange(len(s)):
            while q and q[0][1] &lt; i:
                q.popleft()
            left.append(max(left[-1], 1+2*(i-q[0][0]) if q else 1))
            q.append((i, i+P[2*i+2]//2))
        q = collections.deque()
        result = right = 0
        for i in reversed(xrange(len(s))):
            while q and q[0][1] &gt; i:
                q.popleft()
            right = max(right, 1+2*(q[0][0]-i) if q else 1)
            q.append((i, i-P[2*i+2]//2))
            result = max(result, left[i]*right)
        return result


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def maxProduct(self, s):
        """
        :type s: str
        :rtype: int
        """
        def manacher(s):
            s = '^#' + '#'.join(s) + '#$'
            P = [0]*len(s)
            C, R = 0, 0
            for i in xrange(1, len(s)-1):
                i_mirror = 2*C-i
                if R &gt; i:
                    P[i] = min(R-i, P[i_mirror])
                while s[i+1+P[i]] == s[i-1-P[i]]:
                    P[i] += 1
                if i+P[i] &gt; R:
                    C, R = i, i+P[i]
            return P

        import operator
        def accumulate(iterable, func=operator.add, initial=None):
            it = iter(iterable)
            total = initial
            if initial is None:
                try:
                    total = next(it)
                except StopIteration:
                    return
            yield total
            for element in it:
                total = func(total, element)
                yield total

        def fin_max_len(s):
            P = manacher(s)
            intervals = [[(i-2)//2-P[i]//2, (i-2)//2+P[i]//2] for i in xrange(2,len(P)-2, 2)]
            dp = [0]*len(s)
            for l, r in reversed(intervals): 
                dp[r] = r-l+1
            for i in reversed(xrange(len(s)-1)):
                dp[i] = max(dp[i], dp[i+1]-2)
            return list(accumulate(dp, max, 0))
        
        l1, l2 = fin_max_len(s), fin_max_len(s[::-1])[::-1]
        return max(x*y for x, y in itertools.izip(l1, l2))

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1977 - https://leetcode.com/problems/number-of-ways-to-separate-numbers/
Time: O(n^2)  Space: O(n^2)   Hard
.Python/number-of-ways-to-separate-numbers.py


```python
# Time:  O(n^2)
# Space: O(n^2)

class Solution(object):
    def numberOfCombinations(self, num):
        """
        :type num: str
        :rtype: int
        """
        MOD = 10**9+7
        def find_longest_common_prefix(num):
            lcp = [[0]*(len(num)+1) for _ in xrange(len(num)+1)]  # lcp[i][j]: longest length of the common prefix which starts at num[i], num[j]
            for i in reversed(xrange(len(lcp)-1)):
                for j in reversed(xrange(len(lcp[0])-1)):
                    if num[i] == num[j]:
                        lcp[i][j] = lcp[i+1][j+1]+1
            return lcp

        def is_less_or_equal_to_with_same_length(num, lcp, i, j, l):
            return lcp[i][j] &gt;= l or num[i+lcp[i][j]] &lt; num[j+lcp[i][j]]

        lcp = find_longest_common_prefix(num)
        dp = [[0]*len(num) for _ in xrange(len(num))]  # dp[i][l]: the count of numbers ending at num[i], where the length of the last number is l+1
        dp[0][0] = int(num[0] != '0')
        for i in xrange(1, len(num)):
            dp[i][i] = dp[i-1][i-1]
            if num[i] == '0':
                continue
            accu = 0
            for l in xrange(len(num)-i+1):
                ni = i+l-1
                dp[ni][l-1] = accu  # accumulated count where the length of the second to last number ending at num[i-1] is shorter than the length of the last number ending at num[i+l-1]
                if i-l &lt; 0:
                    continue
                if num[i-l] != '0' and is_less_or_equal_to_with_same_length(num, lcp, i-l, i, l):
                    dp[ni][l-1] = (dp[ni][l-1] + dp[i-1][l-1]) % MOD
                accu = (accu + dp[i-1][l-1]) % MOD
        return reduce(lambda total, x: (total+x)%MOD, dp[-1], 0)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1981 - https://leetcode.com/problems/minimize-the-difference-between-target-and-chosen-elements/
Time: O(t * m * n)  Space: O(t)   Medium
.Python/minimize-the-difference-between-target-and-chosen-elements.py


```python
# Time:  O(t * m * n), t is target
# Space: O(t)

class Solution(object):
    def minimizeTheDifference(self, mat, target):
        """
        :type mat: List[List[int]]
        :type target: int
        :rtype: int
        """
        chosen_min = sum(min(row) for row in mat)
        if chosen_min &gt;= target:
            return chosen_min-target
        dp = {0}
        for row in mat:
            dp = {total+x for total in dp for x in row if (total+x)-target &lt; target-chosen_min}
        return min(abs(target-total) for total in dp)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1986 - https://leetcode.com/problems/minimum-number-of-work-sessions-to-finish-the-tasks/
Time: O(n * 2^n)  Space: O(2^n)   Medium
.Python/minimum-number-of-work-sessions-to-finish-the-tasks.py


```python
# Time:  O(n * 2^n)
# Space: O(2^n)

class Solution(object):
    def minSessions(self, tasks, sessionTime):
        """
        :type tasks: List[int]
        :type sessionTime: int
        :rtype: int
        """
        # dp[mask]: min used time by choosing tasks in mask bitset
        dp = [float("inf") for _ in xrange(1&lt;
<len(tasks))] +="" <<="1" basis="" continue="" dp[0]="0" dp[mask]%sessiontime="" for="" if="" in="" mask="" new_mask="mask:" task="" tasks:="" xrange(len(dp)-1):="">
 sessionTime:
                    task += sessionTime-dp[mask]%sessionTime  # take a break
                dp[new_mask] = min(dp[new_mask], dp[mask]+task)
        return (dp[-1]+sessionTime-1)//sessionTime


# Time:  O(n * 2^n)
# Space: O(2^n)
class Solution2(object):
    def minSessions(self, tasks, sessionTime):
        """
        :type tasks: List[int]
        :type sessionTime: int
        :rtype: int
        """
        # dp[mask][0]: min number of sessions by choosing tasks in mask bitset
        # dp[mask][1]: min used time of last session by choosing tasks in mask bitset
        dp = [[float("inf")]*2 for _ in xrange(1&lt;&lt;len(tasks))]
        dp[0] = [0, sessionTime]
        for mask in xrange(len(dp)-1):
            basis = 1
            for task in tasks:
                new_mask = mask|basis
                basis &lt;&lt;= 1
                if new_mask == mask:
                    continue
                if dp[mask][1]+task &lt;= sessionTime:
                    dp[new_mask] = min(dp[new_mask], [dp[mask][0], dp[mask][1]+task])
                else:
                    dp[new_mask] = min(dp[new_mask], [dp[mask][0]+1, task])
        return dp[-1][0]
</len(tasks))]>
```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1987 - https://leetcode.com/problems/number-of-unique-good-subsequences/
Time: O(n)  Space: O(1)   Hard
.Python/number-of-unique-good-subsequences.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def numberOfUniqueGoodSubsequences(self, binary):
        """
        :type binary: str
        :rtype: int
        """
        MOD = 10**9+7
        ends0, ends1 = 0, 0
        has_zero = False
        for b in binary:
            if b == '1':
                ends1 = (ends0+ends1+1)%MOD  # curr subsequences end with 1 is all prev distinct subsequences appended by 1 and plus "1"
            else:
                ends0 = (ends0+ends1)%MOD  # curr subsequences end with 0 is all prev distinct subsequences appended by 0 and don't plus "0"
                has_zero = True
        return (ends0+ends1+int(has_zero))%MOD  # add "0" if has_zero

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1994 - https://leetcode.com/problems/the-number-of-good-subsets/
Time: O(n * 2^p)  Space: O(2^p)   Hard
.Python/the-number-of-good-subsets.py


```python
# Time:  O(n * 2^p), p is the number of primes in [1, n]
# Space: O(2^p)

import collections


class Solution(object):
    def numberOfGoodSubsets(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def sieve_of_eratosthenes(n):  # Time: O(n * log(logn)), Space: O(n)
            if n &lt; 2:
                return []
            primes = [2]
            is_prime = [True]*((n+1)//2)
            for i in xrange(1, len(is_prime)):
                if not is_prime[i]:
                    continue
                primes.append(2*i+1)
                for j in xrange(2*i*(i+1), len(is_prime), (2*i+1)):
                    is_prime[j] = False
            return primes

        def to_mask(primes, x):
            mask, basis = 0, 1
            for p in primes:
                if x%p == 0:
                    mask |= basis
                basis &lt;&lt;= 1
            return mask

        MOD = 10**9+7
        primes = sieve_of_eratosthenes(max(nums))
        dp = [0]*(1&lt;&lt;len(primes))  # dp[i] = the number of different good subsets of which the total product equals to the product of the primes in bitset i
        dp[0] = 1
        cnts = collections.Counter(nums)
        for x, cnt in cnts.iteritems():
            if x == 1 or any(x%(p*p) == 0 for p in primes if p*p &lt;= x):
                continue
            mask = to_mask(primes, x)
            for i in xrange(len(dp)-1):
                if i&amp;mask:
                    continue
                dp[i|mask] = (dp[i|mask]+cnt*dp[i])%MOD
        return (pow(2, cnts[1], MOD))*(reduce(lambda total, x: (total+x)%MOD, dp, 0)-1)%MOD

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 1997 - https://leetcode.com/problems/first-day-where-you-have-been-in-all-the-rooms/
Time: O(n)  Space: O(n)   Medium
.Python/first-day-where-you-have-been-in-all-the-rooms.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def firstDayBeenInAllRooms(self, nextVisit):
        """
        :type nextVisit: List[int]
        :rtype: int
        """
        MOD = 10**9+7

        dp = [0]*len(nextVisit)
        for i in xrange(1, len(dp)):
            dp[i] = (dp[i-1]+1+(dp[i-1]-dp[nextVisit[i-1]])+1)%MOD
        return dp[-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2002 - https://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-subsequences/
Time: O(3^n)  Space: O(2^n)   Medium
.Python/maximum-product-of-the-length-of-two-palindromic-subsequences.py


```python
# Time:  O(3^n)
# Space: O(2^n)

class Solution(object):
    def maxProduct(self, s):
        """
        :type s: str
        :rtype: int
        """
        def palindromic_subsequence_length(s, mask):
            result = 0
            left, right = 0, len(s)-1
            left_bit, right_bit = 1&lt;
<left, 1<<right="" <="right:" elif="" if="" left="" left,="" left_bit="left+1," left_bit<<1="" mask&left_bit="0:" mask&right_bit="0:" right,="" right_bit="" while="">
 &gt;1
                elif s[left] == s[right]:
                    result += 1 if left == right else 2
                    left, left_bit = left+1, left_bit&lt;&lt;1
                    right, right_bit = right-1, right_bit&gt;&gt;1
                else:
                    return 0
            return result
        
        dp = [palindromic_subsequence_length(s, mask) for mask in xrange(1&lt;
 <len(s))] #="" <="result:" continue="" dp[mask]*(len(s)-dp[mask])="" enumeration:="" for="" if="" in="" mask="" optimize="" result="0" submask="" xrange(len(dp)):="">
  sum(nCr(n, k) * 2^k for k in xrange(n+1)) = (1 + 2)^n = 3^n
            # =&gt; Time: O(3^n), see https://cp-algorithms.com/algebra/all-submasks.html
            submask = inverse_mask = (len(dp)-1)^mask
            while submask:
                result = max(result, dp[mask]*dp[submask])
                submask = (submask-1)&amp;inverse_mask
        return result
 </len(s))]>
</left,>
```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2008 - https://leetcode.com/problems/maximum-earnings-from-taxi/
Time: O(n + mlogm)  Space: O(n)   Medium
.Python/maximum-earnings-from-taxi.py


```python
# Time:  O(n + mlogm), m is the number of rides
# Space: O(n)

class Solution(object):
    def maxTaxiEarnings(self, n, rides):
        """
        :type n: int
        :type rides: List[List[int]]
        :rtype: int
        """
        rides.sort()
        dp = [0]*(n+1)
        j = 0
        for i in xrange(1, n+1):
            dp[i] = max(dp[i], dp[i-1])
            while j &lt; len(rides) and rides[j][0] == i:
                dp[rides[j][1]] = max(dp[rides[j][1]], dp[i]+rides[j][1]-rides[j][0]+rides[j][2])
                j += 1
        return dp[-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2019 - https://leetcode.com/problems/the-score-of-students-solving-math-expression/
Time: O(n^3 * a^2)  Space: O(n^2)   Hard
.Python/the-score-of-students-solving-math-expression.py


```python
# Time:  O(n^3 * a^2)
# Space: O(n^2)

class Solution(object):
    def scoreOfStudents(self, s, answers):
        """
        :type s: str
        :type answers: List[int]
        :rtype: int
        """
        MAX_ANS = 1000
        n = (len(s)+1)//2
        dp = [[set() for _ in xrange(n)] for _ in xrange(n)]
        for i in xrange(n):
            dp[i][i].add(int(s[i*2]))
        for l in xrange(1, n):
            for left in xrange(n-l):
                right = left+l
                for k in xrange(left, right):
                    if s[2*k+1] == '+':
                        dp[left][right].update((x+y for x in dp[left][k] for y in dp[k+1][right] if x+y &lt;= MAX_ANS))
                    else:
                        dp[left][right].update((x*y for x in dp[left][k] for y in dp[k+1][right] if x*y &lt;= MAX_ANS))
        target = eval(s)
        return sum(5 if ans == target else 2 if ans in dp[0][-1] else 0 for ans in answers)


# Time:  O(n^3 * a^2)
# Space: O(n^2)
class Solution2(object):
    def scoreOfStudents(self, s, answers):
        """
        :type s: str
        :type answers: List[int]
        :rtype: int
        """
        MAX_ANS = 1000
        def evaluate(s):
            def compute(operands, operators):
                right, left = operands.pop(), operands.pop()
                operands.append(ops[operators.pop()](left, right))

            ops = {'+':operator.add, '*':operator.mul}
            precedence = {'+':0, '*':1}
            operands, operators, operand = [], [], 0
            for c in s:
                if c.isdigit():
                    operands.append(int(c))
                else:
                    while operators and precedence[operators[-1]] &gt;= precedence[c]:
                        compute(operands, operators)
                    operators.append(c)
            while operators:
                compute(operands, operators)
            return operands[-1]

        n = (len(s)+1)//2
        dp = [[set() for _ in xrange(n)] for _ in xrange(n)]
        for i in xrange(n):
            dp[i][i].add(int(s[i*2]))
        for l in xrange(1, n):
            for left in xrange(n-l):
                right = left+l
                for k in xrange(left, right):
                    if s[2*k+1] == '+':
                        dp[left][right].update((x+y for x in dp[left][k] for y in dp[k+1][right] if x+y &lt;= MAX_ANS))
                    else:
                        dp[left][right].update((x*y for x in dp[left][k] for y in dp[k+1][right] if x*y &lt;= MAX_ANS))
        target = evaluate(s)
        return sum(5 if ans == target else 2 if ans in dp[0][-1] else 0 for ans in answers)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2031 - https://leetcode.com/problems/count-subarrays-with-more-ones-than-zeros/
Time: O(n)  Space: O(n)   Medium
.Python/count-subarrays-with-more-ones-than-zeros.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def subarraysWithMoreZerosThanOnes(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        MOD = 10**9+7

        lookup = collections.defaultdict(int)
        lookup[0] = 1
        result = total = same = more = 0
        for x in nums:
            total += 1 if x == 1 else -1
            new_same = lookup[total]
            new_more = (same+more+1)%MOD if x == 1 else (more-new_same)%MOD
            lookup[total] += 1
            result = (result+new_more)%MOD
            same, more = new_same, new_more
        return result


# Time:  O(n)
# Space: O(n)
class Solution2(object):
    def subarraysWithMoreZerosThanOnes(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        MOD = 10**9+7

        lookup = {0:-1}
        dp = [0]*len(nums)
        result = total = 0
        for i, x in enumerate(nums):
            total += 1 if x == 1 else -1
            if total not in lookup:
                if total &gt; 0:
                    dp[i] = i+1
            else:
                j = lookup[total]
                if j != -1:
                    dp[i] = dp[j]
                if x &gt; 0:
                    dp[i] += (i-1)-j
            lookup[total] = i
            result = (result+dp[i])%MOD
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2044 - https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/
Time: O(min(2^n, m * n))  Space: O(min(2^n, m))   Medium
.Python/count-number-of-maximum-bitwise-or-subsets.py


```python
# Time:  O(min(2^n, m * n)), m is the 'bitwise or' of nums
# Space: O(min(2^n, m))

import collections


class Solution(object):
    def countMaxOrSubsets(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dp = collections.Counter([0])
        for x in nums:
            for k, v in dp.items():
                dp[k|x] += v
        return dp[reduce(lambda x, y: x|y, nums)]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2052 - https://leetcode.com/problems/minimum-cost-to-separate-sentence-into-rows/
Time: O(s + n * k)  Space: O(k)   Medium
.Python/minimum-cost-to-separate-sentence-into-rows.py


```python
# Time:  O(s + n * k), n is the number of the word_lens
# Space: O(k)

class Solution(object):
    def minimumCost(self, sentence, k):
        """
        :type sentence: str
        :type k: int
        :rtype: int
        """
        def lens(sentence):
            j = len(sentence)-1
            for i in reversed(xrange(-1, len(sentence))):
                if i == -1 or sentence[i] == ' ':
                    yield j-i
                    j = i-1

        word_lens, dp = [], []  # dp[i]: min cost of word_lens[-1-i:]
        t = -1
        for l in lens(sentence):
            word_lens.append(l)
            dp.append(float("inf"))
            t += l+1
            if t &lt;= k:
                dp[-1] = 0
                continue
            total = l
            for j in reversed(xrange(len(dp)-1)):
                dp[-1] = min(dp[-1], dp[j] + (k-total)**2)
                total += (word_lens[j]+1)
                if total &gt; k:
                    word_lens = word_lens[j:]  # minimize len(word_lens) s.t. sum(word_lens) &gt; k
                    dp = dp[j:]
                    break
        return dp[-1] if dp else 0


# Time:  O(s + n * k), n is the number of the word_lens
# Space: O(n)
class Solution2(object):
    def minimumCost(self, sentence, k):
        """
        :type sentence: str
        :type k: int
        :rtype: int
        """
        word_lens = []
        j = 0
        for i in xrange(len(sentence)+1):
            if i != len(sentence) and sentence[i] != ' ':
                continue
            word_lens.append(i-j)
            j = i+1
        dp = [float("inf")]*(len(word_lens))  # dp[i]: min cost of word_lens[i:]
        i, total = len(word_lens)-1, -1
        while i &gt;= 0 and total + (word_lens[i]+1) &lt;= k:  # find max i s.t. the length of the last line &gt; k
            total += (word_lens[i]+1)
            dp[i] = 0
            i -= 1
        for i in reversed(xrange(i+1)):
            total = word_lens[i]
            for j in xrange(i+1, len(dp)):
                dp[i] = min(dp[i], dp[j] + (k-total)**2)
                total += (word_lens[j]+1)
                if total &gt; k:
                    break
        return dp[0]


# Time:  O(s + n * k), n is the number of the word_lens
# Space: O(n)
class Solution3(object):
    def minimumCost(self, sentence, k):
        """
        :type sentence: str
        :type k: int
        :rtype: int
        """
        word_lens = []
        j = 0
        for i in xrange(len(sentence)+1):
            if i != len(sentence) and sentence[i] != ' ':
                continue
            word_lens.append(i-j)
            j = i+1
        dp = [float("inf")]*(1+(len(word_lens)-1))  # dp[i]: min cost of the first i word_lens where i in [0, len(words)-1]
        dp[0] = 0
        for i in xrange(1, (len(word_lens)-1)+1):
            total = word_lens[i-1]
            for j in reversed(xrange(i)):
                dp[i] = min(dp[i], dp[j] + (k-total)**2)
                if j-1 &lt; 0:
                    continue
                total += (word_lens[j-1]+1)
                if total &gt; k:
                    break
        i, total = len(word_lens)-1, -1
        while i &gt;= 0 and total + (word_lens[i]+1) &lt;= k:  # find max i s.t. the length of the last line &gt; k
            total += (word_lens[i]+1)
            i -= 1
        return min(dp[j] for j in xrange(i+1, len(dp)))

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2060 - https://leetcode.com/problems/check-if-an-original-string-exists-given-two-encoded-strings/
Time: O(m * n * k)  Space: O(min(m, n) * k)   Hard
.Python/check-if-an-original-string-exists-given-two-encoded-strings.py


```python
# Time:  O(m * n * k), k is the max number of consecutive digits in s1 and s2
# Space: O(m * n * k)

# top-down dp (faster since accessing less states)
class Solution(object):
    def possiblyEquals(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        def general_possible_numbers(s):  # Time: O(2^l), Space: O(2^l), l is the length of consecutive digits, and l is at most 3
            dp = [set() for _ in xrange(len(s))]
            for i in xrange(len(s)):
                curr, basis = 0, 1
                for j in reversed(xrange(i+1)):
                    curr += int(s[j])*basis
                    basis *= 10
                    if s[j] == '0':
                        continue
                    if j == 0:
                        dp[i].add(curr)
                    else:
                        dp[i].update(x+curr for x in dp[j-1])        
            return dp[-1]

        def optimized_possible_numbers(s):
            assert(len(s) &lt;= 3)
            result = {int(s)}
            if len(s) &gt;= 2:
                if s[1] != '0':
                    result.add(int(s[:1])+int(s[1:]))
            if len(s) &gt;= 3:
                if s[2] != '0':
                    result.add(int(s[:2])+int(s[2:]))
                    if s[1] != '0':
                        result.add(int(s[0:1])+int(s[1:2])+int(s[2:]))
            return result
    
        def memoization(s1, s2, i, j, k, lookup):
            if (i, j, k) not in lookup:
                if i == len(s1) and j == len(s2):
                    lookup[(i, j, k)] = (k == 0)
                elif i != len(s1) and s1[i].isdigit():
                    lookup[(i, j, k)] = False
                    for ni in xrange(i+1, len(s1)+1):
                        if ni == len(s1) or not s1[ni].isdigit():
                            break
                    for x in optimized_possible_numbers(s1[i:ni]):
                        if memoization(s1, s2, ni, j, k+x, lookup):
                            lookup[(i, j, k)] = True
                            break
                elif j != len(s2) and s2[j].isdigit():
                    lookup[(i, j, k)] = False
                    for nj in xrange(j+1, len(s2)+1):
                        if nj == len(s2) or not s2[nj].isdigit():
                            break
                    for x in optimized_possible_numbers(s2[j:nj]):
                        if memoization(s1, s2, i, nj, k-x, lookup):
                            lookup[(i, j, k)] = True
                            break
                elif k &lt; 0:
                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j, k+1, lookup) if i != len(s1) else False
                elif k &gt; 0:
                    lookup[(i, j, k)] = memoization(s1, s2, i, j+1, k-1, lookup) if j != len(s2) else False
                else:
                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j+1, k, lookup) if i != len(s1) and j != len(s2) and s1[i] == s2[j] else False
            return lookup[(i, j, k)]

        return memoization(s1, s2, 0, 0, 0, {})


# Time:  O(m * n * k), k is the max number of consecutive digits in s1 and s2
# Space: O(m * n * k)
# top-down dp (faster since accessing less states)
class Solution2(object):
    def possiblyEquals(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        def memoization(s1, s2, i, j, k, lookup):
            if (i, j, k) not in lookup:
                if i == len(s1) and j == len(s2):
                    lookup[(i, j, k)] = (k == 0)
                elif i != len(s1) and s1[i].isdigit():
                    lookup[(i, j, k)] = False
                    for ni in xrange(i+1, len(s1)+1):
                        if (ni == len(s1) or s1[ni] != '0') and memoization(s1, s2, ni, j, k+int(s1[i:ni]), lookup):
                            lookup[(i, j, k)] = True
                            break
                        if ni == len(s1) or not s1[ni].isdigit():
                            break
                elif j != len(s2) and s2[j].isdigit():
                    lookup[(i, j, k)] = False
                    for nj in xrange(j+1, len(s2)+1):
                        if (nj == len(s2) or s2[nj] != '0') and memoization(s1, s2, i, nj, k-int(s2[j:nj]), lookup):
                            lookup[(i, j, k)] = True
                            break
                        if nj == len(s2) or not s2[nj].isdigit():
                            break
                elif k &lt; 0:
                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j, k+1, lookup) if i != len(s1) else False
                elif k &gt; 0:
                    lookup[(i, j, k)] = memoization(s1, s2, i, j+1, k-1, lookup) if j != len(s2) else False
                else:
                    lookup[(i, j, k)] = memoization(s1, s2, i+1, j+1, k, lookup) if i != len(s1) and j != len(s2) and s1[i] == s2[j] else False
            return lookup[(i, j, k)]

        return memoization(s1, s2, 0, 0, 0, {})


# Time:  O(m * n * k), k is the max number of consecutive digits in s1 and s2
# Space: O(min(m, n) * k)
# bottom-up dp
class Solution3(object):
    def possiblyEquals(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        MAX_DIGIT_LEN = 3
        w = 1+MAX_DIGIT_LEN
        dp = [[set() for _ in xrange(len(s2)+1)] for _ in xrange(w)]
        dp[0][0].add(0)
        for i in xrange(len(s1)+1):
            if i:
                dp[(i-1)%w] = [set() for _ in xrange(len(s2)+1)]
            if i != len(s1) and s1[i] == '0':
                continue
            for j in xrange(len(s2)+1):
                for k in dp[i%w][j]:
                    if i != len(s1) and j != len(s2) and s1[i] == s2[j] and k == 0:
                        dp[(i+1)%w][j+1].add(k)
                    if k &lt;= 0 and i != len(s1):
                        if not s1[i].isdigit():
                            if k:
                                dp[(i+1)%w][j].add(k+1)
                        elif s1[i] != '0':
                            curr = 0
                            for ni in xrange(i, len(s1)):
                                if not s1[ni].isdigit():
                                    break
                                curr = curr*10 + int(s1[ni])
                                dp[(ni+1)%w][j].add(k+curr)
                    if k &gt;= 0 and j != len(s2):
                        if not s2[j].isdigit():
                            if k:
                                dp[i%w][j+1].add(k-1)
                        elif s2[j] != '0':
                            curr = 0
                            for nj in xrange(j, len(s2)):
                                if not s2[nj].isdigit():
                                    break
                                curr = curr*10 + int(s2[nj])
                                dp[i%w][nj+1].add(k-curr)
        return 0 in dp[len(s1)%w][len(s2)]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2088 - https://leetcode.com/problems/count-fertile-pyramids-in-a-land/
Time: O(m * n)  Space: O(n)   Hard
.Python/count-fertile-pyramids-in-a-land.py


```python
# Time:  O(m * n)
# Space: O(n)

class Solution(object):
    def countPyramids(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        def count(grid, reverse):
            def get_grid(i, j):
                return grid[~i][j] if reverse else grid[i][j]

            result = 0
            dp = [0]*len(grid[0])
            for i in xrange(1, len(grid)):
                new_dp = [0]*len(grid[0])
                for j in xrange(1, len(grid[0])-1):
                    if get_grid(i, j) == get_grid(i-1, j-1) == get_grid(i-1, j) == get_grid(i-1, j+1) == 1:
                        new_dp[j] = min(dp[j-1], dp[j+1])+1
                dp = new_dp
                result += sum(dp)
            return result
        
        return count(grid, False) + count(grid, True)


# Time:  O(m * n)
# Space: O(m * n)
class Solution2(object):
    def countPyramids(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        def count(grid):
            dp = [[0 for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))]
            for i in xrange(1, len(grid)):
                for j in xrange(1, len(grid[0])-1):
                    if grid[i][j] == grid[i-1][j-1] == grid[i-1][j] == grid[i-1][j+1] == 1:
                        dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1])+1
            return sum(sum(row) for row in dp)
        
        return count(grid) + count(grid[::-1])

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2140 - https://leetcode.com/problems/solving-questions-with-brainpower/
Time: O(n)  Space: O(n)   Medium
.Python/solving-questions-with-brainpower.py


```python
# Time:  O(n)
# Space: O(n)

# dp
class Solution(object):
    def mostPoints(self, questions):
        """
        :type questions: List[List[int]]
        :rtype: int
        """
        dp = [0]*(len(questions)+1)
        for i in reversed(xrange(len(dp)-1)):
            dp[i] = max(dp[i+1], questions[i][0] + (dp[i+1+questions[i][1]] if i+1+questions[i][1] &lt; len(dp) else 0))
        return dp[0]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2143 - https://leetcode.com/problems/choose-numbers-from-two-arrays-in-range/
Time: O(n^2 * v)  Space: O(n * v)   Hard
.Python/choose-numbers-from-two-arrays-in-range.py


```python
# Time:  O(n^2 * v), v is max(max(nums1), max(nums2))
# Space: O(n * v)

import collections
import itertools


# dp
class Solution(object):
    def countSubranges(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        MOD = 10**9+7

        result = 0
        dp = collections.Counter()
        for x, y in itertools.izip(nums1, nums2):
            new_dp = collections.Counter()
            new_dp[x] += 1
            new_dp[-y] += 1
            for v, c in dp.iteritems():
                new_dp[v+x] = (new_dp[v+x]+c)%MOD
                new_dp[v-y] = (new_dp[v-y]+c)%MOD
            dp = new_dp
            result = (result+dp[0])%MOD
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2167 - https://leetcode.com/problems/minimum-time-to-remove-all-cars-containing-illegal-goods/
Time: O(n)  Space: O(1)   Hard
.Python/minimum-time-to-remove-all-cars-containing-illegal-goods.py


```python
# Time:  O(n)
# Space: O(1)

# dp
class Solution(object):
    def minimumTime(self, s):
        """
        :type s: str
        :rtype: int
        """
        left = 0
        result = left+(len(s)-0)
        for i in xrange(1, len(s)+1):
            left = min(left+2*(s[i-1] == '1'), i)
            result = min(result, left+(len(s)-i))
        return result


# Time:  O(n)
# Space: O(n)
# dp
class Solution2(object):
    def minimumTime(self, s):
        """
        :type s: str
        :rtype: int
        """
        result, right = len(s), [0]*(len(s)+1)
        for i in reversed(xrange(len(s))):
            right[i] = min(right[i+1]+2*(s[i] == '1'), len(s)-i)
        left = 0
        result = left+right[0]
        for i in xrange(1, len(s)+1):
            left = min(left+2*(s[i-1] == '1'), i)     
            result = min(result, left+right[i])
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2174 - https://leetcode.com/problems/remove-all-ones-with-row-and-column-flips-ii/
Time: O((m * n) * 2^(m * n))  Space: O(2^(m * n))   Medium
.Python/remove-all-ones-with-row-and-column-flips-ii.py


```python
# Time:  O(m * n * 2^(m * n))
# Space: O(2^(m * n))

# dp, bitmasks
class Solution(object):
    def removeOnes(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        rows = [0]*len(grid)
        mask, bit = 0, 1
        for _ in xrange(len(grid[0])):
            mask += bit
            bit &lt;&lt;= 1
        for i in xrange(len(grid)):
            rows[i] = mask
            mask &lt;&lt;= len(grid[0])

        cols = [0]*len(grid[0])
        mask, bit = 0, 1
        for _ in xrange(len(grid)):
            mask += bit
            bit &lt;&lt;= len(grid[0])
        for j in xrange(len(grid[0])):
            cols[j] = mask
            mask &lt;&lt;= 1

        full_mask = (1&lt;&lt;(len(grid)*len(grid[0])))-1
        masks = [[full_mask for _ in xrange(len(grid[0]))] for _ in xrange(len(grid))]
        target, bit = 0, 1
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                target += bit*grid[i][j]
                masks[i][j] -= (rows[i]+cols[j]-bit)
                bit &lt;&lt;= 1

        dp = [float("inf") for _ in xrange(target+1)]
        dp[0] = 0
        for mask in xrange(1, target+1):
            for i in xrange(len(grid)):
                for j in xrange(len(grid[0])):
                    if grid[i][j]:
                        dp[mask] = min(dp[mask], dp[mask&amp;masks[i][j]]+1)
        return dp[target]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2184 - https://leetcode.com/problems/number-of-ways-to-build-sturdy-brick-wall/
Time: O(h * p^2)  Space: O(p^2)   Medium
.Python/number-of-ways-to-build-sturdy-brick-wall.py


```python
# Time:  O(h * p^2), p is the number of patterns
# Space: O(p^2)

# bitmask, backtracking, dp
class Solution(object):
    def buildWall(self, height, width, bricks):
        """
        :type height: int
        :type width: int
        :type bricks: List[int]
        :rtype: int
        """
        MOD = 10**9+7
        def backtracking(height, width, bricks, total, mask, lookup, patterns):
            if mask in lookup:
                return
            lookup.add(mask)
            if total &gt;= width:
                if total == width:
                    patterns.append(mask^(1&lt;
<width)) """="" #="" %="" &="" (r1="" *="" 0,="" 512="" :rtype:="" :type="" [0]*len(patterns)]="" adj="[[j" adj[j])="" backtracking(height,="" backtracking,="" be="" bitmask,="" bricks):="" bricks,="" bricks:="" buildwall(self,="" class="" def="" dp="[[1]*len(patterns)," dp[(i+1)%2]="[sum(dp[i%2][k]" enumerate(patterns)="" exponentiation="" for="" height,="" height:="" i="" if="" in="" int="" is="" j="" j,="" k="" list[int]="" logh),="" lookup="[]," lookup,="" lookup.add(mask)="" lookup:="" mask="" mask,="" mask|(1<<(total+x)),="" matrix="" may="" mod="10**9+7" not="" number="" o(p^3="" o(p^3)="" of="" p="" patterns)="" patterns):="" patterns,="" patterns]="" r1="" r2="" r2)]="" return="" set()="" solution_tle(object):="" space:="" sum(dp[(height-1)%2])="" the="" time:="" to="" total="" total+x,="" total,="" up="" width,="" width:="" x="" xrange(height-1):="" xrange(len(patterns))]="">
 = width:
                if total == width:
                    patterns.append(mask^(1&lt;&lt;width))
                return
            for x in bricks:
                backtracking(height, width, bricks, total+x, mask|(1&lt;&lt;(total+x)), lookup, patterns)

        def matrix_mult(A, B):
            ZB = zip(*B)
            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        patterns, lookup = [], set()
        backtracking(height, width, bricks, 0, 0, lookup, patterns)
        return reduce(lambda x,y: (x+y)%MOD,
                      matrix_mult([[1]*len(patterns)],
                                   matrix_expo([[int((mask1 &amp; mask2) == 0)
                                                 for mask2 in patterns] 
                                                 for mask1 in patterns], height-1))[0],
                      0)  # Time: O(p^3 * logh), Space: O(p^2)
</width))>
```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2188 - https://leetcode.com/problems/minimum-time-to-finish-the-race/
Time: O((n + l) * logc)  Space: O(n + l + logc)   Hard
.Python/minimum-time-to-finish-the-race.py


```python
# Time:  O((n + l) * logc)
# Space: O(n + l + logc)

# greedy, dp
class Solution(object):
    def minimumFinishTime(self, tires, changeTime, numLaps):
        """
        :type tires: List[List[int]]
        :type changeTime: int
        :type numLaps: int
        :rtype: int
        """
        def ceil_log2(x):
            return (x-1).bit_length()

        dp = [float("inf")]*ceil_log2(changeTime+1)  # dp[i]: min time to complete i+1 laps without changing a tire
        for f, r in tires:
            total = curr = f
            cnt = 0
            while curr &lt; changeTime+f:  # at worst (f, r) = (1, 2) =&gt; 2^(cnt-1) &lt; changeTime+1 =&gt; cnt &lt; ceil(log2(changeTime+1))
                dp[cnt] = min(dp[cnt], total)
                curr *= r
                total += curr
                cnt += 1
        dp2 = [float("inf")]*numLaps  # dp2[i]: min time to complete i+1 laps with changing zero or more tires
        for i in xrange(numLaps):
            dp2[i] = min((dp2[i-j-1]+changeTime if i-j-1 &gt;= 0 else 0)+dp[j] for j in xrange(min(i+1, len(dp))))
        return dp2[-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2189 - https://leetcode.com/problems/number-of-ways-to-build-house-of-cards/
Time: O(n^2)  Space: O(n)   Medium
.Python/number-of-ways-to-build-house-of-cards.py


```python
# Time:  O(n^2)
# Space: O(n)

# dp
class Solution(object):
    def houseOfCards(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [0]*(n+1)  # dp[i]: number of ways with i cards and at most t triangles in the first row
        dp[0] = 1
        for t in xrange(1, (n+1)//3+1):
            for i in reversed(xrange(3*t-1, n+1)):
                dp[i] += dp[i-(3*t-1)]
        return dp[n]


# Time:  O(n^3)
# Space: O(n^2)
# dp
class Solution_TLE(object):
    def houseOfCards(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [[0]*(n+1) for _ in xrange((n+1)//3+1)]  # dp[t][i]: number of ways with i cards and t triangles in the first row
        dp[0][0] = 1
        for t in xrange(1, (n+1)//3+1):
            for i in xrange(3*t-1, n+1):
                dp[t][i] = sum(dp[j][i-(3*t-1)] for j in xrange(t))
        return sum(dp[t][n] for t in xrange((n+1)//3+1))

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2209 - https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/
Time: O(m * n)  Space: O(m * n)   Hard
.Python/minimum-white-tiles-after-covering-with-carpets.py


```python
# Time:  O(m * n)
# Space: O(m * n)

# dp
class Solution(object):
    def minimumWhiteTiles(self, floor, numCarpets, carpetLen):
        """
        :type floor: str
        :type numCarpets: int
        :type carpetLen: int
        :rtype: int
        """
        dp = [[0]*(numCarpets+1) for _ in xrange(len(floor)+1)]  # dp[i][j] : min number of white tiles in the first i floors with j carpets
        for i in xrange(1, len(dp)):
            dp[i][0] = dp[i-1][0] + int(floor[i-1])
            for j in xrange(1, numCarpets+1):
                dp[i][j] = min(dp[i-1][j] + int(floor[i-1]), dp[max(i-carpetLen, 0)][j-1])
        return dp[-1][-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2218 - https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/
Time: O(min(n * k^2, m * k)))  Space: O(k)   Hard
.Python/maximum-value-of-k-coins-from-piles.py


```python
# Time:  O(min(n * k^2, m * k)), m = sum(len(pile) for pile in piles)
# Space: O(k)

# dp
class Solution(object):
    def maxValueOfCoins(self, piles, k):
        """
        :type piles: List[List[int]]
        :type k: int
        :rtype: int
        """
        dp = [0]
        for pile in piles:
            new_dp = [0]*min(len(dp)+len(pile), k+1)
            for i in xrange(len(dp)):
                curr = 0
                for j in xrange(min(k-i, len(pile))+1):
                    new_dp[i+j] = max(new_dp[i+j], dp[i]+curr)
                    curr += pile[j] if j &lt; len(pile) else 0
            dp = new_dp
        return dp[-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2222 - https://leetcode.com/problems/number-of-ways-to-select-buildings/
Time: O(n)  Space: O(1)   Medium
.Python/number-of-ways-to-select-buildings.py


```python
# Time:  O(k * n) = O(n)
# Space: O(k) = O(1)

# dp
class Solution(object):
    def numberOfWays(self, s):
        """
        :type s: str
        :rtype: int
        """
        K = 3
        dp = [[0]*2 for _ in xrange(K)]  # dp[i][j]: number of ways of selecting i+1 buildings ending with type j
        for c in s:
            j = ord(c)-ord('0')
            dp[0][j] += 1
            for i in xrange(1, len(dp)):
                dp[i][j] += dp[i-1][1^j]
        return dp[-1][0]+dp[-1][1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2247 - https://leetcode.com/problems/maximum-cost-of-trip-with-k-highways/
Time: O(n^2 * 2^n)  Space: O(n * 2^n)   Hard
.Python/maximum-cost-of-trip-with-k-highways.py


```python
# Time:  O(n^2 * 2^n)
# Space: O(n * 2^n)

import itertools


# combination based dp
class Solution(object):
    def maximumCost(self, n, highways, k):
        """
        :type n: int
        :type highways: List[List[int]]
        :type k: int
        :rtype: int
        """
        if k+1 &gt; n:  # optionally optimize
            return -1
        adj = [[] for _ in xrange(n)]
        for c1, c2, t in highways:
            adj[c1].append((c2, t))
            adj[c2].append((c1, t))
        result = -1 if k != 1 else 0
        dp = [[0, []] for _ in xrange((1&lt;
<n))] """="" #="" *="" 0)="" 2^n)="" :rtype:="" :type="" <="" adj[u]:="" based="" bfs="" bin(mask).count('1')="k:" choice="" choice,="" class="" cnt="" cnt):="" continue="" def="" dp="" dp[1<<i][1].append(i)="" dp[new_mask][0]="total+t" dp[new_mask][0])="" dp[new_mask][0]:="" dp[new_mask][1]="[v]" dp[new_mask][1].append(v)="" for="" highways,="" highways:="" i="" if="" in="" int="" itertools.combinations(xrange(n),="" k):="" k+1="" k:="" lasts="dp[mask]" lasts:="" list[list[int]]="" mask="reduce(lambda" mask&(1<<v):="" maximumcost(self,="" n+1):="" n,="" n:="" new_mask="mask|(1&lt;&lt;v)" o(n="" o(n^2="" result="" return="" solution2(object):="" space:="" t="" time:="" total+t="dp[new_mask][0]:" total,="" u="" v,="" x,="" xrange(1,="" xrange(n):="" y:x|(1<<y),="">
 n:  # required to optimize, otherwise, TLE or MLE
            return -1
        adj = [[] for _ in xrange(n)]
        for c1, c2, t in highways:
            adj[c1].append((c2, t))
            adj[c2].append((c1, t))
        result = -1
        dp = [(u, 1&lt;&lt;u, 0) for u in xrange(n)]
        while dp:
            new_dp = []
            for u, mask, total in dp:
                if bin(mask).count('1') == k+1:
                    result = max(result, total)
                for v, t in adj[u]:
                    if mask&amp;(1&lt;&lt;v) == 0:
                        new_dp.append((v, mask|(1&lt;&lt;v), total+t))
            dp = new_dp
        return result
</n))]>
```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2266 - https://leetcode.com/problems/count-number-of-texts/
Time: O(n)  Space: O(1)   Medium
.Python/count-number-of-texts.py


```python
# Time:  O(n)
# Space: O(1)

# dp
class Solution(object):
    def countTexts(self, pressedKeys):
        """
        :type pressedKeys: str
        :rtype: int
        """
        MOD = 10**9+7
        dp = [1]*5
        for i in xrange(1, len(pressedKeys)+1):
            dp[i%5] = 0
            for j in reversed(xrange(max(i-(4 if pressedKeys[i-1] in "79" else 3), 0), i)):
                if pressedKeys[j] != pressedKeys[i-1]:
                    break
                dp[i%5] = (dp[i%5]+dp[j%5])%MOD
        return dp[len(pressedKeys)%5]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2267 - https://leetcode.com/problems/check-if-there-is-a-valid-parentheses-string-path/
Time: O(m * n * (m + n) / 32)  Space: O(n * (m + n) / 32)   Hard
.Python/check-if-there-is-a-valid-parentheses-string-path.py


```python
# Time:  O((m * n) * (m + n) / 32)
# Space: O(n * (m + n) / 32)

# dp with bitsets
class Solution(object):
    def hasValidPath(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: bool
        """
        if (len(grid)+len(grid[0])-1)%2:
            return False
        dp = [0]*(len(grid[0])+1)
        for i in xrange(len(grid)):
            dp[0] = int(not i)
            for j in xrange(len(grid[0])):
                dp[j+1] = (dp[j]|dp[j+1])&lt;&lt;1 if grid[i][j] == '(' else (dp[j]|dp[j+1])&gt;&gt;1
        return dp[-1]&amp;1


# Time:  O(m * n)
# Space: O(n)
# dp, optimized from solution1 (wrong answer)
class Solution_WA(object):
    def hasValidPath(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: bool
        """
        if (len(grid)+len(grid[0])-1)%2:
            return False
        dp = [[float("inf"), float("-inf")] for _ in xrange(len(grid[0])+1)]
        for i in xrange(len(grid)):
            dp[0] = [0, 0] if not i else [float("inf"), float("-inf")]
            for j in xrange(len(grid[0])):
                d = 1 if grid[i][j] == '(' else -1
                dp[j+1] = [min(dp[j+1][0], dp[j][0])+d, max(dp[j+1][1], dp[j][1])+d]
                # bitset pattern is like xxx1010101xxxx (in fact, it is not always true in this problem where some paths are invalid)
                if dp[j+1][1] &lt; 0:
                    dp[j+1] = [float("inf"), float("-inf")]
                else:
                    dp[j+1][0] = max(dp[j+1][0], dp[j+1][1]%2)
        return dp[-1][0] == 0

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2289 - https://leetcode.com/problems/steps-to-make-array-non-decreasing/
Time: O(n)  Space: O(n)   Hard
.Python/steps-to-make-array-non-decreasing.py


```python
# Time:  O(n)
# Space: O(n)

# mono stack, dp
class Solution(object):
    def totalSteps(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dp = [0]*len(nums)  # dp[i]: number of rounds for nums[i] to remove all the covered elements
        stk = []
        for i in reversed(xrange(len(nums))):
            while stk and nums[stk[-1]] &lt; nums[i]:
                dp[i] = max(dp[i]+1, dp[stk.pop()])
            stk.append(i)
        return max(dp)


# Time:  O(n)
# Space: O(n)
# mono stack, dp
class Solution2(object):
    def totalSteps(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        dp = [0]*len(nums)  # dp[i]: number of rounds for nums[i] to be removed
        stk = []
        for i in xrange(len(nums)):
            curr = 0
            while stk and nums[stk[-1]] &lt;= nums[i]:
                curr = max(curr, dp[stk.pop()])
            if stk:
                dp[i] = curr+1
            stk.append(i)
        return max(dp)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2291 - https://leetcode.com/problems/maximum-profit-from-trading-stocks/
Time: O(n * b)  Space: O(b)   Medium
.Python/maximum-profit-from-trading-stocks.py


```python
# Time:  O(n * b)
# Space: O(b)

import itertools


# dp, optimized from solution2
class Solution(object):
    def maximumProfit(self, present, future, budget):
        """
        :type present: List[int]
        :type future: List[int]
        :type budget: int
        :rtype: int
        """
        dp = [0]*(budget+1)
        for i, (p, f) in enumerate(itertools.izip(present, future)):
            if f-p &lt; 0:
                continue
            for b in reversed(xrange(p, budget+1)):
                dp[b] = max(dp[b], dp[b-p]+(f-p))
        return dp[-1]


# Time:  O(n * b)
# Space: O(b)
import itertools


# dp
class Solution2(object):
    def maximumProfit(self, present, future, budget):
        """
        :type present: List[int]
        :type future: List[int]
        :type budget: int
        :rtype: int
        """
        dp = [[0]*(budget+1) for _ in xrange(2)]
        for i, (p, f) in enumerate(itertools.izip(present, future)):
            for b in xrange(budget+1):
                dp[(i+1)%2][b] = max(dp[i%2][b], (dp[i%2][b-p]+(f-p) if b-p &gt;= 0 else 0))
        return dp[len(present)%2][-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2297 - https://leetcode.com/problems/jump-game-ix/
Time: O(n)  Space: O(1)   Medium
.Python/jump-game-ix.py


```python
# Time:  O(n)
# Space: O(1)

# dp, mono stack
class Solution(object):
    def minCost(self, nums, costs):
        """
        :type nums: List[int]
        :type costs: List[int]
        :rtype: int
        """
        stk1, stk2 = [], []
        dp = [float("inf")]*len(nums)
        dp[0] = 0
        for i in xrange(len(nums)):
            while stk1 and nums[stk1[-1]] &lt;= nums[i]:
                dp[i] = min(dp[i], dp[stk1.pop()]+costs[i])
            stk1.append(i)
            while stk2 and nums[stk2[-1]] &gt; nums[i]:
                dp[i] = min(dp[i], dp[stk2.pop()]+costs[i])
            stk2.append(i)
        return dp[-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2304 - https://leetcode.com/problems/minimum-path-cost-in-a-grid/
Time: O(m * n^2)  Space: O(n)   Medium
.Python/minimum-path-cost-in-a-grid.py


```python
# Time:  O(m * n^2)
# Space: O(n)

# dp
class Solution(object):
    def minPathCost(self, grid, moveCost):
        """
        :type grid: List[List[int]]
        :type moveCost: List[List[int]]
        :rtype: int
        """
        dp = [[0]*len(grid[0]) for _ in xrange(2)]
        dp[0] = [grid[0][j] for j in xrange(len(grid[0]))]
        for i in xrange(len(grid)-1):
            for j in xrange(len(grid[0])):
                dp[(i+1)%2][j] = min(dp[i%2][k]+moveCost[x][j] for k, x in enumerate(grid[i]))+grid[i+1][j]
        return min(dp[(len(grid)-1)%2])

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2305 - https://leetcode.com/problems/fair-distribution-of-cookies/
Time: O(k * 3^n)  Space: O(2^n)   Medium
.Python/fair-distribution-of-cookies.py


```python
# Time:  O(k * 3^n)
# Space: O(2^n)

# dp, submask enumeration
class Solution(object):
    def distributeCookies(self, cookies, k):
        """
        :type cookies: List[int]
        :type k: int
        :rtype: int
        """
        total = [0]*(1&lt;&lt;len(cookies))
        for mask in xrange(1&lt;&lt;len(cookies)):
            total[mask] = sum(cookies[i] for i in xrange(len(cookies)) if mask&amp;(1&lt;&lt;i))
        dp = [[float("inf")]*(1&lt;&lt;len(cookies)) for _ in xrange(2)]
        dp[0][0] = 0
        for i in xrange(k):
            for mask in xrange(1&lt;&lt;len(cookies)):
                submask = mask
                while submask:
                    dp[(i+1)%2][mask] = min(dp[(i+1)%2][mask], max(total[submask], dp[i%2][mask^submask]))
                    submask = (submask-1)&amp;mask
        return dp[k%2][-1]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2312 - https://leetcode.com/problems/selling-pieces-of-wood/
Time: O(m * n * (m + n))  Space: O(m + n)   Hard
.Python/selling-pieces-of-wood.py


```python
# Time:  O(m * n * (m + n))
# Space: O(m * n)

# dp
class Solution(object):
    def sellingWood(self, m, n, prices):
        """
        :type m: int
        :type n: int
        :type prices: List[List[int]]
        :rtype: int
        """
        dp = [[0]*(n+1) for i in xrange(m+1)]
        for h, w, p in prices:
            dp[h][w] = p
        for i in xrange(1, m+1):
            for j in xrange(1, n+1):
                for k in xrange(1, i//2+1):
                    dp[i][j] = max(dp[i][j], dp[k][j]+dp[i-k][j])
                for k in xrange(1, j//2+1):
                    dp[i][j] = max(dp[i][j], dp[i][k]+dp[i][j-k])
        return dp[m][n]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2313 - https://leetcode.com/problems/minimum-flips-in-binary-tree-to-get-result/
Time: O(n)  Space: O(h)   Hard
.Python/minimum-flips-in-binary-tree-to-get-result.py


```python
# Time:  O(n)
# Space: O(h)

class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        pass


import collections


# tree dp with stack
class Solution(object):
    def minimumFlips(self, root, result):
        """
        :type root: Optional[TreeNode]
        :type result: bool
        :rtype: int
        """
        INF = float("inf")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
            4: lambda x, y: x^y ,
            5: lambda x, y: not x if x is not None else not y
        }
        
        def iter_dfs(root, result):
            ret = collections.defaultdict(lambda: INF)
            stk = [(1, (root, ret))]
            while stk:
                step, args = stk.pop()
                if step == 1:
                    node, ret = args
                    if not node:
                        ret[None] = 0 # null object pattern
                        continue
                    if node.left == node.right:
                        ret[True] = node.val^1
                        ret[False] = node.val^0
                        continue
                    ret1 = collections.defaultdict(lambda: INF)
                    ret2 = collections.defaultdict(lambda: INF)
                    stk.append((2, (node, ret1, ret2, ret)))
                    stk.append((1, (node.right, ret2)))
                    stk.append((1, (node.left, ret1)))
                elif step == 2:
                    node, ret1, ret2, ret = args
                    for k1, v1 in ret1.iteritems():
                        for k2, v2 in ret2.iteritems():
                            ret[OP[node.val](k1, k2)] = min(ret[OP[node.val](k1, k2)], v1+v2)
            return ret[result]

        return iter_dfs(root, result)


import collections


# tree dp with recursion
class Solution2(object):
    def minimumFlips(self, root, result):
        """
        :type root: Optional[TreeNode]
        :type result: bool
        :rtype: int
        """
        INF = float("inf")
        OP = {
            2: lambda x, y: x or y,
            3: lambda x, y: x and y,
            4: lambda x, y: x^y ,
            5: lambda x, y: not x if x is not None else not y
        }
        
        def dfs(node):
            if not node:
                return {None: 0}  # null object pattern
            if node.left == node.right:
                return {True: node.val^1, False: node.val^0}
            left = dfs(node.left)
            right = dfs(node.right)
            dp = collections.defaultdict(lambda: INF)
            for k1, v1 in left.iteritems():
                for k2, v2 in right.iteritems():
                    dp[OP[node.val](k1, k2)] = min(dp[OP[node.val](k1, k2)], v1+v2)
            return dp

        return dfs(root)[result]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2318 - https://leetcode.com/problems/number-of-distinct-roll-sequences/
Time: O(6^3 * n)  Space: O(6^2)   Hard
.Python/number-of-distinct-roll-sequences.py


```python
# Time:  O(6^3 * n)
# Space: O(6^2)

import collections


# dp
class Solution(object):
    def distinctSequences(self, n):
        """
        :type n: int
        :rtype: int
        """
        def gcd(a, b):
            while b:
                a, b = b, a%b
            return a

        if n == 1:
            return 6
        MOD = 10**9 + 7
        dp = [[0]*6 for _ in xrange(6)]
        for i in xrange(6):
            for j in xrange(6):
                if i != j and gcd(i+1, j+1) == 1:
                    dp[i][j] = 1
        for _ in xrange(n-2):
            new_dp = [[0]*6 for _ in xrange(6)]
            for i in xrange(6):
                for j in xrange(6):
                    if not dp[i][j]:
                        continue
                    for k in xrange(6):
                        if not dp[j][k]:
                            continue
                        if k != i:
                            new_dp[i][j] = (new_dp[i][j]+dp[j][k]) % MOD
            dp = new_dp
        return sum(dp[i][j] for i in xrange(6) for j in xrange(6)) % MOD

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2320 - https://leetcode.com/problems/count-number-of-ways-to-place-houses/
Time: O(logn)  Space: O(1)   Medium
.Python/count-number-of-ways-to-place-houses.py


```python
# Time:  O(logn)
# Space: O(1)

import itertools


# matrix exponentiation
class Solution(object):
    def countHousePlacements(self, n):
        """
        :type n: int
        :rtype: int
        """
        MOD = 10**9+7
        def matrix_mult(A, B):
            ZB = zip(*B)
            return [[sum(a*b % MOD for a, b in itertools.izip(row, col)) % MOD for col in ZB] for row in A]
 
        def matrix_expo(A, K):
            result = [[int(i == j) for j in xrange(len(A))] for i in xrange(len(A))]
            while K:
                if K % 2:
                    result = matrix_mult(result, A)
                A = matrix_mult(A, A)
                K /= 2
            return result

        T = [[1, 1],
             [1, 0]]
        return pow(matrix_mult([[1,  0]], matrix_expo(T, n+1))[0][0], 2, MOD)  # [a1, a0] * T^N

    
# Time:  O(n)
# Space: O(1)
# dp
class Solution2(object):
    def countHousePlacements(self, n):
        """
        :type n: int
        :rtype: int
        """
        MOD = 10**9+7
        prev, curr = 0, 1
        for _ in xrange(n+1):
            prev, curr = curr, (prev+curr)%MOD
        return pow(curr, 2, MOD)

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2327 - https://leetcode.com/problems/number-of-people-aware-of-a-secret/
Time: O(n)  Space: O(f)   Medium
.Python/number-of-people-aware-of-a-secret.py


```python
# Time:  O(n)
# Space: O(f)

# dp
class Solution(object):
    def peopleAwareOfSecret(self, n, delay, forget):
        """
        :type n: int
        :type delay: int
        :type forget: int
        :rtype: int
        """
        MOD = 10**9+7
        dp = [0]*forget
        dp[0] = 1
        for i in xrange(1, n):
            dp[i%forget] = ((dp[(i-1)%forget] if i-1 else 0)-dp[i%forget]+dp[(i-delay)%forget]) % MOD
        return sum(dp)%MOD

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2328 - https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/
Time: O(m * n)  Space: O(m * n)   Hard
.Python/number-of-increasing-paths-in-a-grid.py


```python
# Time:  O(m * n)
# Space: O(m * n)

# topological sort, bottom-up dp
class Solution(object):
    def countPaths(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        MOD = 10**9+7
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        in_degree = [[0]*len(grid[0]) for _ in xrange(len(grid))]
        q = []
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                for di, dj in directions:
                    ni, nj = i+di, j+dj
                    if 0 &lt;= ni &lt; len(grid) and 0 &lt;= nj &lt; len(grid[0]) and grid[i][j] &gt; grid[ni][nj]:
                        in_degree[i][j] += 1
                if not in_degree[i][j]:
                    q.append((i, j))
        dp = [[1]*len(grid[0]) for _ in xrange(len(grid))]
        result = 0
        while q:
            new_q = []
            for i, j in q:
                result = (result+dp[i][j])%MOD
                for di, dj in directions:
                    ni, nj = i+di, j+dj
                    if not (0 &lt;= ni &lt; len(grid) and 0 &lt;= nj &lt; len(grid[0]) and grid[i][j] &lt; grid[ni][nj]):
                        continue
                    dp[ni][nj] = (dp[ni][nj]+dp[i][j])%MOD
                    in_degree[ni][nj] -= 1
                    if not in_degree[ni][nj]:
                        new_q.append((ni, nj))
            q = new_q
        return result


# Time:  O(m * n)
# Space: O(m * n)
# top-down dp, memoization
class Solution2(object):
    def countPaths(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        MOD = 10**9+7
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def memoization(grid, i, j, lookup):
            if not lookup[i][j]:
                lookup[i][j] = 1
                for di, dj in directions:
                    ni, nj = i+di, j+dj
                    if 0 &lt;= ni &lt; len(grid) and 0 &lt;= nj &lt; len(grid[0]) and grid[i][j] &lt; grid[ni][nj]:
                        lookup[i][j] = (lookup[i][j]+memoization(grid, ni, nj, lookup)) % MOD
            return lookup[i][j]

        lookup = [[0]*len(grid[0]) for _ in xrange(len(grid))]
        return sum(memoization(grid, i, j, lookup) for i in xrange(len(grid)) for j in xrange(len(grid[0]))) % MOD

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2361 - https://leetcode.com/problems/minimum-costs-using-the-train-line/
Time: O(n)  Space: O(1)   Hard
.Python/minimum-costs-using-the-train-line.py


```python
# Time:  O(n)
# Space: O(1)

import itertools


# dp
class Solution(object):
    def minimumCosts(self, regular, express, expressCost):
        """
        :type regular: List[int]
        :type express: List[int]
        :type expressCost: int
        :rtype: List[int]
        """
        result = []
        dp = [0, expressCost]  # dp[0]: min cost of regular route to curr stop, dp[1]: min cost of express route to curr stop
        for r, e in itertools.izip(regular, express):
            dp = [min(dp[0]+r, dp[1]+e), min(dp[0]+(r+expressCost), dp[1]+e)]
            result.append(min(dp[0], dp[1]))
        return result

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2369 - https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/
Time: O(n)  Space: O(1)   Medium
.Python/check-if-there-is-a-valid-partition-for-the-array.py


```python
# Time:  O(n)
# Space: O(1)

# dp
class Solution(object):
    def validPartition(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        dp = [False]*4
        dp[0] = True
        for i in xrange(len(nums)):
            dp[(i+1)%4] = False
            if i-1 &gt;= 0 and nums[i] == nums[i-1]:
                dp[(i+1)%4] |= dp[((i+1)-2)%4]
            if i-2 &gt;= 0 and (nums[i] == nums[i-1] == nums[i-2] or
                             nums[i] == nums[i-1]+1 == nums[i-2]+2):
                dp[(i+1)%4] |= dp[((i+1)-3)%4]
        return dp[len(nums)%4]

```



----------------------------------------------------------------------------------------

### Dynamic Programming - 2370 - https://leetcode.com/problems/longest-ideal-subsequence/
Time: O(n)  Space: O(1)   Medium
.Python/longest-ideal-subsequence.py


```python
# Time:  O(n)
# Space: O(1)

# dp
class Solution(object):
    def longestIdealString(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: int
        """
        dp = [0]*26
        for c in s:
            x = ord(c)-ord('a')
            dp[x] = max(dp[i] for i in xrange(max(x-k, 0), min(x+k+1, 26)))+1
        return max(dp)

```



----------------------------------------------------------------------------------------

### Greedy - 1005 - https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/
Time: O(n) on average  Space: O(1)   Easy
.Python/maximize-sum-of-array-after-k-negations.py


```python
# Time:  O(n) ~ O(n^2), O(n) on average.
# Space: O(1)

import random


# quick select solution
class Solution(object):
    def largestSumAfterKNegations(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: int
        """
        def kthElement(nums, k, compare):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in xrange(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx &gt; k:
                    right = new_pivot_idx - 1
                else:  # new_pivot_idx &lt; k.
                    left = new_pivot_idx + 1
                    
        kthElement(A, K, lambda a, b: a &lt; b)
        remain = K
        for i in xrange(K):
            if A[i] &lt; 0:
                A[i] = -A[i]
                remain -= 1
        return sum(A) - ((remain)%2)*min(A)*2


# Time:  O(nlogn)
# Space: O(1)
class Solution2(object):
    def largestSumAfterKNegations(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: int
        """
        A.sort()
        remain = K
        for i in xrange(K):
            if A[i] &gt;= 0:
                break
            A[i] = -A[i]
            remain -= 1
        return sum(A) - (remain%2)*min(A)*2

```



----------------------------------------------------------------------------------------

### Greedy - 1024 - https://leetcode.com/problems/video-stitching/
Time: O(nlogn)  Space: O(1)   Medium
.Python/video-stitching.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def videoStitching(self, clips, T):
        """
        :type clips: List[List[int]]
        :type T: int
        :rtype: int
        """
        if T == 0:
            return 0
        result = 1
        curr_reachable, reachable = 0, 0
        clips.sort()
        for left, right in clips:
            if left &gt; reachable:
                break
            elif left &gt; curr_reachable:
                curr_reachable = reachable
                result += 1
            reachable = max(reachable, right)
            if reachable &gt;= T:
                return result
        return -1

```



----------------------------------------------------------------------------------------

### Greedy - 1029 - https://leetcode.com/problems/two-city-scheduling/
Time: O(n) on average  Space: O(1)   Easy
.Python/two-city-scheduling.py


```python
# Time:  O(n) ~ O(n^2), O(n) on average.
# Space: O(1)

import random


# quick select solution
class Solution(object):
    def twoCitySchedCost(self, costs):
        """
        :type costs: List[List[int]]
        :rtype: int
        """
        def kthElement(nums, k, compare):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in xrange(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx &gt; k:
                    right = new_pivot_idx - 1
                else:  # new_pivot_idx &lt; k.
                    left = new_pivot_idx + 1
                    
        kthElement(costs, len(costs)//2, lambda a, b: a[0]-a[1] &lt; b[0]-b[1])
        result = 0
        for i in xrange(len(costs)):
            result += costs[i][0] if i &lt; len(costs)//2 else costs[i][1]
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1053 - https://leetcode.com/problems/previous-permutation-with-one-swap/
Time: O(n)  Space: O(1)   Medium
.Python/previous-permutation-with-one-swap.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def prevPermOpt1(self, A):
        """
        :type A: List[int]
        :rtype: List[int]
        """
        for left in reversed(xrange(len(A)-1)):
            if A[left] &gt; A[left+1]:
                break
        else:
            return A
        right = len(A)-1
        while A[left] &lt;= A[right]:
            right -= 1
        while A[right-1] == A[right]:
            right -= 1
        A[left], A[right] = A[right], A[left]
        return A

```



----------------------------------------------------------------------------------------

### Greedy - 1055 - https://leetcode.com/problems/shortest-way-to-form-string/
Time: O(m + n)  Space: O(m)   Medium
.Python/shortest-way-to-form-string.py


```python
# Time:  O(m + n), m is the length of source
#                , n is the length of target
# Space: O(m)

# greedy solution
class Solution(object):
    def shortestWay(self, source, target):
        """
        :type source: str
        :type target: str
        :rtype: int
        """
        lookup = [[None for _ in xrange(26)] for _ in xrange(len(source)+1)]
        find_char_next_pos = [None]*26
        for i in reversed(xrange(len(source))):
            find_char_next_pos[ord(source[i])-ord('a')] = i+1
            lookup[i] = list(find_char_next_pos)

        result, start = 1, 0
        for c in target:
            start = lookup[start][ord(c)-ord('a')]
            if start != None:
                continue
            result += 1
            start = lookup[0][ord(c)-ord('a')]
            if start == None:
                return -1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1058 - https://leetcode.com/problems/minimize-rounding-error-to-meet-target/
Time: O(n) on average  Space: O(n)   Medium
.Python/minimize-rounding-error-to-meet-target.py


```python
# Time:  O(n) on average
# Space: O(n)

import math
import random


class Solution(object):
    def minimizeError(self, prices, target):
        """
        :type prices: List[str]
        :type target: int
        :rtype: str
        """
        def kthElement(nums, k, compare=lambda a, b: a &lt; b):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in xrange(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx &gt; k:
                    right = new_pivot_idx - 1
                else:  # new_pivot_idx &lt; k.
                    left = new_pivot_idx + 1
        
        errors = []
        lower, upper = 0, 0
        for i, p in enumerate(map(float, prices)):
            lower += int(math.floor(p))
            upper += int(math.ceil(p))
            if p != math.floor(p):
                errors.append(p-math.floor(p))
        if not lower &lt;= target &lt;= upper:
            return "-1"

        lower_round_count = upper-target
        kthElement(errors, lower_round_count)
        result = 0.0
        for i in xrange(len(errors)):
            if i &lt; lower_round_count:
                result += errors[i]
            else:
                result += 1.0-errors[i]
        return "{:.3f}".format(result)

```



----------------------------------------------------------------------------------------

### Greedy - 1081 - https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/
Time: O(n)  Space: O(1)   Medium
.Python/smallest-subsequence-of-distinct-characters.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def smallestSubsequence(self, text):
        """
        :type text: str
        :rtype: str
        """
        count = collections.Counter(text)

        lookup, stk = set(), []
        for c in text:
            if c not in lookup:
                while stk and stk[-1] &gt; c and count[stk[-1]]:
                    lookup.remove(stk.pop())
                stk += c
                lookup.add(c)
            count[c] -= 1
        return "".join(stk)

```



----------------------------------------------------------------------------------------

### Greedy - 1090 - https://leetcode.com/problems/largest-values-from-labels/
Time: O(nlogn)  Space: O(n)   Medium
.Python/largest-values-from-labels.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class Solution(object):
    def largestValsFromLabels(self, values, labels, num_wanted, use_limit):
        """
        :type values: List[int]
        :type labels: List[int]
        :type num_wanted: int
        :type use_limit: int
        :rtype: int
        """
        counts = collections.defaultdict(int)
        val_labs = zip(values,labels)
        val_labs.sort(reverse=True)
        result = 0
        for val, lab in val_labs:
            if counts[lab] &gt;= use_limit:
                continue
            result += val
            counts[lab] += 1
            num_wanted -= 1
            if num_wanted == 0:
                break
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1111 - https://leetcode.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-nesting-depth-of-two-valid-parentheses-strings.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxDepthAfterSplit(self, seq):
        """
        :type seq: str
        :rtype: List[int]
        """
        return [(i &amp; 1) ^ (seq[i] == '(') for i, c in enumerate(seq)]


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def maxDepthAfterSplit(self, seq):
        """
        :type seq: str
        :rtype: List[int]
        """
        A, B = 0, 0
        result = [0]*len(seq)
        for i, c in enumerate(seq):
            point = 1 if c == '(' else -1
            if (point == 1 and A &lt;= B) or \
               (point == -1 and A &gt;= B):
                A += point
            else:
                B += point
                result[i] = 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1163 - https://leetcode.com/problems/last-substring-in-lexicographical-order/
Time: O(n)  Space: O(1)   Hard
.Python/last-substring-in-lexicographical-order.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def lastSubstring(self, s):
        """
        :type s: str
        :rtype: str
        """
        left, right, l = 0, 1, 0
        while right+l &lt; len(s):
            if s[left+l] == s[right+l]:
                l += 1
                continue
            if s[left+l] &gt; s[right+l]:
                right += l+1
            else:
                left = max(right, left+l+1)
                right = left+1
            l = 0
        return s[left:]


# Time:  O(n)
# Space: O(n)
import collections


class Solution2(object):
    def lastSubstring(self, s):
        """
        :type s: str
        :rtype: str
        """
        count = collections.defaultdict(list)
        for i in xrange(len(s)):
            count[s[i]].append(i)

        max_c = max(count.iterkeys())
        starts = {}
        for i in count[max_c]:
            starts[i] = i+1
        while len(starts)-1 &gt; 0:
            lookup = set()
            next_count = collections.defaultdict(list)
            for start, end in starts.iteritems():
                if end == len(s):  # finished
                    lookup.add(start)
                    continue
                next_count[s[end]].append(start)				
                if end in starts:  # overlapped
                    lookup.add(end)			
            next_starts = {}
            max_c = max(next_count.iterkeys())
            for start in next_count[max_c]:
                if start not in lookup:
                    next_starts[start] = starts[start]+1
            starts = next_starts
        return s[next(starts.iterkeys()):]

```



----------------------------------------------------------------------------------------

### Greedy - 1167 - https://leetcode.com/problems/minimum-cost-to-connect-sticks/
Time: O(nlogn)  Space: O(n)   Medium
.Python/minimum-cost-to-connect-sticks.py


```python
# Time:  O(nlogn)
# Space: O(n)

import heapq


class Solution(object):
    def connectSticks(self, sticks):
        """
        :type sticks: List[int]
        :rtype: int
        """
        heapq.heapify(sticks)
        result = 0
        while len(sticks) &gt; 1:
            x, y = heapq.heappop(sticks), heapq.heappop(sticks)
            result += x+y
            heapq.heappush(sticks, x+y)
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1183 - https://leetcode.com/problems/maximum-number-of-ones/
Time: O(1)  Space: O(1)   Hard
.Python/maximum-number-of-ones.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def maximumNumberOfOnes(self, width, height, sideLength, maxOnes):
        """
        :type width: int
        :type height: int
        :type sideLength: int
        :type maxOnes: int
        :rtype: int
        """
        if width &lt; height:
            width, height = height, width

        # 1. split matrix by SxS tiles
        # 2. split each SxS tile into four parts
        #    (r, c), (r, S-c), (S-r, c), (S-r, S-c)
        # 3. for each count of tile part in matrix is
        #    (R+1)*(C+1), (R+1)*C, R*(C+1), R*C (already in descending order)
        # 4. fill one into matrix by tile part of which count is in descending order
        #    until number of ones in a tile comes to maxOnes
        # 
        # ps. area of a tile and its count in matrix are as follows:
        #
        #  |&lt;---- c ----&gt;|&lt;-- S-c --&gt;|
        #  ^             |           |
        #  |             |           |
        #  r (R+1)*(C+1) |  (R+1)*C  |
        #  |             |           |
        #  v             |           |
        #  ---------------------------
        #  ^             |           |
        #  |             |           |
        #  S-r  R*(C+1)  |   R*C     |
        #  |             |           |
        #  v             |           |
        #  ---------------------------
        #

        R, r = divmod(height, sideLength)
        C, c = divmod(width, sideLength)
        assert(R &lt;= C)
        area_counts = [(r*c, (R+1)*(C+1)), \
                       (r*(sideLength-c), (R+1)*C), \
                       ((sideLength-r)*c, R*(C+1)), \
                       ((sideLength-r)*(sideLength-c), R*C)]
        result = 0
        for area, count in area_counts:
            area = min(maxOnes, area)
            result += count*area
            maxOnes -= area
            if not maxOnes:
                break
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1196 - https://leetcode.com/problems/how-many-apples-can-you-put-into-the-basket/
Time: O(nlogn)  Space: O(n)   Easy
.Python/how-many-apples-can-you-put-into-the-basket.py


```python
# Time:  O(nlogn)
# Space: O(n)

class Solution(object):
    def maxNumberOfApples(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        LIMIT = 5000
        arr.sort()
        result, total = 0, 0
        for x in arr:
            if total+x &gt; LIMIT:
                break
            total += x
            result += 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1199 - https://leetcode.com/problems/minimum-time-to-build-blocks/
Time: O(nlogn)  Space: O(n)   Hard
.Python/minimum-time-to-build-blocks.py


```python
# Time:  O(nlogn)
# Space: O(n)

import heapq


class Solution(object):
    def minBuildTime(self, blocks, split):
        """
        :type blocks: List[int]
        :type split: int
        :rtype: int
        """
        heapq.heapify(blocks)
        while len(blocks) != 1:
            x, y = heapq.heappop(blocks), heapq.heappop(blocks)
            heapq.heappush(blocks, y+split)
        return heapq.heappop(blocks)

```



----------------------------------------------------------------------------------------

### Greedy - 1221 - https://leetcode.com/problems/split-a-string-in-balanced-strings/
Time: O(n)  Space: O(1)   Easy
.Python/split-a-string-in-balanced-strings.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def balancedStringSplit(self, s):
        """
        :type s: str
        :rtype: int
        """
        result, count = 0, 0      
        for c in s:
            count += 1 if c == 'L' else -1            
            if count == 0:
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1247 - https://leetcode.com/problems/minimum-swaps-to-make-strings-equal/
Time: O(n)  Space: O(1)   Easy
.Python/minimum-swaps-to-make-strings-equal.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minimumSwap(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: int
        """
        x1, y1 = 0, 0
        for i in xrange(len(s1)):
            if s1[i] == s2[i]:
                continue
            x1 += int(s1[i] == 'x')
            y1 += int(s1[i] == 'y')
        if x1%2 !=  y1%2:  # impossible
            return -1
        # case1: per xx or yy needs one swap, (x1//2 + y1//2) 
        # case2: per xy or yx needs two swaps, (x1%2 + y1%2)
        return (x1//2 + y1//2) + (x1%2 + y1%2)

```



----------------------------------------------------------------------------------------

### Greedy - 1249 - https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-remove-to-make-valid-parentheses.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def minRemoveToMakeValid(self, s):
        """
        :type s: str
        :rtype: str
        """
        result = list(s)
        count = 0
        for i, v in enumerate(result):
            if v == '(':
                count += 1
            elif v == ')':
                if count:
                    count -= 1
                else:
                    result[i] = ""
        if count:
            for i in reversed(xrange(len(result))):
                if result[i] == '(':
                    result[i] = ""
                    count -= 1
                    if not count:
                        break
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Greedy - 1253 - https://leetcode.com/problems/reconstruct-a-2-row-binary-matrix/
Time: O(n)  Space: O(1)   Medium
.Python/reconstruct-a-2-row-binary-matrix.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def reconstructMatrix(self, upper, lower, colsum):
        """
        :type upper: int
        :type lower: int
        :type colsum: List[int]
        :rtype: List[List[int]]
        """
        upper_matrix, lower_matrix = [0]*len(colsum), [0]*len(colsum)
        for i in xrange(len(colsum)):
            upper_matrix[i] = int(upper &gt; 0 and colsum[i] != 0)
            lower_matrix[i] = colsum[i]-upper_matrix[i]
            upper -= upper_matrix[i]
            lower -= lower_matrix[i]
        return [upper_matrix, lower_matrix] if upper == lower == 0 else []

```



----------------------------------------------------------------------------------------

### Greedy - 1272 - https://leetcode.com/problems/remove-interval/
Time: O(n)  Space: O(1)   Medium
.Python/remove-interval.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def removeInterval(self, intervals, toBeRemoved):
        """
        :type intervals: List[List[int]]
        :type toBeRemoved: List[int]
        :rtype: List[List[int]]
        """
        A, B = toBeRemoved
        return [[x, y] for a, b in intervals
                for x, y in ((a, min(A, b)), (max(a, B), b))
                if x &lt; y]

```



----------------------------------------------------------------------------------------

### Greedy - 1282 - https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/
Time: O(n)  Space: O(n)   Medium
.Python/group-the-people-given-the-group-size-they-belong-to.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def groupThePeople(self, groupSizes):
        """
        :type groupSizes: List[int]
        :rtype: List[List[int]]
        """
        groups, result = collections.defaultdict(list), []
        for i, size in enumerate(groupSizes):
            groups[size].append(i)
            if len(groups[size]) == size:
                result.append(groups.pop(size))
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1288 - https://leetcode.com/problems/remove-covered-intervals/
Time: O(nlogn)  Space: O(1)   Medium
.Python/remove-covered-intervals.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def removeCoveredIntervals(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: int
        """
        intervals.sort(key=lambda x: [x[0], -x[1]])
        result, max_right = 0, 0
        for left, right in intervals:
            result += int(right &gt; max_right)
            max_right = max(max_right, right)
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1296 - https://leetcode.com/problems/divide-array-in-sets-of-k-consecutive-numbers/
Time: O(nlogn)  Space: O(n)   Medium
.Python/divide-array-in-sets-of-k-consecutive-numbers.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class Solution(object):
    def isPossibleDivide(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: bool
        """
        count = collections.Counter(nums)
        for num in sorted(count.keys()):
            c = count[num]
            if not c:
                continue
            for i in xrange(num, num+k):
                if count[i] &lt; c:
                    return False
                count[i] -= c
        return True

```



----------------------------------------------------------------------------------------

### Greedy - 1326 - https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/
Time: O(n)  Space: O(n)   Hard
.Python/minimum-number-of-taps-to-open-to-water-a-garden.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def minTaps(self, n, ranges):
        """
        :type n: int
        :type ranges: List[int]
        :rtype: int
        """
        def jump_game(A):
            jump_count, reachable, curr_reachable = 0, 0, 0
            for i, length in enumerate(A):
                if i &gt; reachable:
                    return -1
                if i &gt; curr_reachable:
                    curr_reachable = reachable
                    jump_count += 1
                reachable = max(reachable, i+length)
            return jump_count
    
        max_range = [0]*(n+1)
        for i, r in enumerate(ranges):
            left, right = max(i-r, 0), min(i+r, n)
            max_range[left] = max(max_range[left], right-left)
        return jump_game(max_range)

```



----------------------------------------------------------------------------------------

### Greedy - 1338 - https://leetcode.com/problems/reduce-array-size-to-the-half/
Time: O(n)  Space: O(n)   Medium
.Python/reduce-array-size-to-the-half.py


```python
# Time:  O(n)
# Space: O(n)

import collections

        
class Solution(object):
    def minSetSize(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        counting_sort = [0]*len(arr)
        count = collections.Counter(arr)
        for c in count.itervalues():
            counting_sort[c-1] += 1
        result, total = 0, 0
        for c in reversed(xrange(len(arr))):
            if not counting_sort[c]:
                continue
            count = min(counting_sort[c],
                        ((len(arr)+1)//2 - total - 1)//(c+1) + 1)
            result += count
            total += count*(c+1)
            if total &gt;= (len(arr)+1)//2:
                break
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1353 - https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/
Time: O(r + nlogn)  Space: O(n)   Medium
.Python/maximum-number-of-events-that-can-be-attended.py


```python
# Time:  O(r + nlogn), r is the max end day of events
# Space: O(n)

import heapq


class Solution(object):
    def maxEvents(self, events):
        """
        :type events: List[List[int]]
        :rtype: int
        """
        events.sort(reverse=True)
        min_heap = []
        result = 0
        for d in xrange(1, max(events, key=lambda x:x[1])[1]+1):
            while events and events[-1][0] == d:
                heapq.heappush(min_heap, events.pop()[1])
            while min_heap and min_heap[0] == d-1:
                heapq.heappop(min_heap)
            if not min_heap:
                continue
            heapq.heappop(min_heap)
            result += 1       
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1354 - https://leetcode.com/problems/construct-target-array-with-multiple-sums/
Time: O(log(max(t)) * logn)  Space: O(n)   Hard
.Python/construct-target-array-with-multiple-sums.py


```python
# Time:  O(log(max(t)) * logn)
# Space: O(n)

import heapq


class Solution(object):
    def isPossible(self, target):
        """
        :type target: List[int]
        :rtype: bool
        """
        # (1) x + remain = y
        # (2) y + remain = total
        # (1) - (2) =&gt; x - y = y - total
        #           =&gt; x = 2*y - total
        total = sum(target)
        max_heap = [-x for x in target]
        heapq.heapify(max_heap)
        while total != len(target):
            y = -heapq.heappop(max_heap)
            remain = total-y
            x = y-remain
            if x &lt;= 0:
                return False
            if x &gt; remain:  # for case [1, 1000000000]
                x = x%remain + remain
            heapq.heappush(max_heap, -x)
            total = x+remain
        return True

```



----------------------------------------------------------------------------------------

### Greedy - 1386 - https://leetcode.com/problems/cinema-seat-allocation/
Time: O(n)  Space: O(n)   Medium
.Python/cinema-seat-allocation.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def maxNumberOfFamilies(self, n, reservedSeats):
        """
        :type n: int
        :type reservedSeats: List[List[int]]
        :rtype: int
        """
        lookup = collections.defaultdict(lambda: [False]*3)
        for r, c in reservedSeats:
            if 2 &lt;= c &lt;= 5:
                lookup[r][0] = True
            if 4 &lt;= c &lt;= 7:
                lookup[r][1] = True
            if 6 &lt;= c &lt;= 9:
                lookup[r][2] = True
        result = 2*n
        for a, b, c in lookup.itervalues():
            if not a and not c:
                continue
            if not a or not b or not c:
                result -= 1
                continue
            result -= 2
        return result


# Time:  O(nlogn)
# Space: O(1)
class Solution2(object):
    def maxNumberOfFamilies(self, n, reservedSeats):
        """
        :type n: int
        :type reservedSeats: List[List[int]]
        :rtype: int
        """
        reservedSeats.sort()
        result, i = 2*n, 0
        while i &lt; len(reservedSeats):
            reserved = [False]*3
            curr = reservedSeats[i][0]
            while i &lt; len(reservedSeats) and reservedSeats[i][0] == curr:
                _, c  = reservedSeats[i]
                if 2 &lt;= c &lt;= 5:
                    reserved[0] = True
                if 4 &lt;= c &lt;= 7:
                    reserved[1] = True
                if 6 &lt;= c &lt;= 9:
                    reserved[2] = True
                i += 1
            if not reserved[0] and not reserved[2]:
                continue
            if not all(reserved):
                result -= 1
                continue
            result -= 2
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1400 - https://leetcode.com/problems/construct-k-palindrome-strings/
Time: O(n)  Space: O(1)   Medium
.Python/construct-k-palindrome-strings.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def canConstruct(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: bool
        """
        count = collections.Counter(s)
        odd = sum(v%2 for v in count.itervalues())
        return odd &lt;= k &lt;= len(s)

```



----------------------------------------------------------------------------------------

### Greedy - 1402 - https://leetcode.com/problems/reducing-dishes/
Time: O(nlogn)  Space: O(1)   Hard
.Python/reducing-dishes.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def maxSatisfaction(self, satisfaction):
        """
        :type satisfaction: List[int]
        :rtype: int
        """
        satisfaction.sort(reverse=True)
        result, curr = 0, 0
        for x in satisfaction:
            curr += x
            if curr &lt;= 0:
                break
            result += curr
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1403 - https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/
Time: O(nlogn)  Space: O(1)   Easy
.Python/minimum-subsequence-in-non-increasing-order.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def minSubsequence(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        result, total, curr = [], sum(nums), 0
        nums.sort(reverse=True)
        for i, x in enumerate(nums):
            curr += x
            if curr &gt; total-curr:
                break
        return nums[:i+1]

```



----------------------------------------------------------------------------------------

### Greedy - 1405 - https://leetcode.com/problems/longest-happy-string/
Time: O(n)  Space: O(1)   Medium
.Python/longest-happy-string.py


```python
# Time:  O(n)
# Space: O(1)

import heapq


class Solution(object):
    def longestDiverseString(self, a, b, c):
        """
        :type a: int
        :type b: int
        :type c: int
        :rtype: str
        """
        max_heap = []
        if a:
            heapq.heappush(max_heap, (-a, 'a'))
        if b:
            heapq.heappush(max_heap, (-b, 'b'))
        if c:
            heapq.heappush(max_heap, (-c, 'c'))
        result = []
        while max_heap:
            count1, c1 = heapq.heappop(max_heap)
            if len(result) &gt;= 2 and result[-1] == result[-2] == c1:
                if not max_heap:
                    return "".join(result)
                count2, c2 = heapq.heappop(max_heap)
                result.append(c2)
                count2 += 1
                if count2:
                    heapq.heappush(max_heap, (count2, c2))
                heapq.heappush(max_heap, (count1, c1))
                continue
            result.append(c1)
            count1 += 1
            if count1 != 0:
                heapq.heappush(max_heap, (count1, c1))
        return "".join(result)


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def longestDiverseString(self, a, b, c):
        """
        :type a: int
        :type b: int
        :type c: int
        :rtype: str
        """
        choices = [[a, 'a'], [b, 'b'], [c, 'c']]
        result = []
        for _ in xrange(a+b+c):
            choices.sort(reverse=True)
            for i, (x, c) in enumerate(choices):
                if x and result[-2:] != [c, c]:
                    result.append(c)
                    choices[i][0] -= 1
                    break
            else:
                break
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Greedy - 1414 - https://leetcode.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/
Time: O(logk)  Space: O(1)   Medium
.Python/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k.py


```python
# Time:  O(logk)
# Space: O(1)

class Solution(object):
    def findMinFibonacciNumbers(self, k):
        """
        :type k: int
        :rtype: int
        """
        result, a, b = 0, 1, 1
        while b &lt;= k:
            b, a = a+b, b
        while k:
            if a &lt;= k:
                k -= a
                result += 1
            a, b = b-a, a
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1419 - https://leetcode.com/problems/minimum-number-of-frogs-croaking/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-number-of-frogs-croaking.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minNumberOfFrogs(self, croakOfFrogs):
        """
        :type croakOfFrogs: str
        :rtype: int
        """
        S = "croak"
        lookup = [0]*len(S)
        result = 0
        for c in croakOfFrogs:
            i = S.find(c)
            lookup[i] += 1
            if lookup[i-1]:
                lookup[i-1] -= 1
            elif i == 0:
                result += 1
            else:
                return -1
        return result if result == lookup[-1] else -1

```



----------------------------------------------------------------------------------------

### Greedy - 1433 - https://leetcode.com/problems/check-if-a-string-can-break-another-string/
Time: O(n)  Space: O(1)   Medium
.Python/check-if-a-string-can-break-another-string.py


```python
# Time:  O(n)
# Space: O(1)

import collections
import string


class Solution(object):
    def checkIfCanBreak(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        def is_break(count1, count2):
            curr1, curr2 = 0, 0
            for c in string.ascii_lowercase:
                curr1 += count1[c]
                curr2 += count2[c]
                if curr1 &lt; curr2:
                    return False
            return True

        count1, count2 = collections.Counter(s1), collections.Counter(s2)
        return is_break(count1, count2) or is_break(count2, count1)
    

# Time:  O(nlogn)
# Space: O(1)
import itertools


class Solution2(object):
    def checkIfCanBreak(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        return not {1, -1}.issubset(set(cmp(a, b) for a, b in itertools.izip(sorted(s1), sorted(s2))))


# Time:  O(nlogn)
# Space: O(1)
import itertools


class Solution3(object):
    def checkIfCanBreak(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: bool
        """
        s1, s2 = sorted(s1), sorted(s2)
        return all(a &gt;= b for a, b in itertools.izip(s1, s2)) or \
               all(a &lt;= b for a, b in itertools.izip(s1, s2))

```



----------------------------------------------------------------------------------------

### Greedy - 1488 - https://leetcode.com/problems/avoid-flood-in-the-city/
Time: O(nlogn)  Space: O(n)   Medium
.Python/avoid-flood-in-the-city.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections
import heapq


class Solution(object):
    def avoidFlood(self, rains):
        """
        :type rains: List[int]
        :rtype: List[int]
        """
        lookup = collections.defaultdict(list)
        i = len(rains)-1
        for lake in reversed(rains):
            lookup[lake].append(i)
            i -= 1
        result, min_heap = [], []
        for i, lake in enumerate(rains):
            if lake:
                if len(lookup[lake]) &gt;= 2:
                    lookup[lake].pop()
                    heapq.heappush(min_heap, lookup[lake][-1])
                result.append(-1)
            elif min_heap:
                j = heapq.heappop(min_heap)
                if j &lt; i:
                    return []
                result.append(rains[j])
            else:
                result.append(1)
        return result if not min_heap else []

```



----------------------------------------------------------------------------------------

### Greedy - 1518 - https://leetcode.com/problems/water-bottles/
Time: O(logn/logm)  Space: O(1)   Easy
.Python/water-bottles.py


```python
# Time:  O(logn/logm), n is numBottles, m is numExchange
# Space: O(1)

class Solution(object):
    def numWaterBottles(self, numBottles, numExchange):
        """
        :type numBottles: int
        :type numExchange: int
        :rtype: int
        """
        result = numBottles
        while numBottles &gt;= numExchange:
            numBottles, remainder = divmod(numBottles, numExchange)
            result += numBottles
            numBottles += remainder
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1520 - https://leetcode.com/problems/maximum-number-of-non-overlapping-substrings/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-number-of-non-overlapping-substrings.py


```python
# Time:  O(n)
# space: O(1)

class Solution(object):
    def maxNumOfSubstrings(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        def find_right_from_left(s, first, last, left):
            right, i = last[ord(s[left])-ord('a')], left
            while i &lt;= right:
                if first[ord(s[i])-ord('a')] &lt; left:
                    return -1
                right = max(right, last[ord(s[i])-ord('a')])
                i += 1
            return right
            
        first, last = [float("inf")]*26, [float("-inf")]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        result = [""]
        right = float("inf")
        for left, c in enumerate(s):
            if left != first[ord(c)-ord('a')]:
                continue
            new_right = find_right_from_left(s, first, last, left)
            if new_right == -1:
                continue
            if left &gt; right:
                result.append("")
            right = new_right
            result[-1] = s[left:right+1]
        return result


# Time:  O(n)
# space: O(1)
class Solution2(object):
    def maxNumOfSubstrings(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        def find_right_from_left(s, first, last, left):
            right, i = last[ord(s[left])-ord('a')], left
            while i &lt;= right:
                if first[ord(s[i])-ord('a')] &lt; left:
                    return -1
                right = max(right, last[ord(s[i])-ord('a')])
                i += 1
            return right

        first, last = [float("inf")]*26, [float("-inf")]*26
        for i, c in enumerate(s):
            first[ord(c)-ord('a')] = min(first[ord(c)-ord('a')], i)
            last[ord(c)-ord('a')] = max(last[ord(c)-ord('a')], i)
        intervals = []
        for c in xrange(len(first)):
            if first[c] == float("inf"):
                continue
            left, right = first[c], find_right_from_left(s, first, last, first[c])
            if right != -1:
                intervals.append((right, left))
        intervals.sort()  # Time: O(26log26)
        result, prev = [], -1
        for right, left in intervals:
            if left &lt;= prev:
                continue
            result.append(s[left:right+1])
            prev = right
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1526 - https://leetcode.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/
Time: O(n)  Space: O(1)   Hard
.Python/minimum-number-of-increments-on-subarrays-to-form-a-target-array.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minNumberOperations(self, target):
        """
        :type target: List[int]
        :rtype: int
        """
        return target[0]+sum(max(target[i]-target[i-1], 0) for i in xrange(1, len(target)))


# Time:  O(n)
# Space: O(n)
import itertools


class Solution2(object):
    def minNumberOperations(self, target):
        """
        :type target: List[int]
        :rtype: int
        """
        return sum(max(b-a, 0) for b, a in itertools.izip(target, [0]+target))

```



----------------------------------------------------------------------------------------

### Greedy - 1536 - https://leetcode.com/problems/minimum-swaps-to-arrange-a-binary-grid/
Time: O(n^2)  Space: O(1)   Medium
.Python/minimum-swaps-to-arrange-a-binary-grid.py


```python
# Time:  O(n^2)
# Space: O(1)

import itertools


class Solution(object):
    def minSwaps(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        result = 0
        for target in reversed(xrange(1, len(grid))):
            row_idx = len(grid)-1-target
            while row_idx &lt; len(grid):
                row = grid[row_idx]
                if not sum(itertools.islice(row, len(row)-target, len(row))):
                    break
                row_idx += 1
            else:
                return -1
            while row_idx != len(grid)-1-target:
                grid[row_idx], grid[row_idx-1] = grid[row_idx-1], grid[row_idx]
                result += 1
                row_idx -= 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1546 - https://leetcode.com/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/
Time: O(n)  Space: O(n)   Medium
.Python/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def maxNonOverlapping(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        lookup = {0:-1}
        result, accu, right = 0, 0, -1
        for i, num in enumerate(nums):
            accu += num
            if accu-target in lookup and lookup[accu-target] &gt;= right:
                right = i
                result += 1  # greedy
            lookup[accu] = i
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1564 - https://leetcode.com/problems/put-boxes-into-the-warehouse-i/
Time: O(nlogn)  Space: O(1)   Medium
.Python/put-boxes-into-the-warehouse-i.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):
        """
        :type boxes: List[int]
        :type warehouse: List[int]
        :rtype: int
        """
        boxes.sort(reverse=True)
        result = 0
        for h in boxes:
            if h &gt; warehouse[result]:
                continue
            result += 1
            if result == len(warehouse):
                break
        return result


# Time:  O(nlogn + m)
# Space: O(1)
class Solution2(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):
        """
        :type boxes: List[int]
        :type warehouse: List[int]
        :rtype: int
        """
        boxes.sort()
        for i in xrange(1, len(warehouse)):
            warehouse[i] = min(warehouse[i], warehouse[i-1])
        result, curr = 0, 0
        for h in reversed(warehouse):
            if boxes[curr] &gt; h:
                continue
            result += 1
            curr += 1
            if curr == len(boxes):
                break
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1567 - https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-length-of-subarray-with-positive-product.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def getMaxLen(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result, neg_cnt, last_zero_pos, first_valid_neg_pos = 0, 0, -1, -1
        for i in xrange(len(nums)):
            if nums[i] == 0:
                neg_cnt = 0
                last_zero_pos = i
                first_valid_neg_pos = -1
                continue
            if nums[i] &lt; 0:
                if first_valid_neg_pos == -1:
                    first_valid_neg_pos = i
                neg_cnt += 1
            result = max(result, i-(last_zero_pos if neg_cnt%2 == 0 else first_valid_neg_pos))
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1568 - https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/
Time: O(m^2 * n^2)  Space: O(m * n)   Medium
.Python/minimum-number-of-days-to-disconnect-island.py


```python
# Time:  O(m^2 * n^2)
# Space: O(m * n)

class Solution(object):
    def minDays(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    
        def floodfill(grid, i, j, lookup):
            stk = [(i, j)]
            lookup[i][j] = 1
            while stk:
                i, j = stk.pop()
                for di, dj in directions:
                    ni, nj = i+di, j+dj
                    if not (0 &lt;= ni &lt; len(grid) and
                            0 &lt;= nj &lt; len(grid[0]) and
                            grid[ni][nj] and
                            not lookup[ni][nj]):
                        continue
                    lookup[ni][nj] = 1
                    stk.append((ni, nj))
         
        def count_islands(grid):
            lookup = [[0]*len(grid[0]) for _ in xrange(len(grid))]
            island_cnt = 0
            for i in xrange(len(grid)):
                for j in xrange(len(grid[0])):
                    if grid[i][j] == 0 or lookup[i][j]:
                        continue
                    island_cnt += 1
                    floodfill(grid, i, j, lookup)
            return island_cnt

    
        if count_islands(grid) != 1:
            return 0
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if grid[i][j] == 0:
                    continue
                grid[i][j] = 0
                island_cnt = count_islands(grid)
                grid[i][j] = 1
                if island_cnt != 1:
                    return 1
        return 2

```



----------------------------------------------------------------------------------------

### Greedy - 1578 - https://leetcode.com/problems/minimum-deletion-cost-to-avoid-repeating-letters/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-deletion-cost-to-avoid-repeating-letters.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minCost(self, s, cost):
        """
        :type s: str
        :type cost: List[int]
        :rtype: int
        """
        result = accu = max_cost = 0
        for i in xrange(len(s)):
            if i and s[i] != s[i-1]:
                result += accu-max_cost
                accu = max_cost = 0
            accu += cost[i]
            max_cost = max(max_cost, cost[i])
        result += accu-max_cost
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1580 - https://leetcode.com/problems/put-boxes-into-the-warehouse-ii/
Time: O(nlogn)  Space: O(1)   Medium
.Python/put-boxes-into-the-warehouse-ii.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def maxBoxesInWarehouse(self, boxes, warehouse):
        """
        :type boxes: List[int]
        :type warehouse: List[int]
        :rtype: int
        """
        boxes.sort(reverse=True)
        left, right = 0, len(warehouse)-1
        for h in boxes:
            if h &lt;= warehouse[left]:
                left += 1
            elif h &lt;= warehouse[right]:
                right -= 1
            if left &gt; right:
                break
        return left + (len(warehouse)-1-right)

```



----------------------------------------------------------------------------------------

### Greedy - 1585 - https://leetcode.com/problems/check-if-string-is-transformable-with-substring-sort-operations/
Time: O(n)  Space: O(n)   Hard
.Python/check-if-string-is-transformable-with-substring-sort-operations.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def isTransformable(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: bool
        """
        idxs = [[] for _ in xrange(10)]
        for i in reversed(xrange(len(s))):
            idxs[int(s[i])].append(i)
        for c in t:
            d = int(c)
            if not idxs[d]:
                return False
            for k in xrange(d):  # a char can be moved left to the current position if it meets no smaller one
                if idxs[k] and idxs[k][-1] &lt; idxs[d][-1]:
                    return False
            idxs[d].pop()
        return True

```



----------------------------------------------------------------------------------------

### Greedy - 1589 - https://leetcode.com/problems/maximum-sum-obtained-of-any-permutation/
Time: O(nlogn)  Space: O(n)   Medium
.Python/maximum-sum-obtained-of-any-permutation.py


```python
# Time:  O(nlogn)
# Space: O(n)

import itertools


class Solution(object):
    def maxSumRangeQuery(self, nums, requests):
        """
        :type nums: List[int]
        :type requests: List[List[int]]
        :rtype: int
        """
        def addmod(a, b, mod):  # avoid overflow in other languages
            a %= mod
            b %= mod
            if mod-a &lt;= b:
                b -= mod
            return a+b
        
        def mulmod(a, b, mod):  # avoid overflow in other languages
            a %= mod
            b %= mod
            if a &lt; b:
                a, b = b, a
            result = 0
            while b &gt; 0:
                if b%2 == 1:
                    result = addmod(result, a, mod)
                a = addmod(a, a, mod)
                b //= 2
            return result

        MOD = 10**9+7

        count = [0]*len(nums)
        for start, end in requests:
            count[start] += 1
            if end+1 &lt; len(count):
                count[end+1] -= 1
        for i in xrange(1, len(count)):
            count[i] += count[i-1]
        nums.sort()
        count.sort()
        result = 0
        for i, (num, c) in enumerate(itertools.izip(nums, count)):
            # result = addmod(result, mulmod(num, c, MOD), MOD)
            result = (result+num*c)%MOD
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1591 - https://leetcode.com/problems/strange-printer-ii/
Time: O(c * m * n + e)  Space: O(e)   Hard
.Python/strange-printer-ii.py


```python
# Time:  O(c * m * n + e), c is the number of colors
#                        , e is the number of edges in adj, at most O(c^2)
# Space: O(e)

import collections


class Solution(object):
    def isPrintable(self, targetGrid):
        """
        :type targetGrid: List[List[int]]
        :rtype: bool
        """
        VISITING, VISITED = range(2)
        def has_cycle(adj, color, lookup):
            stk = [(1, color)]
            while stk:
                step, color = stk.pop()
                if step == 1:
                    lookup[color] = VISITING
                    stk.append((2, color))
                    for new_color in adj[color]:
                        if new_color in lookup:
                            if lookup[new_color] == VISITED:
                                continue
                            return True  # VISITING
                        stk.append((1, new_color))
                elif step == 2:
                    lookup[color] = VISITED
            return False

        boxes = collections.defaultdict(lambda:[len(targetGrid), len(targetGrid[0]), -1, -1])
        for r, row in enumerate(targetGrid):
            for c, color in enumerate(row):
                boxes[color][0] = min(boxes[color][0], r)
                boxes[color][1] = min(boxes[color][1], c)
                boxes[color][2] = max(boxes[color][2], r)
                boxes[color][3] = max(boxes[color][3], c)
        adj = collections.defaultdict(set)
        for color, (min_r, min_c, max_r, max_c) in boxes.iteritems():
            for r in xrange(min_r, max_r+1):
                for c in xrange(min_c, max_c+1):
                    if targetGrid[r][c] != color:
                        adj[color].add(targetGrid[r][c])

        lookup = {}
        return all(color in lookup or not has_cycle(adj, color, lookup) for color in boxes.iterkeys())
            

# Time:  O(c * m * n + e), c is the number of colors
#                        , e is the number of edges in adj, at most O(c^2)
# Space: O(e)
class Solution2(object):
    def isPrintable(self, targetGrid):
        """
        :type targetGrid: List[List[int]]
        :rtype: bool
        """
        VISITING, VISITED = range(2)
        def has_cycle(adj, color, lookup):
            lookup[color] = VISITING
            for new_color in adj[color]:
                if (new_color not in lookup and has_cycle(adj, new_color, lookup)) or \
                   lookup[new_color] == VISITING:
                    return True
            lookup[color] = VISITED
            return False          

        MAX_COLOR = 60
        adj = collections.defaultdict(set)
        for color in xrange(1, MAX_COLOR+1):
            min_r = len(targetGrid)
            min_c = len(targetGrid[0])
            max_r = -1
            max_c = -1
            for r in xrange(len(targetGrid)):
                for c in xrange(len(targetGrid[r])):
                    if targetGrid[r][c] == color:
                        min_r = min(min_r, r)
                        min_c = min(min_c, c)
                        max_r = max(max_r, r)
                        max_c = max(max_c, c)
            for r in xrange(min_r, max_r+1):
                for c in xrange(min_c, max_c+1):
                    if targetGrid[r][c] != color:
                        adj[color].add(targetGrid[r][c])

        lookup = {}
        return all(color in lookup or not has_cycle(adj, color, lookup) for color in xrange(1, MAX_COLOR+1))

```



----------------------------------------------------------------------------------------

### Greedy - 1599 - https://leetcode.com/problems/maximum-profit-of-operating-a-centennial-wheel/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-profit-of-operating-a-centennial-wheel.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minOperationsMaxProfit(self, customers, boardingCost, runningCost):
        """
        :type customers: List[int]
        :type boardingCost: int
        :type runningCost: int
        :rtype: int
        """
        max_run = -1
        i = max_prof = prof = waiting = 0
        run = 1
        while i &lt; len(customers) or waiting &gt; 0:
            if i &lt; len(customers):
                waiting += customers[i]  # each run i increases people by customers[i]
                i += 1
            boarding = min(waiting, 4)  # greedy
            waiting -= boarding
            prof += boarding * boardingCost - runningCost 
            if prof &gt; max_prof:
                max_prof = prof
                max_run = run
            run += 1
        return max_run

```



----------------------------------------------------------------------------------------

### Greedy - 1605 - https://leetcode.com/problems/find-valid-matrix-given-row-and-column-sums/
Time: O(m + n)  Space: O(1)   Medium
.Python/find-valid-matrix-given-row-and-column-sums.py


```python
# Time:  O(m + n), excluding ctor of result
# Space: O(1)

# optimized from Solution2 since we can find next i, j pair without nested loops
class Solution(object):
    def restoreMatrix(self, rowSum, colSum):
        """
        :type rowSum: List[int]
        :type colSum: List[int]
        :rtype: List[List[int]]
        """
        matrix = [[0]*len(colSum) for _ in xrange(len(rowSum))]
        i = j = 0
        while i &lt; len(matrix) and j &lt; len(matrix[0]):
            matrix[i][j] = min(rowSum[i], colSum[j])  # greedily used
            rowSum[i] -= matrix[i][j]
            colSum[j] -= matrix[i][j]
            if not rowSum[i]:  # won't be used in row i, ++i
                i += 1
            if not colSum[j]:  # won't be used in col j, ++j
                j += 1
        return matrix


# Time:  O(m * n)
# Space: O(1)
class Solution2(object):
    def restoreMatrix(self, rowSum, colSum):
        """
        :type rowSum: List[int]
        :type colSum: List[int]
        :rtype: List[List[int]]
        """
        matrix = [[0]*len(colSum) for _ in xrange(len(rowSum))]
        for i in xrange(len(matrix)):
            for j in xrange(len(matrix[i])):
                matrix[i][j] = min(rowSum[i], colSum[j])  # greedily used
                rowSum[i] -= matrix[i][j]
                colSum[j] -= matrix[i][j]
        return matrix

```



----------------------------------------------------------------------------------------

### Greedy - 1616 - https://leetcode.com/problems/split-two-strings-to-make-palindrome/
Time: O(n)  Space: O(1)   Medium
.Python/split-two-strings-to-make-palindrome.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def checkPalindromeFormation(self, a, b):
        """
        :type a: str
        :type b: str
        :rtype: bool
        """
        def is_palindrome(s, i, j):
            while i &lt; j:
                if s[i] != s[j]:
                    return False
                i += 1
                j -= 1
            return True

        def check(a, b):
            i, j = 0, len(b)-1
            while i &lt; j:
                if a[i] != b[j]:
                    return is_palindrome(a, i, j) or is_palindrome(b, i, j)
                i += 1
                j -= 1
            return True

        return check(a, b) or check(b, a)

```



----------------------------------------------------------------------------------------

### Greedy - 1632 - https://leetcode.com/problems/rank-transform-of-a-matrix/
Time: O(m * n * log(m * n))  Space: O(m * n)   Hard
.Python/rank-transform-of-a-matrix.py


```python
# Time:  O(m * n * log(m * n) + m * n * (m * n)) = O(m * n * log(m * n))
# Space: O(m * n)

import collections


class UnionFind(object):  # Time: O(n * (n)), Space: O(n)
    def __init__(self, n, cb):
        self.set = range(n)
        self.rank = [0]*n
        self.cb = cb

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        if self.rank[x_root] &lt; self.rank[y_root]:  # union by rank
            self.set[x_root] = y_root
            self.cb(y_root, x_root, y_root)
        elif self.rank[x_root] &gt; self.rank[y_root]:
            self.set[y_root] = x_root
            self.cb(x_root, x_root, y_root)
        else:
            self.set[y_root] = x_root
            self.rank[x_root] += 1
            self.cb(x_root, x_root, y_root)
        return True


class Solution(object):
    def matrixRankTransform(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: List[List[int]]
        """
        def cb(x, y, z):
            new_rank[x] = max(new_rank[y], new_rank[z])

        lookup = collections.defaultdict(list)
        for i in xrange(len(matrix)):
            for j in xrange(len(matrix[0])):
                lookup[matrix[i][j]].append([i, j])
        rank = [0]*(len(matrix)+len(matrix[0]))
        for x in sorted(lookup):
            new_rank = rank[:]
            union_find = UnionFind(len(matrix)+len(matrix[0]), cb)
            for i, j in lookup[x]:
                union_find.union_set(i, j+len(matrix))
            for i, j in lookup[x]:
                matrix[i][j] = rank[i] = rank[j+len(matrix)] = new_rank[union_find.find_set(i)]+1
        return matrix

```



----------------------------------------------------------------------------------------

### Greedy - 1647 - https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-deletions-to-make-character-frequencies-unique.py


```python
# Time:  O(n)
# Space: O(1)

import collections
import string

class Solution(object):
    def minDeletions(self, s):
        """
        :type s: str
        :rtype: int
        """
        count = collections.Counter(s)
        result = 0
        lookup = set()
        for c in string.ascii_lowercase:
            for i in reversed(xrange(1, count[c]+1)):
                if i not in lookup:
                    lookup.add(i)
                    break
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1653 - https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-deletions-to-make-string-balanced.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minimumDeletions(self, s):
        """
        :type s: str
        :rtype: int
        """
        result = b_cnt = 0
        for c in s:
            if c == 'b':
                b_cnt += 1
            elif b_cnt:
                b_cnt -= 1
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1663 - https://leetcode.com/problems/smallest-string-with-a-given-numeric-value/
Time: O(n)  Space: O(1)   Medium
.Python/smallest-string-with-a-given-numeric-value.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def getSmallestString(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: str
        """
        MAX_DIFF = ord('z')-ord('a')

        k -= n
        result = ['a']*n
        for i in reversed(xrange(n)):
            tmp = min(k, MAX_DIFF)
            result[i] = chr(ord('a')+tmp)
            k -= tmp
            if k == 0:
                break
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Greedy - 1665 - https://leetcode.com/problems/minimum-initial-energy-to-finish-tasks/
Time: O(nlogn)  Space: O(1)   Hard
.Python/minimum-initial-energy-to-finish-tasks.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def minimumEffort(self, tasks):
        """
        :type tasks: List[List[int]]
        :rtype: int
        """
        tasks.sort(key=lambda x: x[1]-x[0])  # sort by waste in asc
        result = 0
        # you can see proof here, https://leetcode.com/problems/minimum-initial-energy-to-finish-tasks/discuss/944633/Explanation-on-why-sort-by-difference
        for a, m in tasks:  # we need to pick all the wastes, so greedily to pick the least waste first is always better
            result = max(result+a, m)
        return result


# Time:  O(nlogn)
# Space: O(1)
class Solution2(object):
    def minimumEffort(self, tasks):
        """
        :type tasks: List[List[int]]
        :rtype: int
        """
        tasks.sort(key=lambda x: x[0]-x[1])  # sort by save in desc
        result = curr = 0
        for a, m in tasks:  # we need to pick all the saves, so greedily to pick the most save first is always better
            result += max(m-curr, 0)
            curr = max(curr, m)-a
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1673 - https://leetcode.com/problems/find-the-most-competitive-subsequence/
Time: O(n)  Space: O(k)   Meidum
.Python/find-the-most-competitive-subsequence.py


```python
# Time:  O(n)
# Space: O(k)

class Solution(object):
    def mostCompetitive(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        stk = []
        for i, x in enumerate(nums):
            while stk and stk[-1] &gt; x and len(stk)+(len(nums)-i) &gt; k:
                stk.pop()
            if len(stk) &lt; k:
                stk.append(x)
        return stk

```



----------------------------------------------------------------------------------------

### Greedy - 1674 - https://leetcode.com/problems/minimum-moves-to-make-array-complementary/
Time: O(n + k)  Space: O(k)   Meidum
.Python/minimum-moves-to-make-array-complementary.py


```python
# Time:  O(n + k)
# Space: O(k)

class Solution(object):
    def minMoves(self, nums, limit):
        """
        :type nums: List[int]
        :type limit: int
        :rtype: int
        """
        diff = [0]*(2*(limit+1))
        for i in xrange(len(nums)//2):
            left, right = nums[i], nums[-1-i]
            diff[min(left, right)+1] -= 1        # if target total grows to min(left, right)+1, one less move
            diff[left+right] -= 1                # if target total grows to left+right, one less move
            diff[left+right+1] += 1              # if target total grows to left+right+1, one more move
            diff[max(left, right)+limit+1] += 1  # if target total grows to max(left, right)+limit+1, one more move
        result = count = len(nums)               # default is to move all nums
        for total in xrange(2, 2*limit+1):       # enumerate all possible target totals
            count += diff[total]
            result = min(result, count)
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1686 - https://leetcode.com/problems/stone-game-vi/
Time: O(nlogn)  Space: O(n)   Medium
.Python/stone-game-vi.py


```python
# Time:  O(nlogn)
# Space: O(n)

class Solution(object):
    def stoneGameVI(self, aliceValues, bobValues):
        """
        :type aliceValues: List[int]
        :type bobValues: List[int]
        :rtype: int
        """
        sorted_vals = sorted(((a, b) for a, b in zip(aliceValues, bobValues)), key=sum, reverse=True)
        return cmp(sum(a for a, _ in sorted_vals[::2]), sum(b for _, b in sorted_vals[1::2]))

```



----------------------------------------------------------------------------------------

### Greedy - 1689 - https://leetcode.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/
Time: O(n)  Space: O(1)   Medium
.Python/partitioning-into-minimum-number-of-deci-binary-numbers.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minPartitions(self, n):
        """
        :type n: str
        :rtype: int
        """
        return int(max(n))

```



----------------------------------------------------------------------------------------

### Greedy - 1702 - https://leetcode.com/problems/maximum-binary-string-after-change/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-binary-string-after-change.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def maximumBinaryString(self, binary):
        """
        :type binary: str
        :rtype: str
        """
        result = list(binary)
        zeros = ones = 0
        for i, c in enumerate(result):
            if c == '0':
                zeros += 1
            elif zeros == 0:
                ones += 1
            result[i] = '1'
        if ones != len(result):
            result[zeros+ones-1] = '0'
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Greedy - 1705 - https://leetcode.com/problems/maximum-number-of-eaten-apples/
Time: O(nlogn)  Space: O(n)   Medium
.Python/maximum-number-of-eaten-apples.py


```python
# Time:  O(nlogn)
# Space: O(n)

import heapq


class Solution(object):
    def eatenApples(self, apples, days):
        """
        :type apples: List[int]
        :type days: List[int]
        :rtype: int
        """
        min_heap = []
        result = i = 0
        while i &lt; len(apples) or min_heap:
            if i &lt; len(apples) and apples[i] &gt; 0:
                heapq.heappush(min_heap, [i+days[i], i])
            while min_heap and (min_heap[0][0] &lt;= i or apples[min_heap[0][1]] == 0):
                heapq.heappop(min_heap)
            if min_heap:
                apples[min_heap[0][1]] -= 1
                result += 1
            i += 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1708 - https://leetcode.com/problems/largest-subarray-length-k/
Time: O(n)  Space: O(1)   Easy
.Python/largest-subarray-length-k.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def largestSubarray(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: List[int]
        """
        left, right, l = 0, 1, 0
        while right+k-1 &lt; len(nums) and right+l &lt; len(nums):
            if nums[left+l] == nums[right+l]:
                l += 1
                continue
            if nums[left+l] &gt; nums[right+l]:
                right += l+1
            else:
                left = max(right, min(left+l+1, len(nums)-k))
                right = left+1
            l = 0
        return nums[left:left+k]

```



----------------------------------------------------------------------------------------

### Greedy - 1710 - https://leetcode.com/problems/maximum-units-on-a-truck/
Time: O(nlogn)  Space: O(1)   Easy
.Python/maximum-units-on-a-truck.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def maximumUnits(self, boxTypes, truckSize):
        """
        :type boxTypes: List[List[int]]
        :type truckSize: int
        :rtype: int
        """
        boxTypes.sort(key=lambda x: x[1], reverse=True)
        result = 0
        for box, units in boxTypes:
            if truckSize &gt; box:
                truckSize -= box
                result += box*units
            else:
                result += truckSize*units
                break
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1717 - https://leetcode.com/problems/maximum-score-from-removing-substrings/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-score-from-removing-substrings.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def maximumGain(self, s, x, y):
        """
        :type s: str
        :type x: int
        :type y: int
        :rtype: int
        """
        def score(s, a, x):
            i = result = 0
            for j in xrange(len(s)):
                s[i] = s[j]
                i += 1
                if i &gt;= 2 and s[i-2:i] == a:
                    i -= 2
                    result += x
            s[:] = s[:i]
            return result
                
        s, a, b = list(s), list("ab"), list("ba")
        if x &lt; y:
            x, y = y, x
            a, b = b, a
        return score(s, a, x) + score(s, b, y)

```



----------------------------------------------------------------------------------------

### Greedy - 1725 - https://leetcode.com/problems/number-of-rectangles-that-can-form-the-largest-square/
Time: O(n)  Space: O(1)   Easy
.Python/number-of-rectangles-that-can-form-the-largest-square.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countGoodRectangles(self, rectangles):
        """
        :type rectangles: List[List[int]]
        :rtype: int
        """
        result = mx = 0
        for l, w in rectangles:
            side = min(l, w)
            if side &gt; mx:
                result, mx = 1, side
            elif side == mx:
                result += 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1727 - https://leetcode.com/problems/largest-submatrix-with-rearrangements/
Time: O(m * nlogn)  Space: O(1)   Medium
.Python/largest-submatrix-with-rearrangements.py


```python
# Time:  O(m * nlogn)
# Space: O(1)

class Solution(object):
    def largestSubmatrix(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: int
        """
        for c in xrange(len(matrix[0])):
            h = 0
            for r in xrange(len(matrix)):
                h = h+1 if matrix[r][c] == 1 else 0
                matrix[r][c] = h
        result = 0
        for row in matrix:
            row.sort()
            for c in xrange(len(row)):
                result = max(result, (len(row)-c) * row[c])
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1733 - https://leetcode.com/problems/minimum-number-of-people-to-teach/
Time: O(n * m^2)  Space: O(n * m)   Medium
.Python/minimum-number-of-people-to-teach.py


```python
# Time:  O(n * m^2)
# Space: O(n * m)

import collections


class Solution(object):
    def minimumTeachings(self, n, languages, friendships):
        """
        :type n: int
        :type languages: List[List[int]]
        :type friendships: List[List[int]]
        :rtype: int
        """
        language_sets = map(set, languages)  # Space: O(m * n)
        candidates = set(i-1 for u, v in friendships if not language_sets[u-1] &amp; language_sets[v-1] for i in [u, v])  # Time: O(m^2 * n), Space: O(m)
        count = collections.Counter()
        for i in candidates:  # Time: O(m * n)
            count += collections.Counter(languages[i])
        return len(candidates) - max(count.values() + [0])

```



----------------------------------------------------------------------------------------

### Greedy - 1736 - https://leetcode.com/problems/latest-time-by-replacing-hidden-digits/
Time: O(1)  Space: O(1)   Easy
.Python/latest-time-by-replacing-hidden-digits.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def maximumTime(self, time):
        """
        :type time: str
        :rtype: str
        """
        result = list(time)
        for i, c in enumerate(time): 
            if c != "?":
                continue
            if i == 0:
                result[i] = '2' if result[i+1] in "?0123" else '1'
            elif i == 1:
                result[i] = '3' if result[0] == '2' else '9'
            elif i == 3:
                result[i] = '5'
            elif i == 4:
                result[i] = '9'
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Greedy - 1737 - https://leetcode.com/problems/change-minimum-characters-to-satisfy-one-of-three-conditions/
Time: O(m + n)  Space: O(1)   Medium
.Python/change-minimum-characters-to-satisfy-one-of-three-conditions.py


```python
# Time:  O(m + n)
# Space: O(1)

import collections


class Solution(object):
    def minCharacters(self, a, b):
        """
        :type a: str
        :type b: str
        :rtype: int
        """
        count1 = collections.Counter(ord(c)-ord('a') for c in a)
        count2 = collections.Counter(ord(c)-ord('a') for c in b)
        result = len(a) + len(b) - max((count1+count2).itervalues())  # condition 3
        for i in xrange(26-1):
            if i &gt; 0:
                count1[i] += count1[i-1]
                count2[i] += count2[i-1]
            result = min(result, len(a) - count1[i] + count2[i])  # condition 1
            result = min(result, len(b) - count2[i] + count1[i])  # condition 2
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1749 - https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-absolute-sum-of-any-subarray.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxAbsoluteSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        curr = mx = mn = 0
        for num in nums:
            curr += num
            mx = max(mx, curr)
            mn = min(mn, curr)
        return mx-mn

```



----------------------------------------------------------------------------------------

### Greedy - 1754 - https://leetcode.com/problems/largest-merge-of-two-strings/
Time: O(m * n)  Space: O(m + n)   Medium
.Python/largest-merge-of-two-strings.py


```python
# Time:  O(n * m)
# Space: O(n + m)

import collections


class Solution(object):
    def largestMerge(self, word1, word2):
        """
        :type word1: str
        :type word2: str
        :rtype: str
        """
        q1 = collections.deque(word1)
        q2 = collections.deque(word2)
        result = []
        while q1 or q2:
            if q1 &gt; q2:
                result.append(q1.popleft())
            else:
                result.append(q2.popleft())
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Greedy - 1758 - https://leetcode.com/problems/minimum-changes-to-make-alternating-binary-string/
Time: O(n)  Space: O(1)   Easy
.Python/minimum-changes-to-make-alternating-binary-string.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minOperations(self, s):
        """
        :type s: str
        :rtype: int
        """
        cnt = sum(int(c) == i%2 for i, c in enumerate(s))
        return min(cnt, len(s)-cnt)

```



----------------------------------------------------------------------------------------

### Greedy - 1759 - https://leetcode.com/problems/count-number-of-homogenous-substrings/
Time: O(n)  Space: O(1)   Medium
.Python/count-number-of-homogenous-substrings.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countHomogenous(self, s):
        """
        :type s: str
        :rtype: int
        """
        MOD = 10**9+7
        result = cnt = 0
        for i in xrange(len(s)):
            if i and s[i-1] == s[i]:
                cnt += 1
            else:
                cnt = 1
            result = (result+cnt)%MOD
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1762 - https://leetcode.com/problems/buildings-with-an-ocean-view/
Time: O(n)  Space: O(1)   Medium
.Python/buildings-with-an-ocean-view.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def findBuildings(self, heights):
        """
        :type heights: List[int]
        :rtype: List[int]
        """
        result = []
        for i, h in enumerate(heights):
            while result and heights[result[-1]] &lt;= h:
                result.pop()
            result.append(i)
        return result


# Time:  O(n)
# Space: O(1)
class Solution2(object):
    def findBuildings(self, heights):
        """
        :type heights: List[int]
        :rtype: List[int]
        """
        result = []
        for i in reversed(xrange(len(heights))):
            if not result or heights[result[-1]] &lt; heights[i]:
                result.append(i)
        result.reverse()
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1764 - https://leetcode.com/problems/form-array-by-concatenating-subarrays-of-another-array/
Time: O(n)  Space: O(n)   Medium
.Python/form-array-by-concatenating-subarrays-of-another-array.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def canChoose(self, groups, nums):
        """
        :type groups: List[List[int]]
        :type nums: List[int]
        :rtype: bool
        """
        def getPrefix(pattern):
            prefix = [-1]*len(pattern)
            j = -1
            for i in xrange(1, len(pattern)):
                while j+1 &gt; 0 and pattern[j+1] != pattern[i]:
                    j = prefix[j]
                if pattern[j+1] == pattern[i]:
                    j += 1
                prefix[i] = j
            return prefix
        
        def KMP(text, pattern, start):
            prefix = getPrefix(pattern)
            j = -1
            for i in xrange(start, len(text)):
                while j+1 &gt; 0 and pattern[j+1] != text[i]:
                    j = prefix[j]
                if pattern[j+1] == text[i]:
                    j += 1
                if j+1 == len(pattern):
                    return i-j
            return -1

        pos = 0
        for group in groups:
            pos = KMP(nums, group, pos)
            if pos == -1:
                return False
            pos += len(group)
        return True

```



----------------------------------------------------------------------------------------

### Greedy - 1769 - https://leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-number-of-operations-to-move-all-balls-to-each-box.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minOperations(self, boxes):
        """
        :type boxes: str
        :rtype: List[int]
        """
        result = [0]*len(boxes)
        for direction in (lambda x:x, reversed):
            cnt = accu = 0
            for i in direction(xrange(len(boxes))):
                result[i] += accu
                if boxes[i] == '1':
                    cnt += 1
                accu += cnt
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1775 - https://leetcode.com/problems/equal-sum-arrays-with-minimum-number-of-operations/
Time: O(m + n)  Space: O(1)   Medium
.Python/equal-sum-arrays-with-minimum-number-of-operations.py


```python
# Time:  O(m + n)
# Space: O(1)

import collections


class Solution(object):
    def minOperations(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        if len(nums1)*6 &lt; len(nums2) or len(nums1) &gt; len(nums2)*6:
            return -1
        diff = sum(nums2)-sum(nums1)
        if diff &lt; 0:
            nums1, nums2 = nums2, nums1
            diff = -diff
        count = collections.Counter(6-num for num in nums1)
        count += collections.Counter(num-1 for num in nums2)
        result = 0
        for i in reversed(xrange(1, 6)):
            if not count[i]:
                continue
            cnt = min(count[i], (diff+i-1)//i)
            result += cnt
            diff -= i*cnt
            if diff &lt;= 0:
                break
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1785 - https://leetcode.com/problems/minimum-elements-to-add-to-form-a-given-sum/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-elements-to-add-to-form-a-given-sum.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minElements(self, nums, limit, goal):
        """
        :type nums: List[int]
        :type limit: int
        :type goal: int
        :rtype: int
        """
        return (abs(sum(nums)-goal) + (limit-1))//limit

```



----------------------------------------------------------------------------------------

### Greedy - 1788 - https://leetcode.com/problems/maximize-the-beauty-of-the-garden/
Time: O(n)  Space: O(n)   Hard
.Python/maximize-the-beauty-of-the-garden.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def maximumBeauty(self, flowers):
        """
        :type flowers: List[int]
        :rtype: int
        """
        lookup = {}
        prefix = [0]
        result = float("-inf")
        for i, f in enumerate(flowers):
            prefix.append(prefix[-1]+f if f &gt; 0 else prefix[-1])
            if not f in lookup:
                lookup[f] = i
                continue
            result = max(result, 2*f+prefix[i+1]-prefix[lookup[f]] if f &lt; 0 else prefix[i+1]-prefix[lookup[f]])
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1793 - https://leetcode.com/problems/maximum-score-of-a-good-subarray/
Time: O(n)  Space: O(1)   Hard
.Python/maximum-score-of-a-good-subarray.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def maximumScore(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        result = curr = nums[k]
        left = right = k
        while left-1 &gt;= 0 or right+1 &lt; len(nums):
            # choosing larger one to expand is always better than or equal to choosing smaller one
            if (nums[left-1] if left-1 &gt;= 0 else 0) &lt;= (nums[right+1] if right+1 &lt; len(nums) else 0):
                right += 1
            else:
                left -= 1
            curr = min(curr, nums[left], nums[right])
            result = max(result, curr*(right-left+1))
        return result


# Time:  O(nlogn)
# Space: O(n)
import bisect


class Solution2(object):
    def maximumScore(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        def score(nums, k):
            prefix = [nums[k]]*(k+1)
            for i in reversed(xrange(k)):
                prefix[i] = min(prefix[i+1], nums[i])
            result = right = nums[k]
            for j in xrange(k+1, len(nums)):
                right = min(right, nums[j])
                i = bisect.bisect_left(prefix, right)
                if i &gt;= 0:
                    result = max(result, right*(j-i+1))
            return result

        return max(score(nums, k), score(nums[::-1], len(nums)-1-k))

```



----------------------------------------------------------------------------------------

### Greedy - 1794 - https://leetcode.com/problems/count-pairs-of-equal-substrings-with-minimum-difference/
Time: O(n)  Space: O(1)   Medium
.Python/count-pairs-of-equal-substrings-with-minimum-difference.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def countQuadruples(self, firstString, secondString):
        """
        :type firstString: str
        :type secondString: str
        :rtype: int
        """
        lookup1 = [-1]*26
        for i in reversed(xrange(len(firstString))):
            lookup1[ord(firstString[i])-ord('a')] = i
        lookup2 = [-1]*26
        for i in xrange(len(secondString)):
            lookup2[ord(secondString[i])-ord('a')] = i
        result, diff = 0, float("inf")
        for i in xrange(26):
            if lookup1[i] == -1 or lookup2[i] == -1:
                continue
            if lookup1[i]-lookup2[i] &lt; diff:
                diff = lookup1[i]-lookup2[i]
                result = 0
            result += int(lookup1[i]-lookup2[i] == diff)
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1798 - https://leetcode.com/problems/maximum-number-of-consecutive-values-you-can-make/
Time: O(nlogn)  Space: O(1)   Medium
.Python/maximum-number-of-consecutive-values-you-can-make.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def getMaximumConsecutive(self, coins):
        """
        :type coins: List[int]
        :rtype: int
        """
        coins.sort()
        result = 1
        for c in coins:
            if c &gt; result:
                break
            result += c
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1801 - https://leetcode.com/problems/number-of-orders-in-the-backlog/
Time: O(nlogn)  Space: O(n)   Medium
.Python/number-of-orders-in-the-backlog.py


```python
# Time:  O(nlogn)
# Space: O(n)

import heapq


class Solution(object):
    def getNumberOfBacklogOrders(self, orders):
        """
        :type orders: List[List[int]]
        :rtype: int
        """
        MOD = 10**9 + 7
        buy, sell  = [], []  # max_heap, min_heap
        for p, a, t in orders:
            if t == 0:
                heapq.heappush(buy, [-p, a])
            else:
                heapq.heappush(sell, [p, a])
            while sell and buy and sell[0][0] &lt;= -buy[0][0]:
                k = min(buy[0][1], sell[0][1])
                tmp = heapq.heappop(buy)
                tmp[1] -= k
                if tmp[1]:
                    heapq.heappush(buy, tmp)
                tmp = heapq.heappop(sell)
                tmp[1] -= k
                if tmp[1]:
                    heapq.heappush(sell, tmp)
        return reduce(lambda x, y: (x+y) % MOD, (a for _, a in buy + sell))

```



----------------------------------------------------------------------------------------

### Greedy - 1815 - https://leetcode.com/problems/maximum-number-of-groups-getting-fresh-donuts/
Time: O((b/2) * (n/(b/2)+1)^(b/2))  Space: O((n/(b/2)+1)^(b/2))   Hard
.Python/maximum-number-of-groups-getting-fresh-donuts.py


```python
# Time:  O((b/2) * (n/(b/2)+1)^(b/2))
# Space: O((n/(b/2)+1)^(b/2))

# greedy + memoization solution
class Solution(object):
    def maxHappyGroups(self, batchSize, groups):
        """
        :type batchSize: int
        :type groups: List[int]
        :rtype: int
        """
        def memoization(batchSize, count, mask, remain, lookup):
            if lookup[mask] == 0:
                a_remain = 0
                if remain in count:
                    curr, basis = mask, 1
                    for i, c in count.iteritems():
                        if i == remain:
                            break
                        basis *= c+1
                        curr //= c+1
                    a_remain = curr%(count[remain]+1)
                result = 0
                if a_remain:
                    result = max(result, int(remain == 0) + memoization(batchSize, count, mask-basis, 0, lookup))
                else:
                    curr, basis = mask, 1
                    for i, c in count.iteritems():
                        if curr%(c+1):
                            result = max(result, int(remain == 0) + memoization(batchSize, count, mask-basis, (remain-i)%batchSize, lookup))
                        basis *= c+1
                        curr //= c+1
                lookup[mask] = result
            return lookup[mask]
    
        count = [0]*batchSize
        for i in groups:
            count[i%len(count)] += 1
        result = count[0]
        count[0] = 0
        for i in xrange(1, len(count)//2+1):  # optimization
            pair_count = min(count[i], count[len(count)-i]) if 2*i != len(count) else count[i]//2
            result += pair_count
            count[i] -= pair_count
            count[len(count)-i] -= pair_count
        new_count = {i:c for i, c in enumerate(count) if c}
        max_mask = reduce(lambda total, c: total*(c+1), new_count.itervalues(), 1)
        lookup = [0]*max_mask
        return result+memoization(batchSize, new_count, max_mask-1, 0, lookup)


# Time:  O((b/2) * (n/(b/2)+1)^(b/2))
# Space: O((n/(b/2)+1)^(b/2))
# dp solution
class Solution2(object):
    def maxHappyGroups(self, batchSize, groups):
        """
        :type batchSize: int
        :type groups: List[int]
        :rtype: int
        """
        count = [0]*batchSize
        for i in groups:
            count[i%len(count)] += 1
        result = count[0]
        count[0] = 0
        for i in xrange(1, len(count)//2+1):  # optimization
            pair_count = min(count[i], count[len(count)-i]) if 2*i != len(count) else count[i]//2
            result += pair_count
            count[i] -= pair_count
            count[len(count)-i] -= pair_count
        new_count = {i:c for i, c in enumerate(count) if c}
        max_mask = reduce(lambda total, c: total*(c+1), new_count.itervalues(), 1)
        dp = [0]*max_mask
        for mask in xrange(len(dp)):
            remain = 0
            curr, basis = mask, 1
            for i, c in new_count.iteritems():
                ai = curr%(c+1)
                if ai:
                    dp[mask] = max(dp[mask], dp[mask-basis])
                remain = (remain+ai*i)%batchSize
                basis *= c+1
                curr //= c+1
            if mask != len(dp)-1 and remain == 0:
                dp[mask] += 1
        return result+dp[-1]

```



----------------------------------------------------------------------------------------

### Greedy - 1824 - https://leetcode.com/problems/minimum-sideway-jumps/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-sideway-jumps.py


```python
# Time:  O(n)
# Space: O(1)

# greedy solution
class Solution(object):
    def minSideJumps(self, obstacles):
        """
        :type obstacles: List[int]
        :rtype: int
        """
        result, lanes = 0, set([2])
        for i in xrange(len(obstacles)-1):
            lanes.discard(obstacles[i+1])
            if lanes:
                continue
            result += 1
            lanes = set(j for j in xrange(1, 4) if j not in [obstacles[i], obstacles[i+1]])
        return result

        
# Time:  O(n)
# Space: O(1)
# dp solution
class Solution2(object):
    def minSideJumps(self, obstacles):
        """
        :type obstacles: List[int]
        :rtype: int
        """
        dp = [1, 0, 1]        
        for i in obstacles:
            if i:
                dp[i-1] = float("inf")
            for j in xrange(3):
                if j+1 != i:
                    dp[j] = min(dp[0]+(j != 0), dp[1]+(j != 1), dp[2]+(j != 2))
        return min(dp)

```



----------------------------------------------------------------------------------------

### Greedy - 1827 - https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/
Time: O(n)  Space: O(1)   Easy
.Python/minimum-operations-to-make-the-array-increasing.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minOperations(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = prev = 0
        for curr in nums:
            if prev &lt; curr:
                prev = curr
                continue
            prev += 1
            result += prev-curr                
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1833 - https://leetcode.com/problems/minimum-operations-to-make-the-array-increasing/
Time: O(nlogn)  Space: O(1)   Medium
.Python/maximum-ice-cream-bars.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def maxIceCream(self, costs, coins):
        """
        :type costs: List[int]
        :type coins: int
        :rtype: int
        """
        costs.sort()
        for i, c in enumerate(costs):
            coins -= c
            if coins &lt; 0:
                return i
        return len(costs)

```



----------------------------------------------------------------------------------------

### Greedy - 1840 - https://leetcode.com/problems/maximum-building-height/
Time: O(nlogn)  Space: O(1)   Hard
.Python/maximum-building-height.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def maxBuilding(self, n, restrictions):
        """
        :type n: int
        :type restrictions: List[List[int]]
        :rtype: int
        """
        restrictions.extend([[1, 0], [n, n-1]])
        restrictions.sort()
        for i in reversed(xrange(len(restrictions)-1)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1]+(restrictions[i+1][0]-restrictions[i][0]))
        result = 0
        for i in xrange(1, len(restrictions)):
            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1]+(restrictions[i][0]-restrictions[i-1][0]))
            left, h1 = restrictions[i-1]
            right, h2 = restrictions[i]
            result = max(result, max(h1, h2)+((right-left)-abs(h1-h2))//2)
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1842 - https://leetcode.com/problems/next-palindrome-using-same-digits/
Time: O(n)  Space: O(1)   Hard
.Python/next-palindrome-using-same-digits.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def nextPalindrome(self, num):
        """
        :type num: str
        :rtype: str
        """
        def next_permutation(nums, begin, end):
            def reverse(nums, begin, end):
                left, right = begin, end-1
                while left &lt; right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

            k, l = begin-1, begin
            for i in reversed(xrange(begin, end-1)):
                if nums[i] &lt; nums[i+1]:
                    k = i
                    break
            else:
                reverse(nums, begin, end)
                return False
            for i in reversed(xrange(k+1, end)):
                if nums[i] &gt; nums[k]:
                    l = i
                    break
            nums[k], nums[l] = nums[l], nums[k]
            reverse(nums, k+1, end)
            return True
        
        nums = list(num)
        if not next_permutation(nums, 0, len(nums)//2):
            return ""
        for i in xrange(len(nums)//2):
            nums[-1-i] = nums[i]
        return "".join(nums)

```



----------------------------------------------------------------------------------------

### Greedy - 1846 - https://leetcode.com/problems/maximum-element-after-decreasing-and-rearranging/
Time: O(nlogn)  Space: O(1)   Medium
.Python/maximum-element-after-decreasing-and-rearranging.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def maximumElementAfterDecrementingAndRearranging(self, arr):
        """
        :type arr: List[int]
        :rtype: int
        """
        arr.sort()
        result = 1
        for i in xrange(1, len(arr)):
            result = min(result+1, arr[i])
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1850 - https://leetcode.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/
Time: O((k + n) * n)  Space: O(n)   Medium
.Python/minimum-adjacent-swaps-to-reach-the-kth-smallest-number.py


```python
# Time:  O((k + n) * n)
# Space: O(n)

class Solution(object):
    def getMinSwaps(self, num, k):
        """
        :type num: str
        :type k: int
        :rtype: int
        """
        def next_permutation(nums, begin, end):
            def reverse(nums, begin, end):
                left, right = begin, end-1
                while left &lt; right:
                    nums[left], nums[right] = nums[right], nums[left]
                    left += 1
                    right -= 1

            k, l = begin-1, begin
            for i in reversed(xrange(begin, end-1)):
                if nums[i] &lt; nums[i+1]:
                    k = i
                    break
            else:
                reverse(nums, begin, end)
                return False
            for i in reversed(xrange(k+1, end)):
                if nums[i] &gt; nums[k]:
                    l = i
                    break
            nums[k], nums[l] = nums[l], nums[k]
            reverse(nums, k+1, end)
            return True
        
        new_num = list(num)
        while k:
            next_permutation(new_num, 0, len(new_num))
            k -= 1
        result = 0
        for i in xrange(len(new_num)):
            if new_num[i] == num[i]:
                continue
            #   // greedily move the one with the least cost from new_num to num without missing optimal cost
            for j in xrange(i+1, len(new_num)):
                if new_num[j] == num[i]:
                    break
            result += j-i
            for j in reversed(xrange(i+1, j+1)):
                new_num[j], new_num[j-1] = new_num[j-1], new_num[j]
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1864 - https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-binary-string-alternating/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-number-of-swaps-to-make-the-binary-string-alternating.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minSwaps(self, s):
        """
        :type s: str
        :rtype: int
        """
        def cost(s, x): 
            diff = 0 
            for c in s:
                diff += int(c) != x
                x ^= 1
            return diff//2
    
        ones = s.count('1')
        zeros = len(s)-ones 
        if abs(ones-zeros) &gt; 1:
            return -1
        if ones &gt; zeros:
            return cost(s, 1)
        if ones &lt; zeros:
            return cost(s, 0)
        return min(cost(s, 1), cost(s, 0))

```



----------------------------------------------------------------------------------------

### Greedy - 1874 - https://leetcode.com/problems/minimize-product-sum-of-two-arrays/
Time: O(nlogn)  Space: O(1)   Medium
.Python/minimize-product-sum-of-two-arrays.py


```python
# Time:  O(nlogn)
# Space: O(1)

# Same problem from https://codingcompetitions.withgoogle.com/codejam/round/00000000004330f6/0000000000432f33

import itertools
import operator


class Solution(object):
    def minProductSum(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        def inner_product(vec1, vec2):
            return sum(itertools.imap(operator.mul, vec1, vec2))


        nums1.sort()
        nums2.sort(reverse=True)
        return inner_product(nums1, nums2)

```



----------------------------------------------------------------------------------------

### Greedy - 1877 - https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/
Time: O(nlogn)  Space: O(1)   Medium
.Python/minimize-maximum-pair-sum-in-array.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def minPairSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums.sort()
        return max(nums[i]+nums[-1-i] for i in xrange(len(nums)//2))

```



----------------------------------------------------------------------------------------

### Greedy - 1881 - https://leetcode.com/problems/maximum-value-after-insertion/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-value-after-insertion.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxValue(self, n, x):
        """
        :type n: str
        :type x: int
        :rtype: str
        """
        check = (lambda i: str(x) &gt; n[i]) if n[0] != '-' else (lambda i: str(x) &lt; n[i])
        for i in xrange(len(n)):
            if check(i):
                break
        else:
            i = len(n)
        return n[:i] + str(x) + n[i:]

```



----------------------------------------------------------------------------------------

### Greedy - 1887 - https://leetcode.com/problems/reduction-operations-to-make-the-array-elements-equal/
Time: O(nlogn)  Space: O(1)   Medium
.Python/reduction-operations-to-make-the-array-elements-equal.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def reductionOperations(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        nums.sort()
        result = curr = 0
        for i in xrange(1, len(nums)): 
            if nums[i-1] &lt; nums[i]:
                curr += 1
            result += curr
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1893 - https://leetcode.com/problems/check-if-all-the-integers-in-a-range-are-covered/
Time: O(n + r)  Space: O(r)   Easy
.Python/check-if-all-the-integers-in-a-range-are-covered.py


```python
# Time:  O(n + r)
# Space: O(r)

# if r is small, this is better
class Solution(object):
    def isCovered(self, ranges, left, right):
        """
        :type ranges: List[List[int]]
        :type left: int
        :type right: int
        :rtype: bool
        """
        RANGE_SIZE = 50

        interval = [0]*(RANGE_SIZE+1)
        for l, r in ranges:
            interval[l-1] += 1
            interval[(r-1)+1] -= 1
        cnt = 0
        for i in xrange((right-1)+1):
            cnt += interval[i]
            if i &gt;= left-1 and not cnt:
                return False
        return True


# Time:  O(nlogn)
# Space: O(1)
# if r is big, this is better
class Solution2(object):
    def isCovered(self, ranges, left, right):
        """
        :type ranges: List[List[int]]
        :type left: int
        :type right: int
        :rtype: bool
        """
        ranges.sort()
        for l, r in ranges:
            if l &lt;= left &lt;= r:
                left = r+1
        return left &gt; right


# Time:  O(n * r)
# Space: O(1)
class Solution3(object):
    def isCovered(self, ranges, left, right):
        """
        :type ranges: List[List[int]]
        :type left: int
        :type right: int
        :rtype: bool
        """
        return all(any(l &lt;= i &lt;= r for l, r in ranges) for i in xrange(left, right+1))

```



----------------------------------------------------------------------------------------

### Greedy - 1894 - https://leetcode.com/problems/find-the-student-that-will-replace-the-chalk/
Time: O(n)  Space: O(1)   Medium
.Python/find-the-student-that-will-replace-the-chalk.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def chalkReplacer(self, chalk, k):
        """
        :type chalk: List[int]
        :type k: int
        :rtype: int
        """
        k %= sum(chalk)
        for i, x in enumerate(chalk):
            if k &lt; x:
                return i
            k -= x
        return -1

```



----------------------------------------------------------------------------------------

### Greedy - 1897 - https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/
Time: O(n)  Space: O(1)   Easy
.Python/redistribute-characters-to-make-all-strings-equal.py


```python
# Time:  O(n)
# Space: O(1)

import collections


class Solution(object):
    def makeEqual(self, words):
        """
        :type words: List[str]
        :rtype: bool
        """
        cnt = collections.defaultdict(int)
        for w in words:
            for c in w:
                cnt[c] += 1
        return all(v%len(words) == 0 for v in cnt.itervalues())

```



----------------------------------------------------------------------------------------

### Greedy - 1899 - https://leetcode.com/problems/merge-triplets-to-form-target-triplet/
Time: O(n)  Space: O(1)   Medium
.Python/merge-triplets-to-form-target-triplet.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def mergeTriplets(self, triplets, target):
        """
        :type triplets: List[List[int]]
        :type target: List[int]
        :rtype: bool
        """
        result = [0]*3
        for t in triplets:
            if all(t[i] &lt;= target[i] for i in xrange(3)):
                result = [max(result[i], t[i]) for i in xrange(3)]
        return result == target

```



----------------------------------------------------------------------------------------

### Greedy - 1911 - https://leetcode.com/problems/maximum-alternating-subsequence-sum/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-alternating-subsequence-sum.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxAlternatingSum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = nums[0]
        for i in xrange(len(nums)-1):
            result += max(nums[i+1]-nums[i], 0)
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1913 - https://leetcode.com/problems/maximum-product-difference-between-two-pairs/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-product-difference-between-two-pairs.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maxProductDifference(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        largest, smallest = [0]*2, [float("inf")]*2
        for x in nums:
            if x &gt;= largest[0]:
                largest[:] = [x, largest[0]]
            elif x &gt; largest[1]:
                largest[1] =x
            if x &lt;= smallest[0]:
                smallest[:] = [x, smallest[0]]
            elif x &lt; smallest[1]:
                smallest[1] = x
        return largest[0]*largest[1] - smallest[0]*smallest[1]

```



----------------------------------------------------------------------------------------

### Greedy - 1921 - https://leetcode.com/problems/eliminate-maximum-number-of-monsters/
Time: O(nlogn)  Space: O(1)   Medium
.Python/eliminate-maximum-number-of-monsters.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def eliminateMaximum(self, dist, speed):
        """
        :type dist: List[int]
        :type speed: List[int]
        :rtype: int
        """
        for i in xrange(len(dist)):
            dist[i] = (dist[i]-1)//speed[i]
        dist.sort()
        result = 0
        for i in xrange(len(dist)):
            if result &gt; dist[i]:
                break
            result += 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1927 - https://leetcode.com/problems/sum-game/
Time: O(n)  Space: O(1)   Medium
.Python/sum-game.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def sumGame(self, num):
        """
        :type num: str
        :rtype: bool
        """
        # (1) if both halfs have '?',
        #     alice will optimally choose 9 or 0 from one half to maximize or minimize the diff of both half sums,
        #     and bob will optimally choose the same number from the other half to minimize or maximize the diff of both half sums.
        #     in the end, it turns that only one half has '?' and the diff of both half sums is still the same as original
        # (2) if smaller half has no '?', then alice wins
        # (3) if smaller half has '?'
        #     (3.1) if cnt of '?' is odd, alice can choose the last number to make the diff of both half sums != 0, then alice wins
        #     (3.2) if cnt of '?' is even
        #           (3.2.1) if larger-smaller = cnt/2 * 9, bob can always make a pair of sum 9 no matter what alice chooses, then bob wins
        #           (3.2.2) if larger-smaller &gt; cnt/2 * 9, alice can always choose 0 no matter what bob chooses, then alice wins
        #           (3.2.3) if larger-smaller &lt; cnt/2 * 9, alice can always choose 9 no matter what bob chooses, then alice wins
        cnt = total = 0
        for i in xrange(len(num)):
            if num[i] == '?':
                cnt += (-1 if i &lt; len(num)//2 else 1)
            else:
                total += (int(num[i]) if i &lt; len(num)//2 else -int(num[i]))
        return True if cnt%2 else total != cnt//2*9

```



----------------------------------------------------------------------------------------

### Greedy - 1936 - https://leetcode.com/problems/add-minimum-number-of-rungs/
Time: O(n)  Space: O(1)   Medium
.Python/add-minimum-number-of-rungs.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def addRungs(self, rungs, dist):
        """
        :type rungs: List[int]
        :type dist: int
        :rtype: int
        """
        def ceil_divide(a, b):
            return (a+(b-1))//b

        result = prev = 0
        for curr in rungs:
            result += ceil_divide(curr-prev, dist)-1
            prev = curr
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 1946 - https://leetcode.com/problems/largest-number-after-mutating-substring/
Time: O(n)  Space: O(1)   Medium
.Python/largest-number-after-mutating-substring.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maximumNumber(self, num, change):
        """
        :type num: str
        :type change: List[int]
        :rtype: str
        """
        mutated = False
        result = map(int, list(num))
        for i, d in enumerate(result):
            if change[d] &lt; d:
                if mutated:
                    break
            elif change[d] &gt; d:
                result[i] = str(change[d])
                mutated = True
        return "".join(map(str, result))

```



----------------------------------------------------------------------------------------

### Greedy - 1953 - https://leetcode.com/problems/maximum-number-of-weeks-for-which-you-can-work/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-number-of-weeks-for-which-you-can-work.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def numberOfWeeks(self, milestones):
        """
        :type milestones: List[int]
        :rtype: int
        """
        total, max_num = sum(milestones), max(milestones)
        other_total = (total-max_num)
        return other_total+min(other_total+1, max_num)

```



----------------------------------------------------------------------------------------

### Greedy - 1975 - https://leetcode.com/problems/maximum-matrix-sum/
Time: O(n^2)  Space: O(1)   Medium
.Python/maximum-matrix-sum.py


```python
# Time:  O(n^2)
# Space: O(1)

class Solution(object):
    def maxMatrixSum(self, matrix):
        """
        :type matrix: List[List[int]]
        :rtype: int
        """
        abs_total = sum(abs(x) for row in matrix for x in row)
        min_abs_val = min(abs(x) for row in matrix for x in row)
        neg_cnt = sum(x &lt; 0 for row in matrix for x in row)
        return abs_total if neg_cnt%2 == 0 else abs_total - 2*min_abs_val

```



----------------------------------------------------------------------------------------

### Greedy - 2027 - https://leetcode.com/problems/minimum-moves-to-convert-string/
Time: O(n)  Space: O(1)   Easy
.Python/minimum-moves-to-convert-string.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def minimumMoves(self, s):
        """
        :type s: str
        :rtype: int
        """
        result = i = 0
        while i &lt; len(s):
            if s[i] == 'X':
                result += 1
                i += 3
            else:
                i += 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 2030 - https://leetcode.com/problems/smallest-k-length-subsequence-with-occurrences-of-a-letter/
Time: O(n)  Space: O(n)   Hard
.Python/smallest-k-length-subsequence-with-occurrences-of-a-letter.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def smallestSubsequence(self, s, k, letter, repetition):
        """
        :type s: str
        :type k: int
        :type letter: str
        :type repetition: int
        :rtype: str
        """
        stk = []
        suffix = [0]*(len(s)+1)
        for i in reversed(xrange(len(suffix)-1)):
            suffix[i] = suffix[i+1]+(s[i] == letter)
        for i, c in enumerate(s): 
            while stk and stk[-1] &gt; c and len(stk)+(len(s)-i) &gt; k and (stk[-1] != letter or repetition+1 &lt;= suffix[i]):
                repetition += (stk.pop() == letter)
            if len(stk) &lt; min(k-(repetition-(c == letter)), k):
                repetition -= (c == letter)
                stk.append(c)
        return "".join(stk)

```



----------------------------------------------------------------------------------------

### Greedy - 2036 - https://leetcode.com/problems/maximum-alternating-subarray-sum/
Time: O(n)  Space: O(1)   Medium
.Python/maximum-alternating-subarray-sum.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def maximumAlternatingSubarraySum(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def kadane(nums, start):
            result = float("-inf")
            curr = odd = 0
            for i in xrange(start, len(nums)):
                curr = (curr+nums[i]) if not odd else max(curr-nums[i], 0)
                result = max(result, curr)
                odd ^= 1
            return result

        return max(kadane(nums, 0), kadane(nums, 1))

```



----------------------------------------------------------------------------------------

### Greedy - 2037 - https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/
Time: O(nlogn)  Space: O(1)   Easy
.Python/minimum-number-of-moves-to-seat-everyone.py


```python
# Time:  O(nlogn)
# Space: O(1)

import itertools


class Solution(object):
    def minMovesToSeat(self, seats, students):
        """
        :type seats: List[int]
        :type students: List[int]
        :rtype: int
        """
        seats.sort()
        students.sort()
        return sum(abs(a-b) for a, b in itertools.izip(seats, students))

```



----------------------------------------------------------------------------------------

### Greedy - 2071 - https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/
Time: O(n * (logn)^2)  Space: O(n)   Hard
.Python/maximum-number-of-tasks-you-can-assign.py


```python
# Time:  O(n * (logn)^2)
# Space: O(n)

from sortedcontainers import SortedList


class Solution(object):
    def maxTaskAssign(self, tasks, workers, pills, strength):
        """
        :type tasks: List[int]
        :type workers: List[int]
        :type pills: int
        :type strength: int
        :rtype: int
        """
        def check(tasks, workers, pills, strength, x):
            w = SortedList(workers[-x:])
            for task in tasks[-x:]:  # greedily assign
                i = w.bisect_left(task)
                if i != len(w):
                    w.pop(i)
                    continue
                if pills:
                    i = w.bisect_left(task-strength)
                    if i != len(w):
                        w.pop(i)
                        pills -= 1
                        continue
                return False
            return True

        tasks.sort(reverse=True)
        workers.sort()
        left, right = 1, min(len(workers), len(tasks))
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(tasks, workers, pills, strength, mid):
                right = mid-1
            else:
                left = mid+1
        return right


# Time:  O(n^2 * logn)
# Space: O(n)
class Solution2(object):
    def maxTaskAssign(self, tasks, workers, pills, strength):
        """
        :type tasks: List[int]
        :type workers: List[int]
        :type pills: int
        :type strength: int
        :rtype: int
        """
        def check(tasks, workers, pills, strength, x):
            w = workers[-x:]
            for task in tasks[-x:]:  # greedily assign
                i = bisect.bisect_left(w, task)
                if i != len(w):
                    w.pop(i)
                    continue
                if pills:
                    i = bisect.bisect_left(w, task-strength)
                    if i != len(w):
                        w.pop(i)
                        pills -= 1
                        continue
                return False
            return True

        tasks.sort(reverse=True)
        workers.sort()
        left, right = 1, min(len(workers), len(tasks))
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(tasks, workers, pills, strength, mid):
                right = mid-1
            else:
                left = mid+1
        return right

```



----------------------------------------------------------------------------------------

### Greedy - 2086 - https://leetcode.com/problems/minimum-number-of-buckets-required-to-collect-rainwater-from-houses/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-number-of-buckets-required-to-collect-rainwater-from-houses.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def minimumBuckets(self, street):
        """
        :type street: str
        :rtype: int
        """
        result = 0
        street = list(street)
        for i, c in enumerate(street):
            if c != 'H' or (i and street[i-1] == 'B'):
                continue
            if i+1 &lt; len(street) and street[i+1] == '.':
                street[i+1] = 'B'
                result += 1
            elif i and street[i-1] == '.':
                street[i-1] = 'B'
                result += 1
            else:
                return -1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 2087 - https://leetcode.com/problems/minimum-cost-homecoming-of-a-robot-in-a-grid/
Time: O(m + n)  Space: O(1)   Medium
.Python/minimum-cost-homecoming-of-a-robot-in-a-grid.py


```python
# Time:  O(m + n)
# Space: O(1)

class Solution(object):
    def minCost(self, startPos, homePos, rowCosts, colCosts):
        """
        :type startPos: List[int]
        :type homePos: List[int]
        :type rowCosts: List[int]
        :type colCosts: List[int]
        :rtype: int
        """
        [x0, y0], [x1, y1] = startPos, homePos
        return (sum(rowCosts[i] for i in xrange(min(x0, x1), max(x0, x1)+1))-rowCosts[x0]) + \
               (sum(colCosts[i] for i in xrange(min(y0, y1), max(y0, y1)+1))-colCosts[y0])

```



----------------------------------------------------------------------------------------

### Greedy - 2126 - https://leetcode.com/problems/destroying-asteroids/
Time: O(nlogn)  Space: O(1)   Medium
.Python/destroying-asteroids.py


```python
# Time:  O(nlogn)
# Space: O(1)

class Solution(object):
    def asteroidsDestroyed(self, mass, asteroids):
        """
        :type mass: int
        :type asteroids: List[int]
        :rtype: bool
        """
        asteroids.sort()
        for x in asteroids:
            if x &gt; mass:
                return False
            mass += min(x, asteroids[-1]-mass)
        return True

```



----------------------------------------------------------------------------------------

### Greedy - 2136 - https://leetcode.com/problems/earliest-possible-day-of-full-bloom/
Time: O(nlogn)  Space: O(n)   Hard
.Python/earliest-possible-day-of-full-bloom.py


```python
# Time:  O(nlogn)
# Space: O(n)

class Solution(object):
    def earliestFullBloom(self, plantTime, growTime):
        """
        :type plantTime: List[int]
        :type growTime: List[int]
        :rtype: int
        """
        order = range(len(growTime))
        order.sort(key=lambda x: growTime[x], reverse=True)
        result = curr = 0
        for i in order:
            curr += plantTime[i]
            result = max(result, curr+growTime[i])
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 2139 - https://leetcode.com/problems/minimum-moves-to-reach-target-score/
Time: O(logn)  Space: O(1)   Medium
.Python/minimum-moves-to-reach-target-score.py


```python
# Time:  O(logn)
# Space: O(1)

# greedy
class Solution(object):
    def minMoves(self, target, maxDoubles):
        """
        :type target: int
        :type maxDoubles: int
        :rtype: int
        """
        result = 0
        while target &gt; 1 and maxDoubles:
            result += 1+target%2
            target //= 2
            maxDoubles -= 1
        return result+(target-1)

```



----------------------------------------------------------------------------------------

### Greedy - 2141 - https://leetcode.com/problems/maximum-running-time-of-n-computers/
Time: O(nlogm)  Space: O(1)   Hard
.Python/maximum-running-time-of-n-computers.py


```python
# Time:  O(nlogm)
# Space: O(1)

import heapq


# greedy
class Solution(object):
    def maxRunTime(self, n, batteries):
        """
        :type n: int
        :type batteries: List[int]
        :rtype: int
        """
        total = sum(batteries)
        for i in xrange(len(batteries)):
            batteries[i] = -batteries[i]  # max_heap
        heapq.heapify(batteries)
        while -batteries[0] &gt; total//n:
            n -= 1
            total -= -heapq.heappop(batteries)
        return total//n


# Time:  O(nlogr), r is the range of possible minutes
# Space: O(1)
# binary search
class Solution2(object):
    def maxRunTime(self, n, batteries):
        """
        :type n: int
        :type batteries: List[int]
        :rtype: int
        """
        def check(n, batteries, x):
            return sum(min(b, x) for b in batteries) &gt;= n*x

        left, right = min(batteries), sum(batteries)//n
        while left &lt;= right:
            mid = left + (right-left)//2
            if not check(n, batteries, mid):
                right = mid-1
            else:
                left = mid+1
        return right

```



----------------------------------------------------------------------------------------

### Greedy - 2144 - https://leetcode.com/problems/minimum-cost-of-buying-candies-with-discount/
Time: O(nlogn)  Space: O(1)   Easy
.Python/minimum-cost-of-buying-candies-with-discount.py


```python
# Time:  O(nlogn)
# Space: O(1)

# greedy
class Solution(object):
    def minimumCost(self, cost):
        """
        :type cost: List[int]
        :rtype: int
        """
        cost.sort(reverse=True)
        return sum(x for i, x in enumerate(cost) if i%3 != 2)

```



----------------------------------------------------------------------------------------

### Greedy - 2147 - https://leetcode.com/problems/number-of-ways-to-divide-a-long-corridor/
Time: O(n)  Space: O(1)   Hard
.Python/number-of-ways-to-divide-a-long-corridor.py


```python
# Time:  O(n)
# Space: O(1)

# greedy, combinatorics
class Solution(object):
    def numberOfWays(self, corridor):
        """
        :type corridor: str
        :rtype: int
        """
        MOD = 10**9+7
        result, cnt, j = 1, 0, -1
        for i, x in enumerate(corridor):
            if x != 'S':
                continue
            cnt += 1
            if cnt &gt;= 3 and cnt%2:
                result = result*(i-j)%MOD
            j = i
        return result if cnt and cnt%2 == 0 else 0

```



----------------------------------------------------------------------------------------

### Greedy - 2160 - https://leetcode.com/problems/minimum-sum-of-four-digit-number-after-splitting-digits/
Time: O(1)  Space: O(1)   Easy
.Python/minimum-sum-of-four-digit-number-after-splitting-digits.py


```python
# Time:  O(d) = O(1), d is the number of digits
# Space: O(d) = O(1)

# greedy
class Solution(object):
    def minimumSum(self, num):
        """
        :type num: int
        :rtype: int
        """
        def inplace_counting_sort(nums, reverse=False):  # Time: O(n)
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in xrange(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(xrange(len(nums))):  # inplace but unstable sort
                while nums[i] &gt;= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in xrange(len(nums)):
                nums[i] = ~nums[i]  # restore values
            if reverse:  # unstable sort
                nums.reverse()
    
        nums = map(int, list(str(num)))
        inplace_counting_sort(nums)
        a = b = 0
        for x in nums:
            a = a*10+x
            a, b = b, a
        return a+b


# Time:  O(dlogd) = O(1), d is the number of digits
# Space: O(d) = O(1)
# greedy
class Solution2(object):
    def minimumSum(self, num):
        """
        :type num: int
        :rtype: int
        """
        nums = sorted(map(int, list(str(num))))
        a = b = 0
        for x in nums:
            a = a*10+x
            a, b = b, a
        return a+b

```



----------------------------------------------------------------------------------------

### Greedy - 2165 - https://leetcode.com/problems/smallest-value-of-the-rearranged-number/
Time: O(d)  Space: O(d)   Medium
.Python/smallest-value-of-the-rearranged-number.py


```python
# Time:  O(d), d is the number of digits
# Space: O(d)

# greedy, counting sort
class Solution(object):
    def smallestNumber(self, num):
        """
        :type num: int
        :rtype: int
        """
        def inplace_counting_sort(nums, reverse=False):  # Time: O(n)
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in xrange(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(xrange(len(nums))):  # inplace but unstable sort
                while nums[i] &gt;= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in xrange(len(nums)):
                nums[i] = ~nums[i]  # restore values
            if reverse:  # unstable sort
                nums.reverse()

        sign = 1 if num &gt;= 0 else -1
        nums = map(int, list(str(abs(num))))
        inplace_counting_sort(nums, reverse=(sign == -1))
        i = next((i for i in xrange(len(nums)) if nums[i] != 0), 0)
        nums[0], nums[i] = nums[i], nums[0]
        return sign*int("".join(map(str, nums)))


# Time:  O(dlogd), d is the number of digits
# Space: O(d)
# greedy
class Solution2(object):
    def smallestNumber(self, num):
        """
        :type num: int
        :rtype: int
        """
        sign = 1 if num &gt;= 0 else -1
        nums = sorted(str(abs(num)), reverse=(sign == -1))
        i = next((i for i in xrange(len(nums)) if nums[i] != '0'), 0)
        nums[0], nums[i] = nums[i], nums[0]
        return sign*int("".join(nums))

```



----------------------------------------------------------------------------------------

### Greedy - 2178 - https://leetcode.com/problems/maximum-split-of-positive-even-integers/
Time: O(sqrt(n))  Space: O(1)   Medium
.Python/maximum-split-of-positive-even-integers.py


```python
# Time:  O(sqrt(n))
# Space: O(1)

# greedy
class Solution(object):
    def maximumEvenSplit(self, finalSum):
        """
        :type finalSum: int
        :rtype: List[int]
        """
        if finalSum%2:
            return []
        result = []
        i = 2
        while i &lt;= finalSum:
            result.append(i)
            finalSum -= i
            i += 2
        result[-1] += finalSum
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 2182 - https://leetcode.com/problems/construct-string-with-repeat-limit/
Time: O(n)  Space: O(1)   Medium
.Python/construct-string-with-repeat-limit.py


```python
# Time:  O(26 * n)
# Space: O(26)

import collections


# greedy
class Solution(object):
    def repeatLimitedString(self, s, repeatLimit):
        """
        :type s: str
        :type repeatLimit: int
        :rtype: str
        """
        cnt = collections.Counter(map(lambda x: ord(x)-ord('a'), s))
        result = []
        top1 = 25
        while True:
            top1 = next((i for i in reversed(xrange(top1+1)) if cnt[i]), -1)
            if top1 == -1:
                break
            c = min(cnt[top1], repeatLimit-int(len(result) &gt; 0 and result[-1] == top1))
            cnt[top1] -= c
            result.extend([top1]*c)
            top2 = next((j for j in reversed(xrange(top1)) if cnt[j]), -1)
            if top2 == -1:
                break
            cnt[top2] -= 1
            result.append(top2)
        return "".join(map(lambda x: chr(x+ord('a')), result))

```



----------------------------------------------------------------------------------------

### Greedy - 2193 - https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/
Time: O(nlogn)  Space: O(n)   Hard
.Python/minimum-number-of-moves-to-make-palindrome.py


```python
# Time:  O(nlogn)
# Space: O(n)

class BIT(object):  # 0-indexed
    def __init__(self, n):
        self.__bit = [0]*(n+1)

    def add(self, i, val):
        i += 1
        while i &lt; len(self.__bit):
            self.__bit[i] += val
            i += (i &amp; -i)

    def query(self, i):
        i += 1
        ret = 0
        while i &gt; 0:
            ret += self.__bit[i]
            i -= (i &amp; -i)
        return ret


# greedy, bit, fenwick tree
class Solution(object):
    def minMovesToMakePalindrome(self, s):
        """
        :type s: str
        :rtype: int
        """
        idxs = [[] for _ in xrange(26)]
        for i, c in enumerate(s):
            idxs[ord(c)-ord('a')].append(i)
        targets, pairs = [0]*len(s), []
        for c, idx in enumerate(idxs):
            for i in xrange(len(idx)//2):
                pairs.append((idx[i], idx[~i]))
            if len(idx)%2:
                targets[idx[len(idx)//2]] = len(s)//2
        pairs.sort()
        for i, (l, r) in enumerate(pairs):
            targets[l], targets[r] = i, (len(s)-1)-i
        bit = BIT(len(s))
        result = 0
        for i in targets:
            result += i-bit.query(i-1)  # move from bit.query(i-1) to i
            bit.add(i, 1)
        return result


# Time:  O(n^2)
# Space: O(n)
# greedy
class Solution2(object):
    def minMovesToMakePalindrome(self, s):
        """
        :type s: str
        :rtype: int
        """
        s = list(s)
        result = 0
        while s:
            i = s.index(s[-1])
            if i == len(s)-1:
                result += i//2
            else:
                result += i
                s.pop(i)
            s.pop()
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 2195 - https://leetcode.com/problems/append-k-integers-with-minimal-sum/
Time: O(nlogn)  Space: O(n)   Medium
.Python/append-k-integers-with-minimal-sum.py


```python
# Time:  O(nlogn)
# Space: O(n)

# greedy
class Solution(object):
    def minimalKSum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        result = k*(k+1)//2
        curr = k+1
        for x in sorted(set(nums)):
            if x &lt; curr:
                result += curr-x
                curr += 1
        return result


# Time:  O(nlogn)
# Space: O(n)
# greedy
class Solution2(object):
    def minimalKSum(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        result = prev = 0
        nums.append(float("inf"))
        for x in sorted(set(nums)):
            if not k:
                break
            cnt = min((x-1)-prev, k)
            k -= cnt
            result += ((prev+1)+(prev+cnt))*cnt//2
            prev = x
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 2207 - https://leetcode.com/problems/maximize-number-of-subsequences-in-a-string/
Time: O(n)  Space: O(1)   Medium
.Python/maximize-number-of-subsequences-in-a-string.py


```python
# Time:  O(n)
# Space: O(1)

# counting, greedy
class Solution(object):
    def maximumSubsequenceCount(self, text, pattern):
        """
        :type text: str
        :type pattern: str
        :rtype: int
        """
        result = cnt1 = cnt2 = 0
        for c in text:
            if c == pattern[1]:
                result += cnt1
                cnt2 += 1
            if c == pattern[0]:
                cnt1 += 1
        return result + max(cnt1, cnt2)  # add pattern[1] at back or pattern[0] at front

```



----------------------------------------------------------------------------------------

### Greedy - 2214 - https://leetcode.com/problems/minimum-health-to-beat-game/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-health-to-beat-game.py


```python
# Time:  O(n)
# Space: O(1)

# greedy
class Solution(object):
    def minimumHealth(self, damage, armor):
        """
        :type damage: List[int]
        :type armor: int
        :rtype: int
        """
        return sum(damage)-min(max(damage), armor)+1

```



----------------------------------------------------------------------------------------

### Greedy - 2216 - https://leetcode.com/problems/minimum-deletions-to-make-array-beautiful/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-deletions-to-make-array-beautiful.py


```python
# Time:  O(n)
# Space: O(1)

# greedy
class Solution(object):
    def minDeletion(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        result = 0
        for i in xrange(len(nums)-1):
            result += int(i%2 == result%2 and nums[i] == nums[i+1])
        return result+(len(nums)-result)%2

```



----------------------------------------------------------------------------------------

### Greedy - 2224 - https://leetcode.com/problems/minimum-number-of-operations-to-convert-time/
Time: O(1)  Space: O(1)   Easy
.Python/minimum-number-of-operations-to-convert-time.py


```python
# Time:  O(1)
# Space: O(1)

# greedy
class Solution(object):
    def convertTime(self, current, correct):
        """
        :type current: str
        :type correct: str
        :rtype: int
        """
        OPS = (60, 15, 5, 1)
        diff = (int(correct[:2])*60+int(correct[3:]))-(int(current[:2])*60+int(current[3:]))
        result = 0
        for x in OPS:
            q, diff = divmod(diff, x)
            result += q
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 2259 - https://leetcode.com/problems/remove-digit-from-number-to-maximize-result/
Time: O(n)  Space: O(1)   Easy
.Python/remove-digit-from-number-to-maximize-result.py


```python
# Time:  O(n)
# Space: O(1)

# greedy
class Solution(object):
    def removeDigit(self, number, digit):
        """
        :type number: str
        :type digit: str
        :rtype: str
        """
        i = next((i for i in xrange(len(number)-1) if digit == number[i] &lt; number[i+1]), len(number)-1)
        if i+1 == len(number):
            i = next((i for i in reversed(xrange(len(number))) if digit == number[i]))
        return number[:i]+number[i+1:]

```



----------------------------------------------------------------------------------------

### Greedy - 2263 - https://leetcode.com/problems/make-array-non-decreasing-or-non-increasing/
Time: O(nlogn)  Space: O(n)   Hard
.Python/make-array-non-decreasing-or-non-increasing.py


```python
# Time:  O(nlogn)
# Space: O(n)

import heapq


# greedy, heap
class Solution(object):
    def convertArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def f(nums):
            result = 0
            max_heap = []
            for x in nums:
                if max_heap and x &lt; -max_heap[0]:
                    result += -heapq.heappop(max_heap)-x
                    heapq.heappush(max_heap, -x)
                heapq.heappush(max_heap, -x)
            return result
        
        return min(f(nums), f((x for x in reversed(nums))))


# Time:  O(n^2)
# Space: O(n)
import collections


# dp
class Solution2(object):
    def convertArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        vals = sorted(set(nums))
        def f(nums):
            dp = collections.defaultdict(int)  # dp[i]: min(cnt(j) for j in vals if j &lt;= i)
            for x in nums:
                prev = -1
                for i in vals:
                    dp[i] = min(dp[i]+abs(i-x), dp[prev]) if prev != -1 else dp[i]+abs(i-x)
                    prev = i
            return dp[vals[-1]]

        return min(f(nums), f((x for x in reversed(nums))))

```



----------------------------------------------------------------------------------------

### Greedy - 2268 - https://leetcode.com/problems/minimum-number-of-keypresses/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-number-of-keypresses.py


```python
# Time:  O(n)
# Space: O(1)

import collections


# greedy, sort
class Solution(object):
    def minimumKeypresses(self, s):
        """
        :type s: str
        :rtype: int
        """
        return sum(cnt*(i//9+1) for i, cnt in enumerate(sorted(collections.Counter(s).itervalues(), reverse=True)))

```



----------------------------------------------------------------------------------------

### Greedy - 2279 - https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/
Time: O(nlogn)  Space: O(1)   Medium
.Python/maximum-bags-with-full-capacity-of-rocks.py


```python
# Time:  O(nlogn)
# Space: O(1)

# sort, greedy
class Solution(object):
    def maximumBags(self, capacity, rocks, additionalRocks):
        """
        :type capacity: List[int]
        :type rocks: List[int]
        :type additionalRocks: int
        :rtype: int
        """
        for i in xrange(len(capacity)):
            capacity[i] -= rocks[i]
        capacity.sort()
        for i, c in enumerate(capacity):
            if c &gt; additionalRocks:
                return i
            additionalRocks -= c
        return len(capacity)

```



----------------------------------------------------------------------------------------

### Greedy - 2285 - https://leetcode.com/problems/maximum-total-importance-of-roads/
Time: O(n)  Space: O(n)   Medium
.Python/maximum-total-importance-of-roads.py


```python
# Time:  O(n)
# Space: O(n)

# greedy, counting sort
class Solution(object):
    def maximumImportance(self, n, roads):
        """
        :type n: int
        :type roads: List[List[int]]
        :rtype: int
        """
        def inplace_counting_sort(nums, reverse=False):  # Time: O(n)
            count = [0]*(max(nums)+1)
            for num in nums:
                count[num] += 1
            for i in xrange(1, len(count)):
                count[i] += count[i-1]
            for i in reversed(xrange(len(nums))):  # inplace but unstable sort
                while nums[i] &gt;= 0:
                    count[nums[i]] -= 1
                    j = count[nums[i]]
                    nums[i], nums[j] = nums[j], ~nums[i]
            for i in xrange(len(nums)):
                nums[i] = ~nums[i]  # restore values
            if reverse:  # unstable sort
                nums.reverse()

        degree = [0]*n
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
        inplace_counting_sort(degree)
        return sum(i*x for i, x in enumerate(degree, 1))


# Time:  O(nlogn)
# Space: O(1)
# greedy, sort
class Solution2(object):
    def maximumImportance(self, n, roads):
        """
        :type n: int
        :type roads: List[List[int]]
        :rtype: int
        """
        degree = [0]*n
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
        degree.sort()
        return sum(i*x for i, x in enumerate(degree, 1))

```



----------------------------------------------------------------------------------------

### Greedy - 2294 - https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/
Time: O(nlogn)  Space: O(1)   Medium
.Python/partition-array-such-that-maximum-difference-is-k.py


```python
# Time:  O(nlogn)
# Space: O(1)

# sort, greedy
class Solution(object):
    def partitionArray(self, nums, k):
        """
        :type nums: List[int]
        :type k: int
        :rtype: int
        """
        nums.sort()
        result, prev = 1, 0
        for i in xrange(len(nums)):
            if nums[i]-nums[prev] &lt;= k:
                continue
            prev = i
            result += 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 2311 - https://leetcode.com/problems/longest-binary-subsequence-less-than-or-equal-to-k/
Time: O(n)  Space: O(1)   Medium
.Python/longest-binary-subsequence-less-than-or-equal-to-k.py


```python
# Time:  O(n)
# Space: O(1)

# greedy
class Solution(object):
    def longestSubsequence(self, s, k):
        """
        :type s: str
        :type k: int
        :rtype: int
        """
        result, base = 0, 1
        for i in reversed(xrange(len(s))):
            if s[i] == '0':
                result += 1
            elif base &lt;= k:
                k -= base
                result += 1
            if base &lt;= k:
                base &lt;&lt;= 1
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 2321 - https://leetcode.com/problems/maximum-score-of-spliced-array/
Time: O(n)  Space: O(1)   Hard
.Python/maximum-score-of-spliced-array.py


```python
# Time:  O(n)
# Space: O(1)

# greedy, kadane's algorithm
class Solution(object):
    def maximumsSplicedArray(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        def kadane(a):
            result = curr = 0
            for x in a:
                curr = max(curr+x, 0)
                result = max(result, curr)
            return result
    
        return max(sum(nums1)+kadane((nums2[i]-nums1[i] for i in xrange(len(nums1)))),
                   sum(nums2)+kadane((nums1[i]-nums2[i] for i in xrange(len(nums2)))))

```



----------------------------------------------------------------------------------------

### Greedy - 2323 - https://leetcode.com/problems/find-minimum-time-to-finish-all-jobs-ii/
Time: O(nlogn)  Space: O(1)   Medium
.Python/find-minimum-time-to-finish-all-jobs-ii.py


```python
# Time:  O(nlogn)
# Space: O(1)

import itertools


# greedy
class Solution(object):
    def minimumTime(self, jobs, workers):
        """
        :type jobs: List[int]
        :type workers: List[int]
        :rtype: int
        """
        def ceil_divide(a, b):
            return (a+(b-1))//b

        jobs.sort()
        workers.sort()
        return max(ceil_divide(j, w) for j, w in itertools.izip(jobs, workers))

```



----------------------------------------------------------------------------------------

### Greedy - 2340 - https://leetcode.com/problems/minimum-adjacent-swaps-to-make-a-valid-array/
Time: O(n)  Space: O(1)   Medium
.Python/minimum-adjacent-swaps-to-make-a-valid-array.py


```python
# Time:  O(n)
# Space: O(1)

# array, greedy
class Solution(object):
    def minimumSwaps(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        min_idx = min(xrange(len(nums)), key=nums.__getitem__)
        max_idx = max(reversed(xrange(len(nums))), key=nums.__getitem__)
        return ((len(nums)-1)-max_idx)+min_idx-int(max_idx &lt; min_idx)

```



----------------------------------------------------------------------------------------

### Greedy - 2366 - https://leetcode.com/problems/minimum-replacements-to-sort-the-array/
Time: O(n)  Space: O(1)   Hard
.Python/minimum-replacements-to-sort-the-array.py


```python
# Time:  O(n)
# Space: O(1)

# greedy, math
class Solution(object):
    def minimumReplacement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        def ceil_divide(a, b):
            return (a+b-1)//b

        result = 0
        curr = nums[-1]
        for x in reversed(nums):
            cnt = ceil_divide(x, curr)
            result += cnt-1
            curr = x//cnt
        return result

```



----------------------------------------------------------------------------------------

### Greedy - 2371 - https://leetcode.com/problems/minimize-maximum-value-in-a-grid/
Time: O((m * n) * log(m * n))  Space: O(m * n)   Hard
.Python/minimize-maximum-value-in-a-grid.py


```python
# Time:  O((m * n) * log(m * n))
# Space: O(m * n)

# sort, greedy
class Solution(object):
    def minScore(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: List[List[int]]
        """
        idxs = [(i, j) for i in xrange(len(grid)) for j in xrange(len(grid[0]))]
        idxs.sort(key=lambda x: grid[x[0]][x[1]])
        row_max, col_max = [0]*len(grid), [0]*len(grid[0])
        for i, j in idxs:
            grid[i][j] = row_max[i] = col_max[j] = max(row_max[i], col_max[j])+1
        return grid

```



----------------------------------------------------------------------------------------

### Greedy - 2375 - https://leetcode.com/problems/construct-smallest-number-from-di-string/
Time: O(n)  Space: O(1)   Medium
.Python/construct-smallest-number-from-di-string.py


```python
# Time:  O(n)
# Space: O(1)

# constructive algorithms
class Solution(object):
    def smallestNumber(self, pattern):
        """
        :type pattern: str
        :rtype: str
        """
        result = []
        for i in xrange(len(pattern)+1):
            if not (i == len(pattern) or pattern[i] == 'I'):
                continue
            for x in reversed(range(len(result)+1, (i+1)+1)):
                result.append(x)
        return "".join(map(str, result))

```



----------------------------------------------------------------------------------------

### Graph - 1042 - https://leetcode.com/problems/flower-planting-with-no-adjacent/
Time: O(n)  Space: O(n)   Easy
.Python/flower-planting-with-no-adjacent.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def gardenNoAdj(self, N, paths):
        """
        :type N: int
        :type paths: List[List[int]]
        :rtype: List[int]
        """
        result = [0]*N
        G = [[] for i in xrange(N)]
        for x, y in paths:
            G[x-1].append(y-1)
            G[y-1].append(x-1)
        for i in xrange(N):
            result[i] = ({1, 2, 3, 4} - {result[j] for j in G[i]}).pop()
        return result

```



----------------------------------------------------------------------------------------

### Graph - 1101 - https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/
Time: O(nlogn)  Space: O(n)   Medium
.Python/the-earliest-moment-when-everyone-become-friends.py


```python
# Time:  O(nlogn)
# Space: O(n)

class UnionFind(object):
    def __init__(self, n):
        self.set = range(n)
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def earliestAcq(self, logs, N):
        """
        :type logs: List[List[int]]
        :type N: int
        :rtype: int
        """
        logs.sort()
        union_find = UnionFind(N)
        for t, a, b in logs:
            union_find.union_set(a, b)
            if union_find.count == 1:
                return t
        return -1

```



----------------------------------------------------------------------------------------

### Graph - 1135 - https://leetcode.com/problems/connecting-cities-with-minimum-cost/
Time: O(nlogn)  Space: O(n)   Medium
.Python/connecting-cities-with-minimum-cost.py


```python
# Time:  O(nlogn)
# Space: O(n)

class UnionFind(object):
    def __init__(self, n):
        self.set = range(n)
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[min(x_root, y_root)] = max(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def minimumCost(self, N, connections):
        """
        :type N: int
        :type connections: List[List[int]]
        :rtype: int
        """
        connections.sort(key = lambda x: x[2])
        union_find = UnionFind(N)
        result = 0
        for u, v, val in connections:
            if union_find.union_set(u-1, v-1):
                result += val
        return result if union_find.count == 1 else -1

```



----------------------------------------------------------------------------------------

### Graph - 1168 - https://leetcode.com/problems/optimize-water-distribution-in-a-village/
Time: O(nlogn)  Space: O(n)   Hard
.Python/optimize-water-distribution-in-a-village.py


```python
# Time:  O(nlogn)
# Space: O(n)

class UnionFind(object):
    def __init__(self, n):
        self.set = range(n)
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def minCostToSupplyWater(self, n, wells, pipes):
        """
        :type n: int
        :type wells: List[int]
        :type pipes: List[List[int]]
        :rtype: int
        """
        w = [[c, 0, i] for i, c in enumerate(wells, 1)]
        p = [[c, i, j] for i, j, c in pipes]
        result = 0
        union_find = UnionFind(n+1)
        for c, x, y in sorted(w+p):
            if not union_find.union_set(x, y):
                continue
            result += c
            if union_find.count == 1:
                break
        return result

```



----------------------------------------------------------------------------------------

### Graph - 1334 - https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/
Time: O(n^3)  Space: O(n^2)   Medium
.Python/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance.py


```python
# Time:  O(n^3)
# Space: O(n^2)

class Solution(object):
    def findTheCity(self, n, edges, distanceThreshold):
        """
        :type n: int
        :type edges: List[List[int]]
        :type distanceThreshold: int
        :rtype: int
        """
        dist = [[float("inf")]*n for _ in xrange(n)]
        for i, j, w in edges:
            dist[i][j] = dist[j][i] = w
        for i in xrange(n):
            dist[i][i] = 0
        for k in xrange(n): 
            for i in xrange(n): 
                for j in xrange(n): 
                    dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]) 
        result = {sum(d &lt;= distanceThreshold for d in dist[i]): i for i in xrange(n)}
        return result[min(result.iterkeys())]

```



----------------------------------------------------------------------------------------

### Graph - 1349 - https://leetcode.com/problems/maximum-students-taking-exam/
Time: O(m * n * sqrt(m * n))  Space: O(m + n)   Hard
.Python/maximum-students-taking-exam.py


```python
# Time:  O(m * n * sqrt(m * n))
# Space: O(m * n)

# the problem is the same as google codejam 2008 round 3 problem C
# https://github.com/kamyu104/GoogleCodeJam-2008/blob/master/Round%203/no_cheating.py

import collections


from functools import partial

# Time:  O(E * sqrt(V))
# Space: O(V)
# Source code from http://code.activestate.com/recipes/123641-hopcroft-karp-bipartite-matching/
# Hopcroft-Karp bipartite max-cardinality matching and max independent set
# David Eppstein, UC Irvine, 27 Apr 2002
def bipartiteMatch(graph):
    '''Find maximum cardinality matching of a bipartite graph (U,V,E).
    The input format is a dictionary mapping members of U to a list
    of their neighbors in V.  The output is a triple (M,A,B) where M is a
    dictionary mapping members of V to their matches in U, A is the part
    of the maximum independent set in U, and B is the part of the MIS in V.
    The same object may occur in both U and V, and is treated as two
    distinct vertices if this happens.'''
    
    # initialize greedy matching (redundant, but faster than full search)
    matching = {}
    for u in graph:
        for v in graph[u]:
            if v not in matching:
                matching[v] = u
                break
    
    while 1:
        # structure residual graph into layers
        # pred[u] gives the neighbor in the previous layer for u in U
        # preds[v] gives a list of neighbors in the previous layer for v in V
        # unmatched gives a list of unmatched vertices in final layer of V,
        # and is also used as a flag value for pred[u] when u is in the first layer
        preds = {}
        unmatched = []
        pred = dict([(u,unmatched) for u in graph])
        for v in matching:
            del pred[matching[v]]
        layer = list(pred)
        
        # repeatedly extend layering structure by another pair of layers
        while layer and not unmatched:
            newLayer = {}
            for u in layer:
                for v in graph[u]:
                    if v not in preds:
                        newLayer.setdefault(v,[]).append(u)
            layer = []
            for v in newLayer:
                preds[v] = newLayer[v]
                if v in matching:
                    layer.append(matching[v])
                    pred[matching[v]] = v
                else:
                    unmatched.append(v)
        
        # did we finish layering without finding any alternating paths?
        if not unmatched:
            unlayered = {}
            for u in graph:
                for v in graph[u]:
                    if v not in preds:
                        unlayered[v] = None
            return (matching,list(pred),list(unlayered))

        # recursively search backward through layers to find alternating paths
        # recursion returns true if found path, false otherwise
        def recurse(v):
            if v in preds:
                L = preds[v]
                del preds[v]
                for u in L:
                    if u in pred:
                        pu = pred[u]
                        del pred[u]
                        if pu is unmatched or recurse(pu):
                            matching[v] = u
                            return 1
            return 0
        
        def recurse_iter(v):
            def divide(v):
                if v not in preds:
                    return
                L = preds[v]
                del preds[v]
                for u in L :
                    if u in pred and pred[u] is unmatched:  # early return
                        del pred[u]
                        matching[v] = u
                        ret[0] = True
                        return
                stk.append(partial(conquer, v, iter(L)))

            def conquer(v, it):
                for u in it:
                    if u not in pred:
                        continue
                    pu = pred[u]
                    del pred[u]
                    stk.append(partial(postprocess, v, u, it))
                    stk.append(partial(divide, pu))
                    return

            def postprocess(v, u, it):
                if not ret[0]:
                    stk.append(partial(conquer, v, it))
                    return
                matching[v] = u

            ret, stk = [False], []
            stk.append(partial(divide, v))
            while stk:
                stk.pop()()
            return ret[0]

        for v in unmatched: recurse_iter(v)


# Hopcroft-Karp bipartite matching
class Solution(object):
    def maxStudents(self, seats):
        """
        :type seats: List[List[str]]
        :rtype: int
        """
        directions = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)]
        E, count = collections.defaultdict(list), 0
        for i in xrange(len(seats)):
            for j in xrange(len(seats[0])):
                if seats[i][j] != '.':
                    continue
                count += 1
                if j%2:
                    continue
                for dx, dy in directions:
                    ni, nj = i+dx, j+dy
                    if 0 &lt;= ni &lt; len(seats) and \
                       0 &lt;= nj &lt; len(seats[0]) and \
                       seats[ni][nj] == '.':
                        E[i*len(seats[0])+j].append(ni*len(seats[0])+nj)
        return count-len(bipartiteMatch(E)[0])


# Time:  O(|V| * |E|) = O(m^2 * n^2)
# Space: O(|V| + |E|) = O(m * n)
# Hungarian bipartite matching
class Solution2(object):
    def maxStudents(self, seats):
        """
        :type seats: List[List[str]]
        :rtype: int
        """
        directions = [(-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1)]
        def dfs(seats, e, lookup, matching):
            i, j = e
            for dx, dy in directions:
                ni, nj = i+dx, j+dy
                if 0 &lt;= ni &lt; len(seats) and 0 &lt;= nj &lt; len(seats[0]) and \
                    seats[ni][nj] == '.' and not lookup[ni][nj]:
                    lookup[ni][nj] = True
                    if matching[ni][nj] == -1 or dfs(seats, matching[ni][nj], lookup, matching):
                        matching[ni][nj] = e
                        return True
            return False
        
        def Hungarian(seats):
            result = 0
            matching = [[-1]*len(seats[0]) for _ in xrange(len(seats))]
            for i in xrange(len(seats)):
                for j in xrange(0, len(seats[0]), 2):
                    if seats[i][j] != '.':
                        continue
                    lookup = [[False]*len(seats[0]) for _ in xrange(len(seats))]
                    if dfs(seats, (i, j), lookup, matching):
                        result += 1
            return result
          
        count = 0
        for i in xrange(len(seats)):
            for j in xrange(len(seats[0])):
                if seats[i][j] == '.':
                    count += 1
        return count-Hungarian(seats)


# Time:  O(m * 2^n * 2^n) = O(m * 4^n)
# Space: O(2^n)
# dp solution
class Solution3(object):
    def maxStudents(self, seats):
        """
        :type seats: List[List[str]]
        :rtype: int
        """
        def popcount(n):
            result = 0
            while n:
                n &amp;= n - 1
                result += 1
            return result
        
        dp = {0: 0}
        for row in seats:
            invalid_mask = sum(1 &lt;&lt; c for c, v in enumerate(row) if v == '#')
            new_dp = {}
            for mask1, v1 in dp.iteritems():
                for mask2 in xrange(1 &lt;&lt; len(seats[0])):
                    if (mask2 &amp; invalid_mask) or \
                       (mask2 &amp; (mask1 &lt;&lt; 1)) or (mask2 &amp; (mask1 &gt;&gt; 1)) or \
                       (mask2 &amp; (mask2 &lt;&lt; 1)) or (mask2 &amp; (mask2 &gt;&gt; 1)):
                        continue
                    new_dp[mask2] = max(new_dp.get(mask2, 0), v1+popcount(mask2))
            dp = new_dp
        return max(dp.itervalues()) if dp else 0

```



----------------------------------------------------------------------------------------

### Graph - 1361 - https://leetcode.com/problems/validate-binary-tree-nodes/
Time: O(n)  Space: O(n)   Medium
.Python/validate-binary-tree-nodes.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def validateBinaryTreeNodes(self, n, leftChild, rightChild):
        """
        :type n: int
        :type leftChild: List[int]
        :type rightChild: List[int]
        :rtype: bool
        """
        roots = set(range(n)) - set(leftChild) - set(rightChild)
        if len(roots) != 1:
            return False
        root, = roots
        stk = [root]
        lookup = set([root])
        while stk:
            node = stk.pop()
            for c in (leftChild[node], rightChild[node]):
                if c &lt; 0:
                    continue
                if c in lookup:
                    return False
                lookup.add(c)
                stk.append(c)
        return len(lookup) == n

```



----------------------------------------------------------------------------------------

### Graph - 1462 - https://leetcode.com/problems/course-schedule-iv/
Time: O(n^3)  Space: O(n^2)   Medium
.Python/course-schedule-iv.py


```python
# Time:  O(n^3)
# Space: O(n^2)

class Solution(object):
    def checkIfPrerequisite(self, n, prerequisites, queries):
        """
        :type n: int
        :type prerequisites: List[List[int]]
        :type queries: List[List[int]]
        :rtype: List[bool]
        """
        def floydWarshall(n, graph): 
            reachable = set(map(lambda x: x[0]*n+x[1], graph)) 
            for k in xrange(n): 
                for i in xrange(n): 
                    for j in xrange(n): 
                        if i*n+j not in reachable and (i*n+k in reachable and k*n+j in reachable):
                            reachable.add(i*n+j)
            return reachable

        reachable = floydWarshall(n, prerequisites)
        return [i*n+j in reachable for i, j in queries]


# Time:  O(n * q)
# Space: O(p + n)
import collections


class Solution2(object):
    def checkIfPrerequisite(self, n, prerequisites, queries):
        """
        :type n: int
        :type prerequisites: List[List[int]]
        :type queries: List[List[int]]
        :rtyp
        """
        graph = collections.defaultdict(list)
        for u, v in prerequisites:
            graph[u].append(v)
        result = []
        for i, j in queries:
            stk, lookup = [i], set([i])
            while stk:
                node = stk.pop()
                for nei in graph[node]:
                    if nei in lookup:
                        continue
                    stk.append(nei)
                    lookup.add(nei)
            result.append(j in lookup)
        return result

```



----------------------------------------------------------------------------------------

### Graph - 1489 - https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/
Time: O(nlogn)  Space: O(n)   Hard
.Python/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree.py


```python
# Time:  O(nlogn)
# Space: O(n)

class UnionFind(object):
    def __init__(self, n):
        self.set = range(n)
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def findCriticalAndPseudoCriticalEdges(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[List[int]]
        """
        def MST(n, edges, unused=None, used=None):
            union_find = UnionFind(n)
            weight = 0
            if used is not None:
                u, v, w, _ = edges[used]
                if union_find.union_set(u, v):
                    weight += w
            for i, (u, v, w, _) in enumerate(edges):
                if i == unused:
                    continue
                if union_find.union_set(u, v):
                    weight += w
            return weight if union_find.count == 1 else float("inf")
        
        for i, edge in enumerate(edges):
            edge.append(i)
        edges.sort(key=lambda x: x[2])
        mst = MST(n, edges)
        result = [[], []]
        for i, edge in enumerate(edges):
            if mst &lt; MST(n, edges, unused=i):
                result[0].append(edge[3])
            elif mst == MST(n, edges, used=i):
                result[1].append(edge[3])
        return result

```



----------------------------------------------------------------------------------------

### Graph - 1557 - https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/
Time: O(e)  Space: O(n)   Medium
.Python/minimum-number-of-vertices-to-reach-all-nodes.py


```python
# Time:  O(e)
# Space: O(n)

class Solution(object):
    def findSmallestSetOfVertices(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[int]
        """
        result = []
        lookup = set()
        for u, v in edges:
            lookup.add(v)
        for i in xrange(n):
            if i not in lookup:
                result.append(i)
        return result

```



----------------------------------------------------------------------------------------

### Graph - 1579 - https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/
Time: O(n + m)  Space: O(n)   Hard
.Python/remove-max-number-of-edges-to-keep-graph-fully-traversable.py


```python
# Time:  O(n + m * (n)) ~= O(n + m)
# Space: O(n)

class UnionFind(object):
    def __init__(self, n):
        self.set = range(n)
        self.count = n

    def find_set(self, x):
        if self.set[x] != x:
            self.set[x] = self.find_set(self.set[x])  # path compression.
        return self.set[x]

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        self.set[max(x_root, y_root)] = min(x_root, y_root)
        self.count -= 1
        return True


class Solution(object):
    def maxNumEdgesToRemove(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        result = 0
        union_find_a, union_find_b = UnionFind(n), UnionFind(n)
        for t, i, j in edges:
            if t != 3:
                continue
            a = union_find_a.union_set(i-1, j-1)
            b = union_find_b.union_set(i-1, j-1)
            if not a and not b:
                result += 1
        for t, i, j in edges:
            if t == 1:
                if not union_find_a.union_set(i-1, j-1):
                    result += 1
            elif t == 2:
                if not union_find_b.union_set(i-1, j-1):
                    result += 1
        return result if union_find_a.count == union_find_b.count == 1 else -1

```



----------------------------------------------------------------------------------------

### Graph - 1584 - https://leetcode.com/problems/min-cost-to-connect-all-points/
Time: O(n^2)  Space: O(n)   Medium
.Python/min-cost-to-connect-all-points.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def minCostConnectPoints(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        result, u = 0, 0  # we can start from any node as u
        dist = [float("inf")]*len(points)
        lookup = set()
        for _ in xrange(len(points)-1):
            x0, y0 = points[u]
            lookup.add(u)
            for v, (x, y) in enumerate(points):
                if v in lookup:
                    continue
                dist[v] = min(dist[v], abs(x-x0) + abs(y-y0))
            val, u = min((val, v) for v, val in enumerate(dist)) 
            dist[u] = float("inf")  # used
            result += val
        return result



# Time:  O(eloge) = O(n^2 * logn)
# Space: O(e) = O(n^2)
# kruskal's algorithm
class UnionFind(object):  # Time: O(n * (n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        if self.rank[x_root] &lt; self.rank[y_root]:  # union by rank
            self.set[x_root] = y_root
        elif self.rank[x_root] &gt; self.rank[y_root]:
            self.set[y_root] = x_root
        else:
            self.set[y_root] = x_root
            self.rank[x_root] += 1
        return True


class Solution2(object):
    def minCostConnectPoints(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        edges = []
        for u in xrange(len(points)):
            for v in xrange(u+1, len(points)):
                edges.append((u, v, abs(points[v][0]-points[u][0]) + abs(points[v][1]-points[u][1])))
        edges.sort(key=lambda x: x[2])
        result = 0
        union_find = UnionFind(len(points))
        for u, v, val in edges:
            if union_find.union_set(u, v):
                result += val
        return result

```



----------------------------------------------------------------------------------------

### Graph - 1601 - https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/
Time: O((n + r) * 2^r)  Space: O(n + r)   Hard
.Python/maximum-number-of-achievable-transfer-requests.py


```python
# Time:  O((n + r) * 2^r)
# Space: O(n + r)

import itertools


# early return solution
class Solution(object):
    def maximumRequests(self, n, requests):
        """
        :type n: int
        :type requests: List[List[int]]
        :rtype: int
        """
        for k in reversed(xrange(1, len(requests)+1)):
            for c in itertools.combinations(xrange(len(requests)), k):
                change = [0]*n
                for i in c:
                    change[requests[i][0]] -= 1
                    change[requests[i][1]] += 1
                if all(c == 0 for c in change):
                    return k  # early return
        return 0
    

# Time:  O((n + r) * 2^r)
# Space: O(n + r)
# full search solution (much slower)
class Solution2(object):
    def maximumRequests(self, n, requests):
        """
        :type n: int
        :type requests: List[List[int]]
        :rtype: int
        """
        def evaluate(n, requests, mask):
            change = [0]*n
            base, count = 1, 0
            for i in xrange(len(requests)):
                if base &amp; mask:
                    change[requests[i][0]] -= 1
                    change[requests[i][1]] += 1
                    count += 1
                base &lt;&lt;= 1
            return count if all(c == 0 for c in change) else 0

        return max(evaluate(n, requests, i) for i in xrange(1 &lt;&lt; len(requests)))

```



----------------------------------------------------------------------------------------

### Graph - 1615 - https://leetcode.com/problems/maximal-network-rank/
Time: O(m + n + k^2)  Space: O(m + n)   Medium
.Python/maximal-network-rank.py


```python
# Time:  O(m + n + k^2), k is the number of values greater or equal to top2
# Space: O(m + n)

# optimized from Solution2 with counting sort
class Solution(object):
    def maximalNetworkRank(self, n, roads):
        """
        :type n: int
        :type roads: List[List[int]]
        :rtype: int
        """
        MAX_N = 100
        MAX_NUM = MAX_N-1
        def counting_sort(arr, key=lambda x:x, reverse=False):  # Time: O(n), Space: O(n)
            count = [0]*(MAX_NUM+1)
            for x in arr:
                count[key(x)] += 1
            for i in xrange(1, len(count)):
                count[i] += count[i-1]
            result = [0]*len(arr)
            if not reverse:
                for x in reversed(arr):  # stable sort
                    count[key(x)] -= 1
                    result[count[key(x)]] = x
            else:
                for x in arr:  # stable sort
                    count[key(x)] -= 1
                    result[count[key(x)]] = x
                result.reverse()
            return result

        degree = [0]*n
        adj = collections.defaultdict(set)
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
            adj[a].add(b)
            adj[b].add(a)
        sorted_idx = counting_sort(xrange(n), key=lambda x:degree[x], reverse=True)
        m = 2
        while m &lt; n:
            if degree[sorted_idx[m]] != degree[sorted_idx[1]]:
                break
            m += 1
        result = degree[sorted_idx[0]] + degree[sorted_idx[1]] - 1  # at least sum(top2 values) - 1
        for i in xrange(m-1):  # only need to check pairs of top2 values
            for j in xrange(i+1, m):
                if degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]) &gt; result:  # if equal to ideal sum of top2 values, break
                    return degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]])                                                 
        return result


# Time:  O(m + nlogn + k^2), k is the number of values greater or equal to top2
# Space: O(m + n)
import collections


# optimized from Solution3
class Solution2(object):
    def maximalNetworkRank(self, n, roads):
        """
        :type n: int
        :type roads: List[List[int]]
        :rtype: int
        """
        degree = [0]*n
        adj = collections.defaultdict(set)
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
            adj[a].add(b)
            adj[b].add(a)
        sorted_idx = range(n)
        sorted_idx.sort(key=lambda x:-degree[x])
        m = 2
        while m &lt; n:
            if degree[sorted_idx[m]] != degree[sorted_idx[1]]:
                break
            m += 1
        result = degree[sorted_idx[0]] + degree[sorted_idx[1]] - 1  # at least sum(top2 values) - 1
        for i in xrange(m-1):  # only need to check pairs of top2 values
            for j in xrange(i+1, m):
                if degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]]) &gt; result:  # if equal to ideal sum of top2 values, break
                    return degree[sorted_idx[i]]+degree[sorted_idx[j]]-int(sorted_idx[i] in adj and sorted_idx[j] in adj[sorted_idx[i]])                                                 
        return result


# Time:  O(m + n^2)
# Space: O(m + n)
import collections


class Solution3(object):
    def maximalNetworkRank(self, n, roads):
        """
        :type n: int
        :type roads: List[List[int]]
        :rtype: int
        """
        degree = [0]*n
        adj = collections.defaultdict(set)
        for a, b in roads:
            degree[a] += 1
            degree[b] += 1
            adj[a].add(b)
            adj[b].add(a)
        result = 0
        for i in xrange(n-1):
            for j in xrange(i+1, n):
                result = max(result, degree[i]+degree[j]-int(i in adj and j in adj[i]))
        return result

```



----------------------------------------------------------------------------------------

### Graph - 1627 - https://leetcode.com/problems/graph-connectivity-with-threshold/
Time: O(nlogn + q)  Space: O(n)   Hard
.Python/graph-connectivity-with-threshold.py


```python
# Time:  O((nlogn + q) * (n)) ~= O(nlogn + q)
# Space: O(n)

class UnionFind(object):  # Time: O(n * (n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        if self.rank[x_root] &lt; self.rank[y_root]:  # union by rank
            self.set[x_root] = y_root
        elif self.rank[x_root] &gt; self.rank[y_root]:
            self.set[y_root] = x_root
        else:
            self.set[y_root] = x_root
            self.rank[x_root] += 1
        return True


class Solution(object):
    def areConnected(self, n, threshold, queries):
        """
        :type n: int
        :type threshold: int
        :type queries: List[List[int]]
        :rtype: List[bool]
        """
        union_find = UnionFind(n)
        for i in xrange(threshold+1, n+1):
            # https://stackoverflow.com/questions/25905118/finding-big-o-of-the-harmonic-series
            # sum of harmonic series is O(logn)
            for j in xrange(2*i, n+1, i):  # step by i
                union_find.union_set(i-1, j-1)
        return [union_find.find_set(q[0]-1) == union_find.find_set(q[1]-1) for q in queries]

```



----------------------------------------------------------------------------------------

### Graph - 1631 - https://leetcode.com/problems/path-with-minimum-effort/
Time: O(m * n * log(m * n))  Space: O(m * n)   Medium
.Python/path-with-minimum-effort.py


```python
# Time:  O(m * n * log(m * n))
# Space: O(m * n)

import heapq


# Dijkstra algorithm solution
class Solution(object):
    def minimumEffortPath(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        dst = (len(heights)-1, len(heights[0])-1)
        dist = [[float("inf")]*len(heights[0]) for _ in xrange(len(heights))]
        dist[0][0] = 0;
        min_heap = [(0, 0, 0)]
        lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]
        while min_heap:
            d, r, c = heapq.heappop(min_heap)
            if lookup[r][c]:
                continue
            lookup[r][c] = True
            if (r, c) == dst:
                return d
            for dr, dc in directions:
                nr, nc = r+dr, c+dc
                if not (0 &lt;= nr &lt; len(heights) and 0 &lt;= nc &lt; len(heights[0]) and not lookup[nr][nc]):
                    continue
                nd = max(d, abs(heights[nr][nc]-heights[r][c]))
                if nd &lt; dist[nr][nc]:
                    dist[nr][nc] = nd
                    heapq.heappush(min_heap, (nd, nr, nc))
        return -1


# Time:  O(m * n * log(m * n) + m * n * (m * n)) = O(m * n * log(m * n))
# Space: O(m * n)
import collections


class UnionFind(object):  # Time: O(n * (n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        if self.rank[x_root] &lt; self.rank[y_root]:  # union by rank
            self.set[x_root] = y_root
        elif self.rank[x_root] &gt; self.rank[y_root]:
            self.set[y_root] = x_root
        else:
            self.set[y_root] = x_root
            self.rank[x_root] += 1
        return True


# union find solution
class Solution2(object):
    def minimumEffortPath(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: int
        """
        def index(n, i, j):
            return i*n + j
    
        diffs = []
        for i in xrange(len(heights)):
            for j in xrange(len(heights[0])):
                if i &gt; 0:
                    diffs.append((abs(heights[i][j]-heights[i-1][j]), index(len(heights[0]), i-1, j), index(len(heights[0]), i, j)))
                if j &gt; 0:
                    diffs.append((abs(heights[i][j]-heights[i][j-1]), index(len(heights[0]), i, j-1), index(len(heights[0]), i, j)))
        diffs.sort()
        union_find = UnionFind(len(heights)*len(heights[0]))
        for d, i, j in diffs:
            if union_find.union_set(i, j):
                if union_find.find_set(index(len(heights[0]), 0, 0)) == \
                   union_find.find_set(index(len(heights[0]), len(heights)-1, len(heights[0])-1)):
                    return d
        return 0


# Time:  O(m * n * logh)
# Space: O(m * n)
# bi-bfs solution
class Solution3(object):
    def minimumEffortPath(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def check(heights, x):  # bi-bfs
            lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]
            left, right = {(0, 0)}, {(len(heights)-1, len(heights[0])-1)}
            while left:
                for r, c in left:
                    lookup[r][c] = True
                new_left = set()
                for r, c in left:
                    if (r, c) in right: 
                        return True
                    for dr, dc in directions:
                        nr, nc = r+dr, c+dc
                        if not (0 &lt;= nr &lt; len(heights) and
                                0 &lt;= nc &lt; len(heights[0]) and
                                abs(heights[nr][nc]-heights[r][c]) &lt;= x and
                                not lookup[nr][nc]):
                            continue
                        new_left.add((nr, nc))
                left = new_left
                if len(left) &gt; len(right): 
                    left, right = right, left
            return False            
        

        left, right = 0, 10**6
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(heights, mid):
                right = mid-1
            else:
                left = mid+1
        return left


# Time:  O(m * n * logh)
# Space: O(m * n)
import collections


# bfs solution
class Solution4(object):
    def minimumEffortPath(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def check(heights, x):
            lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]
            q = collections.deque([(0, 0)])
            while q:
                r, c = q.popleft()
                if (r, c) == (len(heights)-1, len(heights[0])-1):
                    return True
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 &lt;= nr &lt; len(heights) and
                                0 &lt;= nc &lt; len(heights[0]) and
                                abs(heights[nr][nc]-heights[r][c]) &lt;= x and
                                not lookup[nr][nc]):
                            continue
                    lookup[nr][nc] = True
                    q.append((nr, nc))
            return False            
        
        left, right = 0, 10**6
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(heights, mid):
                right = mid-1
            else:
                left = mid+1
        return left


# Time:  O(m * n * logh)
# Space: O(m * n)
# dfs solution
class Solution5(object):
    def minimumEffortPath(self, heights):
        """
        :type heights: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def check(heights, x):
            lookup = [[False]*len(heights[0]) for _ in xrange(len(heights))]
            stk = [(0, 0)]
            while stk:
                r, c = stk.pop()
                if (r, c) == (len(heights)-1, len(heights[0])-1):
                    return True
                for dr, dc in directions:
                    nr, nc = r+dr, c+dc
                    if not (0 &lt;= nr &lt; len(heights) and
                                0 &lt;= nc &lt; len(heights[0]) and
                                abs(heights[nr][nc]-heights[r][c]) &lt;= x and
                                not lookup[nr][nc]):
                            continue
                    lookup[nr][nc] = True
                    stk.append((nr, nc))
            return False            
        
        left, right = 0, 10**6
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(heights, mid):
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Graph - 1697 - https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/
Time: O(nlogn + mlogm)  Space: O(n)   Hard
.Python/checking-existence-of-edge-length-limited-paths.py


```python
# Time:  O(nlogn + mlogm + n * (n)) = O(nlogn + mlogm)
# Space: O(n)

class UnionFind(object):  # Time: O(n * (n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        if self.rank[x_root] &lt; self.rank[y_root]:  # union by rank
            self.set[x_root] = y_root
        elif self.rank[x_root] &gt; self.rank[y_root]:
            self.set[y_root] = x_root
        else:
            self.set[y_root] = x_root
            self.rank[x_root] += 1
        return True


class Solution(object):
    def distanceLimitedPathsExist(self, n, edgeList, queries):
        """
        :type n: int
        :type edgeList: List[List[int]]
        :type queries: List[List[int]]
        :rtype: List[bool]
        """
        for i, q in enumerate(queries):
            q.append(i)
        edgeList.sort(key=lambda x: x[2])
        queries.sort(key=lambda x: x[2])
        
        union_find = UnionFind(n)
        result = [False]*len(queries)
        curr = 0
        for u, v, w, i in queries: 
            while curr &lt; len(edgeList) and edgeList[curr][2] &lt; w: 
                union_find.union_set(edgeList[curr][0], edgeList[curr][1])
                curr += 1
            result[i] = union_find.find_set(u) == union_find.find_set(v)
        return result

```



----------------------------------------------------------------------------------------

### Graph - 1719 - https://leetcode.com/problems/number-of-ways-to-reconstruct-a-tree/
Time: O(nlogn)  Space: O(n)   Hard
.Python/number-of-ways-to-reconstruct-a-tree.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class Solution(object):
    def checkWays(self, pairs):
        """
        :type pairs: List[List[int]]
        :rtype: int
        """
        adj = collections.defaultdict(set)
        for x, y in pairs:
            adj[x].add(y)
            adj[y].add(x)
        n, mul = len(adj), False
        lookup = set()
        for node in sorted(adj.iterkeys(), key=lambda i: len(adj[i]), reverse=True):
            lookup.add(node)
            parent = 0
            for x in adj[node]:
                if x not in lookup:
                    continue
                if parent == 0 or len(adj[x]) &lt; len(adj[parent]):
                    parent = x
            if parent:
                if any(True for x in adj[node] if x != parent and x not in adj[parent]):
                    return 0
                mul |= len(adj[parent]) == len(adj[node])
            elif len(adj[node]) != n-1:
                return 0
        return 1 + mul

```



----------------------------------------------------------------------------------------

### Graph - 1724 - https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths-ii/
Time: ctor: O(nlogn + mlogm)query: O(logn)  Space: O(nlogn + m)   Hard
.Python/checking-existence-of-edge-length-limited-paths-ii.py


```python
# Time:  ctor:  O(mlogm + m * (n) + nlogn) ~= O(mlogm + nlogn)
#        query: O((n) + logn) ~= O(logn)
# Space: O(nlogn + m)

from functools import partial

# Template:
# https://github.com/kamyu104/GoogleKickStart-2020/blob/main/Round%20D/locked_doors.py
class TreeInfos(object):  # Time: O(NlogN), Space: O(NlogN), N is the number of nodes
    def __init__(self, children):
        def preprocess(curr, parent, weight):
            if parent != -1:
                W[curr].append(weight)
                P[curr].append(parent)  # ancestors of the node i
            i = 0
            while i &lt; len(P[curr]) and i &lt; len(P[P[curr][i]]):
                W[curr].append(max(W[curr][i], W[P[curr][i]][i]))
                P[curr].append(P[P[curr][i]][i])
                i += 1
            C[0] += 1
            L[curr] = C[0]  # the subtree of the node i is represented by traversal index L[i]..R[i]

        def divide(curr, parent, weight):
            stk.append(partial(postprocess, curr))
            for child, w in reversed(children[curr]):
                if child == parent:
                    continue
                stk.append(partial(divide, child, curr, w))
            stk.append(partial(preprocess, curr, parent, weight))

        def postprocess(curr):
            R[curr] = C[0]  # the subtree of the node i is represented by traversal index L[i]..R[i]

        N = len(children)
        L, R, P, W, C = [0]*N, [0]*N, [[] for _ in xrange(N)], [[] for _ in xrange(N)], [-1]
        for i in xrange(N):
            if L[i]:
                continue
            stk = []
            stk.append(partial(divide, i, -1, 0))
            while stk:
                stk.pop()()
        self.L, self.R, self.P, self.W = L, R, P, W
    
    def is_ancestor(self, a, b):  # includes itself
        return self.L[a] &lt;= self.L[b] &lt;= self.R[b] &lt;= self.R[a]
    
    def max_weights(self, a, b):
        def binary_lift(a, b):
            w = 0
            for i in reversed(xrange(len(self.P[a]))):  # O(logN)
                if i &lt; len(self.P[a]) and not self.is_ancestor(self.P[a][i], b):
                    w = max(w, self.W[a][i])
                    a = self.P[a][i]
            return max(w, self.W[a][0])

        w = 0
        if not self.is_ancestor(a, b):
            w = max(w, binary_lift(a, b))
        if not self.is_ancestor(b, a):
            w = max(w, binary_lift(b, a))
        return w

    
class UnionFind(object):  # Time: O(n * (n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x_root, y_root = map(self.find_set, (x, y))
        if x_root == y_root:
            return False
        if self.rank[x_root] &lt; self.rank[y_root]:  # union by rank
            self.set[x_root] = y_root
        elif self.rank[x_root] &gt; self.rank[y_root]:
            self.set[y_root] = x_root
        else:
            self.set[y_root] = x_root
            self.rank[x_root] += 1
        return True


class DistanceLimitedPathsExist(object):

    def __init__(self, n, edgeList):
        """
        :type n: int
        :type edgeList: List[List[int]]
        """
        edgeList.sort(key = lambda x:x[2])
        self.__uf = UnionFind(n)
        self.__adj = [[] for _ in xrange(n)]
        for index, (i, j, weight) in enumerate(edgeList):
            if not self.__uf.union_set(i, j):
                continue
            self.__adj[i].append((j, weight))
            self.__adj[j].append((i, weight))
        self.__tree_infos = TreeInfos(self.__adj)

    def query(self, p, q, limit):
        """
        :type p: int
        :type q: int
        :type limit: int
        :rtype: bool
        """
        if self.__uf.find_set(p) != self.__uf.find_set(q):
            return False
        return self.__tree_infos.max_weights(p, q) &lt; limit


# Time:  ctor:  O(mlogm + m * (n) * logm) ~= O(mlogm)
#        query: O(logm + (n) * logm) ~= O(logm)
# Space: O(n + m * (n) + m) ~= O(n + m)
import collections
import sortedcontainers
import bisect


class SnapshotArray(object):

    def __init__(self, length):
        """
        :type length: int
        """
        self.__snaps = collections.defaultdict(lambda:sortedcontainers.SortedList([(0, 0)]))

    def set(self, index, val, snap_id):
        """
        :type index: int
        :type val: int
        :rtype: None
        """
        i = self.__snaps[index].bisect_left((snap_id, float("-inf")))
        if i != len(self.__snaps[index]) and self.__snaps[index][i][0] == snap_id:
            self.__snaps[index].remove(self.__snaps[index][i])
        self.__snaps[index].add((snap_id, val))

    def get(self, index, snap_id):
        """
        :type index: int
        :type snap_id: int
        :rtype: int
        """
        i = self.__snaps[index].bisect_left((snap_id+1, float("-inf"))) - 1
        return self.__snaps[index][i][1]   
 

class VersionedUnionFind(object):  # Time: O(n * (n)), Space: O(n)

    def __init__(self, n):
        self.snap_id = 0
        self.set = SnapshotArray(n)
        for i in xrange(n):
            self.set.set(i, i, self.snap_id)
        self.rank = SnapshotArray(n)

    def find_set(self, x, snap_id):
        stk = []
        while self.set.get(x, snap_id) != x:  # path compression
            stk.append(x)
            x = self.set.get(x, snap_id)
        while stk:
            self.set.set(stk.pop(), x, snap_id)
        return x

    def union_set(self, x, y):
        x_root = self.find_set(x, self.snap_id)
        y_root = self.find_set(y, self.snap_id)
        if x_root == y_root:
            return False
        if self.rank.get(x_root, self.snap_id) &lt; self.rank.get(y_root, self.snap_id):  # union by rank
            self.set.set(x_root, y_root, self.snap_id)
        elif self.rank.get(x_root, self.snap_id) &gt; self.rank.get(y_root, self.snap_id):
            self.set.set(y_root, x_root, self.snap_id)
        else:
            self.set.set(y_root, x_root, self.snap_id)
            self.rank.set(x_root, self.rank.get(x_root, self.snap_id)+1, self.snap_id)
        return True

    def snap(self):
        self.snap_id += 1


class DistanceLimitedPathsExist2(object):

    def __init__(self, n, edgeList):
        """
        :type n: int
        :type edgeList: List[List[int]]
        """
        edgeList.sort(key = lambda x:x[2])
        self.__uf = VersionedUnionFind(n)
        self.__weights = []
        for index, (i, j, weight) in enumerate(edgeList):
            if not self.__uf.union_set(i, j):
                continue
            self.__uf.snap()
            self.__weights.append(weight)  

    def query(self, p, q, limit):
        """
        :type p: int
        :type q: int
        :type limit: int
        :rtype: bool
        """
        snap_id = bisect.bisect_left(self.__weights, limit)-1
        if snap_id == -1:
            return False
        return self.__uf.find_set(p, snap_id) == self.__uf.find_set(q, snap_id)

```



----------------------------------------------------------------------------------------

### Graph - 1743 - https://leetcode.com/problems/restore-the-array-from-adjacent-pairs/
Time: O(n)  Space: O(n)   Medium
.Python/restore-the-array-from-adjacent-pairs.py


```python
# Time:  O(n)
# Space: O(n)

import collections


class Solution(object):
    def restoreArray(self, adjacentPairs):
        """
        :type adjacentPairs: List[List[int]]
        :rtype: List[int]
        """
        adj = collections.defaultdict(list)
        for u, v in adjacentPairs: 
            adj[u].append(v)
            adj[v].append(u)
        result = next([x, adj[x][0]] for x in adj if len(adj[x]) == 1)
        while len(result) != len(adjacentPairs)+1:
            result.append(adj[result[-1]][adj[result[-1]][0] == result[-2]])
        return result

```



----------------------------------------------------------------------------------------

### Graph - 1761 - https://leetcode.com/problems/minimum-degree-of-a-connected-trio-in-a-graph/
Time: O(n^3)  Space: O(n^2)   Hard
.Python/minimum-degree-of-a-connected-trio-in-a-graph.py


```python
# Time:  O(n^3)
# Space: O(n^2)

class Solution(object):
    def minTrioDegree(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        adj = [set() for _ in xrange(n+1)]
        degree = [0]*(n+1)
        for u, v in edges:
            adj[min(u, v)].add(max(u, v))
            degree[u] += 1
            degree[v] += 1
        result = float("inf")
        for u in xrange(1, n+1):
            for v in adj[u]:
                for w in adj[u]:
                    if v &lt; w and w in adj[v]:
                        result = min(result, degree[u]+degree[v]+degree[w] - 6)
        return result if result != float("inf") else -1

```



----------------------------------------------------------------------------------------

### Graph - 1778 - https://leetcode.com/problems/shortest-path-in-a-hidden-grid/
Time: O(m * n)  Space: O(m * n)   Medium
.Python/shortest-path-in-a-hidden-grid.py


```python
# Time:  O(m * n)
# Space: O(m * n)

class GridMaster(object):
    def canMove(self, direction):
        pass

    def move(self, direction):
        pass

    def isTarget(self):
        pass


import collections


class Solution(object):
    def findShortestPath(self, master):
        """
        :type master: GridMaster
        :rtype: int
        """
        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}
        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}

        def dfs(pos, target, master, lookup, adj):
            if target[0] is None and master.isTarget():
                target[0] = pos
            lookup.add(pos)
            for d, (di, dj) in directions.iteritems():
                if not master.canMove(d):
                    continue
                nei = (pos[0]+di, pos[1]+dj)
                adj[pos].add(nei)
                adj[nei].add(pos)
                if nei in lookup:
                    continue
                master.move(d)
                dfs(nei, target, master, lookup, adj)
                master.move(rollback[d])
                        
        def bi_bfs(adj, start, target):
            left, right = {start}, {target}
            lookup = set()
            steps = 0
            while left:
                for pos in left:
                    lookup.add(pos)
                new_left = set()
                for pos in left:
                    if pos in right: 
                        return steps
                    for nei in adj[pos]:
                        if nei in lookup:
                            continue
                        new_left.add(nei)
                left = new_left
                steps += 1
                if len(left) &gt; len(right): 
                    left, right = right, left
            return -1         
        
        start = (0, 0)
        target = [None]
        adj = collections.defaultdict(set)
        dfs(start, target, master, set(), adj)
        if not target[0]:
            return -1
        return bi_bfs(adj, start, target[0])


# Time:  O(m * n)
# Space: O(m * n)
class Solution2(object):
    def findShortestPath(self, master):
        """
        :type master: GridMaster
        :rtype: int
        """
        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}
        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}

        def dfs(pos, target, master, lookup, adj):
            if target[0] is None and master.isTarget():
                target[0] = pos
            lookup.add(pos)
            for d, (di, dj) in directions.iteritems():
                if not master.canMove(d):
                    continue
                nei = (pos[0]+di, pos[1]+dj)
                adj[pos].add(nei)
                adj[nei].add(pos)
                if nei in lookup:
                    continue
                master.move(d)
                dfs(nei, target, master, lookup, adj)
                master.move(rollback[d])
                        
        def bfs(adj, start, target):
            q = [start]
            lookup = set(q)
            steps = 0
            while q:
                new_q = []
                for pos in q:
                    if pos == target:
                        return steps
                    for nei in adj[pos]:
                        if nei in lookup:
                            continue
                        lookup.add(nei)
                        new_q.append(nei)
                q = new_q
                steps += 1
            return -1  
        
        start = (0, 0)
        target = [None]
        adj = collections.defaultdict(set)
        dfs(start, target, master, set(), adj)
        if not target[0]:
            return -1
        return bfs(adj, start, target[0])

```



----------------------------------------------------------------------------------------

### Graph - 1782 - https://leetcode.com/problems/count-pairs-of-nodes/
Time: O(n + e + q)  Space: O(n + e)   Hard
.Python/count-pairs-of-nodes.py


```python
# Time:  O(n + e + q)
# Space: O(n + e)

import collections
import itertools


# pure counting solution
class Solution(object):
    def countPairs(self, n, edges, queries):
        """
        :type n: int
        :type edges: List[List[int]]
        :type queries: List[int]
        :rtype: List[int]
        """
        degree = [0]*(n+1)
        shared = collections.Counter((min(n1, n2), max(n1, n2)) for n1, n2 in edges)
        for u, v in edges:
            degree[u] += 1
            degree[v] += 1
        cnt = [0]*(2*(max(degree[1:])+1))
        count = collections.Counter(degree[1:])
        for i, j in itertools.product(count, count):  # Time: O(d^2) = O(e)
            if i &lt; j:
                cnt[i+j] += count[i]*count[j]
            elif i == j:
                cnt[i+j] += count[i]*(count[i]-1)//2
        for (i, j), shared_degree in shared.iteritems():
            cnt[degree[i]+degree[j]] -= 1
            cnt[degree[i]+degree[j]-shared_degree] += 1
        for i in reversed(xrange(len(cnt)-1)):  # accumulate
            cnt[i] += cnt[i+1]
        return [cnt[q+1] if q+1 &lt; len(cnt) else 0 for q in queries]


# Time:  O(nlogn + q * (n + e))
# Space: O(n + e)
import collections


# two pointers solution
class Solution2(object):
    def countPairs(self, n, edges, queries):
        """
        :type n: int
        :type edges: List[List[int]]
        :type queries: List[int]
        :rtype: List[int]
        """
        degree = [0]*(n+1)
        shared = collections.Counter((min(n1, n2), max(n1, n2)) for n1, n2 in edges)
        for n1, n2 in edges:
            degree[n1] += 1
            degree[n2] += 1
        sorted_degree = sorted(degree)
        result = []
        for k, q in enumerate(queries):
            left, right = 1, n
            cnt = 0
            while left &lt; right:
                if q &lt; sorted_degree[left]+sorted_degree[right]:
                    cnt += right-left
                    right -= 1
                else:
                    left += 1
            for (i, j), shared_degree in shared.iteritems():
                if degree[i]+degree[j]-shared_degree &lt;= q &lt; degree[i]+degree[j]:
                    cnt -= 1
            result.append(cnt)
        return result

```



----------------------------------------------------------------------------------------

### Graph - 1786 - https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/
Time: O(|E| * log|V|)  Space: O(|E|)   Medium
.Python/number-of-restricted-paths-from-first-to-last-node.py


```python
# Time:  O(|E| * log|V|)
# Space: O(|E| + |V|)

import heapq


class Solution(object):
    def countRestrictedPaths(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: int
        """
        MOD = 10**9+7
        adj = [[] for _ in xrange(n)]
        for u, v, w in edges:
            adj[u-1].append((v-1, w))
            adj[v-1].append((u-1, w))
        dist = [float("inf")]*n
        dp = [0]*n
        dist[n-1] = 0
        dp[n-1] = 1
        min_heap = [(0, n-1)]
        while min_heap:
            w, u = heapq.heappop(min_heap)
            if w &gt; dist[u]:
                continue
            for v, d in adj[u]:
                if w+d &lt; dist[v]:
                    dist[v] = w+d
                    heapq.heappush(min_heap, (dist[v], v))
                elif w &gt; dist[v]:
                    dp[u] = (dp[u]+dp[v])%MOD
            if u == 0:  # early return
                break
        return dp[0]

```



----------------------------------------------------------------------------------------

### Graph - 1791 - https://leetcode.com/problems/find-center-of-star-graph/
Time: O(n)  Space: O(n)   Medium
.Python/find-center-of-star-graph.py


```python
# Time:  O(1)
# Space: O(1)

class Solution(object):
    def findCenter(self, edges):
        """
        :type edges: List[List[int]]
        :rtype: int
        """
        return edges[0][edges[0][1] in edges[1]]

```



----------------------------------------------------------------------------------------

### Graph - 1810 - https://leetcode.com/problems/minimum-path-cost-in-a-hidden-grid/
Time: O(m * n * log(m * n))  Space: O(m * n)   Medium
.Python/minimum-path-cost-in-a-hidden-grid.py


```python
# Time:  O(m * n * log(m * n))
# Space: O(m * n)

class GridMaster(object):
    def canMove(self, direction):
        pass

    def move(self, direction):
        pass

    def isTarget(self):
        pass


import collections
import heapq


class Solution(object):
    def findShortestPath(self, master):
        """
        :type master: GridMaster
        :rtype: int
        """
        directions = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}
        rollback = {'L': 'R', 'R': 'L', 'U': 'D', 'D': 'U'}

        def dfs(pos, target, master, lookup, adj):
            if target[0] is None and master.isTarget():
                target[0] = pos
            lookup.add(pos)
            for d, (di, dj) in directions.iteritems():
                if not master.canMove(d):
                    continue
                nei = (pos[0]+di, pos[1]+dj)
                if nei in adj[pos]:
                    continue
                adj[pos][nei] = master.move(d)
                if nei not in lookup:
                    dfs(nei, target, master, lookup, adj)
                adj[nei][pos] = master.move(rollback[d])
                        
        def dijkstra(adj, start, target):
            dist = {start:0}
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if dist[u] &lt; curr:
                    continue
                for v, w in adj[u].iteritems():
                    if v in dist and dist[v] &lt;= curr+w:
                        continue
                    dist[v] = curr+w
                    heapq.heappush(min_heap, (curr+w, v))
            return dist[target] if target in dist else -1 
        
        start = (0, 0)
        target = [None]
        adj = collections.defaultdict(dict)
        dfs(start, target, master, set(), adj)
        if not target[0]:
            return -1
        return dijkstra(adj, start, target[0])

```



----------------------------------------------------------------------------------------

### Graph - 1820 - https://leetcode.com/problems/maximum-number-of-accepted-invitations/
Time: O(m * n * sqrt(m + n))  Space: O(m + n)   Medium
.Python/maximum-number-of-accepted-invitations.py


```python
# Time:  O(m * n * sqrt(m + n))
# Space: O(m * n)

from functools import partial

# Time:  O(E * sqrt(V))
# Space: O(V)
# Source code from http://code.activestate.com/recipes/123641-hopcroft-karp-bipartite-matching/
# Hopcroft-Karp bipartite max-cardinality matching and max independent set
# David Eppstein, UC Irvine, 27 Apr 2002
def bipartiteMatch(graph):
    '''Find maximum cardinality matching of a bipartite graph (U,V,E).
    The input format is a dictionary mapping members of U to a list
    of their neighbors in V.  The output is a triple (M,A,B) where M is a
    dictionary mapping members of V to their matches in U, A is the part
    of the maximum independent set in U, and B is the part of the MIS in V.
    The same object may occur in both U and V, and is treated as two
    distinct vertices if this happens.'''
    
    # initialize greedy matching (redundant, but faster than full search)
    matching = {}
    for u in graph:
        for v in graph[u]:
            if v not in matching:
                matching[v] = u
                break
    
    while 1:
        # structure residual graph into layers
        # pred[u] gives the neighbor in the previous layer for u in U
        # preds[v] gives a list of neighbors in the previous layer for v in V
        # unmatched gives a list of unmatched vertices in final layer of V,
        # and is also used as a flag value for pred[u] when u is in the first layer
        preds = {}
        unmatched = []
        pred = dict([(u,unmatched) for u in graph])
        for v in matching:
            del pred[matching[v]]
        layer = list(pred)
        
        # repeatedly extend layering structure by another pair of layers
        while layer and not unmatched:
            newLayer = {}
            for u in layer:
                for v in graph[u]:
                    if v not in preds:
                        newLayer.setdefault(v,[]).append(u)
            layer = []
            for v in newLayer:
                preds[v] = newLayer[v]
                if v in matching:
                    layer.append(matching[v])
                    pred[matching[v]] = v
                else:
                    unmatched.append(v)
        
        # did we finish layering without finding any alternating paths?
        if not unmatched:
            unlayered = {}
            for u in graph:
                for v in graph[u]:
                    if v not in preds:
                        unlayered[v] = None
            return (matching,list(pred),list(unlayered))

        # recursively search backward through layers to find alternating paths
        # recursion returns true if found path, false otherwise
        def recurse(v):
            if v in preds:
                L = preds[v]
                del preds[v]
                for u in L:
                    if u in pred:
                        pu = pred[u]
                        del pred[u]
                        if pu is unmatched or recurse(pu):
                            matching[v] = u
                            return 1
            return 0
        
        def recurse_iter(v):
            def divide(v):
                if v not in preds:
                    return
                L = preds[v]
                del preds[v]
                for u in L :
                    if u in pred and pred[u] is unmatched:  # early return
                        del pred[u]
                        matching[v] = u
                        ret[0] = True
                        return
                stk.append(partial(conquer, v, iter(L)))

            def conquer(v, it):
                for u in it:
                    if u not in pred:
                        continue
                    pu = pred[u]
                    del pred[u]
                    stk.append(partial(postprocess, v, u, it))
                    stk.append(partial(divide, pu))
                    return

            def postprocess(v, u, it):
                if not ret[0]:
                    stk.append(partial(conquer, v, it))
                    return
                matching[v] = u

            ret, stk = [False], []
            stk.append(partial(divide, v))
            while stk:
                stk.pop()()
            return ret[0]

        for v in unmatched: recurse_iter(v)


import collections


# Hopcroft-Karp bipartite matching
class Solution(object):
    def maximumInvitations(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        adj = collections.defaultdict(list)
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if not grid[i][j]:
                    continue
                adj[j].append(i)
        return len(bipartiteMatch(adj)[0])


# Time:  O(|V| * |E|) = O(min(m, n) * (m * n))
# Space: O(|V|) = O(min(m, n))
# Hungarian bipartite matching with less space
class Solution2(object):
    def maximumInvitations(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        def augment(grid, u, lookup, match):
            lookup.add(u)
            for v in xrange(V):
                if not get_grid(u, v) or (v in match and match[v] in lookup):
                    continue
                if v not in match or augment(grid, match[v], lookup, match):
                    match[v] = u  # greedily match
                    return True
            return False
    
        def hungarian(grid):
            match = {}
            for i in xrange(U):
                augment(grid, i, set(), match)
            return len(match)

        U, V = min(len(grid), len(grid[0])), max(len(grid), len(grid[0]))
        get_grid = (lambda x, y: grid[x][y]) if len(grid) &lt; len(grid[0]) else (lambda x, y: grid[y][x])
        return hungarian(grid)


# Time:  O(|V| * |E|) = O(min(m, n) * (m * n))
# Space: O(|E|) = O(m * n)
import collections


# Hungarian bipartite matching
class Solution3(object):
    def maximumInvitations(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        def augment(adj, u, lookup, match):
            for v in adj[u]:
                if v in lookup:
                    continue
                lookup.add(v)
                if v not in match or augment(adj, match[v], lookup, match):
                    match[v] = u  # greedily match
                    return True
            return False
    
        def hungarian(adj):
            match = {}
            for i in adj.iterkeys():
                augment(adj, i, set(), match)
            return len(match)
        
        adj = collections.defaultdict(list)
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if not grid[i][j]:
                    continue
                if len(grid) &lt; len(grid[0]):
                    adj[i].append(j)
                else:
                    adj[j].append(i)
        return hungarian(adj)

```



----------------------------------------------------------------------------------------

### Graph - 1879 - https://leetcode.com/problems/minimum-xor-sum-of-two-arrays/
Time: O(n^3)  Space: O(n^2)   Hard
.Python/minimum-xor-sum-of-two-arrays.py


```python
# Time:  O(n^3)
# Space: O(n^2)

# weighted bipartite matching solution
class Solution(object):
    def minimumXORSum(self, nums1, nums2):
        # Template translated from:
        # https://github.com/kth-competitive-programming/kactl/blob/main/content/graph/WeightedMatching.h
        def hungarian(a):  # Time: O(n^2 * m), Space: O(n + m)
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in xrange(1, n):
                p[0] = i
                j0 = 0  # add "dummy" worker 0
                dist, pre = [float("inf")]*m, [-1]*m
                done = [False]*(m+1)
                while True:  # dijkstra
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float("inf")
                    for j in xrange(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur &lt; dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] &lt; delta:
                            delta, j1 = dist[j], j
                    for j in xrange(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0:  # update alternating path
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in xrange(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans  # min cost
        
        adj = [[0]*len(nums2) for _ in xrange(len(nums1))]
        for i in xrange(len(nums1)):
            for j in xrange(len(nums2)):
                adj[i][j] = nums1[i]^nums2[j]
        return hungarian(adj)[0]


# Time:  O(n * 2^n)
# Space: O(2^n)
# dp solution
class Solution2(object):
    def minimumXORSum(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: int
        """
        dp = [(float("inf"), float("inf"))]*(2**len(nums2))
        dp[0] = (0, 0)
        for mask in xrange(len(dp)):
            bit = 1
            for i in xrange(len(nums2)):
                if (mask&amp;bit) == 0:
                    dp[mask|bit] = min(dp[mask|bit], (dp[mask][0]+(nums1[dp[mask][1]]^nums2[i]), dp[mask][1]+1))
                bit &lt;&lt;= 1
        return dp[-1][0]

```



----------------------------------------------------------------------------------------

### Graph - 1947 - https://leetcode.com/problems/maximum-compatibility-score-sum/
Time: O(m^2 * (n + m))  Space: O(m^2)   Medium
.Python/maximum-compatibility-score-sum.py


```python
# Time:  O(m^2 * (n + m))
# Space: O(m^2)

import itertools


# weighted bipartite matching solution
class Solution(object):
    def maxCompatibilitySum(self, students, mentors):
        """
        :type students: List[List[int]]
        :type mentors: List[List[int]]
        :rtype: int
        """
        # Template translated from:
        # https://github.com/kth-competitive-programming/kactl/blob/main/content/graph/WeightedMatching.h
        def hungarian(a):  # Time: O(n^2 * m), Space: O(n + m)
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in xrange(1, n):
                p[0] = i
                j0 = 0  # add "dummy" worker 0
                dist, pre = [float("inf")]*m, [-1]*m
                done = [False]*(m+1)
                while True:  # dijkstra
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float("inf")
                    for j in xrange(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur &lt; dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] &lt; delta:
                            delta, j1 = dist[j], j
                    for j in xrange(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0:  # update alternating path
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in xrange(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans  # min cost

        def score(s, m):
            return sum(int(a == b) for a, b in itertools.izip(s, m))

        return -hungarian([[-score(s, m) for m in mentors] for s in students])[0]


# Time:  O(m * (n + 2^m))
# Space: O(2^m)
# dp solution
class Solution2(object):
    def maxCompatibilitySum(self, students, mentors):
        """
        :type students: List[List[int]]
        :type mentors: List[List[int]]
        :rtype: int
        """
        def popcount(n):  # Time: O(logn) ~= O(1) if n is a 32-bit number
            result = 0
            while n:
                n &amp;= n-1
                result += 1
            return result

        def masks(vvi):
            result = []
            for vi in vvi:
                mask, bit = 0, 1
                for i in xrange(len(vi)):
                    if vi[i]:
                        mask |= bit
                    bit &lt;&lt;= 1
                result.append(mask)
            return result

        nums1, nums2 = masks(students), masks(mentors)
        dp = [(0, 0)]*(2**len(nums2))
        for mask in xrange(len(dp)):
            bit = 1
            for i in xrange(len(nums2)):
                if (mask&amp;bit) == 0:
                    dp[mask|bit] = max(dp[mask|bit], (dp[mask][0]+(len(students[0])-popcount(nums1[dp[mask][1]]^nums2[i])), dp[mask][1]+1))
                bit &lt;&lt;= 1
        return dp[-1][0]

```



----------------------------------------------------------------------------------------

### Graph - 1971 - https://leetcode.com/problems/find-if-path-exists-in-graph/
Time: O(|V| + |E|)  Space: O(|V| + |E|)   Easy
.Python/find-if-path-exists-in-graph.py


```python
# Time:  O(|V| + |E|)
# Space: O(|V| + |E|)

import collections


# bi-bfs solution
class Solution(object):
    def validPath(self, n, edges, start, end):
        """
        :type n: int
        :type edges: List[List[int]]
        :type start: int
        :type end: int
        :rtype: bool
        """
        def bi_bfs(adj, start, target):
            left, right = {start}, {target}
            lookup = set()
            steps = 0
            while left:
                for pos in left:
                    lookup.add(pos)
                new_left = set()
                for pos in left:
                    if pos in right: 
                        return steps
                    for nei in adj[pos]:
                        if nei in lookup:
                            continue
                        new_left.add(nei)
                left = new_left
                steps += 1
                if len(left) &gt; len(right): 
                    left, right = right, left
            return -1

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return bi_bfs(adj, start, end) &gt;= 0


# Time:  O(|V| + |E|)
# Space: O(|V| + |E|)
# bfs solution
class Solution2(object):
    def validPath(self, n, edges, start, end):
        """
        :type n: int
        :type edges: List[List[int]]
        :type start: int
        :type end: int
        :rtype: bool
        """
        def bfs(adj, start, target):
            q = [start]
            lookup = set(q)
            steps = 0
            while q:
                new_q = []
                for pos in q:
                    if pos == target:
                        return steps
                    for nei in adj[pos]:
                        if nei in lookup:
                            continue
                        lookup.add(nei)
                        new_q.append(nei)
                q = new_q
                steps += 1
            return -1  

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return bfs(adj, start, end) &gt;= 0


# Time:  O(|V| + |E|)
# Space: O(|V| + |E|)
# dfs solution
class Solution3(object):
    def validPath(self, n, edges, start, end):
        """
        :type n: int
        :type edges: List[List[int]]
        :type start: int
        :type end: int
        :rtype: bool
        """
        def dfs(adj, start, target):
            stk = [start]
            lookup = set(stk)
            while stk:
                pos = stk.pop()
                if pos == target:
                    return True
                for nei in reversed(adj[pos]):
                    if nei in lookup:
                        continue
                    lookup.add(nei)
                    stk.append(nei)
            return False 

        adj = collections.defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return dfs(adj, start, end)

```



----------------------------------------------------------------------------------------

### Graph - 1976 - https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/
Time: O(|E| * log|V|)  Space: O(|E|)   Medium
.Python/number-of-ways-to-arrive-at-destination.py


```python
# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)
# Space: O(|E| + |V|) = O(|E|)

import heapq


class Solution(object):
    def countPaths(self, n, roads):
        """
        :type n: int
        :type roads: List[List[int]]
        :rtype: int
        """
        MOD = 10**9+7

        def dijkstra(adj, start, target):
            best = collections.defaultdict(lambda:float("inf"))
            best[start] = 0
            min_heap = [(0, start)]
            dp = [0]*(len(adj))  # modified, add dp to keep number of ways
            dp[0] = 1
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if best[u] &lt; curr:
                    continue
                if u == target:  # modified, early return
                    break
                for v, w in adj[u]:                
                    if v in best and best[v] &lt;= curr+w:
                        if best[v] == curr+w:  # modified, update number of ways in this minimal time
                            dp[v] = (dp[v]+dp[u])%MOD
                        continue
                    dp[v] = dp[u]  # modified, init number of ways in this minimal time
                    best[v] = curr+w
                    heapq.heappush(min_heap, (curr+w, v))
            return dp[target]

        adj = [[] for i in xrange(n)]
        for u, v, w in roads:
            adj[u].append((v, w))
            adj[v].append((u, w))
        return dijkstra(adj, 0, n-1)

```



----------------------------------------------------------------------------------------

### Graph - 2076 - https://leetcode.com/problems/process-restricted-friend-requests/
Time: O(n * r)  Space: O(n)   Hard
.Python/process-restricted-friend-requests.py


```python
# Time:  O(n * (alpha(n) + r)) = O(n * r)
# Space: O(n)

class UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] &gt; self.rank[y]:  # union by rank
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True


class Solution(object):
    def friendRequests(self, n, restrictions, requests):
        """
        :type n: int
        :type restrictions: List[List[int]]
        :type requests: List[List[int]]
        :rtype: List[bool]
        """
        result = []
        uf = UnionFind(n)
        for u, v in requests:
            pu, pv = uf.find_set(u), uf.find_set(v)
            ok = True
            for x, y in restrictions:
                px, py = uf.find_set(x), uf.find_set(y)
                if {px, py} == {pu, pv}:
                    ok = False
                    break
            result.append(ok)
            if ok:
                uf.union_set(u, v) 
        return result

```



----------------------------------------------------------------------------------------

### Graph - 2077 - https://leetcode.com/problems/paths-in-maze-that-lead-to-same-room/
Time: O(|V|^3)  Space: O(|E|)   Medium
.Python/paths-in-maze-that-lead-to-same-room.py


```python
# Time:  O(|V|^3)
# Space: O(|E|)

class Solution(object):
    def numberOfPaths(self, n, corridors):
        """
        :type n: int
        :type corridors: List[List[int]]
        :rtype: int
        """
        adj = [set() for _ in xrange(n)]
        for u, v in corridors:
            adj[min(u, v)-1].add(max(u, v)-1)
        return sum(k in adj[i] for i in xrange(n) for j in adj[i] for k in adj[j])

```



----------------------------------------------------------------------------------------

### Graph - 2092 - https://leetcode.com/problems/find-all-people-with-secret/
Time: O(nlogn)  Space: O(nlogn)   Hard
.Python/find-all-people-with-secret.py


```python
# Time:  O(nlogn)
# Space: O(n)

import collections


class Solution(object):
    def findAllPeople(self, n, meetings, firstPerson):
        """
        :type n: int
        :type meetings: List[List[int]]
        :type firstPerson: int
        :rtype: List[int]
        """
        meetings.sort(key=lambda x: x[2])
        result = {0, firstPerson}
        adj = collections.defaultdict(list)
        for i, (x, y, _) in enumerate(meetings):
            adj[x].append(y)
            adj[y].append(x)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            q = [i for i in adj.iterkeys() if i in result]
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v in result:
                            continue
                        result.add(v)
                        new_q.append(v)
                q = new_q
            adj = collections.defaultdict(list)
        return list(result)


# Time:  O(nlogn)
# Space: O(n)
import collections


class Solution2(object):
    def findAllPeople(self, n, meetings, firstPerson):
        """
        :type n: int
        :type meetings: List[List[int]]
        :type firstPerson: int
        :rtype: List[int]
        """
        meetings.sort(key=lambda x: x[2])
        result = {0, firstPerson}
        adj = collections.defaultdict(list)
        for i, (x, y, _) in enumerate(meetings):
            adj[x].append(y)
            adj[y].append(x)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            stk = [i for i in adj.iterkeys() if i in result]
            while stk:
                u = stk.pop()
                for v in adj[u]:
                    if v in result:
                        continue
                    result.add(v)
                    stk.append(v)
            adj = collections.defaultdict(list)
        return list(result)


# Time:  O(nlogn)
# Space: O(n)
class UnionFind(object):  # Time: O(n * alpha(n)), Space: O(n)
    def __init__(self, n):
        self.set = range(n)
        self.rank = [0]*n

    def find_set(self, x):
        stk = []
        while self.set[x] != x:  # path compression
            stk.append(x)
            x = self.set[x]
        while stk:
            self.set[stk.pop()] = x
        return x

    def union_set(self, x, y):
        x, y = self.find_set(x), self.find_set(y)
        if x == y:
            return False
        if self.rank[x] &gt; self.rank[y]:  # union by rank
            x, y = y, x
        self.set[x] = self.set[y]
        if self.rank[x] == self.rank[y]:
            self.rank[y] += 1
        return True

    def reset(self, x):
        self.set[x] = x
        self.rank[x] = 0


class Solution3(object):
    def findAllPeople(self, n, meetings, firstPerson):
        """
        :type n: int
        :type meetings: List[List[int]]
        :type firstPerson: int
        :rtype: List[int]
        """
        meetings.sort(key=lambda x: x[2])
        uf = UnionFind(n)
        uf.union_set(0, firstPerson)
        group = set()
        for i, (x, y, _) in enumerate(meetings):
            group.add(x)
            group.add(y)
            uf.union_set(x, y)
            if i+1 != len(meetings) and meetings[i+1][2] == meetings[i][2]:
                continue
            while group:
                x = group.pop()
                if uf.find_set(x) != uf.find_set(0):
                    uf.reset(x)
        return [i for i in xrange(n) if uf.find_set(i) == uf.find_set(0)]

```



----------------------------------------------------------------------------------------

### Graph - 2093 - https://leetcode.com/problems/minimum-cost-to-reach-city-with-discounts/
Time: O(|E| * log|V|)  Space: O(|V| + |E|)   Medium
.Python/minimum-cost-to-reach-city-with-discounts.py


```python
# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|) by using binary heap,
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)
# Space: O(|E| + |V|) = O(|E|)

import collections
import heapq


class Solution(object):
    def minimumCost(self, n, highways, discounts):
        """
        :type n: int
        :type highways: List[List[int]]
        :type discounts: int
        :rtype: int
        """
        adj = [[] for _ in xrange(n)]
        for u, v, w in highways:
            adj[u].append((v, w))
            adj[v].append((u, w))
        src, dst = 0, n-1
        best = collections.defaultdict(lambda: collections.defaultdict(lambda: float("inf")))
        best[src][discounts] = 0
        min_heap = [(0, src, discounts)]
        while min_heap:
            result, u, k = heapq.heappop(min_heap)
            if best[u][k] &lt; result:
                continue
            if u == dst:
                return result
            for v, w in adj[u]:
                if result+w &lt; best[v][k]:
                    best[v][k] = result+w                    
                    heapq.heappush(min_heap, (result+w, v, k))
                if k &gt; 0 and result+w//2 &lt; best[v][k-1]:
                    best[v][k-1] = result+w//2                   
                    heapq.heappush(min_heap, (result+w//2, v, k-1))
        return -1

```



----------------------------------------------------------------------------------------

### Graph - 2097 - https://leetcode.com/problems/valid-arrangement-of-pairs/
Time: O(|V| + |E|)  Space: O(|V| + |E|)   Hard
.Python/valid-arrangement-of-pairs.py


```python
# Time:  O(|V| + |E|)
# Space: O(|V| + |E|)

import collections


# Hierholzer Algorithm
class Solution(object):
    def validArrangement(self, pairs):
        """
        :type pairs: List[List[int]]
        :rtype: List[List[int]]
        """
        adj = collections.defaultdict(list)
        degree = collections.defaultdict(int)
        for u, v in pairs: 
            adj[u].append(v)
            degree[u] += 1
            degree[v] -= 1       
        result = []
        stk = [next((u for u, c in degree.iteritems() if c == 1), next(degree.iterkeys()))]
        while stk:
            while adj[stk[-1]]: 
                stk.append(adj[stk[-1]].pop())
            result.append(stk.pop())
        result.reverse()
        return [[result[i], result[i+1]] for i in xrange(len(result)-1)]

```



----------------------------------------------------------------------------------------

### Graph - 2123 - https://leetcode.com/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/
Time: O(m * n * sqrt(m * n))  Space: O(m + n)   Hard
.Python/minimum-operations-to-remove-adjacent-ones-in-matrix.py


```python
# Time:  O(E * sqrt(V)) = O(m * n * sqrt(m * n))
# Space: O(V) = O(m * n)

from functools import partial

# Time:  O(E * sqrt(V))
# Space: O(V)
# Source code from http://code.activestate.com/recipes/123641-hopcroft-karp-bipartite-matching/
# Hopcroft-Karp bipartite max-cardinality matching and max independent set
# David Eppstein, UC Irvine, 27 Apr 2002
def bipartiteMatch(graph):
    '''Find maximum cardinality matching of a bipartite graph (U,V,E).
    The input format is a dictionary mapping members of U to a list
    of their neighbors in V.  The output is a triple (M,A,B) where M is a
    dictionary mapping members of V to their matches in U, A is the part
    of the maximum independent set in U, and B is the part of the MIS in V.
    The same object may occur in both U and V, and is treated as two
    distinct vertices if this happens.'''
    
    # initialize greedy matching (redundant, but faster than full search)
    matching = {}
    for u in graph:
        for v in graph[u]:
            if v not in matching:
                matching[v] = u
                break
    
    while 1:
        # structure residual graph into layers
        # pred[u] gives the neighbor in the previous layer for u in U
        # preds[v] gives a list of neighbors in the previous layer for v in V
        # unmatched gives a list of unmatched vertices in final layer of V,
        # and is also used as a flag value for pred[u] when u is in the first layer
        preds = {}
        unmatched = []
        pred = dict([(u,unmatched) for u in graph])
        for v in matching:
            del pred[matching[v]]
        layer = list(pred)
        
        # repeatedly extend layering structure by another pair of layers
        while layer and not unmatched:
            newLayer = {}
            for u in layer:
                for v in graph[u]:
                    if v not in preds:
                        newLayer.setdefault(v,[]).append(u)
            layer = []
            for v in newLayer:
                preds[v] = newLayer[v]
                if v in matching:
                    layer.append(matching[v])
                    pred[matching[v]] = v
                else:
                    unmatched.append(v)
        
        # did we finish layering without finding any alternating paths?
        if not unmatched:
            unlayered = {}
            for u in graph:
                for v in graph[u]:
                    if v not in preds:
                        unlayered[v] = None
            return (matching,list(pred),list(unlayered))

        # recursively search backward through layers to find alternating paths
        # recursion returns true if found path, false otherwise
        def recurse(v):
            if v in preds:
                L = preds[v]
                del preds[v]
                for u in L:
                    if u in pred:
                        pu = pred[u]
                        del pred[u]
                        if pu is unmatched or recurse(pu):
                            matching[v] = u
                            return 1
            return 0
        
        def recurse_iter(v):
            def divide(v):
                if v not in preds:
                    return
                L = preds[v]
                del preds[v]
                for u in L :
                    if u in pred and pred[u] is unmatched:  # early return
                        del pred[u]
                        matching[v] = u
                        ret[0] = True
                        return
                stk.append(partial(conquer, v, iter(L)))

            def conquer(v, it):
                for u in it:
                    if u not in pred:
                        continue
                    pu = pred[u]
                    del pred[u]
                    stk.append(partial(postprocess, v, u, it))
                    stk.append(partial(divide, pu))
                    return

            def postprocess(v, u, it):
                if not ret[0]:
                    stk.append(partial(conquer, v, it))
                    return
                matching[v] = u

            ret, stk = [False], []
            stk.append(partial(divide, v))
            while stk:
                stk.pop()()
            return ret[0]

        for v in unmatched: recurse_iter(v)


import collections


class Solution(object):
    def minimumOperations(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        def iter_dfs(grid, i, j, lookup, adj):
            if lookup[i][j]:
                return
            lookup[i][j] = True
            stk = [(i, j, (i+j)%2)]
            while stk:
                i, j, color = stk.pop()
                for di, dj in directions:
                    ni, nj = i+di, j+dj
                    if not (0 &lt;= ni &lt; len(grid) and 0 &lt;= nj &lt; len(grid[0]) and grid[ni][nj]):
                        continue
                    if not color:
                        adj[len(grid[0])*ni+nj].append(len(grid[0])*i+j)
                    if lookup[ni][nj]:
                        continue
                    lookup[ni][nj] = True
                    stk.append((ni, nj, color^1))

        adj = collections.defaultdict(list)
        lookup = [[False]*len(grid[0]) for _ in xrange(len(grid))]
        for i in xrange(len(grid)):
            for j in xrange(len(grid[0])):
                if not grid[i][j]:
                    continue
                iter_dfs(grid, i, j, lookup, adj)
        return len(bipartiteMatch(adj)[0])

```



----------------------------------------------------------------------------------------

### Graph - 2127 - https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/
Time: O(n)  Space: O(n)   Hard
.Python/maximum-employees-to-be-invited-to-a-meeting.py


```python
# Time:  O(n)
# Space: O(n)

class Solution(object):
    def maximumInvitations(self, favorite):
        """
        :type favorite: List[int]
        :rtype: int
        """
        def find_cycles(adj):
            result = []
            lookup = [False]*len(adj)
            for u in xrange(len(adj)):
                cnt = {}
                while not lookup[u]:
                    lookup[u] = True
                    cnt[u] = len(cnt)
                    u = adj[u]
                if u in cnt:
                    result.append((u, len(cnt)-cnt[u]))
            return result

        def bfs(adj, u, exclude):
            result = 0
            q = [u]
            while q:
                result += 1
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v == exclude:
                            continue
                        new_q.append(v)
                q = new_q
            return result
            
        inv_adj = [[] for _ in xrange(len(favorite))]  
        for u, v in enumerate(favorite):
            inv_adj[v].append(u)
        cycles = find_cycles(favorite)
        return max(max([l for _, l in cycles if l &gt; 2] or [0]),
                   sum(bfs(inv_adj, u, favorite[u]) + bfs(inv_adj, favorite[u], u) for u, l in cycles if l == 2))

```



----------------------------------------------------------------------------------------

### Graph - 2172 - https://leetcode.com/problems/maximum-and-sum-of-array/
Time: O(n^3)  Space: O(n^2)   Hard
.Python/maximum-and-sum-of-array.py


```python
# Time:  O(n^3)
# Space: O(n^2)

# weighted bipartite matching solution
class Solution(object):
    def maximumANDSum(self, nums, numSlots):
        """
        :type nums: List[int]
        :type numSlots: int
        :rtype: int
        """
        # Template translated from:
        # https://github.com/kth-competitive-programming/kactl/blob/main/content/graph/WeightedMatching.h
        def hungarian(a):  # Time: O(n^2 * m), Space: O(n + m)
            if not a:
                return 0, []
            n, m = len(a)+1, len(a[0])+1
            u, v, p, ans = [0]*n, [0]*m, [0]*m, [0]*(n-1)
            for i in xrange(1, n):
                p[0] = i
                j0 = 0  # add "dummy" worker 0
                dist, pre = [float("inf")]*m, [-1]*m
                done = [False]*(m+1)
                while True:  # dijkstra
                    done[j0] = True
                    i0, j1, delta = p[j0], None, float("inf")
                    for j in xrange(1, m):
                        if done[j]:
                            continue
                        cur = a[i0-1][j-1]-u[i0]-v[j]
                        if cur &lt; dist[j]:
                            dist[j], pre[j] = cur, j0
                        if dist[j] &lt; delta:
                            delta, j1 = dist[j], j
                    for j in xrange(m):
                        if done[j]:
                            u[p[j]] += delta
                            v[j] -= delta
                        else:
                            dist[j] -= delta
                    j0 = j1
                    if not p[j0]:
                        break
                while j0:  # update alternating path
                    j1 = pre[j0]
                    p[j0], j0 = p[j1], j1
            for j in xrange(1, m):
                if p[j]:
                    ans[p[j]-1] = j-1
            return -v[0], ans  # min cost
    
        return -hungarian([[-((nums[i] if i &lt; len(nums) else 0) &amp; (1+x//2)) for x in xrange(2*numSlots)] for i in xrange(2*numSlots)])[0]


# Time:  O(n^3)
# Space: O(n^2)
from scipy.optimize import linear_sum_assignment as hungarian
import itertools


# 3rd-party weighted bipartite matching solution
class Solution2(object):
    def maximumANDSum(self, nums, numSlots):
        """
        :type nums: List[int]
        :type numSlots: int
        :rtype: int
        """
        adj = [[-((nums[i] if i &lt; len(nums) else 0) &amp; (1+x//2)) for x in xrange(2*numSlots)] for i in xrange(2*numSlots)]
        return -sum(adj[i][j] for i, j in itertools.izip(*hungarian(adj)))    


# Time:  O(n * 3^n)
# Space: O(3^n)
# bottom-up dp (hard to implement but faster)
class Solution3(object):
    def maximumANDSum(self, nums, numSlots):
        """
        :type nums: List[int]
        :type numSlots: int
        :rtype: int
        """
        def count(x):
            result = 0
            while x:
                result += x%3
                x //= 3
            return result

        dp = [0]*(3**numSlots)
        for mask in xrange(1, len(dp)):
            i = count(mask)-1
            x = nums[i] if i &lt; len(nums) else 0
            base = 1
            for slot in xrange(1, numSlots+1):
                if mask//base%3:
                    dp[mask] = max(dp[mask], (x&amp;slot)+dp[mask-base])
                base *= 3
        return dp[-1]


# Time:  O(n * 3^n)
# Space: O(3^n)
# memoization, top-down dp (easy to implement but slower)
class Solution4(object):
    def maximumANDSum(self, nums, numSlots):
        """
        :type nums: List[int]
        :type numSlots: int
        :rtype: int
        """
        def memoiztion(i, mask):  # i is metadata, which could be derived from mask, just for shorter implementation
            if lookup[mask] != -1:
                return lookup[mask]
            x = nums[i] if i &lt; len(nums) else 0
            base = 1
            for slot in xrange(1, numSlots+1):
                if mask//base%3:
                     lookup[mask] = max(lookup[mask], (x&amp;slot)+memoiztion(i-1, mask-base))
                base *= 3
            return lookup[mask]
        
        lookup = [-1]*(3**numSlots)
        lookup[0] = 0
        return memoiztion(2*numSlots-1, 3**numSlots-1)

```



----------------------------------------------------------------------------------------

### Graph - 2203 - https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/
Time: O(|E| * log|V|)  Space: O(|E|)   Hard
.Python/minimum-weighted-subgraph-with-the-required-paths.py


```python
# Time:  O((|E| + |V|) * log|V|) = O(|E| * log|V|),
#        if we can further to use Fibonacci heap, it would be O(|E| + |V| * log|V|)
# Space: O(|E| + |V|) = O(|E|)

import heapq


# dijkstra's algorithm
class Solution(object):
    def minimumWeight(self, n, edges, src1, src2, dest):
        """
        :type n: int
        :type edges: List[List[int]]
        :type src1: int
        :type src2: int
        :type dest: int
        :rtype: int
        """
        def dijkstra(adj, start):
            best = [float("inf")]*len(adj)
            best[start] = 0
            min_heap = [(0, start)]
            while min_heap:
                curr, u = heapq.heappop(min_heap)
                if best[u] &lt; curr:
                    continue
                for v, w in adj[u]:                
                    if best[v] &lt;= curr+w:
                        continue
                    best[v] = curr+w
                    heapq.heappush(min_heap, (curr+w, v))
            return best
    
        adj1, adj2 = [[[] for _ in xrange(n)] for _ in xrange(2)]
        for u, v, w in edges:
            adj1[u].append((v, w))
            adj2[v].append((u, w))
        dist1 = dijkstra(adj1, src1)
        dist2 = dijkstra(adj1, src2)
        dist3 = dijkstra(adj2, dest)
        result = min(dist1[i]+dist2[i]+dist3[i] for i in xrange(n))
        return result if result != float("inf") else -1

```



----------------------------------------------------------------------------------------

### Graph - 2204 - https://leetcode.com/problems/distance-to-a-cycle-in-undirected-graph/
Time: O(|V| + |E|)  Space: O(|V| + |E|)   Hard
.Python/distance-to-a-cycle-in-undirected-graph.py


```python
# Time:  O(|V| + |E|)
# Space: O(|V| + |E|)

# graph, dfs, bfs
class Solution(object):
    def distanceToCycle(self, n, edges):
        """
        :type n: int
        :type edges: List[List[int]]
        :rtype: List[int]
        """
        def cycle(parent, v, u):
            result = [parent[v], v]
            while u != parent[v]:
                result.append(u)
                u = parent[u]
            return result
    
        def iter_dfs(adj):
            stk = [0]
            parent = [-2]*len(adj)
            parent[0] = -1
            while stk:
                u = stk.pop()
                for v in reversed(adj[u]):
                    if parent[v] != -2:
                        if v == parent[u]:
                            continue
                        return cycle(parent, v, u)
                    parent[v] = u
                    stk.append(v)

        def bfs(adj, q):
            result = [-1]*n
            for x in q:
                result[x] = 0
            d = 1
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if result[v] != -1:
                            continue
                        result[v] = d
                        new_q.append(v)
                q = new_q
                d += 1
            return result
    
        adj = [[] for _ in xrange(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        return bfs(adj, iter_dfs(adj))

```



----------------------------------------------------------------------------------------

### Graph - 2242 - https://leetcode.com/problems/maximum-score-of-a-node-sequence/
Time: O(|V| + |E|)  Space: O(|V|)   Hard
.Python/maximum-score-of-a-node-sequence.py


```python
# Time:  O(|V| + |E|)
# Space: O(|V|)

import heapq


# graph
class Solution(object):
    def maximumScore(self, scores, edges):
        """
        :type scores: List[int]
        :type edges: List[List[int]]
        :rtype: int
        """
        def find_top3(scores, x, top3):
            heapq.heappush(top3, (scores[x], x))
            if len(top3) &gt; 3:
                heapq.heappop(top3)

        top3 = [[] for _ in xrange(len(scores))]
        for a, b in edges:
            find_top3(scores, b, top3[a])
            find_top3(scores, a, top3[b])
        result = -1
        for a, b in edges:
            for _, c in top3[a]:
                if c == b:
                    continue
                for _, d in top3[b]:
                    if d == a or d == c:
                        continue
                    result = max(result, sum(scores[x] for x in (a, b, c, d)))
        return result

```



----------------------------------------------------------------------------------------

### Graph - 2307 - https://leetcode.com/problems/check-for-contradictions-in-equations/
Time: O(e + q)  Space: O(n)   Hard
.Python/check-for-contradictions-in-equations.py


```python
# Time:  O(e + q)
# Space: O(n)

import collections
import itertools


class UnionFind(object):
    def __init__(self):
        self.set = {}
        self.rank = collections.Counter()

    def find_set(self, x):
        xp, xr = self.set.setdefault(x, (x, 1.0))
        if x != xp:
            pp, pr = self.find_set(xp)  # path compression.
            self.set[x] = (pp, xr*pr)  # x/pp = xr*pr
        return self.set[x]

    def union_set(self, x, y, r):
        (xp, xr), (yp, yr) =  map(self.find_set, (x, y))
        if xp == yp:
            return False
        if self.rank[xp] &lt; self.rank[yp]:  # union by rank
            # to make x/yp = r*yr and merge xp into yp
            # =&gt; since x/xp = xr, we can merge with xp/yp = r*yr/xr 
            self.set[xp] = (yp, r*yr/xr)
        elif self.rank[xp] &gt; self.rank[yp]:
            # to make y/xp = 1/r*xr and merge xp into yp
            # =&gt; since y/yp = yr, we can merge with yp/xp = 1/r*xr/yr 
            self.set[yp] = (xp, 1.0/r*xr/yr)
        else:
            # to make y/xp = 1/r*xr and merge xp into yp
            # =&gt; since y/yp = yr, we can merge with yp/xp = 1/r*xr/yr 
            self.set[yp] = (xp, 1.0/r*xr/yr)
            self.rank[xp] += 1 
        return True

    def query_set(self, x, y):
        if x not in self.set or y not in self.set:
            return -1.0
        (xp, xr), (yp, yr) = map(self.find_set, (x, y))
        return xr/yr if xp == yp else -1.0


# Time:  O(e + q)
# Space: O(n)
import itertools


# union find
class Solution(object):
    def checkContradictions(self, equations, values):
        """
        :type equations: List[List[str]]
        :type values: List[float]
        :rtype: bool
        """
        EPS = 1e-5
        uf = UnionFind()
        return any(not uf.union_set(a, b, k) and abs(uf.query_set(a, b)-k) &gt;= EPS for (a, b), k in itertools.izip(equations, values))


# Time:  O(e + q)
# Space: O(n)
import collections
import itertools


# dfs
class Solution2(object):
    def checkContradictions(self, equations, values):
        """
        :type equations: List[List[str]]
        :type values: List[float]
        :rtype: bool
        """
        def isclose(a, b, rel_tol=1e-09, abs_tol=0.0):
            return abs(a-b) &lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)

        def iter_dfs(adj, u, lookup):
            stk = [u]
            lookup[u] = 1.0
            while stk:
                u = stk.pop()
                for v, k in adj[u]:
                    if v in lookup:
                        if not isclose(lookup[v], lookup[u]*k):
                            return True
                        continue
                    lookup[v] = lookup[u]*k
                    stk.append(v)
            return False

        adj = collections.defaultdict(set)
        for (a, b), k in itertools.izip(equations, values):
            adj[a].add((b, 1.0/k))
            adj[b].add((a, 1.0*k))
        lookup = {}
        for u in adj.iterkeys():
            if u in lookup:
                continue
            if iter_dfs(adj, u, lookup):
                return True
        return False

```



----------------------------------------------------------------------------------------

### Graph - 2359 - https://leetcode.com/problems/find-closest-node-to-given-two-nodes/
Time: O(n)  Space: O(n)   Medium
.Python/find-closest-node-to-given-two-nodes.py


```python
# Time:  O(n)
# Space: O(n)

# graph, hash table
class Solution(object):
    def closestMeetingNode(self, edges, node1, node2):
        """
        :type edges: List[int]
        :type node1: int
        :type node2: int
        :rtype: int
        """
        def dfs(node):
            lookup = {}
            i = 0
            while node != -1:
                if node in lookup:
                    break
                lookup[node] = i
                i += 1
                node = edges[node]
            return lookup
        
        lookup1, lookup2 = dfs(node1), dfs(node2)
        intersect = set(lookup1.iterkeys())&amp;set(lookup2.iterkeys())
        return min(intersect, key=lambda x: (max(lookup1[x], lookup2[x]), x)) if intersect else -1

```



----------------------------------------------------------------------------------------

### Graph - 2360 - https://leetcode.com/problems/longest-cycle-in-a-graph/
Time: O(n)  Space: O(n)   Hard
.Python/longest-cycle-in-a-graph.py


```python
# Time:  O(n)
# Space: O(n)

# graph
class Solution(object):
    def longestCycle(self, edges):
        """
        :type edges: List[int]
        :rtype: int
        """
        result = -1
        lookup = [-1]*len(edges)
        idx = 0
        for i in xrange(len(edges)):
            if lookup[i] != -1:
                continue
            start = idx
            while i != -1:
                if lookup[i] != -1:
                    break
                lookup[i] = idx
                idx += 1
                i = edges[i]
            if i != -1 and lookup[i] &gt;= start:
                result = max(result, idx-lookup[i])
        return result

```



----------------------------------------------------------------------------------------

### Geometry - 1453 - https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/
Time: O(n^2 * logn)  Space: O(n)   Hard
.Python/maximum-number-of-darts-inside-of-a-circular-dartboard.py


```python
# Time:  O(n^2 * logn)
# Space: O(n)

import math


# angle sweep solution
# great explanation:
# https://leetcode.com/problems/maximum-number-of-darts-inside-of-a-circular-dartboard/discuss/636345/Python-O(n3)-and-O(n2logn)-solution-explained-in-detail-with-pictures
class Solution(object):
    def numPoints(self, points, r):
        """
        :type points: List[List[int]]
        :type r: int
        :rtype: int
        """
        def count_points(points, r, i):
            angles = []
            for j in xrange(len(points)):
                if i == j:
                    continue
                dx, dy = points[i][0]-points[j][0], points[i][1]-points[j][1]
                d = math.sqrt(dx**2 + dy**2)
                if d &gt; 2*r:
                    continue
                delta, angle = math.acos(d/(2*r)), math.atan2(dy, dx)
                angles.append((angle-delta, 0)), angles.append((angle+delta, 1))
            angles.sort()
            result, count = 1, 1
            for _, is_closed in angles:  # angle sweep
                if not is_closed:
                    count += 1
                else:
                    count -= 1
                result = max(result, count)
            return result

        return max(count_points(points, r, i) for i in xrange(len(points)))

```



----------------------------------------------------------------------------------------

### Geometry - 1515 - https://leetcode.com/problems/best-position-for-a-service-centre/
Time: O(n * iter)  Space: O(n)   Hard
.Python/best-position-for-a-service-centre.py


```python
# Time:  O(n * iter), iter is the number of iterations
# Space: O(1)

# see reference:
# - https://en.wikipedia.org/wiki/Geometric_median
# - https://wikimedia.org/api/rest_v1/media/math/render/svg/b3fb215363358f12687100710caff0e86cd9d26b
# Weiszfeld's algorithm
class Solution(object):
    def getMinDistSum(self, positions):
        """
        :type positions: List[List[int]]
        :rtype: float
        """
        EPS = 1e-6
        def norm(p1, p2):
            return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)**0.5
        
        def geometry_median(positions, median):
            numerator, denominator = [0.0, 0.0], 0.0
            for p in positions:
                l = norm(median, p)
                if not l:
                    continue                       
                numerator[0] += p[0]/l
                numerator[1] += p[1]/l
                denominator += 1/l
            if denominator == 0.0:
                return True, None
            return False, [numerator[0]/denominator, numerator[1]/denominator]

        median = [float(sum(p[0] for p in positions))/len(positions),
                  float(sum(p[1] for p in positions))/len(positions)]
        prev_median = [float("-inf"), float("-inf")]
        while norm(median, prev_median)*len(positions) &gt; EPS:
            stopped, new_median = geometry_median(positions, median)
            if stopped:
                break
            median, prev_median = new_median, median
        return sum(norm(median, p) for p in positions)


# Time:  O(n * iter), iter is the number of iterations
# Space: O(1)
class Solution2(object):
    def getMinDistSum(self, positions):
        """
        :type positions: List[List[int]]
        :rtype: float
        """
        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        EPS = 1e-6
        def dist(positions, p):
            return sum(((p[0]-x)**2 + (p[1]-y)**2)**0.5 for x, y in positions)
        
        median = [0.0, 0.0]
        median[0] = float(sum(x for x, _ in positions))/len(positions)
        median[1] = float(sum(y for _, y in positions))/len(positions)
        result = dist(positions, median)
        delta = float(max(max(positions, key=lambda x: x[0])[0],
                          max(positions, key=lambda x: x[1])[1])) - \
                float(min(min(positions, key=lambda x: x[0])[0],
                          min(positions, key=lambda x: x[1])[1]))
        while delta &gt; EPS:
            for dx, dy in DIRECTIONS:
                new_median = [median[0] + delta*dx, median[1] + delta*dy]
                nd = dist(positions, new_median)
                if nd &lt; result: 
                    result = nd 
                    median = new_median
                    break 
            else:
                delta /= 2.0
        return result

```



----------------------------------------------------------------------------------------

### Geometry - 1610 - https://leetcode.com/problems/maximum-number-of-visible-points/
Time: O(nlogn)  Space: O(n)   Hard
.Python/maximum-number-of-visible-points.py


```python
# Time:  O(nlogn)
# Space: O(n)

import math


class Solution(object):
    def visiblePoints(self, points, angle, location):
        """
        :type points: List[List[int]]
        :type angle: int
        :type location: List[int]
        :rtype: int
        """
        arr, extra = [], 0
        for p in points:
            if p == location:
                extra += 1
                continue
            arr.append(math.atan2(p[1]-location[1], p[0]-location[0]))
        arr.sort()
        arr.extend([x + 2.0*math.pi for x in arr])  # make it circular
        d = 2.0*math.pi * (angle/360.0)
        left = result = 0
        for right in xrange(len(arr)):
            while arr[right]-arr[left] &gt; d:
                left += 1
            result = max(result, right-left+1)
        return result + extra

```



----------------------------------------------------------------------------------------

### Geometry - 1924 - https://leetcode.com/problems/erect-the-fence-ii/
Time: O(n) on average  Space: O(n)   Hard
.Python/erect-the-fence-ii.py


```python
# Time:  O(n) on average
# Space: O(n)

import random


# reference: https://en.wikipedia.org/wiki/Smallest-circle_problem
class Solution(object):
    def outerTrees(self, trees):
        """
        :type trees: List[List[int]]
        :rtype: List[float]
        """
        def dist(a, b):
            return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5

        def inside(c, p):
            return dist(c[0], p) &lt; c[1]+EPS

        def circle_center(bx, by, cx, cy):
            B = bx*bx + by*by
            C = cx*cx + cy*cy
            D = bx*cy - by*cx
            return [float(cy*B - by*C)/(2*D),
                    float(bx*C - cx*B)/(2*D)]

        def circle_from_2_points(A, B):
            C = [(A[0]+B[0])/2.0, (A[1]+B[1])/2.0]
            return [C, dist(A, B)/2.0]

        def circle_from_3_points(A, B, C):
            I = circle_center(B[0]-A[0], B[1]-A[1],
                              C[0]-A[0], C[1]-A[1])
            I[0] += A[0]
            I[1] += A[1]
            return [I, dist(I, A)]

        def trivial(boundaries):  # circumscribed circle
            if not boundaries:
                return None
            if len(boundaries) == 1:
                return [boundaries[0], 0.0]
            if len(boundaries) == 2:
                return circle_from_2_points(boundaries[0], boundaries[1])
            return circle_from_3_points(boundaries[0], boundaries[1], boundaries[2])

        def Welzl(points, boundaries, curr):
            if curr == len(points) or len(boundaries) == 3:
                return trivial(boundaries)
            result = Welzl(points, boundaries, curr+1)
            if result is not None and inside(result, points[curr]):
                return result
            boundaries.append(points[curr])
            result = Welzl(points, boundaries, curr+1)
            boundaries.pop()
            return result

        EPS = 1e-5
        random.seed(0)
        random.shuffle(trees)
        result = Welzl(trees, [], 0)
        return result[0][0], result[0][1], result[1]

```



----------------------------------------------------------------------------------------

### Geometry - 1956 - https://leetcode.com/problems/minimum-time-for-k-virus-variants-to-spread/
Time: O(nlogn * logr)  Space: O(n)   Hard
.Python/minimum-time-for-k-virus-variants-to-spread.py


```python
# Time:  O(nlogn * logr), r is the sum of range x size and range y size
# Space: O(n)

# Range Maximum Query
class SegmentTree(object):  # 0-based index
    def __init__(self, N,
                 build_fn=lambda x, y: [y]*(2*x),
                 query_fn=lambda x, y: y if x is None else max(x, y),
                 update_fn=lambda x, y: y if x is None else x+y,
                 default_val=0):
        self.N = N
        self.H = (N-1).bit_length()
        self.query_fn = query_fn
        self.update_fn = update_fn
        self.default_val = default_val
        self.tree = build_fn(N, default_val)
        self.lazy = [None]*N

    def __apply(self, x, val):
        self.tree[x] = self.update_fn(self.tree[x], val)
        if x &lt; self.N:
            self.lazy[x] = self.update_fn(self.lazy[x], val)

    def update(self, L, R, h):  # Time: O(logN), Space: O(N)
        def pull(x):
            while x &gt; 1:
                x //= 2
                self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])
                if self.lazy[x] is not None:
                    self.tree[x] = self.update_fn(self.tree[x], self.lazy[x])

        L += self.N
        R += self.N
        L0, R0 = L, R
        while L &lt;= R:
            if L &amp; 1:  # is right child
                self.__apply(L, h)
                L += 1
            if R &amp; 1 == 0:  # is left child
                self.__apply(R, h)
                R -= 1
            L //= 2
            R //= 2
        pull(L0)
        pull(R0)

    def query(self, L, R):  # Time: O(logN), Space: O(N)
        def push(x):
            n = 2**self.H
            while n != 1:
                y = x // n
                if self.lazy[y] is not None:
                    self.__apply(y*2, self.lazy[y])
                    self.__apply(y*2 + 1, self.lazy[y])
                    self.lazy[y] = None
                n //= 2

        result = None
        if L &gt; R:
            return result

        L += self.N
        R += self.N
        push(L)
        push(R)
        while L &lt;= R:
            if L &amp; 1:  # is right child
                result = self.query_fn(result, self.tree[L])
                L += 1
            if R &amp; 1 == 0:  # is left child
                result = self.query_fn(result, self.tree[R])
                R -= 1
            L //= 2
            R //= 2
        return result
    
    def __str__(self):
        showList = []
        for i in xrange(self.N):
            showList.append(self.query(i, i))
        return ",".join(map(str, showList))


# competitive programming solution
class Solution(object):
    def minDayskVariants(self, points, k):
        """
        :type points: List[List[int]]
        :type k: int
        :rtype: int
        """
        def add_rec(rec, intervals):
            x0, y0, x1, y1 = rec
            # add [y0, y1] by 1 in [x0, x1+1)
            intervals.append([[x0,   +1], [y0, y1]])
            intervals.append([[x1+1, -1], [y0, y1]])

        def check(points, k, l):  # Time: O(nlogn), Space: O(n)
            intervals = []
            y_set = set()
            for x, y in points:
                add_rec([x-l, y-l, x+l, y+l], intervals)
                y_set.add(y-l)
                y_set.add(y+l)
            intervals.sort()
            y_to_idx = {y:i for i, y in enumerate(sorted(y_set))}  # coordinate compression
            st = SegmentTree(len(y_to_idx))
            for [_, v], [y0, y1] in intervals:  # line sweep
                st.update(y_to_idx[y0], y_to_idx[y1], v)
                if st.query(0, len(y_to_idx)-1) &gt;= k:
                    return True
            return False
                
        points = [[x+y, x-y] for x, y in points]  # rotate
        min_x = min(points)[0]
        max_x = max(points)[0]
        min_y = min(points, key=lambda x: x[1])[1]
        max_y = max(points, key=lambda x: x[1])[1]
        left, right = 0, ((max_x-min_x)+(max_y-min_y)+1)//2
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(points, k, mid):
                right = mid-1
            else:
                left = mid+1
        return left


# Time:  O(n^2 * logr), r is the sum of range x size and range y size
# Space: O(n)
import collections


# interview solution
class Solution2(object):
    def minDayskVariants(self, points, k):
        """
        :type points: List[List[int]]
        :type k: int
        :rtype: int
        """
        def add_rec(rec, intervals):
            x0, y0, x1, y1 = rec
            # add [y0, y1+1) by 1 in [x0, x1+1)
            intervals[x0][y0] += 1
            intervals[x0][y1+1] -= 1
            intervals[x1+1][y0] -= 1
            intervals[x1+1][y1+1] += 1

        def check(points, k, l):  # Time: O(n^2), Space: O(n)
            intervals = collections.defaultdict(lambda:collections.defaultdict(int))
            y_set = set()
            for x, y in points:
                add_rec([x-l, y-l, x+l, y+l], intervals)
                y_set.add(y-l)
                y_set.add(y+l+1)
            sorted_y = sorted(y_set)
            sorted_x = sorted(intervals.iterkeys())
            count = collections.Counter()
            for x in sorted_x:  # line sweep
                for y, c in intervals[x].iteritems():
                    count[y] += c
                cnt = 0
                for y in sorted_y:
                    cnt += count[y]
                    if cnt &gt;= k:
                        return True
            return False
                
        points = [[x+y, x-y] for x, y in points]  # rotate
        min_x = min(points)[0]
        max_x = max(points)[0]
        min_y = min(points, key=lambda x: x[1])[1]
        max_y = max(points, key=lambda x: x[1])[1]
        left, right = 0, ((max_x-min_x)+(max_y-min_y)+1)//2
        while left &lt;= right:
            mid = left + (right-left)//2
            if check(points, k, mid):
                right = mid-1
            else:
                left = mid+1
        return left

```



----------------------------------------------------------------------------------------

### Geometry - 2101 - https://leetcode.com/problems/detonate-the-maximum-bombs/
Time: O(|V|^2 + \V| * |E|)  Space: O(\V| + |E|)   Medium
.Python/detonate-the-maximum-bombs.py


```python
# Time:  O(|V|^2 + |V| * |E|)
# Space: O(|V| + |E|)

# bfs solution
class Solution(object):
    def maximumDetonation(self, bombs):
        """
        :type bombs: List[List[int]]
        :rtype: int
        """        
        adj = [[] for _ in xrange(len(bombs))]
        for i, (xi, yi, ri) in enumerate(bombs):
            for j, (xj, yj, _) in enumerate(bombs):
                if j == i:
                    continue
                if (xi-xj)**2+(yi-yj)**2 &lt;= ri**2:
                    adj[i].append(j)
        result = 0
        for i in xrange(len(bombs)):
            q = [i]
            lookup = {i}
            while q:
                new_q = []
                for u in q:
                    for v in adj[u]:
                        if v in lookup:
                            continue
                        lookup.add(v)
                        new_q.append(v)
                q = new_q
            result = max(result, len(lookup))
            if result == len(bombs):
                break
        return result


# Time:  O(|V|^2 + |V| * |E|)
# Space: O(|V| + |E|)
# dfs solution
class Solution2(object):
    def maximumDetonation(self, bombs):
        """
        :type bombs: List[List[int]]
        :rtype: int
        """        
        adj = [[] for _ in xrange(len(bombs))]
        for i, (xi, yi, ri) in enumerate(bombs):
            for j, (xj, yj, _) in enumerate(bombs):
                if j == i:
                    continue
                if (xi-xj)**2+(yi-yj)**2 &lt;= ri**2:
                    adj[i].append(j)
        result = 0
        for i in xrange(len(bombs)):
            stk = [i]
            lookup = {i}
            while stk:
                u = stk.pop()
                for v in adj[u]:
                    if v in lookup:
                        continue
                    lookup.add(v)
                    stk.append(v)
            result = max(result, len(lookup))
            if result == len(bombs):
                break
        return result

```



----------------------------------------------------------------------------------------

### Simulation - 1138 - https://leetcode.com/problems/alphabet-board-path/
Time: O(n)  Space: O(1)   Medium
.Python/alphabet-board-path.py


```python
# Time:  O(n)
# Space: O(1)

class Solution(object):
    def alphabetBoardPath(self, target):
        """
        :type target: str
        :rtype: str
        """
        x, y = 0, 0
        result = []
        for c in target:
            y1, x1 = divmod(ord(c)-ord('a'), 5)
            result.append('U' * max(y-y1, 0))
            result.append('L' * max(x-x1, 0))
            result.append('R' * max(x1-x, 0))
            result.append('D' * max(y1-y, 0))
            result.append('!')
            x, y = x1, y1
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Simulation - 1243 - https://leetcode.com/problems/array-transformation/
Time: O(n^2)  Space: O(n)   Easy
.Python/array-transformation.py


```python
# Time:  O(n^2)
# Space: O(n)

class Solution(object):
    def transformArray(self, arr):
        """
        :type arr: List[int]
        :rtype: List[int]
        """
        def is_changable(arr):
            return any(arr[i-1] &gt; arr[i] &lt; arr[i+1] or 
                       arr[i-1] &lt; arr[i] &gt; arr[i+1]
                       for i in xrange(1, len(arr)-1))
        
        while is_changable(arr):
            new_arr = arr[:]
            for i in xrange(1, len(arr)-1):
                new_arr[i] += arr[i-1] &gt; arr[i] &lt; arr[i+1]
                new_arr[i] -= arr[i-1] &lt; arr[i] &gt; arr[i+1]
            arr = new_arr
        return arr

```



----------------------------------------------------------------------------------------

### Simulation - 2061 - https://leetcode.com/problems/number-of-spaces-cleaning-robot-cleaned/
Time: O(m * n)  Space: O(1)   Medium
.Python/number-of-spaces-cleaning-robot-cleaned.py


```python
# Time:  O(m * n)
# Space: O(1)

class Solution(object):
    def numberOfCleanRooms(self, room):
        """
        :type room: List[List[int]]
        :rtype: int
        """
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        result = r = c = d = 0
        while not room[r][c]&amp;(1&lt;&lt;(d+1)):
            result += (room[r][c]&gt;&gt;1) == 0
            room[r][c] |= (1&lt;&lt;(d+1))
            dr, dc = directions[d]
            nr, nc = r+dr, c+dc
            if 0 &lt;= nr &lt; len(room) and 0 &lt;= nc &lt; len(room[0]) and not (room[nr][nc]&amp;1):
                r, c = nr, nc
            else:
                d = (d+1)%4
        return result

```



----------------------------------------------------------------------------------------

### Simulation - 2162 - https://leetcode.com/problems/minimum-cost-to-set-cooking-time/
Time: O(1)  Space: O(1)   Medium
.Python/minimum-cost-to-set-cooking-time.py


```python
# Time:  O(1)
# Space: O(1)

# simulation
class Solution(object):
    def minCostSetTime(self, startAt, moveCost, pushCost, targetSeconds):
        """
        :type startAt: int
        :type moveCost: int
        :type pushCost: int
        :type targetSeconds: int
        :rtype: int
        """     
        def cost(m, s):
            if not (0 &lt;= m &lt;= 99 and s &lt;= 99):
                return float("inf")
            result = 0
            curr = startAt
            for x in map(int, list(str(m*100 + s))):
                result += (moveCost if x != curr else 0)+pushCost
                curr = x
            return result

        m, s = divmod(targetSeconds, 60)
        return min(cost(m, s), cost(m-1, s+60))

```



----------------------------------------------------------------------------------------

### Simulation - 2257 - https://leetcode.com/problems/count-unguarded-cells-in-the-grid/
Time: O(m * n)  Space: O(m * n)   Medium
.Python/count-unguarded-cells-in-the-grid.py


```python
# Time:  O(m * n)
# Space: O(m * n)

import itertools


# array, simulation
class Solution(object):
    def countUnguarded(self, m, n, guards, walls):
        """
        :type m: int
        :type n: int
        :type guards: List[List[int]]
        :type walls: List[List[int]]
        :rtype: int
        """
        DIRECTIONS = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        GREEN, RED, BLOCK = range(3)
        grid = [[GREEN]*n for _ in xrange(m)]
        for r, c in itertools.chain(guards, walls):
            grid[r][c] = BLOCK
        for r, c in guards:
            for dr, dc in DIRECTIONS:
                nr, nc = r+dr, c+dc
                while 0 &lt;= nr &lt; m and 0 &lt;= nc &lt; n and grid[nr][nc] != BLOCK:
                    grid[nr][nc] = RED
                    nr, nc = nr+dr, nc+dc
        return sum(grid[r][c] == GREEN for r in xrange(m) for c in xrange(n))

```



----------------------------------------------------------------------------------------

### Simulation - 2303 - https://leetcode.com/problems/calculate-amount-paid-in-taxes/
Time: O(n)  Space: O(1)   Easy
.Python/calculate-amount-paid-in-taxes.py


```python
# Time:  O(n)
# Space: O(1)

# simulation
class Solution(object):
    def calculateTax(self, brackets, income):
        """
        :type brackets: List[List[int]]
        :type income: int
        :rtype: float
        """
        result = prev = 0
        for u, p in brackets:
            result += max((min(u, income)-prev)*p/100.0, 0.0)
            prev = u
        return result

```



----------------------------------------------------------------------------------------

### Design - 1146 - https://leetcode.com/problems/snapshot-array/
Time: set: O(1) get: O(logn)  Space: O(n)   Medium
.Python/snapshot-array.py


```python
# Time:  set: O(1)
#        get: O(logn), n is the total number of set
# Space: O(n)

import collections
import bisect


class SnapshotArray(object):

    def __init__(self, length):
        """
        :type length: int
        """
        self.__A = collections.defaultdict(lambda: [[0, 0]])
        self.__snap_id = 0


    def set(self, index, val):
        """
        :type index: int
        :type val: int
        :rtype: None
        """
        if self.__A[index][-1][0] == self.__snap_id:
            self.__A[index][-1][1] = val
        else:
            self.__A[index].append([self.__snap_id, val])


    def snap(self):
        """
        :rtype: int
        """
        self.__snap_id += 1
        return self.__snap_id - 1


    def get(self, index, snap_id):
        """
        :type index: int
        :type snap_id: int
        :rtype: int
        """
        i = bisect.bisect_left(self.__A[index], [snap_id+1, float("-inf")]) - 1
        return self.__A[index][i][1]

```



----------------------------------------------------------------------------------------

### Design - 1166 - https://leetcode.com/problems/design-file-system/
Time: create: O(n)get: O(n)  Space: O(n)   Medium
.Python/design-file-system.py


```python
# Time:  create: O(n)
#        get:    O(n)
# Space: O(n)

class FileSystem(object):

    def __init__(self):
        self.__lookup = {"": -1}

    def create(self, path, value):
        """
        :type path: str
        :type value: int
        :rtype: bool
        """
        if path[:path.rfind('/')] not in self.__lookup:
            return False
        self.__lookup[path] = value
        return True
        
    def get(self, path):
        """
        :type path: str
        :rtype: int
        """
        if path not in self.__lookup:
            return -1
        return self.__lookup[path]

```



----------------------------------------------------------------------------------------

### Design - 1172 - https://leetcode.com/problems/dinner-plate-stacks/
Time: push: O(logn)pop: O(1), amortizedpopAtStack: (logn)  Space: O(n * c)   Hard
.Python/dinner-plate-stacks.py


```python
# Time:  push: O(logn)
#        pop:  O(1), amortized
#        popAtStack: O(logn)
# Space: O(n * c)

import heapq


class DinnerPlates(object):

    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.__stks = []
        self.__c = capacity
        self.__min_heap = []

    def push(self, val):
        """
        :type val: int
        :rtype: None
        """
        if self.__min_heap:
            l = heapq.heappop(self.__min_heap)
            if l &lt; len(self.__stks):
                self.__stks[l].append(val)
                return
            self.__min_heap = []  # nothing is valid in min heap
        if not self.__stks or len(self.__stks[-1]) == self.__c:
            self.__stks.append([])
        self.__stks[-1].append(val)

    def pop(self):
        """
        :rtype: int
        """
        while self.__stks and not self.__stks[-1]:
            self.__stks.pop()
        if not self.__stks:
            return -1
        return self.__stks[-1].pop()

    def popAtStack(self, index):
        """
        :type index: int
        :rtype: int
        """
        if index &gt;= len(self.__stks) or not self.__stks[index]:
            return -1
        heapq.heappush(self.__min_heap, index)
        return self.__stks[index].pop()

```



----------------------------------------------------------------------------------------

### Design - 1206 - https://leetcode.com/problems/design-skiplist/
Time: O(logn), on average  Space: O(n)   Hard
.Python/design-skiplist.py


```python
# Time:  O(logn) on average for each operation
# Space: O(n)

# see proof in references:
# 1. https://kunigami.blog/2012/09/25/skip-lists-in-python/
# 2. https://opendatastructures.org/ods-cpp/4_4_Analysis_Skiplists.html
# 3. https://brilliant.org/wiki/skip-lists/
import random


class SkipNode(object):
    def __init__(self, level=0, num=None):
        self.num = num
        self.nexts = [None]*level


class Skiplist(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2  # P = 1/4 in redis implementation
    MAX_LEVEL = 32  # enough for 2^32 elements

    def __init__(self):
        self.__head = SkipNode()
        self.__len = 0

    def search(self, target):
        """
        :type target: int
        :rtype: bool
        """
        return True if self.__find(target, self.__find_prev_nodes(target)) else False
        
    def add(self, num):
        """
        :type num: int
        :rtype: None
        """
        node = SkipNode(self.__random_level(), num)
        if len(self.__head.nexts) &lt; len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(num)
        for i in xrange(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            prevs[i].nexts[i] = node
        self.__len += 1

    def erase(self, num):
        """
        :type num: int
        :rtype: bool
        """
        prevs = self.__find_prev_nodes(num)
        curr = self.__find(num, prevs)
        if not curr:
            return False
        self.__len -= 1   
        for i in reversed(xrange(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return True
    
    def __find(self, num, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate and candidate.num == num:
                return candidate
        return None

    def __find_prev_nodes(self, num):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(xrange(len(self.__head.nexts))):
            while curr.nexts[i] and curr.nexts[i].num &lt; num:
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while random.randint(1, Skiplist.P_DENOMINATOR) &lt;= Skiplist.P_NUMERATOR and \
              level &lt; Skiplist.MAX_LEVEL:
            level += 1
        return level

    def __len__(self):
        return self.__len
    
    def __str__(self):
        result = []
        for i in reversed(xrange(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.num))
                curr = curr.nexts[i]
        return "\n".join(map(lambda x: "-&gt;".join(x), result))

```



----------------------------------------------------------------------------------------

### Design - 1236 - https://leetcode.com/problems/web-crawler/
Time: O(|V| + |E|)  Space: O(|V|)   Medium
.Python/web-crawler.py


```python
# Time:  O(|V| + |E|)
# Space: O(|V|)

# """
# This is HtmlParser's API interface.
# You should not implement it, or speculate about its implementation
# """
class HtmlParser(object):
   def getUrls(self, url):
       """
       :type url: str
       :rtype List[str]
       """
       pass


class Solution(object):
    def crawl(self, startUrl, htmlParser):
        """
        :type startUrl: str
        :type htmlParser: HtmlParser
        :rtype: List[str]
        """
        SCHEME = "http://"
        def hostname(url):
            pos = url.find('/', len(SCHEME))
            if pos == -1:
                return url
            return url[:pos]

        result = [startUrl]
        lookup = set(result)
        for from_url in result:
            name = hostname(from_url)
            for to_url in htmlParser.getUrls(from_url):
                if to_url not in lookup and name == hostname(to_url):
                    result.append(to_url)
                    lookup.add(to_url)
        return result

```



----------------------------------------------------------------------------------------

### Design - 1244 - https://leetcode.com/problems/design-a-leaderboard/
Time: ctor: O(1) add: O(1) top: O(n) reset: O(1)  Space: O(n)   Medium
.Python/design-a-leaderboard.py


```python
# Time:  ctor:  O(1)
#        add:   O(1)
#        top:   O(n)
#        reset: O(1)
# Space: O(n)

import collections
import random


class Leaderboard(object):

    def __init__(self):
        self.__lookup = collections.Counter()
        
    def addScore(self, playerId, score):
        """
        :type playerId: int
        :type score: int
        :rtype: None
        """
        self.__lookup[playerId] += score

    def top(self, K):
        """
        :type K: int
        :rtype: int
        """
        def kthElement(nums, k, compare):
            def PartitionAroundPivot(left, right, pivot_idx, nums, compare):
                new_pivot_idx = left
                nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]
                for i in xrange(left, right):
                    if compare(nums[i], nums[right]):
                        nums[i], nums[new_pivot_idx] = nums[new_pivot_idx], nums[i]
                        new_pivot_idx += 1

                nums[right], nums[new_pivot_idx] = nums[new_pivot_idx], nums[right]
                return new_pivot_idx

            left, right = 0, len(nums) - 1
            while left &lt;= right:
                pivot_idx = random.randint(left, right)
                new_pivot_idx = PartitionAroundPivot(left, right, pivot_idx, nums, compare)
                if new_pivot_idx == k:
                    return
                elif new_pivot_idx &gt; k:
                    right = new_pivot_idx - 1
                else:  # new_pivot_idx &lt; k.
                    left = new_pivot_idx + 1
        
        scores = self.__lookup.values()
        kthElement(scores, K, lambda a, b: a &gt; b)
        return sum(scores[:K])

    def reset(self, playerId):
        """
        :type playerId: int
        :rtype: None
        """
        self.__lookup[playerId] = 0

```



----------------------------------------------------------------------------------------

### Design - 1268 - https://leetcode.com/problems/search-suggestions-system/
Time: ctor: O(n * l) suggest: O(l^2)  Space: O(t)   Medium
.Python/search-suggestions-system.py


```python
# Time:  ctor: O(n * l), n is the number of products
#                      , l is the average length of product name
#        suggest: O(l^2)
# Space: O(t), t is the number of nodes in trie

import collections


class TrieNode(object):

    def __init__(self):
        self.__TOP_COUNT = 3
        self.leaves = collections.defaultdict(TrieNode)
        self.infos = []

    def insert(self, words, i):
        curr = self
        for c in words[i]:
            curr = curr.leaves[c]
            curr.add_info(words, i)

    def add_info(self, words, i):
        self.infos.append(i)
        self.infos.sort(key=lambda x: words[x])
        if len(self.infos) &gt; self.__TOP_COUNT:
            self.infos.pop()


class Solution(object):
    def suggestedProducts(self, products, searchWord):
        """
        :type products: List[str]
        :type searchWord: str
        :rtype: List[List[str]]
        """
        trie = TrieNode()
        for i in xrange(len(products)):
            trie.insert(products, i)
        result = [[] for _ in xrange(len(searchWord))]
        for i, c in enumerate(searchWord):
            if c not in trie.leaves:
                break
            trie = trie.leaves[c]
            result[i] = map(lambda x: products[x], trie.infos)
        return result


# Time:  ctor: O(n * l * log(n * l)), n is the number of products
#                                   , l is the average length of product name
#        suggest: O(l^2)
# Space: O(t), t is the number of nodes in trie
class TrieNode2(object):

    def __init__(self):
        self.__TOP_COUNT = 3
        self.leaves = collections.defaultdict(TrieNode2)
        self.infos = []

    def insert(self, words, i):
        curr = self
        for c in words[i]:
            curr = curr.leaves[c]
            curr.add_info(i)

    def add_info(self, i):
        if len(self.infos) == self.__TOP_COUNT:
            return
        self.infos.append(i)


class Solution2(object):
    def suggestedProducts(self, products, searchWord):
        """
        :type products: List[str]
        :type searchWord: str
        :rtype: List[List[str]]
        """
        products.sort()
        trie = TrieNode2()
        for i in xrange(len(products)):
            trie.insert(products, i)
        result = [[] for _ in xrange(len(searchWord))]
        for i, c in enumerate(searchWord):
            if c not in trie.leaves:
                break
            trie = trie.leaves[c]
            result[i] = map(lambda x: products[x], trie.infos)
        return result


# Time:  ctor: O(n * l * log(n * l)), n is the number of products
#                                   , l is the average length of product name
#        suggest: O(l^2 * n)
# Space: O(n * l)
import bisect


class Solution3(object):
    def suggestedProducts(self, products, searchWord):
        """
        :type products: List[str]
        :type searchWord: str
        :rtype: List[List[str]]
        """
        products.sort()  # Time: O(n * l * log(n * l))
        result = []
        prefix = ""
        for i, c in enumerate(searchWord):  # Time: O(l)
            prefix += c
            start = bisect.bisect_left(products, prefix)  # Time: O(log(n * l))
            new_products = []
            for j in xrange(start, len(products)):  # Time: O(n * l)
                if not (i &lt; len(products[j]) and products[j][i] == c):
                    break
                new_products.append(products[j])
            products = new_products
            result.append(products[:3])
        return result

```



----------------------------------------------------------------------------------------

### Design - 1286 - https://leetcode.com/problems/iterator-for-combination/
Time: O(k)  Space: O(k)   Medium
.Python/iterator-for-combination.py


```python
# Time:  O(k), per operation
# Space: O(k)

import itertools


class CombinationIterator(object):

    def __init__(self, characters, combinationLength):
        """
        :type characters: str
        :type combinationLength: int
        """
        self.__it = itertools.combinations(characters, combinationLength)
        self.__curr = None
        self.__last = characters[-combinationLength:]

    def next(self):
        """
        :rtype: str
        """
        self.__curr = "".join(self.__it.next())
        return self.__curr
    
    def hasNext(self):
        """
        :rtype: bool
        """
        return self.__curr != self.__last


# Time:  O(k), per operation
# Space: O(k)
import functools


class CombinationIterator2(object):

    def __init__(self, characters, combinationLength):
        """
        :type characters: str
        :type combinationLength: int
        """
        self.__characters = characters
        self.__combinationLength = combinationLength
        self.__it = self.__iterative_backtracking()
        self.__curr = None
        self.__last = characters[-combinationLength:]
        
    def __iterative_backtracking(self):
        def conquer():
            if len(curr) == self.__combinationLength:
                return curr

        def prev_divide(c):
            curr.append(c)
        
        def divide(i):
            if len(curr) != self.__combinationLength:
                for j in reversed(xrange(i, len(self.__characters)-(self.__combinationLength-len(curr)-1))):
                    stk.append(functools.partial(post_divide))
                    stk.append(functools.partial(divide, j+1))
                    stk.append(functools.partial(prev_divide, self.__characters[j]))
            stk.append(functools.partial(conquer))

        def post_divide():
            curr.pop()
            
        curr = []
        stk = [functools.partial(divide, 0)]
        while stk:
            result = stk.pop()()
            if result is not None:
                yield result

    def next(self):
        """
        :rtype: str
        """
        self.__curr = "".join(next(self.__it))
        return self.__curr
        
    def hasNext(self):
        """
        :rtype: bool
        """
        return self.__curr != self.__last


# Your CombinationIterator object will be instantiated and called as such:
# obj = CombinationIterator(characters, combinationLength)
# param_1 = obj.next()
# param_2 = obj.hasNext()

```



----------------------------------------------------------------------------------------

### Design - 1348 - https://leetcode.com/problems/tweet-counts-per-frequency/
Time: add: O(logn)query: O(c)  Space: O(n)   Medium
.Python/tweet-counts-per-frequency.py


```python
# Time:  add:   O(logn),
#        query: O(c), c is the total count of matching records
# Space: O(n)

import collections
import random


# Template:
# https://github.com/kamyu104/LeetCode-Solutions/blob/master/Python/design-skiplist.py
class SkipNode(object):
    def __init__(self, level=0, val=None):
        self.val = val
        self.nexts = [None]*level
        self.prevs = [None]*level

class SkipList(object):
    P_NUMERATOR, P_DENOMINATOR = 1, 2  # P = 1/4 in redis implementation
    MAX_LEVEL = 32  # enough for 2^32 elements

    def __init__(self, end=float("inf"), can_duplicated=False):
        random.seed(0)
        self.__head = SkipNode()
        self.__len = 0
        self.__can_duplicated = can_duplicated
        self.add(end)
    
    def lower_bound(self, target):
        return self.__lower_bound(target, self.__find_prev_nodes(target))

    def find(self, target):
        return self.__find(target, self.__find_prev_nodes(target))
        
    def add(self, val):
        if not self.__can_duplicated and self.find(val):
            return False
        node = SkipNode(self.__random_level(), val)
        if len(self.__head.nexts) &lt; len(node.nexts): 
            self.__head.nexts.extend([None]*(len(node.nexts)-len(self.__head.nexts)))
        prevs = self.__find_prev_nodes(val)
        for i in xrange(len(node.nexts)):
            node.nexts[i] = prevs[i].nexts[i]
            if prevs[i].nexts[i]:
                prevs[i].nexts[i].prevs[i] = node
            prevs[i].nexts[i] = node
            node.prevs[i] = prevs[i]
        self.__len += 1
        return True

    def remove(self, val):
        prevs = self.__find_prev_nodes(val)
        curr = self.__find(val, prevs)
        if not curr:
            return False
        self.__len -= 1   
        for i in reversed(xrange(len(curr.nexts))):
            prevs[i].nexts[i] = curr.nexts[i]
            if curr.nexts[i]:
                curr.nexts[i].prevs[i] = prevs[i]
            if not self.__head.nexts[i]:
                self.__head.nexts.pop()
        return True
    
    def __lower_bound(self, val, prevs):
        if prevs:
            candidate = prevs[0].nexts[0]
            if candidate:
                return candidate
        return None

    def __find(self, val, prevs):
        candidate = self.__lower_bound(val, prevs)
        if candidate and candidate.val == val:
            return candidate
        return None

    def __find_prev_nodes(self, val):
        prevs = [None]*len(self.__head.nexts)
        curr = self.__head
        for i in reversed(xrange(len(self.__head.nexts))):
            while curr.nexts[i] and curr.nexts[i].val &lt; val:
                curr = curr.nexts[i]
            prevs[i] = curr
        return prevs

    def __random_level(self):
        level = 1
        while random.randint(1, SkipList.P_DENOMINATOR) &lt;= SkipList.P_NUMERATOR and \
              level &lt; SkipList.MAX_LEVEL:
            level += 1
        return level

    def __len__(self):
        return self.__len-1  # excluding end node
    
    def __str__(self):
        result = []
        for i in reversed(xrange(len(self.__head.nexts))):
            result.append([])
            curr = self.__head.nexts[i]
            while curr:
                result[-1].append(str(curr.val))
                curr = curr.nexts[i]
        return "\n".join(map(lambda x: "-&gt;".join(x), result))

    
class TweetCounts(object):

    def __init__(self):
        self.__records = collections.defaultdict(lambda: SkipList(can_duplicated=True))
        self.__lookup = {"minute":60, "hour":3600, "day":86400}

    def recordTweet(self, tweetName, time):
        """
        :type tweetName: str
        :type time: int
        :rtype: None
        """
        self.__records[tweetName].add(time)

    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):
        """
        :type freq: str
        :type tweetName: str
        :type startTime: int
        :type endTime: int
        :rtype: List[int]
        """
        delta = self.__lookup[freq]
        result = [0]*((endTime-startTime)//delta+1)
        it = self.__records[tweetName].lower_bound(startTime)
        while it is not None and it.val &lt;= endTime:
            result[(it.val-startTime)//delta] += 1
            it = it.nexts[0]
        return result


# Time:  add:   O(n),
#        query: O(rlogn), r is the size of result
# Space: O(n)
import bisect
class TweetCounts2(object):

    def __init__(self):
        self.__records = collections.defaultdict(list)
        self.__lookup = {"minute":60, "hour":3600, "day":86400}

    def recordTweet(self, tweetName, time):
        """
        :type tweetName: str
        :type time: int
        :rtype: None
        """
        bisect.insort(self.__records[tweetName], time)

    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):
        """
        :type freq: str
        :type tweetName: str
        :type startTime: int
        :type endTime: int
        :rtype: List[int]
        """
        delta = self.__lookup[freq]
        i = startTime
        result = []
        while i &lt;= endTime:
            j = min(i+delta, endTime+1)
            result.append(bisect.bisect_left(self.__records[tweetName], j) - \
                          bisect.bisect_left(self.__records[tweetName], i))
            i += delta
        return result

    
# Time:  add:   O(1),
#        query: O(n)
# Space: O(n)
class TweetCounts3(object):

    def __init__(self):
        self.__records = collections.defaultdict(list)
        self.__lookup = {"minute":60, "hour":3600, "day":86400}

    def recordTweet(self, tweetName, time):
        """
        :type tweetName: str
        :type time: int
        :rtype: None
        """
        self.__records[tweetName].append(time)

    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):
        """
        :type freq: str
        :type tweetName: str
        :type startTime: int
        :type endTime: int
        :rtype: List[int]
        """
        delta = self.__lookup[freq]
        result = [0]*((endTime- startTime)//delta+1)
        for t in self.__records[tweetName]:
            if startTime &lt;= t &lt;= endTime:
                result[(t-startTime)//delta] += 1
        return result

```



----------------------------------------------------------------------------------------

### Design - 1352 - https://leetcode.com/problems/product-of-the-last-k-numbers/
Time: ctor: O(1)add: O(1)get: O(1)  Space: O(n)   Medium
.Python/product-of-the-last-k-numbers.py


```python
# Time:  ctor: O(1)
#        add : O(1)
#        get : O(1)
# Space: O(n)

class ProductOfNumbers(object):

    def __init__(self):
        self.__accu = [1]

    def add(self, num):
        """
        :type num: int
        :rtype: None
        """
        if not num:
            self.__accu = [1]
            return
        self.__accu.append(self.__accu[-1]*num)             

    def getProduct(self, k):
        """
        :type k: int
        :rtype: int
        """
        if len(self.__accu) &lt;= k:
            return 0
        return self.__accu[-1] // self.__accu[-1-k]

```



----------------------------------------------------------------------------------------

### Design - 1357 - https://leetcode.com/problems/apply-discount-every-n-orders/
Time: ctor: O(m)getBill: O(p)  Space: O(m)   Medium
.Python/apply-discount-every-n-orders.py


```python
# Time:  ctor:    O(m), m is the number of all products
#        getBill: O(p), p is the number of products to bill
# Space: O(m)

class Cashier(object):

    def __init__(self, n, discount, products, prices):
        """
        :type n: int
        :type discount: int
        :type products: List[int]
        :type prices: List[int]
        """
        self.__n = n
        self.__discount = discount
        self.__curr = 0
        self.__lookup = {p : prices[i] for i, p in enumerate(products)}

    def getBill(self, product, amount):
        """
        :type product: List[int]
        :type amount: List[int]
        :rtype: float
        """
        self.__curr = (self.__curr+1) % self.__n
        result = 0.0
        for i, p in enumerate(product):
            result += self.__lookup[p]*amount[i]
        return result * (1.0 - self.__discount/100.0 if self.__curr == 0 else 1.0)

```



----------------------------------------------------------------------------------------

### Design - 1381 - https://leetcode.com/problems/design-a-stack-with-increment-operation/
Time: ctor: O(1)push: O(1)pop: O(1)increment: O(1)  Space: O(n)   Medium
.Python/design-a-stack-with-increment-operation.py


```python
# Time:  cotr:      O(1)
#        push:      O(1)
#        pop:       O(1)
#        increment: O(1)
# Space: O(n)

class CustomStack(object):

    def __init__(self, maxSize):
        """
        :type maxSize: int
        """
        self.__max_size = maxSize
        self.__stk = []

    def push(self, x):
        """
        :type x: int
        :rtype: None
        """
        if len(self.__stk) == self.__max_size:
            return
        self.__stk.append([x, 0])

    def pop(self):
        """
        :rtype: int
        """
        if not self.__stk:
            return -1
        x, inc = self.__stk.pop()
        if self.__stk:
            self.__stk[-1][1] += inc
        return x + inc

    def increment(self, k, val):
        """
        :type k: int
        :type val: int
        :rtype: None
        """
        i = min(len(self.__stk), k)-1
        if i &gt;= 0:
            self.__stk[i][1] += val

```



----------------------------------------------------------------------------------------

### Design - 1396 - https://leetcode.com/problems/design-underground-system/
Time: ctor: O(1)checkin: O(1)checkout: O(1)getaverage: O(1)  Space: O(n)   Medium
.Python/design-underground-system.py


```python
# Time:  ctor:       O(1)
#        checkin:    O(1)
#        checkout:   O(1)
#        getaverage: O(1)
# Space: O(n)

import collections


class UndergroundSystem(object):

    def __init__(self):
        self.__live = {}
        self.__statistics = collections.defaultdict(lambda: [0, 0])
        

    def checkIn(self, id, stationName, t):
        """
        :type id: int
        :type stationName: str
        :type t: int
        :rtype: None
        """
        self.__live[id] = (stationName, t)

    def checkOut(self, id, stationName, t):
        """
        :type id: int
        :type stationName: str
        :type t: int
        :rtype: None
        """
        startStation, startTime = self.__live.pop(id)
        self.__statistics[startStation, stationName][0] += t-startTime
        self.__statistics[startStation, stationName][1] += 1
        
    def getAverageTime(self, startStation, endStation):
        """
        :type startStation: str
        :type endStation: str
        :rtype: float
        """
        total_time, cnt = self.__statistics[startStation, endStation]
        return float(total_time) / cnt

```



----------------------------------------------------------------------------------------

### Design - 1429 - https://leetcode.com/problems/first-unique-number/
Time: ctor: O(k)add: O(1)showFirstUnique: O(1)  Space: O(n)   Medium
.Python/first-unique-number.py


```python
# Time:  ctor: O(k)
#        add: O(1)
#        showFirstUnique: O(1)
# Space: O(n)

import collections


class FirstUnique(object):

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.__q = collections.OrderedDict()
        self.__dup = set()
        for num in nums:
            self.add(num)

    def showFirstUnique(self):
        """
        :rtype: int
        """
        if self.__q:
            return next(iter(self.__q))
        return -1
    
    def add(self, value):
        """
        :type value: int
        :rtype: None
        """
        if value not in self.__dup and value not in self.__q:
            self.__q[value] = None
            return
        if value in self.__q:
            self.__q.pop(value)
            self.__dup.add(value)

```



----------------------------------------------------------------------------------------

### Design - 1472 - https://leetcode.com/problems/design-browser-history/
Time: ctor: O(1)visit: O(1)back: O(1)forward: O(1)  Space: O(n)   Medium
.Python/design-browser-history.py


```python
# Time:  ctor  : O(1)
#        visit : O(n)
#        back  : O(1)
#        foward: O(1)
# Space: O(n)

class BrowserHistory(object):

    def __init__(self, homepage):
        """
        :type homepage: str
        """
        self.__history = [homepage]
        self.__curr = 0        

    def visit(self, url):
        """
        :type url: str
        :rtype: None
        """
        while len(self.__history) &gt; self.__curr+1:
            self.__history.pop()
        self.__history.append(url)
        self.__curr += 1

    def back(self, steps):
        """
        :type steps: int
        :rtype: str
        """
        self.__curr = max(self.__curr-steps, 0)
        return self.__history[self.__curr]

    def forward(self, steps):
        """
        :type steps: int
        :rtype: str
        """
        self.__curr = min(self.__curr+steps, len(self.__history)-1)
        return self.__history[self.__curr]

```



----------------------------------------------------------------------------------------

### Design - 1476 - https://leetcode.com/problems/subrectangle-queries/
Time: ctor: O(1)update: O(1)get: O(u)  Space: O(u)   Medium
.Python/subrectangle-queries.py


```python
# Time:  ctor:   O(1)
#        update: O(1)
#        get:    O(u), u is the number of updates
# Space: O(u)

class SubrectangleQueries(object):

    def __init__(self, rectangle):
        """
        :type rectangle: List[List[int]]
        """
        self.__rectangle = rectangle
        self.__updates = []
        

    def updateSubrectangle(self, row1, col1, row2, col2, newValue):
        """
        :type row1: int
        :type col1: int
        :type row2: int
        :type col2: int
        :type newValue: int
        :rtype: None
        """
        self.__updates.append((row1, col1, row2, col2, newValue))

    def getValue(self, row, col):
        """
        :type row: int
        :type col: int
        :rtype: int
        """
        for (row1, col1, row2, col2, newValue) in reversed(self.__updates):
            if row1 &lt;= row &lt;= row2 and col1 &lt;= col &lt;= col2:
                return newValue
        return self.__rectangle[row][col]


# Time:  ctor:   O(1)
#        update: O(m * n)
#        get:    O(1)
# Space: O(1)
class SubrectangleQueries2(object):

    def __init__(self, rectangle):
        """
        :type rectangle: List[List[int]]
        """
        self.__rectangle = rectangle
        

    def updateSubrectangle(self, row1, col1, row2, col2, newValue):
        """
        :type row1: int
        :type col1: int
        :type row2: int
        :type col2: int
        :type newValue: int
        :rtype: None
        """
        for r in xrange(row1, row2+1):
            for c in xrange(col1, col2+1):
                self.__rectangle[r][c] = newValue

    def getValue(self, row, col):
        """
        :type row: int
        :type col: int
        :rtype: int
        """
        return self.__rectangle[row][col]

```



----------------------------------------------------------------------------------------

### Design - 1483 - https://leetcode.com/problems/kth-ancestor-of-a-tree-node/
Time: ctor: O(n * logh)get: O(logh)  Space: O(n * logh)   Hard
.Python/kth-ancestor-of-a-tree-node.py


```python
# Time:  ctor: O(n * logh)
#        get:  O(logh)
# Space: O(n * logh)

# binary jump solution (frequently used in competitive programming)
# Template:
# https://github.com/kamyu104/FacebookHackerCup-2019/blob/master/Final%20Round/little_boat_on_the_sea.py
class TreeAncestor(object):

    def __init__(self, n, parent):
        """
        :type n: int
        :type parent: List[int]
        """
        par = [[p] if p != -1 else [] for p in parent]
        q = [par[i] for i, p in enumerate(parent) if p != -1]
        i = 0
        while q:
            new_q = []
            for p in q:
                if not (i &lt; len(par[p[i]])):
                    continue
                p.append(par[p[i]][i])
                new_q.append(p)
            q = new_q
            i += 1
        self.__parent = par

    def getKthAncestor(self, node, k):
        """
        :type node: int
        :type k: int
        :rtype: int
        """
        par, i, pow_i_of_2 = self.__parent, 0, 1
        while pow_i_of_2 &lt;= k:
            if k &amp; pow_i_of_2:
                if not (i &lt; len(par[node])):
                    return -1
                node = par[node][i]
            i += 1
            pow_i_of_2 *= 2
        return node

```



----------------------------------------------------------------------------------------

### Design - 1500 - https://leetcode.com/problems/design-a-file-sharing-system/
Time: ctor: O(1)join: O(logu + c)leave: O(logu + c)request: O(u)  Space: O(u * c)   Medium
.Python/design-a-file-sharing-system.py


```python
# Time:  ctor:    O(1)
#        join:    O(logu + c), u is the number of total joined users
#        leave:   O(logu + c), c is the number of chunks
#        request: O(u)
# Space: O(u * c)

import heapq


# "u ~= n" solution, n is the average number of users who own the chunk
class FileSharing(object):

    def __init__(self, m):
        """
        :type m: int
        """
        self.__users = []
        self.__lookup = set()
        self.__min_heap = []

    def join(self, ownedChunks):
        """
        :type ownedChunks: List[int]
        :rtype: int
        """
        if self.__min_heap:
            userID = heapq.heappop(self.__min_heap)
        else:
            userID = len(self.__users)+1
            self.__users.append(set())
        self.__users[userID-1] = set(ownedChunks)
        self.__lookup.add(userID)
        return userID

    def leave(self, userID):
        """
        :type userID: int
        :rtype: None
        """
        if userID not in self.__lookup:
            return
        self.__lookup.remove(userID)
        self.__users[userID-1] = []
        heapq.heappush(self.__min_heap, userID)

    def request(self, userID, chunkID):
        """
        :type userID: int
        :type chunkID: int
        :rtype: List[int]
        """
        result = []
        for u, chunks in enumerate(self.__users, 1):
            if chunkID not in chunks:
                continue
            result.append(u)
        if not result:
            return
        self.__users[userID-1].add(chunkID)
        return result


# Time:  ctor:    O(1)
#        join:    O(logu + c), u is the number of total joined users
#        leave:   O(logu + c), c is the number of chunks
#        request: O(nlogn)   , n is the average number of users who own the chunk
# Space: O(u * c + m), m is the total number of unique chunks
import collections
import heapq


# "u &gt;&gt; n" solution
class FileSharing2(object):

    def __init__(self, m):
        """
        :type m: int
        """
        self.__users = []
        self.__lookup = set() 
        self.__chunks = collections.defaultdict(set)
        self.__min_heap = []

    def join(self, ownedChunks):
        """
        :type ownedChunks: List[int]
        :rtype: int
        """
        if self.__min_heap:
            userID = heapq.heappop(self.__min_heap)
        else:
            userID = len(self.__users)+1
            self.__users.append(set())
        self.__users[userID-1] = set(ownedChunks)
        self.__lookup.add(userID)
        for c in ownedChunks:
            self.__chunks[c].add(userID)
        return userID

    def leave(self, userID):
        """
        :type userID: int
        :rtype: None
        """
        if userID not in self.__lookup:
            return
        for c in self.__users[userID-1]:
            self.__chunks[c].remove(userID)
        self.__lookup.remove(userID)
        self.__users[userID-1] = []
        heapq.heappush(self.__min_heap, userID)

    def request(self, userID, chunkID):
        """
        :type userID: int
        :type chunkID: int
        :rtype: List[int]
        """
        result = sorted(self.__chunks[chunkID])
        if not result:
            return
        self.__users[userID-1].add(chunkID)
        self.__chunks[chunkID].add(userID)
        return result

```



----------------------------------------------------------------------------------------

### Design - 1570 - https://leetcode.com/problems/dot-product-of-two-sparse-vectors/
Time: ctor: O(n)dot_product: O(min(n, m))  Space: O(n)   Medium
.Python/dot-product-of-two-sparse-vectors.py


```python
# Time:  ctor: O(n)
#        dot_product: O(min(n, m))
# Space: O(n)

class SparseVector:
    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.lookup = {i:v for i, v in enumerate(nums) if v}

    def dotProduct(self, vec):
        """
        :type vec: 'SparseVector'
        :rtype: int
        """
        if len(self.lookup) &gt; len(vec.lookup):
            self, vec = vec, self
        return sum(v*vec.lookup[i] for i, v in self.lookup.iteritems() if i in vec.lookup)

```



----------------------------------------------------------------------------------------

### Design - 1586 - https://leetcode.com/problems/binary-search-tree-iterator-ii/
Time: O(1), amortized  Space: O(h)   Medium
.Python/binary-search-tree-iterator-ii.py


```python
# Time:  O(1), amortized
# Space: O(h)

# Definition for a binary tree node.
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class BSTIterator(object):

    def __init__(self, root):
        """
        :type root: TreeNode
        """
        self.__stk = []
        self.__traversalLeft(root)
        self.__vals = []
        self.__pos = -1

    def hasNext(self):
        """
        :rtype: bool
        """
        return self.__pos+1 != len(self.__vals) or self.__stk

    def next(self):
        """
        :rtype: int
        """
        self.__pos += 1
        if self.__pos == len(self.__vals):
            node = self.__stk.pop()
            self.__traversalLeft(node.right)
            self.__vals.append(node.val)
        return self.__vals[self.__pos]
        
    def hasPrev(self):
        """
        :rtype: bool
        """
        return self.__pos-1 &gt;= 0

    def prev(self):
        """
        :rtype: int
        """
        self.__pos -= 1
        return self.__vals[self.__pos]
    
    def __traversalLeft(self, node):
        while node is not None:
            self.__stk.append(node)
            node = node.left

```



----------------------------------------------------------------------------------------

### Design - 1600 - https://leetcode.com/problems/throne-inheritance/
Time: ctor: O(1)birth: O(1)death: O(1)inherit: O(n)  Space: O(n)   Medium
.Python/throne-inheritance.py


```python
# Time:  ctor:    O(1)
#        birth:   O(1)
#        death:   O(1)
#        inherit: O(n)
# Space: O(n)

import collections


class ThroneInheritance(object):

    def __init__(self, kingName):
        """
        :type kingName: str
        """
        self.__king = kingName
        self.__family_tree = collections.defaultdict(list)
        self.__dead = set()
        

    def birth(self, parentName, childName):
        """
        :type parentName: str
        :type childName: str
        :rtype: None
        """
        self.__family_tree[parentName].append(childName)


    def death(self, name):
        """
        :type name: str
        :rtype: None
        """
        self.__dead.add(name)
        
    
    def getInheritanceOrder(self):
        """
        :rtype: List[str]
        """
        result = []
        stk = [self.__king]
        while stk:  # preorder traversal
            node = stk.pop()
            if node not in self.__dead:
                result.append(node)
            if node not in self.__family_tree:
                continue
            for child in reversed(self.__family_tree[node]):
                stk.append(child)
        return result

```



----------------------------------------------------------------------------------------

### Design - 1603 - https://leetcode.com/problems/design-parking-system/
Time: O(1)  Space: O(1)   Easy
.Python/design-parking-system.py


```python
# Time:  O(1)
# Space: O(1)

class ParkingSystem(object):

    def __init__(self, big, medium, small):
        """
        :type big: int
        :type medium: int
        :type small: int
        """
        self.__space = [0, big, medium, small]

    def addCar(self, carType):
        """
        :type carType: int
        :rtype: bool
        """
        if self.__space[carType] &gt; 0:
            self.__space[carType] -= 1
            return True
        return False

```



----------------------------------------------------------------------------------------

### Design - 1622 - https://leetcode.com/problems/fancy-sequence/
Time: O(1)  Space: O(n)   Hard
.Python/fancy-sequence.py


```python
# Time:  O(1)
# Space: O(n)

MOD = 10**9+7

class Fancy(object):

    def __init__(self):
        self.__arr = []
        self.__ops = [[1, 0]]

    def append(self, val):
        """
        :type val: int
        :rtype: None
        """
        self.__arr.append(val)
        self.__ops.append(self.__ops[-1][:])

    def addAll(self, inc):
        """
        :type inc: int
        :rtype: None
        """
        self.__ops[-1][1] = (self.__ops[-1][1]+inc) % MOD

    def multAll(self, m):
        """
        :type m: int
        :rtype: None
        """
        self.__ops[-1] = [(self.__ops[-1][0]*m) % MOD, (self.__ops[-1][1]*m) % MOD]

    def getIndex(self, idx):
        """
        :type idx: int
        :rtype: int
        """
        if idx &gt;= len(self.__arr):
            return -1
        a1, b1 = self.__ops[idx]
        a2, b2 = self.__ops[-1]
        a = a2*pow(a1, MOD-2, MOD)%MOD  # O(logMOD), we treat it as O(1) here
        b = (b2 - b1*a) % MOD
        return (self.__arr[idx]*a + b) % MOD


# Time:  O(1)
# Space: O(n)
class Fancy2(object):

    def __init__(self):
        self.__arr = []
        self.__op = [1, 0]

    def append(self, val):
        """
        :type val: int
        :rtype: None
        """
        self.__arr.append((val-self.__op[1])*pow(self.__op[0], MOD-2, MOD)%MOD)  # O(logMOD), we treat it as O(1) here

    def addAll(self, inc):
        """
        :type inc: int
        :rtype: None
        """
        self.__op[1] = (self.__op[1]+inc) % MOD

    def multAll(self, m):
        """
        :type m: int
        :rtype: None
        """
        self.__op = [(self.__op[0]*m) % MOD, (self.__op[1]*m) % MOD]

    def getIndex(self, idx):
        """
        :type idx: int
        :rtype: int
        """
        if idx &gt;= len(self.__arr):
            return -1
        a, b = self.__op
        return (self.__arr[idx]*a + b) % MOD

```



----------------------------------------------------------------------------------------

### Design - 1628 - https://leetcode.com/problems/design-an-expression-tree-with-evaluate-function/
Time: O(n)  Space: O(h)   Medium
.Python/design-an-expression-tree-with-evaluate-function.py


```python
# Time:  O(n)
# Space: O(h)

import abc 
from abc import ABCMeta, abstractmethod 


class Node:
    __metaclass__ = ABCMeta
    # define your fields here
    @abstractmethod
    def evaluate(self):
        pass


import operator


class NodeIter(Node):
    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
    
    def __init__(self, val):
        self.val = val
        self.left = None 
        self.right = None
    
    def evaluate(self):
        result = [0]
        stk = [(1, (self, result))]
        while stk:
            step, args = stk.pop()
            if step == 1:
                node, ret = args
                if node.val.isdigit():
                    ret[0] = int(node.val)
                    continue
                ret1, ret2 = [0], [0]
                stk.append((2, (node, ret1, ret2, ret)))
                stk.append((1, (node.right, ret2)))
                stk.append((1, (node.left, ret1)))
            elif step == 2:
                node, ret1, ret2, ret = args
                ret[0] = NodeIter.ops[node.val](ret1[0], ret2[0])
        return result[0]


class TreeBuilder(object):
    def buildTree(self, postfix):
        """
        :type s: List[str]
        :rtype: int
        """
        stk = []
        for c in postfix:
            if c.isdigit():
                stk.append(NodeIter(c))
            else:
                node = NodeIter(c)
                node.right = stk.pop()
                node.left = stk.pop()
                stk.append(node)                
        return stk.pop()


# Time:  O(n)
# Space: O(h)
class NodeRecu(Node):
    ops = {'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.div}
    
    def __init__(self, val):
        self.val = val
        self.left = None 
        self.right = None

    def evaluate(self):
        if self.val.isdigit():
            return int(self.val)
        return NodeRecu.ops[self.val](self.left.evaluate(), self.right.evaluate())
        

class TreeBuilder2(object):
    def buildTree(self, postfix):
        """
        :type s: List[str]
        :rtype: int
        """
        stk = []
        for c in postfix:
            if c.isdigit():
                stk.append(NodeRecu(c))
            else:
                node = NodeRecu(c)
                node.right = stk.pop()
                node.left = stk.pop()
                stk.append(node)
        return stk.pop()

```



----------------------------------------------------------------------------------------

### Design - 1656 - https://leetcode.com/problems/design-an-ordered-stream/
Time: O(1), amortized  Space: O(n)   Easy
.Python/design-an-ordered-stream.py


```python
# Time:  O(1), amortized
# Space: O(n)

class OrderedStream(object):

    def __init__(self, n):
        """
        :type n: int
        """
        self.__i = 0      
        self.__values = [None]*n

    def insert(self, id, value):
        """
        :type id: int
        :type value: str
        :rtype: List[str]
        """
        id -= 1
        self.__values[id] = value
        result = []
        if self.__i != id:
            return result
        while self.__i &lt; len(self.__values) and self.__values[self.__i]:
            result.append(self.__values[self.__i])
            self.__i += 1
        return result

```



----------------------------------------------------------------------------------------

### Design - 1670 - https://leetcode.com/problems/design-front-middle-back-queue/
Time: O(1)  Space: O(n)   Medium
.Python/design-front-middle-back-queue.py


```python
# Time:  O(1)
# Space: O(n)

import collections


class FrontMiddleBackQueue(object):

    def __init__(self):
        self.__left, self.__right = collections.deque(), collections.deque()   

    def pushFront(self, val):
        """
        :type val: int
        :rtype: None
        """
        self.__left.appendleft(val)
        self.__balance()        

    def pushMiddle(self, val):
        """
        :type val: int
        :rtype: None
        """
        if len(self.__left) &gt; len(self.__right):
            self.__right.appendleft(self.__left.pop())
        self.__left.append(val)

    def pushBack(self, val):
        """
        :type val: int
        :rtype: None
        """
        self.__right.append(val)
        self.__balance()

    def popFront(self):
        """
        :rtype: int
        """
        val = (self.__left or collections.deque([-1])).popleft()
        self.__balance()
        return val

    def popMiddle(self):
        """
        :rtype: int
        """
        val = (self.__left or [-1]).pop()
        self.__balance()
        return val

    def popBack(self):
        """
        :rtype: int
        """
        val = (self.__right or self.__left or [-1]).pop()
        self.__balance()
        return val

    def __balance(self):
        if len(self.__left) &gt; len(self.__right)+1:
            self.__right.appendleft(self.__left.pop())
        elif len(self.__left) &lt; len(self.__right):
            self.__left.append(self.__right.popleft())

```



----------------------------------------------------------------------------------------

### Design - 1756 - https://leetcode.com/problems/design-most-recently-used-queue/
Time: ctor: O(nlogn)fetch: O(logn)  Space: O(n)   Medium
.Python/design-most-recently-used-queue.py


```python
# Time:  ctor:  O(nlogn)
# Space: fetch: O(logn)

from sortedcontainers import SortedList


# balanced bst solution
class MRUQueue(object):

    def __init__(self, n):
        """
        :type n: int
        """
        self.__sl = SortedList((i-1, i) for i in xrange(1, n+1))  

    def fetch(self, k):
        """
        :type k: int
        :rtype: int
        """
        last, _ = self.__sl[-1]
        _, val = self.__sl.pop(k-1)
        self.__sl.add((last+1, val))
        return val


# Time:  ctor:  O(n + m), m is the max number of calls
# Space: fetch: O(log(n + m))
class BIT(object):  # 0-indexed.
    def __init__(self, n):
        MAX_CALLS = 2000
        self.__bit = [0]*(n+MAX_CALLS+1)  # Extra one for dummy node.
        for i in xrange(1, len(self.__bit)):
            self.__bit[i] = (1 if i-1 &lt; n else 0) + self.__bit[i-1]
        for i in reversed(xrange(1, len(self.__bit))):
            last_i = i - (i &amp; -i)
            self.__bit[i] -= self.__bit[last_i]

    def add(self, i, val):
        i += 1  # Extra one for dummy node.
        while i &lt; len(self.__bit):
            self.__bit[i] += val
            i += (i &amp; -i)

    def query(self, i):
        i += 1  # Extra one for dummy node.
        ret = 0
        while i &gt; 0:
            ret += self.__bit[i]
            i -= (i &amp; -i)
        return ret

    def binary_lift(self, k):
        floor_log2_n = (len(self.__bit)-1).bit_length()-1
        pow_i = 2**floor_log2_n
        total = pos = 0  # 1-indexed
        for i in reversed(xrange(floor_log2_n+1)):  # O(logN)
            if pos+pow_i &lt; len(self.__bit) and not (total+self.__bit[pos+pow_i] &gt;= k):
                total += self.__bit[pos+pow_i]
                pos += pow_i
            pow_i &gt;&gt;= 1
        return (pos+1)-1  # 0-indexed


# fenwick / bit solution
class MRUQueue2(object):

    def __init__(self, n):
        """
        :type n: int
        """
        self.__bit = BIT(n)
        self.__lookup = {i:i+1 for i in xrange(n)}
        self.__curr = n
        
    def fetch(self, k):
        """
        :type k: int
        :rtype: int
        """
        pos = self.__bit.binary_lift(k)  
        val = self.__lookup.pop(pos)
        self.__bit.add(pos, -1)
        self.__bit.add(self.__curr, 1)
        self.__lookup[self.__curr] = val     
        self.__curr += 1
        return val


# Time:  ctor:  O(n)
# Space: fetch: O(sqrt(n))
import collections
import math


# sqrt decomposition solution
class MRUQueue3(object):

    def __init__(self, n):
        """
        :type n: int
        """
        self.__buckets = [collections.deque() for _ in xrange(int(math.ceil(n**0.5)))]
        for i in xrange(n):
            self.__buckets[i//len(self.__buckets)].append(i+1)

    def fetch(self, k):
        """
        :type k: int
        :rtype: int
        """
        k -= 1
        left, idx = divmod(k, len(self.__buckets))
        val = self.__buckets[left][idx]
        del self.__buckets[left][idx]
        self.__buckets[-1].append(val)
        for i in reversed(xrange(left, len(self.__buckets)-1)):
            x = self.__buckets[i+1].popleft()
            self.__buckets[i].append(x)
        return val

```



----------------------------------------------------------------------------------------

### Design - 1797 - https://leetcode.com/problems/design-authentication-manager/
Time: ctor: O(1)generate: O(1), amortizedrenew: O(1), amortizedcount: O(1), amortized  Space: O(n)   Medium
.Python/design-authentication-manager.py


```python
# Time:  ctor:     O(1)
#        generate: O(1), amortized
#        renew:    O(1), amortized
#        count:    O(1), amortized
# Space: O(n)

import collections


class AuthenticationManager(object):

    def __init__(self, timeToLive):
        """
        :type timeToLive: int
        """
        self.__time = timeToLive
        self.__lookup = collections.OrderedDict()

    def __evict(self, currentTime):
        while self.__lookup and next(self.__lookup.itervalues()) &lt;= currentTime:
            self.__lookup.popitem(last=False)

    def generate(self, tokenId, currentTime):
        """
        :type tokenId: str
        :type currentTime: int
        :rtype: None
        """
        self.__evict(currentTime)
        self.__lookup[tokenId] = currentTime + self.__time


    def renew(self, tokenId, currentTime):
        """
        :type tokenId: str
        :type currentTime: int
        :rtype: None
        """
        self.__evict(currentTime)            
        if tokenId not in self.__lookup:
            return
        del self.__lookup[tokenId]
        self.__lookup[tokenId] = currentTime + self.__time

    def countUnexpiredTokens(self, currentTime):
        """
        :type currentTime: int
        :rtype: int
        """
        self.__evict(currentTime)
        return len(self.__lookup)

```



----------------------------------------------------------------------------------------

### Design - 1804 - https://leetcode.com/problems/implement-trie-ii-prefix-tree/
Time: ctor: O(1)insert: O(n)count_word: O(n)count_prefix: O(n)erase: O(n)  Space: O(t)   Medium
.Python/implement-trie-ii-prefix-tree.py


```python
# Time:  ctor:         O(1)
#        insert:       O(n)
#        count_word:   O(n)
#        count_prefix: O(n)
#        erase:        O(n)
# Space: O(t), t is the number of nodes in trie

class Node:
    def __init__(self):
        self.children = [None]*26
        self.pcnt = 0
        self.cnt = 0

class Trie(object):

    def __init__(self):
        self.__trie = Node()

    def insert(self, word):
        """
        :type word: str
        :rtype: None
        """
        curr = self.__trie
        curr.pcnt += 1
        for c in word:
            if curr.children[ord(c)-ord('a')] is None:
                curr.children[ord(c)-ord('a')] = Node()
            curr = curr.children[ord(c)-ord('a')]
            curr.pcnt += 1
        curr.cnt += 1

    def countWordsEqualTo(self, word):
        """
        :type word: str
        :rtype: int
        """
        curr = self.__trie
        for c in word:
            if curr.children[ord(c)-ord('a')] is None:
                return 0
            curr = curr.children[ord(c)-ord('a')]
        return curr.cnt

    def countWordsStartingWith(self, prefix):
        """
        :type prefix: str
        :rtype: int
        """
        curr = self.__trie
        for c in prefix:
            if curr.children[ord(c)-ord('a')] is None:
                return 0
            curr = curr.children[ord(c)-ord('a')]
        return curr.pcnt

    def erase(self, word):
        """
        :type word: str
        :rtype: None
        """
        cnt = self.countWordsEqualTo(word)
        if not cnt:
            return
        curr = self.__trie
        curr.pcnt -= 1
        for c in word:
            if curr.children[ord(c)-ord('a')].pcnt == 1:
                curr.children[ord(c)-ord('a')] = None  # delete all unused nodes
                return
            curr = curr.children[ord(c)-ord('a')]
            curr.pcnt -= 1
        curr.cnt -= 1

```



----------------------------------------------------------------------------------------

### Design - 1825 - https://leetcode.com/problems/finding-mk-average/
Time: ctor: O(1)add_element: O(logn)calc_mkaverge: O(1)  Space: O(m)   Hard
.Python/finding-mk-average.py


```python
# Time:  ctor:           O(1)
#        add_element:    O(logn)
#        calc_mkaverage: O(1)
# Space: O(m)

import collections
from sortedcontainers import SortedList


class MKAverage(object):

    def __init__(self, m, k):
        """
        :type m: int
        :type k: int
        """
        self.__m = m
        self.__k = k
        self.__dq = collections.deque()
        self.__sl = SortedList()
        self.__total = self.__first_k = self.__last_k = 0

    def addElement(self, num):
        """
        :type num: int
        :rtype: None
        """
        if len(self.__dq) == self.__m:
            self.__remove(self.__dq.popleft())
        self.__dq.append(num)
        self.__add(num)

    def calculateMKAverage(self):
        """
        :rtype: int
        """
        if len(self.__sl) &lt; self.__m:
            return -1
        return (self.__total-self.__first_k-self.__last_k)//(self.__m-2*self.__k)

    def __add(self, num):
        self.__total += num
        idx = self.__sl.bisect_left(num)
        if idx &lt; self.__k:
            self.__first_k += num
            if len(self.__sl) &gt;= self.__k:
                self.__first_k -= self.__sl[self.__k-1]
        if idx &gt; len(self.__sl)-self.__k:
            self.__last_k += num
            if len(self.__sl) &gt;= self.__k:
                self.__last_k -= self.__sl[-self.__k]
        self.__sl.add(num)

    def __remove(self, num):
        self.__total -= num
        idx = self.__sl.index(num)
        if idx &lt; self.__k:
            self.__first_k -= num
            self.__first_k += self.__sl[self.__k]
        elif idx &gt; (len(self.__sl)-1)-self.__k:
            self.__last_k -= num
            self.__last_k += self.__sl[-1-self.__k]
        self.__sl.remove(num)

```



----------------------------------------------------------------------------------------

### Design - 1845 - https://leetcode.com/problems/seat-reservation-manager/
Time: ctor: O(n)reserve: O(logn)unreserve: O(logn)  Space: O(n)   Medium
.Python/seat-reservation-manager.py


```python
# Time:  ctor:      O(n)
#        reserve:   O(logn)
#        unreserve: O(logn)
# Space: O(n)

import heapq


class SeatManager(object):

    def __init__(self, n):
        """
        :type n: int
        """
        self.__min_heap = range(1, n+1)
        # heapq.heapify(self.__min_heap)  # no need for sorted list

    def reserve(self):
        """
        :rtype: int
        """
        return heapq.heappop(self.__min_heap)

    def unreserve(self, seatNumber):
        """
        :type seatNumber: int
        :rtype: None
        """
        heapq.heappush(self.__min_heap, seatNumber)

```



----------------------------------------------------------------------------------------

### Design - 1865 - https://leetcode.com/problems/finding-pairs-with-a-certain-sum/
Time: ctor: O(n1 + n2)add: O(1)count: O(n1)  Space: O(n1 + n2)   Medium
.Python/finding-pairs-with-a-certain-sum.py


```python
# Time:  ctor:  O(n1 + n2)
#        add:   O(1)
#        count: O(n1)
# Space: O(n1 + n2)

import collections


class FindSumPairs(object):

    def __init__(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        """
        self.__nums2 = nums2
        self.__count1 = collections.Counter(nums1)
        self.__count2 = collections.Counter(nums2)

    def add(self, index, val):
        """
        :type index: int
        :type val: int
        :rtype: None
        """
        self.__count2[self.__nums2[index]] -= 1
        self.__nums2[index] += val
        self.__count2[self.__nums2[index]] += 1


    def count(self, tot):
        """
        :type tot: int
        :rtype: int
        """
        return sum(cnt * self.__count2[tot-x] for x, cnt in self.__count1.iteritems())

```



----------------------------------------------------------------------------------------

### Design - 1912 - https://leetcode.com/problems/design-movie-rental-system/
Time: ctor: O(nlogn)search: O(logn)rent: O(logn)drop: O(logn)report: O(logn)  Space: O(n)   Hard
.Python/design-movie-rental-system.py


```python
# Time:  ctor:   O(nlogn)
#        search: O(logn)
#        rent:   O(logn)
#        drop:   O(logn)
#        report: O(logn)
# Space: O(n)

import collections
from sortedcontainers import SortedList


class MovieRentingSystem(object):

    def __init__(self, n, entries):
        """
        :type n: int
        :type entries: List[List[int]]
        """
        self.__movie_to_ordered_price_shop = collections.defaultdict(SortedList) 
        self.__shop_movie_to_price = {}
        self.__rented_ordered_price_shop_movie = SortedList()
        for s, m, p in entries:
            self.__movie_to_ordered_price_shop[m].add((p, s))
            self.__shop_movie_to_price[s, m] = p

    def search(self, movie):
        """
        :type movie: int
        :rtype: List[int]
        """
        return [s for _, s in self.__movie_to_ordered_price_shop[movie][:5]]

    def rent(self, shop, movie):
        """
        :type shop: int
        :type movie: int
        :rtype: None
        """
        price = self.__shop_movie_to_price[shop, movie]
        self.__movie_to_ordered_price_shop[movie].remove((price, shop))
        self.__rented_ordered_price_shop_movie.add((price, shop, movie))

    def drop(self, shop, movie):
        """
        :type shop: int
        :type movie: int
        :rtype: None
        """
        price = self.__shop_movie_to_price[shop, movie]
        self.__movie_to_ordered_price_shop[movie].add((price, shop))
        self.__rented_ordered_price_shop_movie.remove((price, shop, movie))

    def report(self):
        """
        :rtype: List[List[int]]
        """
        return [[s, m] for _, s, m in self.__rented_ordered_price_shop_movie[:5]]

```



----------------------------------------------------------------------------------------

### Design - 1993 - https://leetcode.com/problems/operations-on-tree/
Time: ctor: O(n)lock: O(1)unlock: O(1)upgrade: O(n)  Space: O(n)   Medium
.Python/operations-on-tree.py


```python
# Time:  ctor:    O(n)
#        lock:    O(1)
#        unlock:  O(1)
#        upgrade: O(n)
# Space: O(n)

class LockingTree(object):

    def __init__(self, parent):
        """
        :type parent: List[int]
        """
        self.__parent = parent
        self.__children = [[] for _ in xrange(len(parent))]
        for i, x in enumerate(parent):
            if x != -1:
                self.__children[x].append(i)
        self.__locked = {}

    def lock(self, num, user):
        """
        :type num: int
        :type user: int
        :rtype: bool
        """
        if num in self.__locked:
            return False
        self.__locked[num] = user
        return True

    def unlock(self, num, user):
        """
        :type num: int
        :type user: int
        :rtype: bool
        """
        if self.__locked.get(num) != user:
            return False
        del self.__locked[num]
        return True

    def upgrade(self, num, user):
        """
        :type num: int
        :type user: int
        :rtype: bool
        """
        node = num
        while node != -1:
            if node in self.__locked:
                return False
            node = self.__parent[node]
        result = False
        stk = [num]
        while stk:
            node = stk.pop()
            if node in self.__locked:
                del self.__locked[node]
                result = True
            for child in self.__children[node]:
                stk.append(child)
        if result:
            self.__locked[num] = user
        return result

```



----------------------------------------------------------------------------------------

### Design - 2013 - https://leetcode.com/problems/detect-squares/
Time: ctor: O(1)add: O(1)count: O(n)  Space: O(n)   Medium
.Python/detect-squares.py


```python
# Time:  ctor:  O(1)
#        add:   O(1)
#        count: O(n)
# Space: O(n)

import collections


class DetectSquares(object):

    def __init__(self):
        self.__x_to_ys = collections.defaultdict(set)
        self.__point_counts = collections.defaultdict(int)

    def add(self, point):
        """
        :type point: List[int]
        :rtype: None
        """
        self.__x_to_ys[point[0]].add(point[1])
        self.__point_counts[tuple(point)] += 1
        

    def count(self, point):
        """
        :type point: List[int]
        :rtype: int
        """
        result = 0
        for y in self.__x_to_ys[point[0]]:
            if y == point[1]:
                continue
            dy = y-point[1]
            result += self.__point_counts[(point[0], y)]*self.__point_counts[(point[0]+dy, point[1])]*self.__point_counts[(point[0]+dy, y)]
            result += self.__point_counts[(point[0], y)]*self.__point_counts[(point[0]-dy, point[1])]*self.__point_counts[(point[0]-dy, y)]
        return result 


# Time:  ctor:  O(1)
#        add:   O(1)
#        count: O(n)
# Space: O(n)
import collections


class DetectSquares2(object):

    def __init__(self):
        self.__points = []
        self.__point_counts = collections.defaultdict(int)

    def add(self, point):
        """
        :type point: List[int]
        :rtype: None
        """
        self.__points.append(point)
        self.__point_counts[tuple(point)] += 1

    def count(self, point):
        """
        :type point: List[int]
        :rtype: int
        """
        result = 0
        for x, y in self.__points:
            if not (point[0] != x and point[1] != y and (abs(point[0]-x) == abs(point[1]-y))):
                continue
            result += self.__point_counts[(point[0], y)]*self.__point_counts[(x, point[1])]
        return result

```



----------------------------------------------------------------------------------------

### Design - 2034 - https://leetcode.com/problems/stock-price-fluctuation/
Time: ctor: O(1)update: O(logn)current: O(1)max: O(1)min: O(1)  Space: O(n)   Medium
.Python/stock-price-fluctuation.py


```python
# Time:  ctor:    O(1)
#        update:  O(logn)
#        current: O(1)
#        max:     O(1)
#        min:     O(1)
# Space: O(n)

from sortedcontainers import SortedList


class StockPrice(object):

    def __init__(self):
        self.__curr = 0
        self.__lookup = {}
        self.__sl_by_price = SortedList()

    def update(self, timestamp, price):
        """
        :type timestamp: int
        :type price: int
        :rtype: None
        """
        if timestamp &gt; self.__curr:
            self.__curr = timestamp
        if timestamp in self.__lookup:
            self.__sl_by_price.remove(self.__lookup[timestamp])
        self.__lookup[timestamp] = price
        self.__sl_by_price.add(price)

    def current(self):
        """
        :rtype: int
        """
        return self.__lookup[self.__curr]

    def maximum(self):
        """
        :rtype: int
        """
        return next(reversed(self.__sl_by_price))

    def minimum(self):
        """
        :rtype: int
        """
        return next(iter(self.__sl_by_price))


# Time:  ctor:    O(1)
#        update:  O(logn)
#        current: O(1)
#        max:     O(logn) on average
#        min:     O(logn) on average
# Space: O(n)
import heapq


class StockPrice2(object):

    def __init__(self):
        self.__curr = 0
        self.__lookup = {}
        self.__min_heap = []
        self.__max_heap = []

    def update(self, timestamp, price):
        """
        :type timestamp: int
        :type price: int
        :rtype: None
        """
        def full_delete(heap, sign):  # Time: O(n), Space: O(n)
            heap[:] = [x for x in set(heap) if sign*x[0] == self.__lookup[x[1]]]
            heapq.heapify(heap)

        if timestamp &gt; self.__curr:
            self.__curr = timestamp
        self.__lookup[timestamp] = price
        heapq.heappush(self.__min_heap, (price, timestamp))
        heapq.heappush(self.__max_heap, (-price, timestamp))
        if len(self.__min_heap) &gt; 2*len(self.__lookup):  # avoid too much expired or duplicated data
            full_delete(self.__min_heap, 1)
            full_delete(self.__max_heap, -1)

    def current(self):
        """
        :rtype: int
        """
        return self.__lookup[self.__curr]

    def maximum(self):
        """
        :rtype: int
        """
        while self.__max_heap and self.__lookup[self.__max_heap[0][1]] != -self.__max_heap[0][0]:  # lazy delete
            heapq.heappop(self.__max_heap)
        return -self.__max_heap[0][0]

    def minimum(self):
        """
        :rtype: int
        """
        while self.__min_heap and self.__lookup[self.__min_heap[0][1]] != self.__min_heap[0][0]:  # lazy delete
            heapq.heappop(self.__min_heap)
        return self.__min_heap[0][0]

```



----------------------------------------------------------------------------------------

### Design - 2043 - https://leetcode.com/problems/simple-bank-system/
Time: ctor: O(1)transer: O(1)deposit: O(1)withdraw: O(1)  Space: O(1)   Medium
.Python/simple-bank-system.py


```python
# Time:  ctor:     O(1)
#        transer:  O(1)
#        deposit:  O(1)
#        withdraw: O(1)
# Space: O(1)

class Bank(object):

    def __init__(self, balance):
        """
        :type balance: List[int]
        """
        self.__balance = balance

    def transfer(self, account1, account2, money):
        """
        :type account1: int
        :type account2: int
        :type money: int
        :rtype: bool
        """
        if 1 &lt;= account2 &lt;= len(self.__balance) and self.withdraw(account1, money):
            return self.deposit(account2, money)
        return False

    def deposit(self, account, money):
        """
        :type account: int
        :type money: int
        :rtype: bool
        """
        if 1 &lt;= account &lt;= len(self.__balance):
            self.__balance[account-1] += money
            return True
        return False

    def withdraw(self, account, money):
        """
        :type account: int
        :type money: int
        :rtype: bool
        """
        if 1 &lt;= account &lt;= len(self.__balance) and self.__balance[account-1] &gt;= money:
            self.__balance[account-1] -= money
            return True
        return False

```



----------------------------------------------------------------------------------------

### Design - 2069 - https://leetcode.com/problems/walking-robot-simulation-ii/
Time: O(1)  Space: O(1)   Medium
.Python/walking-robot-simulation-ii.py


```python
# Time:  O(1)
# Space: O(1)

class Robot(object):

    def __init__(self, width, height):
        """
        :type width: int
        :type height: int
        """
        self.__w = width
        self.__h = height
        self.__curr = 0

    def move(self, num):
        """
        :type num: int
        :rtype: None
        """
        self.__curr += num

    def getPos(self):
        """
        :rtype: List[int]
        """
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n &lt; self.__w:
            return [n, 0]
        n -= self.__w-1
        if n &lt; self.__h:
            return [self.__w-1, n]
        n -= self.__h-1
        if n &lt; self.__w:
            return [(self.__w-1)-n, self.__h-1]
        n -= self.__w-1
        return [0, (self.__h-1)-n]

    def getDir(self):
        """
        :rtype: str
        """
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n &lt; self.__w:
            return "South" if n == 0 and self.__curr else "East"
        n -= self.__w-1
        if n &lt; self.__h:
            return "North"
        n -= self.__h-1
        if n &lt; self.__w:
            return "West"
        n -= self.__w-1
        return "South"


# Time:  O(1)
# Space: O(1)
class Robot2(object):

    def __init__(self, width, height):
        """
        :type width: int
        :type height: int
        """
        self.__w = width
        self.__h = height
        self.__curr = 0

    def move(self, num):
        """
        :type num: int
        :rtype: None
        """
        self.__curr += num

    def getPos(self):
        """
        :rtype: List[int]
        """
        return self.__getPosDir()[0] 

    def getDir(self):
        """
        :rtype: str
        """
        return self.__getPosDir()[1]

    def __getPosDir(self):
        n = self.__curr % (2*((self.__w-1)+(self.__h-1)))
        if n &lt; self.__w:
            return [[n, 0], "South" if n == 0 and self.__curr else "East"]
        n -= self.__w-1
        if n &lt; self.__h:
            return [[self.__w-1, n], "North"]
        n -= self.__h-1
        if n &lt; self.__w:
            return [[(self.__w-1)-n, self.__h-1], "West"]
        n -= self.__w-1
        return [[0, (self.__h-1)-n], "South"]

```



----------------------------------------------------------------------------------------

### Design - 2080 - https://leetcode.com/problems/range-frequency-queries/
Time: ctor: O(n)query: O(logn)  Space: O(n)   Medium
.Python/range-frequency-queries.py


```python
# Time:  ctor:  O(n)
#        query: O(logn)
# Space: O(n)

import collections
import bisect


class RangeFreqQuery(object):

    def __init__(self, arr):
        """
        :type arr: List[int]
        """
        self.__idxs = collections.defaultdict(list)
        for i, x in enumerate(arr):
            self.__idxs[x].append(i)

    def query(self, left, right, value):
        """
        :type left: int
        :type right: int
        :type value: int
        :rtype: int
        """
        return bisect.bisect_right(self.__idxs[value], right) - \
               bisect.bisect_left(self.__idxs[value], left)

```



----------------------------------------------------------------------------------------

### Design - 2102 - https://leetcode.com/problems/sequentially-ordinal-rank-tracker/
Time: add: O(logn)get: O(logn)  Space: O(n)   Hard
.Python/sequentially-ordinal-rank-tracker.py


```python
# Time:  add: O(logn)
#        get: O(logn)
# Space: O(n)

from sortedcontainers import SortedList


class SORTracker(object):

    def __init__(self):
        self.__sl = SortedList()
        self.__i = 0

    def add(self, name, score):
        """
        :type name: str
        :type score: int
        :rtype: None
        """
        self.__sl.add((-score, name))
        
    def get(self):
        """
        :rtype: str
        """
        self.__i += 1
        return self.__sl[self.__i-1][1]

```



----------------------------------------------------------------------------------------

### Design - 2166 - https://leetcode.com/problems/design-bitset/
Time: ctor: O(n)fix: O(1)fix: O(1)unfix: O(1)flip: O(1)all: O(1)one: O(1)count: O(1)toString: O(n)  Space: O(n)   Medium
.Python/design-bitset.py


```python
# Time:  ctor:     O(n)
#        fix:      O(1)
#        unfix:    O(1)
#        flip:     O(1)
#        all:      O(1)
#        one:      O(1)
#        count:    O(1)
#        toString: O(n)
# Space: O(n)

# design
class Bitset(object):

    def __init__(self, size):
        """
        :type size: int
        """
        self.__lookup = [False]*size
        self.__flip = False
        self.__cnt = 0

    def fix(self, idx):
        """
        :type idx: int
        :rtype: None
        """
        if self.__lookup[idx] == self.__flip:
            self.__lookup[idx] = not self.__lookup[idx]
            self.__cnt += 1
            
    def unfix(self, idx):
        """
        :type idx: int
        :rtype: None
        """
        if self.__lookup[idx] != self.__flip:
            self.__lookup[idx] = not self.__lookup[idx]
            self.__cnt -= 1

    def flip(self):
        """
        :rtype: None
        """
        self.__flip = not self.__flip
        self.__cnt = len(self.__lookup)-self.__cnt
        

    def all(self):
        """
        :rtype: bool
        """
        return self.__cnt == len(self.__lookup)

    def one(self):
        """
        :rtype: bool
        """
        return self.__cnt &gt;= 1

    def count(self):
        """
        :rtype: int
        """
        return self.__cnt

    def toString(self):
        """
        :rtype: str
        """
        result = ['']*len(self.__lookup)
        for i, x in enumerate(self.__lookup):
            result[i] = '1' if x != self.__flip else '0'
        return "".join(result)

```



----------------------------------------------------------------------------------------

### Design - 2227 - https://leetcode.com/problems/encrypt-and-decrypt-strings/
Time: ctor: O(m + d)encrypt: O(n)decrypt: O(n)  Space: O(n)   Hard
.Python/encrypt-and-decrypt-strings.py


```python
# Time:  ctor:    O(m + d), m is len(keys), d is sum(len(x) for x in dictionary)
#        encrypt: O(n)
#        decrypt: O(n)
# Space: O(m + d)

import collections
import itertools


# freq table
class Encrypter(object):

    def __init__(self, keys, values, dictionary):
        """
        :type keys: List[str]
        :type values: List[str]
        :type dictionary: List[str]
        """
        self.__lookup = {k: v for k, v in itertools.izip(keys, values)}
        self.__cnt = collections.Counter(self.encrypt(x) for x in dictionary)
        
    def encrypt(self, word1):
        """
        :type word1: str
        :rtype: str
        """
        return "".join(self.__lookup[c] for c in word1)

    def decrypt(self, word2):
        """
        :type word2: str
        :rtype: int
        """
        return self.__cnt[word2]

```



----------------------------------------------------------------------------------------

### Design - 2241 - https://leetcode.com/problems/design-an-atm-machine/
Time: ctor: O(1)deposit: O(1)withdraw: O(1)  Space: O(1)   Medium
.Python/design-an-atm-machine.py


```python
# Time:  ctor:     O(1)
#        deposit:  O(1)
#        withdraw: O(1)
# Space: O(1)

# greedy
class ATM(object):

    def __init__(self):
        self.__vals = [20, 50, 100, 200, 500]
        self.__cnt = [0]*len(self.__vals)

    def deposit(self, banknotesCount):
        """
        :type banknotesCount: List[int]
        :rtype: None
        """
        for i, x in enumerate(banknotesCount):
            self.__cnt[i] += x

    def withdraw(self, amount):
        """
        :type amount: int
        :rtype: List[int]
        """
        result = [0]*len(self.__cnt)
        for i in reversed(xrange(len(self.__vals))):
            result[i] = min(amount//self.__vals[i], self.__cnt[i])
            amount -= result[i]*self.__vals[i]
        if amount:
            return [-1]
        for i, c in enumerate(result):
            self.__cnt[i] -= c
        return result

```



----------------------------------------------------------------------------------------

### Design - 2254 - https://leetcode.com/problems/design-video-sharing-platform/
Time: ctor: O(1)upload: O(logn + l)remove: O(logn)like: O(1)dislike: O(1)view: O(1)getLikesAndDislikes: O(1)getViews: O(1)  Space: O(n * l)   Hard
.Python/design-video-sharing-platform.py


```python
# Time:  ctor:                O(1)
#        upload:              O(logn+l)
#        remove:              O(logn)
#        like:                O(1)
#        dislike:             O(1)
#        view:                O(l)
#        getLikesAndDislikes: O(1)
#        getViews:            O(1)
# Space: O(n * l), n = len(videos), l = max(len(v) for v in videos) 

import heapq


# design, heap
class VideoSharingPlatform(object):

    def __init__(self):
        self.__avails = []
        self.__videos = []
        self.__likes = []
        self.__dislikes = []
        self.__views = []

    def upload(self, video):
        """
        :type video: str
        :rtype: int
        """
        if self.__avails:
            i = heapq.heappop(self.__avails)
        else:
            i = len(self.__videos)
            self.__videos.append(None)
            self.__likes.append(0)
            self.__dislikes.append(0)
            self.__views.append(0)
        self.__videos[i] = video
        return i
        
    def remove(self, videoId):
        """
        :type videoId: int
        :rtype: None
        """
        if videoId &gt;= len(self.__videos) or not self.__videos[videoId]:
            return
        heapq.heappush(self.__avails, videoId)
        self.__videos[videoId] = None
        self.__likes[videoId] = self.__dislikes[videoId] = self.__views[videoId] = 0
        
    def watch(self, videoId, startMinute, endMinute):
        """
        :type videoId: int
        :type startMinute: int
        :type endMinute: int
        :rtype: str
        """
        if videoId &gt;= len(self.__videos) or not self.__videos[videoId]:
            return "-1"
        self.__views[videoId] += 1
        return self.__videos[videoId][startMinute:endMinute+1]

    def like(self, videoId):
        """
        :type videoId: int
        :rtype: None
        """
        if videoId &gt;= len(self.__videos) or not self.__videos[videoId]:
            return
        self.__likes[videoId] += 1

    def dislike(self, videoId):
        """
        :type videoId: int
        :rtype: None
        """
        if videoId &gt;= len(self.__videos) or not self.__videos[videoId]:
            return
        self.__dislikes[videoId] += 1

    def getLikesAndDislikes(self, videoId):
        """
        :type videoId: int
        :rtype: List[int]
        """
        if videoId &gt;= len(self.__videos) or not self.__videos[videoId]:
            return [-1]
        return [self.__likes[videoId], self.__dislikes[videoId]]

    def getViews(self, videoId):
        """
        :type videoId: int
        :rtype: int
        """
        if videoId &gt;= len(self.__videos) or not self.__videos[videoId]:
            return -1
        return self.__views[videoId]

```



----------------------------------------------------------------------------------------

### Design - 2276 - https://leetcode.com/problems/count-integers-in-intervals/
Time: ctor: O(1)add: O(logn), amortizedCount: O(1)  Space: O(n)   Hard
.Python/count-integers-in-intervals.py


```python
# Time:  ctor:  O(1)
#        add:   O(logn), amortized
#        count: O(1)
# Space: O(n)

from sortedcontainers import SortedList


# design, sortedlist
class CountIntervals(object):

    def __init__(self):
        self.__sl = SortedList()
        self.__cnt = 0

    def add(self, left, right):
        """
        :type left: int
        :type right: int
        :rtype: None
        """
        i = self.__sl.bisect_right((left,))
        if i-1 &gt;= 0 and self.__sl[i-1][1]+1 &gt;= left:
            i -= 1
            left = self.__sl[i][0]
        to_remove = []
        for i in xrange(i, len(self.__sl)):
            if not (right+1 &gt;= self.__sl[i][0]):
                break
            right = max(right, self.__sl[i][1])
            self.__cnt -= self.__sl[i][1]-self.__sl[i][0]+1
            to_remove.append(i)
        while to_remove:
            del self.__sl[to_remove.pop()]
        self.__sl.add((left, right))
        self.__cnt += right-left+1

    def count(self):
        """
        :rtype: int
        """
        return self.__cnt

```



----------------------------------------------------------------------------------------

### Design - 2286 - https://leetcode.com/problems/booking-concert-tickets-in-groups/
Time: ctor: O(n)gather: O(logn)scatter: O(logn), amortized  Space: O(n)   Hard
.Python/booking-concert-tickets-in-groups.py


```python
# Time:  ctor:    O(n)
#        gather:  O(logn)
#        scatter: O(logn), amortized
# Space: O(n)

# Template:
# https://github.com/kamyu104/LeetCode-Solutions/blob/master/Python/longest-substring-of-one-repeating-character.py
class SegmentTree(object):
    def __init__(self, N,
                 build_fn=lambda _: float("inf"),
                 query_fn=lambda x, y: y if x is None else x if y is None else min(x, y),
                 update_fn=lambda x: x):
        self.tree = [None]*(2*2**((N-1).bit_length()))
        self.base = len(self.tree)//2
        self.query_fn = query_fn
        self.update_fn = update_fn
        for i in xrange(self.base, self.base+N):
            self.tree[i] = build_fn(i-self.base)
        for i in reversed(xrange(1, self.base)):
            self.tree[i] = query_fn(self.tree[2*i], self.tree[2*i+1])

    def update(self, i, h):
        x = self.base+i
        self.tree[x] = self.update_fn(h)
        while x &gt; 1:
            x //= 2
            self.tree[x] = self.query_fn(self.tree[x*2], self.tree[x*2+1])

    def query(self, L, R):
        L += self.base
        R += self.base
        left = right = None
        while L &lt;= R:
            if L &amp; 1:
                left = self.query_fn(left, self.tree[L])
                L += 1
            if R &amp; 1 == 0:
                right = self.query_fn(self.tree[R], right)
                R -= 1
            L //= 2
            R //= 2
        return self.query_fn(left, right)


# design, segment tree, binary search
class BookMyShow(object):

    def __init__(self, n, m):
        """
        :type n: int
        :type m: int
        """
        self.__st = SegmentTree(n,
                                build_fn=lambda _: [m]*2,
                                query_fn=lambda x, y: y if x is None else x if y is None else [max(x[0], y[0]), x[1]+y[1]])
        self.__m = m
        self.__i = 0

    def gather(self, k, maxRow):
        """
        :type k: int
        :type maxRow: int
        :rtype: List[int]
        """
        i = 1
        if k &gt; self.__st.tree[i][0]:
            return []
        while i &lt; self.__st.base:
            i = 2*i+int(self.__st.tree[2*i][0] &lt; k)
        if i-self.__st.base &gt; maxRow:
            return []
        cnt = self.__st.tree[i][0]
        c = self.__m-cnt
        i -= self.__st.base
        self.__st.update(i, [cnt-k]*2)
        return [i, c]

    def scatter(self, k, maxRow):
        """
        :type k: int
        :type maxRow: int
        :rtype: bool
        """
        cnt = self.__st.query(self.__i, maxRow)
        if not cnt or cnt[1] &lt; k:
            return False
        for i in xrange(self.__i, maxRow+1):
            cnt = self.__st.tree[self.__st.base+i][1]
            c = min(cnt, k)
            cnt -= c
            if not cnt:
                self.__i += 1
            self.__st.update(i, [cnt]*2)
            k -= c
            if not k:
                break
        return True

```



----------------------------------------------------------------------------------------

### Design - 2296 - https://leetcode.com/problems/design-a-text-editor/
Time: ctor: O(1)addText: O(l)deleteText: O(k)cursorLeft: O(k)cursorRight: O(k)  Space: O(n)   Hard
.Python/design-a-text-editor.py


```python
# Time:  ctor:        O(1)
#        addText:     O(l)
#        deleteText:  O(k)
#        cursorLeft:  O(k)
#        cursorRight: O(k)
# Space: O(n)

# design, stack
class TextEditor(object):

    def __init__(self):
        self.__LAST_COUNT = 10
        self.__left = []
        self.__right = []

    def addText(self, text):
        """
        :type text: str
        :rtype: None
        """
        for x in text:
            self.__left.append(x)

    def deleteText(self, k):
        """
        :type k: int
        :rtype: int
        """
        return self.__move(k, self.__left, None)

    def cursorLeft(self, k):
        """
        :type k: int
        :rtype: str
        """
        self.__move(k, self.__left, self.__right)
        return self.__last_characters()

    def cursorRight(self, k):
        """
        :type k: int
        :rtype: str
        """
        self.__move(k, self.__right, self.__left)
        return self.__last_characters()

    def __move(self, k, src, dst):
        cnt = min(k, len(src))
        for _ in xrange(cnt):
            if dst is not None:
                dst.append(src[-1])
            src.pop()
        return cnt

    def __last_characters(self):
        return "".join(self.__left[-self.__LAST_COUNT:])

```



----------------------------------------------------------------------------------------

### Design - 2336 - https://leetcode.com/problems/smallest-number-in-infinite-set/
Time: ctor: O(1)popSmallest: O(logn)addBack: O(logn)  Space: O(n)   Medium
.Python/smallest-number-in-infinite-set.py


```python
# Time:  ctor:        O(1)
#        popSmallest: O(logn)
#        addBack:     O(logn)
# Space: O(n)

import heapq


# heap
class SmallestInfiniteSet(object):

    def __init__(self):
        self.__n = 1
        self.__lookup = set()
        self.__min_heap = []

    def popSmallest(self):
        """
        :rtype: int
        """
        if self.__min_heap:
            result = heapq.heappop(self.__min_heap)
            self.__lookup.remove(result)
            return result
        result = self.__n
        self.__n += 1
        return result

    def addBack(self, num):
        """
        :type num: int
        :rtype: None
        """
        if num &gt;= self.__n or num in self.__lookup:
            return
        self.__lookup.add(num)
        heapq.heappush(self.__min_heap, num)

```



----------------------------------------------------------------------------------------

### Design - 2349 - https://leetcode.com/problems/design-a-number-container-system/
Time: ctor: O(1)change: O(logn)find: O(1)  Space: O(n)   Medium
.Python/design-a-number-container-system.py


```python
# Time:  ctor:   O(1)
#        change: O(logn)
#        find:   O(1)
# Space: O(n)

from sortedcontainers import SortedList


# sorted list
class NumberContainers(object):

    def __init__(self):
        self.__idx_to_num = {}
        self.__num_to_idxs = collections.defaultdict(SortedList)

    def change(self, index, number):
        """
        :type index: int
        :type number: int
        :rtype: None
        """
        if index in self.__idx_to_num:
            self.__num_to_idxs[self.__idx_to_num[index]].remove(index)
            if not self.__num_to_idxs[self.__idx_to_num[index]]:
                del self.__num_to_idxs[self.__idx_to_num[index]]
        self.__idx_to_num[index] = number
        self.__num_to_idxs[number].add(index)

    def find(self, number):
        """
        :type number: int
        :rtype: int
        """
        return self.__num_to_idxs[number][0] if number in self.__num_to_idxs else -1

```



----------------------------------------------------------------------------------------

### Design - 2353 - https://leetcode.com/problems/design-a-food-rating-system/
Time: ctor: O(nlogn)changeRating: O(logn)highestRated: O(1)  Space: O(n)   Medium
.Python/design-a-food-rating-system.py


```python
# Time:  ctor:         O(nlogn)
#        changeRating: O(logn)
#        highestRated: O(1)
# Space: O(n)

import collections
import itertools
from sortedcontainers import SortedList


# sorted list
class FoodRatings(object):

    def __init__(self, foods, cuisines, ratings):
        """
        :type foods: List[str]
        :type cuisines: List[str]
        :type ratings: List[int]
        """
        self.__food_to_cuisine = {}
        self.__food_to_rating = {}
        self.__cusine_to_rating_foods = collections.defaultdict(SortedList)
        for food, cuisine, rating in itertools.izip(foods, cuisines, ratings):
            self.__food_to_cuisine[food] = cuisine
            self.__food_to_rating[food] = rating
            self.__cusine_to_rating_foods[cuisine].add((-rating, food))

    def changeRating(self, food, newRating):
        """
        :type food: str
        :type newRating: int
        :rtype: None
        """
        old_rating = self.__food_to_rating[food]
        cuisine = self.__food_to_cuisine[food]
        self.__cusine_to_rating_foods[cuisine].remove((-old_rating, food))
        self.__food_to_rating[food] = newRating
        self.__cusine_to_rating_foods[cuisine].add((-newRating, food))

    def highestRated(self, cuisine):
        """
        :type cuisine: str
        :rtype: str
        """
        return self.__cusine_to_rating_foods[cuisine][0][1]

```



----------------------------------------------------------------------------------------

### Concurrency - 1114 - https://leetcode.com/problems/print-in-order/
Time: O(n)  Space: O(1)   Easy
.Python/print-in-order.py


```python
# Time:  O(n)
# Space: O(1)

import threading


class Foo(object):
    def __init__(self):
        self.__cv = threading.Condition()
        self.__has_first = False
        self.__has_second = False

    def first(self, printFirst):
        """
        :type printFirst: method
        :rtype: void
        """
        with self.__cv:
            # printFirst() outputs "first". Do not change or remove this line.
            printFirst()            
            self.__has_first = True
            self.__cv.notifyAll()

    def second(self, printSecond):
        """
        :type printSecond: method
        :rtype: void
        """
        with self.__cv:
            while not self.__has_first:
                self.__cv.wait()
            # printSecond() outputs "second". Do not change or remove this line.
            printSecond()
            self.__has_second = True
            self.__cv.notifyAll()
              
    def third(self, printThird):
        """
        :type printThird: method
        :rtype: void
        """
        with self.__cv:
            while not self.__has_second:
                self.__cv.wait()
            # printThird() outputs "third". Do not change or remove this line.
            printThird()
            self.__cv.notifyAll()

```



----------------------------------------------------------------------------------------

### Concurrency - 1115 - https://leetcode.com/problems/print-foobar-alternately/
Time: O(n)  Space: O(1)   Medium
.Python/print-foobar-alternately.py


```python
# Time:  O(n)
# Space: O(1)

import threading


class FooBar(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = False
        self.__cv = threading.Condition()

    def foo(self, printFoo):
        """
        :type printFoo: method
        :rtype: void
        """
        for i in xrange(self.__n):
            with self.__cv:
                while self.__curr != False:
                    self.__cv.wait()
                self.__curr = not self.__curr
                # printFoo() outputs "foo". Do not change or remove this line.
                printFoo()
                self.__cv.notify()

    def bar(self, printBar):
        """
        :type printBar: method
        :rtype: void
        """
        for i in xrange(self.__n):
            with self.__cv:
                while self.__curr != True:
                        self.__cv.wait()
                self.__curr = not self.__curr
                # printBar() outputs "bar". Do not change or remove this line.
                printBar()
                self.__cv.notify()

```



----------------------------------------------------------------------------------------

### Concurrency - 1116 - https://leetcode.com/problems/print-zero-even-odd/
Time: O(n)  Space: O(1)   Medium
.Python/print-zero-even-odd.py


```python
# Time:  O(n)
# Space: O(1)

import threading


class ZeroEvenOdd(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = 0
        self.__cv = threading.Condition()
        
	# printNumber(x) outputs "x", where x is an integer.
    def zero(self, printNumber):
        """
        :type printNumber: method
        :rtype: void
        """
        for i in xrange(self.__n):
            with self.__cv:
                while self.__curr % 2 != 0:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(0)
                self.__cv.notifyAll()
        
    def even(self, printNumber):
        """
        :type printNumber: method
        :rtype: void
        """
        for i in xrange(2, self.__n+1, 2):
            with self.__cv:
                while self.__curr % 4 != 3:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(i)
                self.__cv.notifyAll()
        
    def odd(self, printNumber):
        """
        :type printNumber: method
        :rtype: void
        """
        for i in xrange(1, self.__n+1, 2):
            with self.__cv:
                while self.__curr % 4 != 1:
                    self.__cv.wait()
                self.__curr += 1
                printNumber(i)
                self.__cv.notifyAll()

```



----------------------------------------------------------------------------------------

### Concurrency - 1117 - https://leetcode.com/problems/building-h2o/
Time: O(n)  Space: O(1)   Hard
.Python/building-h2o.py


```python
# Time:  O(n)
# Space: O(1)

import threading


class H2O(object):
    def __init__(self):
        self.__l = threading.Lock()
        self.__nH = 0
        self.__nO = 0
        self.__releaseHydrogen = None
        self.__releaseOxygen = None

    def hydrogen(self, releaseHydrogen):
        with self.__l:
            self.__releaseHydrogen = releaseHydrogen
            self.__nH += 1
            self.__output()

    def oxygen(self, releaseOxygen):
        with self.__l:
            self.__releaseOxygen = releaseOxygen
            self.__nO += 1
            self.__output()

    def __output(self):
        while self.__nH &gt;= 2 and \
              self.__nO &gt;= 1:
            self.__nH -= 2
            self.__nO -= 1
            self.__releaseHydrogen()
            self.__releaseHydrogen()
            self.__releaseOxygen()


# Time:  O(n)
# Space: O(1)
# TLE
class H2O2(object):
    def __init__(self):
        self.__nH = 0
        self.__nO = 0
        self.__cv = threading.Condition()

    def hydrogen(self, releaseHydrogen):
        """
        :type releaseHydrogen: method
        :rtype: void
        """
        with self.__cv:
            while (self.__nH+1) - 2*self.__nO &gt; 2:
                self.__cv.wait()
            self.__nH += 1
            # releaseHydrogen() outputs "H". Do not change or remove this line.
            releaseHydrogen()
            self.__cv.notifyAll()

    def oxygen(self, releaseOxygen):
        """
        :type releaseOxygen: method
        :rtype: void
        """
        with self.__cv:
            while 2*(self.__nO+1) - self.__nH &gt; 2:
                self.__cv.wait()
            self.__nO += 1
            # releaseOxygen() outputs "O". Do not change or remove this line.
            releaseOxygen()
            self.__cv.notifyAll()

```



----------------------------------------------------------------------------------------

### Concurrency - 1188 - https://leetcode.com/problems/design-bounded-blocking-queue/
Time: O(n)  Space: O(1)   Medium
.Python/design-bounded-blocking-queue.py


```python
# Time:  O(n)
# Space: O(1)

import threading
import collections


class BoundedBlockingQueue(object):
    def __init__(self, capacity):
        """
        :type capacity: int
        """
        self.__cv = threading.Condition()
        self.__q = collections.deque()
        self.__cap = capacity

    def enqueue(self, element):
        """
        :type element: int
        :rtype: void
        """
        with self.__cv:
            while len(self.__q) == self.__cap:
                self.__cv.wait()
            self.__q.append(element)
            self.__cv.notifyAll()

    def dequeue(self):
        """
        :rtype: int
        """
        with self.__cv:
            while not self.__q:
                self.__cv.wait()
            self.__cv.notifyAll()
            return self.__q.popleft()

    def size(self):
        """
        :rtype: int
        """
        with self.__cv:
            return len(self.__q)

```



----------------------------------------------------------------------------------------

### Concurrency - 1195 - https://leetcode.com/problems/fizz-buzz-multithreaded/
Time: O(n)  Space: O(1)   Medium
.Python/fizz-buzz-multithreaded.py


```python
# Time:  O(n)
# Space: O(1)

import threading


class FizzBuzz(object):
    def __init__(self, n):
        self.__n = n
        self.__curr = 0
        self.__cv = threading.Condition()

    # printFizz() outputs "fizz"
    def fizz(self, printFizz):
        """
        :type printFizz: method
        :rtype: void
        """
        for i in xrange(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 0:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 == 0 and i % 5 != 0:
                    printFizz()
                self.__cv.notify_all()

    # printBuzz() outputs "buzz"
    def buzz(self, printBuzz):
        """
        :type printBuzz: method
        :rtype: void
        """
        for i in xrange(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 1:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 != 0 and i % 5 == 0:
                    printBuzz()
                self.__cv.notify_all()

    # printFizzBuzz() outputs "fizzbuzz"
    def fizzbuzz(self, printFizzBuzz):
        """
        :type printFizzBuzz: method
        :rtype: void
        """
        for i in xrange(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 2:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 == 0 and i % 5 == 0:
                    printFizzBuzz()
                self.__cv.notify_all()

    # printNumber(x) outputs "x", where x is an integer.
    def number(self, printNumber):
        """
        :type printNumber: method
        :rtype: void
        """
        for i in xrange(1, self.__n+1):
            with self.__cv:
                while self.__curr % 4 != 3:
                    self.__cv.wait()
                self.__curr += 1
                if i % 3 != 0 and i % 5 != 0:
                    printNumber(i)
                self.__cv.notify_all()

```



----------------------------------------------------------------------------------------

### Concurrency - 1226 - https://leetcode.com/problems/the-dining-philosophers/
Time: O(n)  Space: O(1)   Medium
.Python/the-dining-philosophers.py


```python
# Time:  O(n)
# Space: O(1)

import threading


class DiningPhilosophers(object):
    def __init__(self):
        self._l = [threading.Lock() for _ in xrange(5)]

    # call the functions directly to execute, for example, eat()
    def wantsToEat(self, philosopher, pickLeftFork, pickRightFork, eat, putLeftFork, putRightFork):
        """
        :type philosopher: int
        :type pickLeftFork: method
        :type pickRightFork: method
        :type eat: method
        :type putLeftFork: method
        :type putRightFork: method
        :rtype: void
        """
        left, right = philosopher, (philosopher+4)%5
        first, second = left, right
        if  philosopher%2 == 0:
            first, second = left, right
        else:
            first, second = right, left

        with self._l[first]:
            with self._l[second]:
                pickLeftFork()
                pickRightFork()
                eat()
                putLeftFork()
                putRightFork()

```



----------------------------------------------------------------------------------------

### Concurrency - 1242 - https://leetcode.com/problems/web-crawler-multithreaded/
Time: O(|V| + |E|)  Space: O(|V|)   Medium
.Python/web-crawler-multithreaded.py


```python
# Time:  O(|V| + |E|)
# Space: O(|V|)

import threading
import Queue


# """
# This is HtmlParser's API interface.
# You should not implement it, or speculate about its implementation
# """
class HtmlParser(object):
   def getUrls(self, url):
       """
       :type url: str
       :rtype List[str]
       """
       pass


class Solution(object):
    NUMBER_OF_WORKERS = 8
    
    def __init__(self):
        self.__cv = threading.Condition()
        self.__q = Queue.Queue()

    def crawl(self, startUrl, htmlParser):
        """
        :type startUrl: str
        :type htmlParser: HtmlParser
        :rtype: List[str]
        """
        SCHEME = "http://"
        def hostname(url):
            pos = url.find('/', len(SCHEME))
            if pos == -1:
                return url
            return url[:pos]

        def worker(htmlParser, lookup):
            while True:
                from_url = self.__q.get()
                if from_url is None:
                    break
                name = hostname(from_url)
                for to_url in htmlParser.getUrls(from_url):
                    if name != hostname(to_url):
                        continue
                    with self.__cv:
                        if to_url not in lookup:
                           lookup.add(to_url)
                           self.__q.put(to_url)
                self.__q.task_done()

        workers = []
        self.__q = Queue.Queue()
        self.__q.put(startUrl)
        lookup = set([startUrl])
        for i in xrange(self.NUMBER_OF_WORKERS):
            t = threading.Thread(target=worker, args=(htmlParser, lookup))
            t.start()
            workers.append(t)
        self.__q.join()
        for t in workers:
            self.__q.put(None)
        for t in workers:
            t.join()
        return list(lookup)


# Time:  O(|V| + |E|)
# Space: O(|V|)
import threading
import collections


class Solution2(object):
    NUMBER_OF_WORKERS = 8
    
    def __init__(self):
        self.__cv = threading.Condition()
        self.__q = collections.deque()
        self.__working_count = 0

    def crawl(self, startUrl, htmlParser):
        """
        :type startUrl: str
        :type htmlParser: HtmlParser
        :rtype: List[str]
        """
        SCHEME = "http://"
        def hostname(url):
            pos = url.find('/', len(SCHEME))
            if pos == -1:
                return url
            return url[:pos]

        def worker(htmlParser, lookup):
            while True:
                with self.__cv:
                    while not self.__q:
                        self.__cv.wait()
                    from_url = self.__q.popleft()
                    if from_url is None:
                        break
                    self.__working_count += 1
                name = hostname(from_url)
                for to_url in htmlParser.getUrls(from_url):
                    if name != hostname(to_url):
                        continue
                    with self.__cv:
                        if to_url not in lookup:
                           lookup.add(to_url)
                           self.__q.append(to_url)
                           self.__cv.notifyAll()
                with self.__cv:
                    self.__working_count -= 1
                    if not self.__q and not self.__working_count:
                        self.__cv.notifyAll()

        workers = []
        self.__q = collections.deque([startUrl])
        lookup = set([startUrl])
        for i in xrange(self.NUMBER_OF_WORKERS):
            t = threading.Thread(target=worker, args=(htmlParser, lookup))
            t.start()
            workers.append(t)
        with self.__cv:
            while self.__q or self.__working_count:
                self.__cv.wait()
            for i in xrange(self.NUMBER_OF_WORKERS):
                self.__q.append(None)
            self.__cv.notifyAll()
        for t in workers:
            t.join()
        return list(lookup)

```



----------------------------------------------------------------------------------------

### Concurrency - 1279 - https://leetcode.com/problems/traffic-light-controlled-intersection/
Time: O(n)  Space: O(1)   Easy
.Python/traffic-light-controlled-intersection.py


```python
# Time:  O(n)
# Space: O(1)

import threading


class TrafficLight(object):
    
    def __init__(self):
        self.__l = threading.Lock()
        self.__light = 1

    def carArrived(self, carId, roadId, direction, turnGreen, crossCar):
        """
        :type roadId: int --&gt; // ID of the car
        :type carId: int --&gt; // ID of the road the car travels on. Can be 1 (road A) or 2 (road B)
        :type direction: int --&gt; // Direction of the car
        :type turnGreen: method --&gt; // Use turnGreen() to turn light to green on current road
        :type crossCar: method --&gt; // Use crossCar() to make car cross the intersection
        :rtype: void
        """
        with self.__l:
            if self.__light != roadId:
                self.__light = roadId
                turnGreen()
            crossCar()

```



----------------------------------------------------------------------------------------
